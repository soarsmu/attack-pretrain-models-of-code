def is_palindrome(s):  	if s == '':  		return True  	else:  		if (ord(s[0]) - ord(s[len(s)-1])) == 0:  			return is_palindrome(s[1 : len(s) - 1])  		else:  			return False    all_fair_and_square = set()  for i in range(10000):  	orig = str(i)  	rev = orig[::-1]    	palin = orig + rev  	intpalin = int(palin)  	if is_palindrome(str(intpalin * intpalin)):  		all_fair_and_square.add(intpalin * intpalin)    	palin = orig[:-1] + rev  	intpalin = int(palin)  	if is_palindrome(str(intpalin * intpalin)):  		all_fair_and_square.add(intpalin * intpalin)  	    import sys    t = int(sys.stdin.readline().strip())  for ii in range(t):  	line = sys.stdin.readline().strip().split()  	a = int(line[0])  	b = int(line[1])  	count = 0  	for num in all_fair_and_square:  		if (num >= a) and (num <= b):  			count += 1  	print "Case #" + str(ii + 1) + ": " + str(count)    <CODESPLIT> 0
import sys    t = int(sys.stdin.readline())  for i in range(t):  	inputline = sys.stdin.readline().strip()  	inputparams = inputline.split()    	n = int(inputparams[0])  	s = int(inputparams[1])  	p = int(inputparams[2])  	validcount = 0  	surprisingcount = 0  	for j in range(n):  		score = int(inputparams[3 + j])  		if (p + (p - 1) * 2) <= score:  			validcount += 1  		elif ((p + (p - 2) * 2) <= score) and (p <= score):  			surprisingcount += 1    	print "Case #%d: %d" % (i + 1, validcount + min(surprisingcount, s))  <CODESPLIT> 0
import sys    def play_war(b1, b2):  	if 0 == len(b1):  		return 0  		  	if b1[0] > b2[0]:  		b1.pop(0)  		b2.pop()  		return 1 + play_war(b1, b2)  	else:  		b1.pop(0)  		b2.pop(0)  		return play_war(b1, b2)  		  def play_deceitful_war(b1, b2):  	if 0 == len(b1):  		return 0  		  	i = len(b1) - 1  	while (i >= 0) and (b1[i] < b2[len(b2) - 1]):  		i -= 1  		  	if i < 0:  		return 0  	  	  	b1.pop(i)  	b2.pop()    	return 1 + play_deceitful_war(b1, b2)      t = int(sys.stdin.readline().strip())    for i in range(t):  	print "Case #" + str(i + 1) + ":",    	n = int(sys.stdin.readline().strip())  	  	blocks1 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)  	blocks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)    	print play_deceitful_war(list(blocks1), list(blocks2)), play_war(blocks1, blocks2)  	  <CODESPLIT> 0
import sys    direction = [[0, 1], [1, 0]]    t = int(sys.stdin.readline())  for i in range(t):  	line = sys.stdin.readline().strip().split()  	n = int(line[0])  	m = int(line[1])  	field = []  	for j in range(n):  		line = [int(x) for x in sys.stdin.readline().strip().split()]  		field.append(line)    	possibleLawn = True  	for j in range(n):  		for k in range(m):  			for direct in range(2):  				coords = [j if (direct == 0) else 0, 0 if (direct == 0) else k]  				possibleField = True  				while (coords[0] < n) and (coords[1] < m):  					if field[j][k] < field[coords[0]][coords[1]]:  						possibleField = False  					coords[0] += direction[direct][0]  					coords[1] += direction[direct][1]    				if possibleField:  					break  			else:  				possibleLawn = False    	print "Case #" + str(i + 1) + ": " + ('YES' if possibleLawn else 'NO')    <CODESPLIT> 0
import sys  import math    def calculate_time(c, f, x, num_farms):  	t = 0.0  	rate = 2.0  	for i in range(num_farms):  		t += c / rate  		rate += f  		  	t += x / rate  	return t	    t = int(sys.stdin.readline().strip())    for i in range(t):  	print "Case #" + str(i + 1) + ":",    	(c, f, x) = [float(i) for i in sys.stdin.readline().strip().split()]  	  	if x <= c:  		t = calculate_time(c, f, x, 0)  	else:  		opt_rate = f * (x - c) / c  		num_farms = (opt_rate - 2) / f  		t1 = calculate_time(c, f, x, int(math.floor(num_farms)))  		t2 = calculate_time(c, f, x, int(math.ceil(num_farms)))    		t = min(t1, t2)  		  	print "%.7f" % t  <CODESPLIT> 0
import sys    def read_row():  	a = int(sys.stdin.readline().strip())  	for j in range(a - 1):  		sys.stdin.readline()  	read_set = set(sys.stdin.readline().strip().split(" "))  	for j in range(5 - a - 1):  		sys.stdin.readline()  		  	return read_set      t = int(sys.stdin.readline().strip())    for i in range(t):  	print "Case #" + str(i + 1) + ":",    	set1 = read_row()  	set2 = read_row()  	  	intersect = set1.intersection(set2)  	  	if 1 == len(intersect):  		print intersect.pop()  	elif 0 == len(intersect):  		print "Volunteer cheated!"  	else:  		print "Bad magician!"  <CODESPLIT> 0
import sys    inputmapping  = "abcdefghijklmnopqrstuvwxyz "  outputmapping = "ynficwlbkuomxsevzpdrjgthaq "    n = int(sys.stdin.readline())  for i in range(n):  	outputstring = sys.stdin.readline().strip()  	inputstring = ""  	for j in range(len(outputstring)):  		outputletter = outputstring[j]  		k = 0  		while outputmapping[k] != outputletter:  			k += 1    		inputstring += inputmapping[k]    	print "Case #%d: %s" % (i + 1, inputstring)	    		  <CODESPLIT> 0
import sys    t = int(sys.stdin.readline())  for i in range(t):  	board = []  	for j in range(4):  		board.append(sys.stdin.readline().strip())    	sys.stdin.readline()    	winX = False  	winO = False  	gameEnded = True    	for j in range(4):  		xCount = 0  		oCount = 0  		tCount = 0  		for k in range(4):  			if board[j][k] == 'X':  				xCount += 1  			if board[j][k] == 'O':  				oCount += 1  			if board[j][k] == 'T':  				tCount += 1    		if xCount + tCount == 4:  			winX = True  		  		if oCount + tCount == 4:  			winO = True    		if xCount + oCount + tCount < 4:  			gameEnded = False    	for k in range(4):  		xCount = 0  		oCount = 0  		tCount = 0  		for j in range(4):  			if board[j][k] == 'X':  				xCount += 1  			if board[j][k] == 'O':  				oCount += 1  			if board[j][k] == 'T':  				tCount += 1    		if xCount + tCount == 4:  			winX = True  		  		if oCount + tCount == 4:  			winO = True    		if xCount + oCount + tCount < 4:  			gameEnded = False    	xCount = 0  	oCount = 0  	tCount = 0  	for j in range(4):  		if board[j][j] == 'X':  			xCount += 1  		if board[j][j] == 'O':  			oCount += 1  		if board[j][j] == 'T':  			tCount += 1    	if xCount + tCount == 4:  		winX = True  	  	if oCount + tCount == 4:  		winO = True    	if xCount + oCount + tCount < 4:  		gameEnded = False      	xCount = 0  	oCount = 0  	tCount = 0  	for j in range(4):  		if board[3 - j][j] == 'X':  			xCount += 1  		if board[3 - j][j] == 'O':  			oCount += 1  		if board[3 - j][j] == 'T':  			tCount += 1    	if xCount + tCount == 4:  		winX = True  	  	if oCount + tCount == 4:  		winO = True    	if xCount + oCount + tCount < 4:  		gameEnded = False    	print "Case #" + str(i + 1) + ": ",  	if winX:  		print "X won"  	elif winO:  		print "O won"  	elif gameEnded:  		print "Draw"  	else:  		print "Game has not completed"  <CODESPLIT> 0
import sys    def generate_matrix(r, c, char):  	mat = [[char for i in range(c)] for j in range(r)]  	return mat  	  def merge(mat1, mat2):  	for i in range(len(mat1)):  		for j in range(len(mat1[i])):  			mat2[i][j] = mat1[i][j]  	return mat2    def solve(r, c, m):  	if 0 == m:  		mat = generate_matrix(r, c, '.')  		mat[0][0] = 'c'  		return mat  		  	f = r * c - m  	  	if 0 == f:  		return False  		  	if 1 == f:  		mat = generate_matrix(r, c, '*')  		mat[0][0] = 'c'  		return mat  		  	if 1 == min(r, c):  		mat = generate_matrix(r, c, '*')  		for i in range(f):  			mat[0 if 1 == r else i][0 if 1 == c else i] = '.'  		mat[0][0] = 'c'  		return mat    	if 2 == min(r, c):  		if (0 != f % 2) or (2 == f):  			return False  		mat = generate_matrix(r, c, '*')  		for i in range(f // 2):  			mat[0 if 2 == r else i][0 if 2 == c else i] = '.'  			mat[1 if 2 == r else i][1 if 2 == c else i] = '.'  		mat[0][0] = 'c'  		return mat  		  	if (3 == r) and (3 == c):  		if (4 == f) or (6 == f):  			mat = generate_matrix(r, c, '*')  			for i in range(f // 2):  				mat[0][i] = '.'  				mat[1][i] = '.'  			mat[0][0] = 'c'  			return mat  		if 8 == f:  			mat = generate_matrix(r, c, '.')  			mat[2][2] = '*'  			mat[0][0] = 'c'  			return mat  		return False  		  	rows_to_reduce = min(r - 3, m // c)  	if 0 < rows_to_reduce:  		res = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)  		if False == res:  			return False  		mat = merge(res, generate_matrix(r, c, '*'))  		return mat  		  	cols_to_reduce = min(c - 3, m // r)  	if 0 < cols_to_reduce:  		res = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)  		if False == res:  			return False  		mat = merge(res, generate_matrix(r, c, '*'))  		return mat  	  	mat = generate_matrix(r, c, '.')  	for i in range(min(m, r - 2)):  		mat[r - i - 1][c - 1] = '*'  	if m == r - 1:  		mat[r - 1][c - 2] = '*'  	mat[0][0] = 'c'  	return mat  			    t = int(sys.stdin.readline().strip())    for i in range(t):  	print "Case #" + str(i + 1) + ":"    	r, c, m = [int(i) for i in sys.stdin.readline().strip().split()]  	  	res = solve(r, c, m)  	  	if False == res:  		print "Impossible"  	else:  		for i in range(r):  			for j in range(c):  				sys.stdout.write(res[i][j])  			print  <CODESPLIT> 0
import sys    n = int(sys.stdin.readline())  for i in range(n):  	inputline = sys.stdin.readline().strip()  	inputparams = inputline.split()    	a = int(inputparams[0])  	b = int(inputparams[1])    	k = a  	ndigits = 0  	while k > 0:  		k /= 10  		ndigits += 1    	cnt = 0    	dic = {}    	for n1digits in range(1, ndigits / 2 + 1):  		n2digits = ndigits - n1digits    		for n1 in range(a / (10 ** n2digits), b / (10 ** n2digits) + 1):  			for n2 in range(a / (10 ** n1digits), b / (10 ** n1digits) + 1):    				k1 = n1 * 10 ** n2digits + n2  				k2 = n2 * 10 ** n1digits + n1    				if (n1digits == n2digits) and (n1 >= n2):  					continue    				if (k1 != k2) and (k1 >=a) and (k2 >= a) and (k1 <= b) and (k2 <= b):    					if min(k1, k2) not in dic:  						dic[min(k1, k2)] = set()    					if max(k1, k2) not in dic[min(k1, k2)]:  						dic[min(k1, k2)].add(max(k1, k2))  						cnt += 1    	print "Case #%d: %d" % (i + 1, cnt)	    <CODESPLIT> 0
import time  import os  import sys  import itertools  import functools  import math    # ----------------------------------------------------------------------    def is_equal_approx(x, y, epsilon=1e-6):      """ Returns True iff y is within relative or absolute 'epsilon' of x.          By default, 'epsilon' is 1e-6.      """      # Check absolute precision.      if -epsilon <= x - y <= epsilon:          return True        # Is x or y too close to zero?      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:          return False        # Check relative precision.      return (-epsilon <= (x - y) / x <= epsilon          or -epsilon <= (x - y) / y <= epsilon)      def read_syms(fd):      return [c for c in fd.readline().strip()]    def read_ints(fd):      return [int(p) for p in fd.readline().strip().split()]    def read_floats(fd):      return [float(p) for p in fd.readline().strip().split()]    class Mtrx(object):            def __init__(self, readfunc):          self.readfunc = readfunc                def cell(self, r, c):          return self.data[r * self.cols + c]            def getrow(self, i):          return [self.cell(i, c) for c in range(self.cols)]        def getcol(self, i):          return [self.cell(c, i) for c in range(self.rows)]            def readfromfile(self, fd):          self.data = []          self.rows, self.cols = read_ints(fd)          for _ in range(self.rows):              line = self.readfunc(fd)              assert len(line) == self.cols              self.data.extend(line)                    def __str__(self):          res = ""          for i in xrange(self.rows):              res += str(self.getrow(i)) + "\n"          return res                 class IntMatrix(Mtrx):      def __init__(self):          super(IntMatrix, self).__init__(read_ints)    class SymMatrix(Mtrx):      def __init__(self):          super(IntMatrix, self).__init__(read_syms)    class memoizeit(object):      def __init__(self, func):          self.func = func          self.cache = {}                def __call__(self, *args):          try:              return self.cache[args]          except KeyError:              value = self.func(*args)              self.cache[args] = value              return value          except TypeError:              return self.func(*args)            @property      def __name__(self):          return self.func.__name__            def __get__(self, obj, objtype):          return functools.partial(self.__call__, obj)    class timeit(object):      def __init__(self, func):          self.func = func      def __call__(self, *args):          start = time.time()          value = self.func(*args)          delta = time.time() - start          print self.func.__name__, "{:7.3f}s, (res: {})".format(delta, value)          return value      def __get__(self, obj, objtype):          return functools.partial(self.__call__, obj)    # ----------------------------------------------------------------------  <CODESPLIT> 1
import math    OEXT = ".out"  IN_S = "small.in"  IN_L = "large.in"  CASE_PRFX = "Case #%s: "      def avg(L):      return 1.0*sum(L)/len(L)    triplets = [[0,0,0], [0,0,1], [0,1,1],               [0,0,2], [0,2,2], [0,1,2],              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],              ]    def analyze_sum(sm, tgt):      av = 1.0 * sm / 3      av_cls = av % 1        #assume non surprising      if av_cls > 0.1:          ns_max_val = math.ceil(av)      else:          ns_max_val = av             #assume surprising      s_max_val = 0       if sm >= 2 and sm <= 28:          if av_cls > 0.5:              s_max_val = math.ceil(av) + 1          elif av_cls > 0.1:              s_max_val = math.ceil(av)           else:              s_max_val = av + 1            if ns_max_val >= tgt:          res = [ns_max_val, None]          kind = 1      elif s_max_val < tgt:          res = [None, None]          kind = 0      else:          res = [None, s_max_val]          kind = 2                print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind      return res, kind    def analyze_triplet(trip, tgt):      sm = sum(trip)      analyze_triplet(sm, tgt)          def read_input(filename):      data = []      with open(filename, "r") as f:          cases = int(f.readline())          for _ in xrange(cases):              case = f.readline().strip().split()              case = [int(c) for c in case]              data.append({"ngoog": case[0], "ssurp": case[1], "ptgt": case[2],                           "trips": case[3:]})      return data    def make_output(fname, output):      fname = fname + OEXT      with open(fname, "w") as f:          restext = []          for i, v in enumerate(output):              restext.append(CASE_PRFX % (i+1,) + str(v) + "\n")          f.writelines(restext)        def main(fname):      data = read_input(fname)      output = []      for case in data:          ansys = [analyze_sum(c, case["ptgt"]) for c in case["trips"]]          non_surp_is_enough = len([k for _, k in ansys if k == 1])          surp_needed = len([k for _, k in ansys if k == 2])          if surp_needed >= case["ssurp"]:              res = non_surp_is_enough + case["ssurp"]          else:              res = non_surp_is_enough + surp_needed          output.append(res)      print "output:", output      make_output(fname, output)           main("examples.in")  main("small.in") <CODESPLIT> 1
import os  import time  import decimal  import functools    #===============================================================================  # Generic helpers  #===============================================================================  # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict    #EOL = os.linesep - using this causes weird \r\r\n problems  EOL = "\n"    # ------------------------------------------------------------------------------    def is_equal_approx(x, y, epsilon=1e-6):      """Returns True iff y is within relative or absolute 'epsilon' of x.            By default, 'epsilon' is 1e-6.      """      # Check absolute precision.      if -epsilon <= x - y <= epsilon:          return True        # Is x or y too close to zero?      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:          return False        # Check relative precision.      return (-epsilon <= (x - y) / x <= epsilon          or -epsilon <= (x - y) / y <= epsilon)      def read_syms(fd):      """Read a line of whitespace separated symbols."""      return fd.readline().strip().split()    def read_ints(fd):      """Read a line of whitespace separated integers."""      return [int(p) for p in read_syms(fd)]    def read_floats(fd):      """Read a line of whitespace separated floats."""      return [float(p) for p in read_syms(fd)]    # ------------------------------------------------------------------------------    class Mtrx(object):      """A matrix object."""            def __init__(self, rows, cols, data):          assert len(data) == rows * cols          self.rows = rows          self.cols = cols          self.data = data                def cell(self, r, c):          return self.data[r * self.cols + c]            def getrow(self, i):          return [self.cell(i, c) for c in xrange(self.cols)]        def getcol(self, i):          return [self.cell(c, i) for c in xrange(self.rows)]            @classmethod      def readfromfile(cls, fd, readfunc, rows=None, cols=None):          """Read matrix from file, assuming first line at location is `R C`.                    Return a new Mtrx object. Reading values is performed by the `readfunc`.          Pre-determined size can be passed using `rows` and `cols`.          """          data = []          if rows is None:              assert cols is None              rows, cols = read_ints(fd)          else:              assert cols is not None          for _ in range(rows):              line = readfunc(fd)              assert len(line) == cols              data.extend(line)          return Mtrx(rows, cols, data)                    @classmethod      def read_int_matrix(cls, fd, rows=None, cols=None):          return cls.readfromfile(fd, read_ints, rows, cols)                    @classmethod      def read_sym_matrix(cls, fd, rows=None, cols=None):          return cls.readfromfile(fd, read_syms, rows, cols)                    def __str__(self):          res = ""          for i in xrange(self.rows):              res += str(self.getrow(i)) + EOL          return res            def __repr__(self):          return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,                                         self.cols, self.data)    # ------------------------------------------------------------------------------    cachetotals = 0  cachemisses = 0    def statreset():      global cachemisses, cachetotals      cachemisses = 0      cachetotals = 0    class memoizeit(object):      """Decorator. Caches a function's return value each time it is called.            If called later with the same arguments, the cached value is returned       (not reevaluated).      """            def __init__(self, func):          self.func = func          self.cache = {}                def __call__(self, *args):                    # update stats          global cachetotals, cachemisses          cachetotals += 1                    try:              return self.cache[args]          except KeyError:                            # update stats              cachemisses += 1                            value = self.func(*args)              self.cache[args] = value              return value          except TypeError:                # update stats              cachemisses += 1                # uncachable -- for instance, passing a list as an argument.              # Better to not cache than to blow up entirely.              return self.func(*args)            @property      def __name__(self):          return self.func.__name__            def __get__(self, obj, objtype):          """Support instance methods."""          return functools.partial(self.__call__, obj)    # ------------------------------------------------------------------------------    class timeit(object):      """Decorator that times a function.            When function ends, print name, runtime, return value and cache stats.      """            def __init__(self, func):          self.func = func                def __call__(self, *args):          start = time.time()          value = self.func(*args)          delta = time.time() - start          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \              cachetotals else 0          print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(              delta, value, cachedata)          return value            def __get__(self, obj, objtype):          return functools.partial(self.__call__, obj)    #===============================================================================  # Input/output  #===============================================================================    def read_input(filename):      data = []      with open(filename, "r") as f:          cases = read_ints(f)[0]          # =============================================          for _ in xrange(cases):              case = {}              case["N"] = read_ints(f)              case["Naomi"] = sorted(read_floats(f))              case["Ken"] = sorted(read_floats(f))              data.append(case)          # =============================================      return data    def make_output(fname, output):      CASE_PRFX = "Case #%s: "      fname = fname + time.strftime("%H%M%S") + ".out"      with open(fname, "w") as f:          restext = []          print "Output content ==============="          # =============================================          for i, outdata in enumerate(output):              line = CASE_PRFX % (i + 1,) + str(outdata) + EOL              print line,              restext.append(line)          # =============================================          print "=" * 30          f.writelines(restext)    #===============================================================================  # Actual solution  #===============================================================================    @timeit  def solveit(case):      ns = case["Naomi"]      ks = case["Ken"]            # calculate deceptive war      nsmin = 0      ksmin = 0            dwpoints = 0      while nsmin < len(ns):          if ns[nsmin] > ks[ksmin]:              ksmin += 1              dwpoints += 1           nsmin += 1            # calculate regular war      nsmax = len(ns) - 1      ksmin = 0            wpoints = 0      while len(ks) >= ksmin + 1:          print ns, ks, nsmax, ksmin          if ns[nsmax] > ks[-1]:              ksmin += 1              wpoints += 1          else:              m = ksmin              for i in xrange(len(ks)-1, ksmin-1, -1):                  if ks[i] < ns[nsmax]:                      m = i + 1                      break              del ks[m]          nsmax -= 1            return str(dwpoints) + " " + str(wpoints)       #===============================================================================  # Main  #===============================================================================    @timeit  def main(fname):      data = read_input(fname)      output = []      for case in data:          statreset() # reset cache stats          # =============================================          res = solveit(case)          output.append(res)          # =============================================      make_output(fname, output)      if __name__ == '__main__':  #    main("sample.in")      main("D-small-attempt0.in")  #    main("C-large.in")  #    main("B-small-attempt0.in")  #    main("A-large.in") <CODESPLIT> 1
from gcjbase import *    NO = "NO"  YES = "YES"      def read_input(filename):      data = []      with open(filename, "r") as f:          cases = read_ints(f)[0]          # =============================================          for _ in xrange(cases):              field = IntMatrix()              field.readfromfile(f)              data.append(field)          # =============================================      return data    def make_output(fname, output):      CASE_PRFX = "Case #%s: "      fname = fname + time.strftime("%H%M%S") + ".out"      with open(fname, "w") as f:          # =============================================          restext = []          print "Output content ==============="          for i, v in enumerate(output):              line = CASE_PRFX % (i+1,) + str(v) + "\n"              print line[:-1]              restext.append(line)          print "=" * 30          f.writelines(restext)          # =============================================    # ----------------------------------------------------------------------    @timeit  def solveit(case):      print case      for row in range(case.rows):          for col in range(case.cols):              cell = case.cell(row, col)              if (any([c > cell for c in case.getrow(row)]) and                  any([c > cell for c in case.getcol(col)])):                  return NO      return YES            @timeit  def main(fname):      data = read_input(fname)      output = []      for i, case in enumerate(data):          # =============================================          res = solveit(case)          output.append(res)          # =============================================      make_output(fname, output)      if __name__ == '__main__':  #    main("sample.in")      main("small.in")      #main("large.in") <CODESPLIT> 1
import os  import time  import decimal  import functools    #===============================================================================  # Generic helpers  #===============================================================================  # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict    #EOL = os.linesep - using this causes weird \r\r\n problems  EOL = "\n"    # ------------------------------------------------------------------------------    def is_equal_approx(x, y, epsilon=1e-6):      """Returns True iff y is within relative or absolute 'epsilon' of x.            By default, 'epsilon' is 1e-6.      """      # Check absolute precision.      if -epsilon <= x - y <= epsilon:          return True        # Is x or y too close to zero?      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:          return False        # Check relative precision.      return (-epsilon <= (x - y) / x <= epsilon          or -epsilon <= (x - y) / y <= epsilon)      def read_syms(fd):      """Read a line of whitespace separated symbols."""      return fd.readline().strip().split()    def read_ints(fd):      """Read a line of whitespace separated integers."""      return [int(p) for p in read_syms(fd)]    def read_floats(fd):      """Read a line of whitespace separated floats."""      return [float(p) for p in read_syms(fd)]    # ------------------------------------------------------------------------------    class Mtrx(object):      """A matrix object."""            def __init__(self, rows, cols, data):          assert len(data) == rows * cols          self.rows = rows          self.cols = cols          self.data = data                def cell(self, r, c):          return self.data[r * self.cols + c]            def getrow(self, i):          return [self.cell(i, c) for c in xrange(self.cols)]        def getcol(self, i):          return [self.cell(c, i) for c in xrange(self.rows)]            @classmethod      def readfromfile(cls, fd, readfunc, rows=None, cols=None):          """Read matrix from file, assuming first line at location is `R C`.                    Return a new Mtrx object. Reading values is performed by the `readfunc`.          Pre-determined size can be passed using `rows` and `cols`.          """          data = []          if rows is None:              assert cols is None              rows, cols = read_ints(fd)          else:              assert cols is not None          for _ in range(rows):              line = readfunc(fd)              assert len(line) == cols              data.extend(line)          return Mtrx(rows, cols, data)                    @classmethod      def read_int_matrix(cls, fd, rows=None, cols=None):          return cls.readfromfile(fd, read_ints, rows, cols)                    @classmethod      def read_sym_matrix(cls, fd, rows=None, cols=None):          return cls.readfromfile(fd, read_syms, rows, cols)                    def __str__(self):          res = ""          for i in xrange(self.rows):              res += str(self.getrow(i)) + EOL          return res            def __repr__(self):          return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,                                         self.cols, self.data)    # ------------------------------------------------------------------------------    cachetotals = 0  cachemisses = 0    def statreset():      global cachemisses, cachetotals      cachemisses = 0      cachetotals = 0    class memoizeit(object):      """Decorator. Caches a function's return value each time it is called.            If called later with the same arguments, the cached value is returned       (not reevaluated).      """            def __init__(self, func):          self.func = func          self.cache = {}                def __call__(self, *args):                    # update stats          global cachetotals, cachemisses          cachetotals += 1                    try:              return self.cache[args]          except KeyError:                            # update stats              cachemisses += 1                            value = self.func(*args)              self.cache[args] = value              return value          except TypeError:                # update stats              cachemisses += 1                # uncachable -- for instance, passing a list as an argument.              # Better to not cache than to blow up entirely.              return self.func(*args)            @property      def __name__(self):          return self.func.__name__            def __get__(self, obj, objtype):          """Support instance methods."""          return functools.partial(self.__call__, obj)    # ------------------------------------------------------------------------------    class timeit(object):      """Decorator that times a function.            When function ends, print name, runtime, return value and cache stats.      """            def __init__(self, func):          self.func = func                def __call__(self, *args):          start = time.time()          value = self.func(*args)          delta = time.time() - start          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \              cachetotals else 0          print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(              delta, value, cachedata)          return value            def __get__(self, obj, objtype):          return functools.partial(self.__call__, obj)    #===============================================================================  # Input/output  #===============================================================================    def read_input(filename):      data = []      with open(filename, "r") as f:          cases = read_ints(f)[0]          # =============================================          for _ in xrange(cases):              case = {}              case["C"], case["F"], case["X"] = read_floats(f)              data.append(case)          # =============================================      return data    def make_output(fname, output):      CASE_PRFX = "Case #%s: "      fname = fname + time.strftime("%H%M%S") + ".out"      with open(fname, "w") as f:          restext = []          print "Output content ==============="          # =============================================          for i, outdata in enumerate(output):              line = CASE_PRFX % (i + 1,) + str(outdata) + EOL              print line,              restext.append(line)          # =============================================          print "=" * 30          f.writelines(restext)    #===============================================================================  # Actual solution  #===============================================================================    @memoizeit  def will_a_farm_help(target, current_rate, farm_cost, farm_rate):      no_farm = target / current_rate      with_farm = farm_cost / current_rate + target / (farm_rate + current_rate)      if no_farm > with_farm:          return True, farm_cost / current_rate      else:          return False, no_farm    @timeit  def solveit(case):      C = case["C"]      F = case["F"]      X = case["X"]            t = 0      current_rate = 2.0 # default rate of 2 cookies per seconds            while True:          new_farm, add_time = will_a_farm_help(X, current_rate, C, F)          if new_farm:              t += add_time              current_rate += F          else:              t += add_time              return t    #===============================================================================  # Main  #===============================================================================    @timeit  def main(fname):      data = read_input(fname)      output = []      for case in data:          statreset() # reset cache stats          # =============================================          res = solveit(case)          output.append(res)          # =============================================      make_output(fname, output)      if __name__ == '__main__':  #    main("sample.in")      main("B-small-attempt0.in")  #    main("B-large.in")  #    main("B-small-attempt0.in")  #    main("A-large.in") <CODESPLIT> 1
# TODO FOR 14 : rounding functions, graph manipulation, desert lion    import time  import os  import functools    #EOL = os.linesep - using this causes weird \r\r\n problems  EOL = "\n"    # ----------------------------------------------------------------------    def is_equal_approx(x, y, epsilon=1e-6):      """Returns True iff y is within relative or absolute 'epsilon' of x.            By default, 'epsilon' is 1e-6.      """      # Check absolute precision.      if -epsilon <= x - y <= epsilon:          return True        # Is x or y too close to zero?      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:          return False        # Check relative precision.      return (-epsilon <= (x - y) / x <= epsilon          or -epsilon <= (x - y) / y <= epsilon)      def read_syms(fd):      """Read a line of whitespace separated symbols."""      return fd.readline().strip().split()    def read_ints(fd):      """Read a line of whitespace separated integers."""      return [int(p) for p in read_syms(fd)]    def read_floats(fd):      """Read a line of whitespace separated floats."""      return [float(p) for p in read_syms(fd)]    class Mtrx(object):      """A matrix object."""            def __init__(self, rows, cols, data):          assert len(data) == rows * cols          self.rows = rows          self.cols = cols          self.data = data                def cell(self, r, c):          return self.data[r * self.cols + c]            def getrow(self, i):          return [self.cell(i, c) for c in xrange(self.cols)]        def getcol(self, i):          return [self.cell(c, i) for c in xrange(self.rows)]            @classmethod      def readfromfile(cls, fd, readfunc, rows=None, cols=None):          """Read matrix from file, assuming first line at location is `R C`.                    Return a new Mtrx object. Reading values is performed by the `readfunc`.          Pre-determined size can be passed using `rows` and `cols`.          """          data = []          if rows is None:              assert cols is None              rows, cols = read_ints(fd)          else:              assert cols is not None          for _ in range(rows):              line = readfunc(fd)              assert len(line) == cols              data.extend(line)          return Mtrx(rows, cols, data)                    @classmethod      def read_int_matrix(cls, fd, rows=None, cols=None):          return cls.readfromfile(fd, read_ints, rows, cols)                    @classmethod      def read_sym_matrix(cls, fd, rows=None, cols=None):          return cls.readfromfile(fd, read_syms, rows, cols)                    def __str__(self):          res = ""          for i in xrange(self.rows):              res += str(self.getrow(i)) + EOL          return res            def __repr__(self):          return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,                                         self.cols, self.data)    #===============================================================================  # Class decorators   #===============================================================================                 cachetotals = 0  cachemisses = 0    def statreset():      global cachemisses, cachetotals      cachemisses = 0      cachetotals = 0    class memoizeit(object):      """Decorator. Caches a function's return value each time it is called.            If called later with the same arguments, the cached value is returned       (not reevaluated).      """            def __init__(self, func):          self.func = func          self.cache = {}                def __call__(self, *args):                    # update stats          global cachetotals, cachemisses          cachetotals += 1                    try:              return self.cache[args]          except KeyError:                            # update stats              cachemisses += 1                            value = self.func(*args)              self.cache[args] = value              return value          except TypeError:                # update stats              cachemisses += 1                # uncachable -- for instance, passing a list as an argument.              # Better to not cache than to blow up entirely.              return self.func(*args)            @property      def __name__(self):          return self.func.__name__            def __get__(self, obj, objtype):          """Support instance methods."""          return functools.partial(self.__call__, obj)    class timeit(object):      """Decorator that times a function.            When function ends, print name, runtime, return value and cache stats.      """            def __init__(self, func):          self.func = func                def __call__(self, *args):          start = time.time()          value = self.func(*args)          delta = time.time() - start          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \              cachetotals else 0          print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(              delta, value, cachedata)          return value            def __get__(self, obj, objtype):          return functools.partial(self.__call__, obj)    # ----------------------------------------------------------------------  <CODESPLIT> 1
import string     OEXT = ".out"  IN_S = "small.in"  IN_L = "large.in"  CASE_PRFX = "Case #%s: "    ddd = {}    def read_input(filename):      data = []      with open(filename, "r") as f:          cases = int(f.readline())          for _ in xrange(cases):              code = f.readline()              data.append(code)      return data    def make_output(fname, output):      fname = fname + OEXT      with open(fname, "w") as f:          restext = []          for i, v in enumerate(output):              restext.append(CASE_PRFX % (i+1,) + v)          f.writelines(restext)        def main(fname):      data = read_input(fname)      output = []      for code in data:          output.append("".join([ddd[k] for k in code]))      print output      make_output(fname, output)        def mainex(fname):      with open(fname, "r") as f:          cases = int(f.readline())          for _ in xrange(cases):              code = f.readline()              trans = f.readline()              for i, c in enumerate(code):                  ddd.setdefault(c, trans[i])            abc = string.ascii_lowercase + " \n"      for c in abc:          if c not in ddd.values():              print "not in trans:", c              missingt = c          if c not in ddd.keys():              print "not in code:", c              missingc = c      ddd.setdefault(missingc, missingt)      print ddd      print len(ddd)      return ddd                    mainex("examples.in")  main("examples_raw.in")  main("small.in") <CODESPLIT> 1
from gcjbase import *    XWON = "X won"  OWON = "O won"  DRAW = "Draw"   NOTOVER = "Game has not completed"      def read_input(filename):      data = []      with open(filename, "r") as f:          cases = read_ints(f)[0]          # =============================================          for _ in xrange(cases):              board = []              for _ in xrange(4):                  board.extend(read_syms(f))              read_syms(f)              data.append(board)          # =============================================      return data    def make_output(fname, output):      CASE_PRFX = "Case #%s: "      fname = fname + time.strftime("%H%M%S") + ".out"      with open(fname, "w") as f:          # =============================================          restext = []          for i, v in enumerate(output):              line = CASE_PRFX % (i+1,) + str(v) + "\n"              print line              restext.append(line)          f.writelines(restext)          # =============================================    # ----------------------------------------------------------------------    def getrow(board, i):      return board[i*4:4*i+4]    def getcol(board, i):      return [c for j, c in enumerate(board) if j % 4 == i ]    def getdiag(board, i):      if i == 0:          return board[0], board[5], board[10], board[15]      return board[3], board[6], board[9], board[12]    @timeit  def solveit(case):      print case      xcase = [(c if c != 'T' else 'X') for c in case]      ocase = [(c if c != 'T' else 'O') for c in case]            # rows      for i in range(4):          if all([x == 'X' for x in getrow(xcase, i)]):              return XWON          if all([x == 'O' for x in getrow(ocase, i)]):              return OWON                # cols      for i in range(4):          if all([x == 'X' for x in getcol(xcase, i)]):              return XWON          if all([x == 'O' for x in getcol(ocase, i)]):              return OWON                # diag      for i in range(2):          if all([x == 'X' for x in getdiag(xcase, i)]):              return XWON          if all([x == 'O' for x in getdiag(ocase, i)]):              return OWON                if any([x == '.' for x in case]):          return NOTOVER      return DRAW            @timeit  def main(fname):      data = read_input(fname)      output = []      for i, case in enumerate(data):          # =============================================          res = solveit(case)          output.append(res)          # =============================================      make_output(fname, output)      if __name__ == '__main__':      #main("sample.in")      main("small.in")      #main("sample.in") <CODESPLIT> 1
import os  import time  import decimal  import functools    #===============================================================================  # Generic helpers  #===============================================================================  # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict    #EOL = os.linesep - using this causes weird \r\r\n problems  EOL = "\n"    # ------------------------------------------------------------------------------    def is_equal_approx(x, y, epsilon=1e-6):      """Returns True iff y is within relative or absolute 'epsilon' of x.            By default, 'epsilon' is 1e-6.      """      # Check absolute precision.      if -epsilon <= x - y <= epsilon:          return True        # Is x or y too close to zero?      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:          return False        # Check relative precision.      return (-epsilon <= (x - y) / x <= epsilon          or -epsilon <= (x - y) / y <= epsilon)      def read_syms(fd):      """Read a line of whitespace separated symbols."""      return fd.readline().strip().split()    def read_ints(fd):      """Read a line of whitespace separated integers."""      return [int(p) for p in read_syms(fd)]    def read_floats(fd):      """Read a line of whitespace separated floats."""      return [float(p) for p in read_syms(fd)]    # ------------------------------------------------------------------------------    class Mtrx(object):      """A matrix object."""            def __init__(self, rows, cols, data):          assert len(data) == rows * cols          self.rows = rows          self.cols = cols          self.data = data                def cell(self, r, c):          return self.data[r * self.cols + c]            def getrow(self, i):          return [self.cell(i, c) for c in xrange(self.cols)]        def getcol(self, i):          return [self.cell(c, i) for c in xrange(self.rows)]            @classmethod      def readfromfile(cls, fd, readfunc, rows=None, cols=None):          """Read matrix from file, assuming first line at location is `R C`.                    Return a new Mtrx object. Reading values is performed by the `readfunc`.          Pre-determined size can be passed using `rows` and `cols`.          """          data = []          if rows is None:              assert cols is None              rows, cols = read_ints(fd)          else:              assert cols is not None          for _ in range(rows):              line = readfunc(fd)              assert len(line) == cols              data.extend(line)          return Mtrx(rows, cols, data)                    @classmethod      def read_int_matrix(cls, fd, rows=None, cols=None):          return cls.readfromfile(fd, read_ints, rows, cols)                    @classmethod      def read_sym_matrix(cls, fd, rows=None, cols=None):          return cls.readfromfile(fd, read_syms, rows, cols)                    def __str__(self):          res = ""          for i in xrange(self.rows):              res += str(self.getrow(i)) + EOL          return res            def __repr__(self):          return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,                                         self.cols, self.data)    # ------------------------------------------------------------------------------    cachetotals = 0  cachemisses = 0    def statreset():      global cachemisses, cachetotals      cachemisses = 0      cachetotals = 0    class memoizeit(object):      """Decorator. Caches a function's return value each time it is called.            If called later with the same arguments, the cached value is returned       (not reevaluated).      """            def __init__(self, func):          self.func = func          self.cache = {}                def __call__(self, *args):                    # update stats          global cachetotals, cachemisses          cachetotals += 1                    try:              return self.cache[args]          except KeyError:                            # update stats              cachemisses += 1                            value = self.func(*args)              self.cache[args] = value              return value          except TypeError:                # update stats              cachemisses += 1                # uncachable -- for instance, passing a list as an argument.              # Better to not cache than to blow up entirely.              return self.func(*args)            @property      def __name__(self):          return self.func.__name__            def __get__(self, obj, objtype):          """Support instance methods."""          return functools.partial(self.__call__, obj)    # ------------------------------------------------------------------------------    class timeit(object):      """Decorator that times a function.            When function ends, print name, runtime, return value and cache stats.      """            def __init__(self, func):          self.func = func                def __call__(self, *args):          start = time.time()          value = self.func(*args)          delta = time.time() - start          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \              cachetotals else 0          print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(              delta, value, cachedata)          return value            def __get__(self, obj, objtype):          return functools.partial(self.__call__, obj)    #===============================================================================  # Input/output  #===============================================================================    def read_input(filename):      data = []      with open(filename, "r") as f:          cases = read_ints(f)[0]          # =============================================          for _ in xrange(cases):              case = {}              case["R"], case["C"], case["M"] = read_ints(f)              data.append(case)          # =============================================      return data    def make_output(fname, output):      CASE_PRFX = "Case #%s: "      fname = fname + time.strftime("%H%M%S") + ".out"      with open(fname, "w") as f:          restext = []          print "Output content ==============="          # =============================================          for i, outdata in enumerate(output):              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL              print line,              restext.append(line)          # =============================================          print "=" * 30          f.writelines(restext)    #===============================================================================  # Actual solution  #===============================================================================    MINE = "*"  CLICK = "c"  UNK = "."    class Board(object):            def __init__(self, r, c):          self.rows = r          self.cols = c          self.edge_row_idx = self.rows - 1          self.edge_col_idx = self.cols - 1          self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]          self.board[0][0] = CLICK        def fill_edge_row(self, m):          i = self.edge_col_idx          while m > 0 and i >= 0:              self.board[self.edge_row_idx][i] = MINE              i -= 1              m -= 1          self.edge_row_idx -= 1        def fill_edge_col(self, m):          i = self.edge_row_idx          while m > 0 and i >= 0:              self.board[i][self.edge_col_idx] = MINE              i -= 1              m -= 1          self.edge_col_idx -= 1        def __str__(self):          return EOL.join(["".join(r) for r in self.board])    @memoizeit  def is_stage_solvable(rows, cols, mines):      """Return True iff stage is solvable.       Also return fill instruction:      0 if impossible/dontcare, 1 to fill row, 2 to fill column,       3 for row special (most in the row), 4 for col special (most in the col)      """      rc = rows * cols            # all full      if mines == rc:          return False, 0        if rows == 1:          return mines <= rc - 1, 2      if cols == 1:          return mines <= rc - 1, 1            # rows and cols > 1      # single cell in corner         if mines == rc - 1:          return True, 1  # doesn't matter what to fill            # won't find 4 cells for the corner      if mines > rc - 4:          return False, 0            if rows == 2:          return (False, 0) if mines == 1 else (True, 2)      if cols == 2:          return (False, 0) if mines == 1 else (True, 1)                # rows and cols > 2      if rows <= cols:          # try to fill columns          if mines >= rows:              return True, 2          if mines == rows - 1:              if mines == cols - 1:                  if rows == 3:                      return False, 0                  return True, 4 # L shape fill, most in the column              else:                  return True, 1 # fill row          return True, 2       else:          # try to fill rows          if mines >= cols:              return True, 1          if mines == cols - 1:              if mines == rows - 1:                  if cols == 3:                      return False, 0                  return True, 3 # L shape fill, most in the row              else:                  return True, 2 # fill column          return True, 1     @timeit  def solveit(case):      rows = case["R"]      cols = case["C"]      mines = case["M"]            b = Board(rows, cols)      r, c, m = rows, cols, mines            while m >= 0:          okgo, howtofill = is_stage_solvable(r, c, m)          if not okgo:              return "Impossible"          if howtofill == 1: # fill row              b.fill_edge_row(m)              if m <= c:                  break # fill and done              m -= c              r -= 1          elif howtofill == 2: # fill column              b.fill_edge_col(m)              if m <= r:                  break # fill and done              m -= r              c -= 1          elif howtofill == 3: # L shape fill, most in the row              b.fill_edge_row(m - 1)              b.fill_edge_col(1)              break # fill and done          elif howtofill == 4: # L shape fill, most in the column              b.fill_edge_col(m - 1)              b.fill_edge_row(1)              break # fill and done          else:              assert False        return str(b)       #===============================================================================  # Main  #===============================================================================    @timeit  def main(fname):      data = read_input(fname)      output = []      for case in data:          statreset() # reset cache stats          # =============================================          res = solveit(case)          output.append(res)          # =============================================      make_output(fname, output)      if __name__ == '__main__':  #    main("sample.in")      main("C-small-attempt0.in")  #    main("B-large.in")  #    main("B-small-attempt0.in")  #    main("A-large.in") <CODESPLIT> 1
import time    OEXT = ".out"  CASE_PRFX = "Case #%s: "    MAXB = 2000000        def circlify(num, cutoff=MAXB):      numstr = str(num) + str(num)      max_opt = len(numstr) / 2      opts = [int(numstr[i:i+max_opt]) for i in xrange(max_opt)]            # only values larger than num (also filters leading zeroes)       # and smaller than cutoff      opts = [o for o in opts if o > num and o <= cutoff]            #clean dupes      return len(set(opts))    def check(A, B):      res2 = 0      start = time.time()      for t in xrange(A, B):          res2 += circlify(t, B)      print res2, time.time()-start          return res2    def read_input(filename):      data = []      with open(filename, "r") as f:          cases = int(f.readline())          for _ in xrange(cases):              case = f.readline().strip().split()              data.append((int(case[0]), int(case[1])))      return data    def make_output(fname, output):      fname = fname + OEXT      with open(fname, "w") as f:          restext = []          for i, v in enumerate(output):              restext.append(CASE_PRFX % (i+1,) + str(v) + "\n")          f.writelines(restext)        def main(fname):      data = read_input(fname)      output = []      for case in data:          output.append(check(case[0], case[1]))      print "output:", output      make_output(fname, output)    main("small.in") <CODESPLIT> 1
  import math  import itertools  import numpy    def read_word(f):      return next(f).strip()    def read_int(f, b=10):      return int(read_word(f), b)    def read_letters(f):      return list(read_word(f))    def read_digits(f, b=10):      return [int(x, b) for x in read_letters(f)]    def read_words(f, d=' '):      return read_word(f).split(d)    def read_ints(f, b=10, d=' '):      return [int(x, b) for x in read_words(f, d)]    def read_floats(f, d=' '):      return [float(x) for x in read_words(f, d)]    def read_arr(f, R, reader=read_ints, *args, **kwargs):      res = []      for i in range(R):          res.append(reader(f, *args, **kwargs))      return res    def solve(solver, fn, out_fn=None):      in_fn = fn + '.in'      if out_fn is None:          out_fn = fn + '.out'      with open(in_fn, 'r') as fi:          with open(out_fn, 'w') as fo:              T = read_int(fi)              for i in range(T):                  case = read_case(fi)                  res = solver(case)                  write_case(fo, i, res)    ################################################################################    def read_case(f):      return read_ints(f)    def write_case(f, i, res):      f.write('Case #%d: '%i)      f.write('%d'%res)      f.write('\n')    ################################################################################    def aux(A, B, x, s):      res = 0      n = int(''.join(x[::-1]+x))      nn = n*n      if nn > B:          return res      if nn >= A:          res += 1      for c in [0, 1, 2]:          if s + c*c < 10:              n = int(''.join(x[::-1]+[str(c)]+x))              nn = n*n              if nn >= A and nn <= B:                  res += 1          if s + 2*c*c < 10:              res += aux(A, B, [str(c)]+x, s + 2*c*c)      return res    def solve_small(case):      [A, B] = case      res = 0      for n in [1, 4, 9]:          if n >= A and n <= B:              res += 1      for c in [1, 2]:          res += aux(A, B, [str(c)], 2*c*c)      return res    def solve_large(case):      return solve_small(case)    DEBUG = 'i'    from run import *  <CODESPLIT> 2
  import sys  import os  import itertools  import math  import numpy    __file__ = sys.argv[0]  __path__ = os.path.dirname(__file__)  __prob__ = os.path.basename(__path__)    def pout(s, back=0):      f = sys._getframe(back+1)      d = 0      if 'depth' in f.f_locals:          d = f.f_locals['depth']      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))    def perr(s, back=0):      f = sys._getframe(back+1)      d = 0      if 'depth' in f.f_locals:          d = f.f_locals['depth']      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))    def argmin(f, s=None):      a = f      if s is None:          s = range(len(a))          f = lambda i: a[i]      res = None      for x in s:          y = f(x)          if res is None or best > y:              best = y              res = x      return res    def argmax(f, s=None):      a = f      if s is None:          s = range(len(a))          f = lambda i: a[i]      res = None      for x in s:          y = f(x)          if res is None or best < y:              best = y              res = x      return res    def read_word(f):      return next(f).strip()    def read_int(f, b=10):      return int(read_word(f), b)    def read_words(f, d=' '):      return read_word(f).split(d)    def read_ints(f, b=10, d=' '):      return [int(x, b) for x in read_words(f, d)]    def read_word_arr(f, R):      res = []      for i in range(R):          res.append(read_word(f))      return res    def read_ints_arr(f, R, dtype=int, *args, **kwargs):      res = []      for i in range(R):          res.append(read_ints(f, *args, **kwargs))      return numpy.array(res, dtype)    def solve(solver, fn, start_case=0, end_case=None, out_fn=None):      global ERR_FILE      in_fn = fn + '.in'      if out_fn is None:          out_fn = fn + '.out'      err_fn = fn + '.err'      if start_case == 0:          append = True          if os.path.exists(out_fn):              with open(out_fn, 'r') as f:                  for l in f:                      if l[:6] == 'Case #':                          start_case = int(l[6:l.index(':')])+1      else:          append = False      with open(in_fn, 'r') as fi:          with open(out_fn, 'a' if append else 'w') as fo:              with open(err_fn, 'w') as ERR_FILE:                  T = read_int(fi)                  for i in range(T):                      case = read_case(fi)                      if i+1 < start_case:                          continue                      print('Case #%d of %d'%(i+1, T))                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))                      perr('case')                      res = solver(case)                      perr('res')                      write_case(fo, i, res)                      fo.flush()                      if end_case is not None and i+1 == end_case:                          break    def test(start_case=1, end_case=None):      fn = os.path.join(__path__, 'test')      solve(solve_small, fn, start_case, end_case)    def small(start_case=1, end_case=None):      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)      solve(solve_small, fn, start_case, end_case)    def small2(start_case=1, end_case=None):      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)      solve(solve_large, fn, start_case, end_case, fn + '2.out')    def large(start_case=0, end_case=None):      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)      solve(solve_large, fn, start_case, end_case)    ################################################################################    def read_case(f):      Z = read_ints(f)      (N, S, p) = Z[:3]      t = Z[3:]      return (N, S, p, t)    def write_case(f, i, res):      f.write('Case #%d: '%(i+1))      f.write('%s'%res)      f.write('\n')    FAIL = 'NO SOLUTION'    def solve_small(case):      (N, S, p, t) = case      res = 0      for i in range(N):          if p >= 2:              if t[i] >= 3*p-2:                  res += 1              elif S > 0 and t[i] >= 3*p-4:                  res += 1                  S -= 1          elif p == 1:              if t[i] >= 3*p-2:                  res += 1          elif p == 0:              res += 1      return res    solve_large = solve_small    ##perr = pout  ##pout = lambda s: None  pout = perr  <CODESPLIT> 2
  import math  import itertools  import numpy as NP    def read_word(f):      return next(f).strip()    def read_int(f, b=10):      return int(read_word(f), b)    def read_letters(f):      return list(read_word(f))    def read_digits(f, b=10):      return [int(x, b) for x in read_letters(f)]    def read_words(f, d=' '):      return read_word(f).split(d)    def read_ints(f, b=10, d=' '):      return [int(x, b) for x in read_words(f, d)]    def read_floats(f, d=' '):      return [float(x) for x in read_words(f, d)]    def read_arr(f, R, reader=read_ints, *args, **kwargs):      return [reader(f, *args, **kwargs) for i in range(R)]    def solve(solver, fn, out_fn=None):      in_fn = fn + '.in'      if out_fn is None:          out_fn = fn + '.out'      with open(in_fn, 'r') as fi:          with open(out_fn, 'w') as fo:              T = read_int(fi)              for i in range(T):                  case = read_case(fi)                  res = solver(case)                  write_case(fo, i, res)    ################################################################################    def read_case(f):      N = read_int(f)      MN = read_floats(f)      MK = read_floats(f)      return (N, MN, MK)    def write_case(f, i, res):      f.write('Case #%d: '%i)      f.write('%d %d'%res)      f.write('\n')    ################################################################################    def solve_small(case):      (N, MN, MK) = case      MN = sorted(MN)      MK = sorted(MK)      y = 0      i = 0      for j in range(N):          while i < N and MN[i] < MK[j]:              i += 1          if i < N:              y += 1              i += 1      z = N      j = 0      for i in range(N):          while j < N and MN[i] > MK[j]:              j += 1          if j < N:              z -= 1              j += 1      return (y, z)    def solve_large(case):      return solve_small(case)    DEBUG = 'i'    from run import *  <CODESPLIT> 2
  import math  import itertools  import numpy    def read_word(f):      return next(f).strip()    def read_int(f, b=10):      return int(read_word(f), b)    def read_letters(f):      return list(read_word(f))    def read_digits(f, b=10):      return [int(x, b) for x in read_letters(f)]    def read_words(f, d=' '):      return read_word(f).split(d)    def read_ints(f, b=10, d=' '):      return [int(x, b) for x in read_words(f, d)]    def read_floats(f, d=' '):      return [float(x) for x in read_words(f, d)]    def read_arr(f, R, reader=read_ints, *args, **kwargs):      res = []      for i in range(R):          res.append(reader(f, *args, **kwargs))      return res    def solve(solver, fn, out_fn=None):      in_fn = fn + '.in'      if out_fn is None:          out_fn = fn + '.out'      with open(in_fn, 'r') as fi:          with open(out_fn, 'w') as fo:              T = read_int(fi)              for i in range(T):                  case = read_case(fi)                  res = solver(case)                  write_case(fo, i, res)    ################################################################################    def read_case(f):      [N, M] = read_ints(f)      A = read_arr(f, N)      return (N, M, A)    def write_case(f, i, res):      f.write('Case #%d: '%i)      f.write('%s'%res)      f.write('\n')    ################################################################################    def solve_small(case):      (N, M, A) = case      rows = [max(row) for row in A]      cols = [max(row[j] for row in A) for j in range(M)]      for i in range(N):          for j in range(M):              if A[i][j] < min(rows[i], cols[j]):                  return 'NO'      return 'YES'    def solve_large(case):      return solve_small(case)    DEBUG = 'i'    from run import *  <CODESPLIT> 2
  import math  import itertools  import numpy as NP    def read_word(f):      return next(f).strip()    def read_int(f, b=10):      return int(read_word(f), b)    def read_letters(f):      return list(read_word(f))    def read_digits(f, b=10):      return [int(x, b) for x in read_letters(f)]    def read_words(f, d=' '):      return read_word(f).split(d)    def read_ints(f, b=10, d=' '):      return [int(x, b) for x in read_words(f, d)]    def read_floats(f, d=' '):      return [float(x) for x in read_words(f, d)]    def read_arr(f, R, reader=read_ints, *args, **kwargs):      return [reader(f, *args, **kwargs) for i in range(R)]    def solve(solver, fn, out_fn=None):      in_fn = fn + '.in'      if out_fn is None:          out_fn = fn + '.out'      with open(in_fn, 'r') as fi:          with open(out_fn, 'w') as fo:              T = read_int(fi)              for i in range(T):                  case = read_case(fi)                  res = solver(case)                  write_case(fo, i, res)    ################################################################################    def read_case(f):      return read_floats(f)    def write_case(f, i, res):      f.write('Case #%d: '%i)      f.write('%s'%res)      f.write('\n')    ################################################################################    def solve_small(case):      (C, F, X) = case      res = 0      i = 0      while X/(2 + i*F) > C/(2 + i*F) + X/(2 + (i+1)*F):          res += C/(2 + i*F)          i += 1      return res + X/(2 + i*F)    def solve_large(case):      return solve_small(case)    DEBUG = 'i'    from run import *  <CODESPLIT> 2
  import math  import itertools  import numpy as NP    def read_word(f):      return next(f).strip()    def read_int(f, b=10):      return int(read_word(f), b)    def read_letters(f):      return list(read_word(f))    def read_digits(f, b=10):      return [int(x, b) for x in read_letters(f)]    def read_words(f, d=' '):      return read_word(f).split(d)    def read_ints(f, b=10, d=' '):      return [int(x, b) for x in read_words(f, d)]    def read_floats(f, d=' '):      return [float(x) for x in read_words(f, d)]    def read_arr(f, R, reader=read_ints, *args, **kwargs):      return [reader(f, *args, **kwargs) for i in range(R)]    def solve(solver, fn, out_fn=None):      in_fn = fn + '.in'      if out_fn is None:          out_fn = fn + '.out'      with open(in_fn, 'r') as fi:          with open(out_fn, 'w') as fo:              T = read_int(fi)              for i in range(T):                  case = read_case(fi)                  res = solver(case)                  write_case(fo, i, res)    ################################################################################    def read_case(f):      R1 = read_int(f)      Q1 = read_arr(f, 4)      R2 = read_int(f)      Q2 = read_arr(f, 4)      return (R1, Q1, R2, Q2)    def write_case(f, i, res):      f.write('Case #%d: '%i)      f.write('%s'%res)      f.write('\n')    ################################################################################    def solve_small(case):      (R1, Q1, R2, Q2) = case      s = set(Q1[R1-1]) & set(Q2[R2-1])      if len(s) == 0:          return 'Volunteer cheated!'      if len(s) == 1:          return s.pop()      return 'Bad magician!'    def solve_large(case):      return solve_small(case)    DEBUG = 'i'    from run import *  <CODESPLIT> 2
  import sys  import os  import itertools  import math  import numpy    __file__ = sys.argv[0]  __path__ = os.path.dirname(__file__)  __prob__ = os.path.basename(__path__)    def pout(s, back=0):      f = sys._getframe(back+1)      d = 0      if 'depth' in f.f_locals:          d = f.f_locals['depth']      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))    def perr(s, back=0):      f = sys._getframe(back+1)      d = 0      if 'depth' in f.f_locals:          d = f.f_locals['depth']      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))    def argmin(f, s=None):      a = f      if s is None:          s = range(len(a))          f = lambda i: a[i]      res = None      for x in s:          y = f(x)          if res is None or best > y:              best = y              res = x      return res    def argmax(f, s=None):      a = f      if s is None:          s = range(len(a))          f = lambda i: a[i]      res = None      for x in s:          y = f(x)          if res is None or best < y:              best = y              res = x      return res    def read_word(f):      return next(f).strip()    def read_int(f, b=10):      return int(read_word(f), b)    def read_words(f, d=' '):      return read_word(f).split(d)    def read_ints(f, b=10, d=' '):      return [int(x, b) for x in read_words(f, d)]    def read_word_arr(f, R):      res = []      for i in range(R):          res.append(read_word(f))      return res    def read_ints_arr(f, R, dtype=int, *args, **kwargs):      res = []      for i in range(R):          res.append(read_ints(f, *args, **kwargs))      return numpy.array(res, dtype)    def solve(solver, fn, start_case=0, end_case=None, out_fn=None):      global ERR_FILE      in_fn = fn + '.in'      if out_fn is None:          out_fn = fn + '.out'      err_fn = fn + '.err'      if start_case == 0:          append = True          if os.path.exists(out_fn):              with open(out_fn, 'r') as f:                  for l in f:                      if l[:6] == 'Case #':                          start_case = int(l[6:l.index(':')])+1      else:          append = False      with open(in_fn, 'r') as fi:          with open(out_fn, 'a' if append else 'w') as fo:              with open(err_fn, 'w') as ERR_FILE:                  T = read_int(fi)                  for i in range(T):                      case = read_case(fi)                      if i+1 < start_case:                          continue                      print('Case #%d of %d'%(i+1, T))                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))                      perr('case')                      res = solver(case)                      perr('res')                      write_case(fo, i, res)                      fo.flush()                      if end_case is not None and i+1 == end_case:                          break    def test(start_case=1, end_case=None):      fn = os.path.join(__path__, 'test')      solve(solve_small, fn, start_case, end_case)    def small(start_case=1, end_case=None):      fn = os.path.join(__path__, '%s-small-practice'%__prob__)      solve(solve_small, fn, start_case, end_case)    def small2(start_case=1, end_case=None):      fn = os.path.join(__path__, '%s-small-practice'%__prob__)      solve(solve_large, fn, start_case, end_case, fn + '2.out')    def large(start_case=0, end_case=None):      fn = os.path.join(__path__, '%s-large-practice'%__prob__)      solve(solve_large, fn, start_case, end_case)    ################################################################################    def read_case(f):      G = read_word(f)      return G    def write_case(f, i, res):      f.write('Case #%d: '%(i+1))      f.write('%s'%res)      f.write('\n')    FAIL = 'NO SOLUTION'    TRANS = {'z': 'q', 'q': 'z', '\n': '\n', ' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm'}    def solve_small(case):      G = case      return ''.join(TRANS[x] for x in G)    solve_large = solve_small    ##perr = pout  ##pout = lambda s: None  pout = perr  <CODESPLIT> 2
  import math  import itertools  import numpy    def read_word(f):      return next(f).strip()    def read_int(f, b=10):      return int(read_word(f), b)    def read_letters(f):      return list(read_word(f))    def read_digits(f, b=10):      return [int(x, b) for x in read_letters(f)]    def read_words(f, d=' '):      return read_word(f).split(d)    def read_ints(f, b=10, d=' '):      return [int(x, b) for x in read_words(f, d)]    def read_floats(f, d=' '):      return [float(x) for x in read_words(f, d)]    def read_arr(f, R, reader=read_ints, *args, **kwargs):      res = []      for i in range(R):          res.append(reader(f, *args, **kwargs))      return res    def solve(solver, fn, out_fn=None):      in_fn = fn + '.in'      if out_fn is None:          out_fn = fn + '.out'      with open(in_fn, 'r') as fi:          with open(out_fn, 'w') as fo:              T = read_int(fi)              for i in range(T):                  case = read_case(fi)                  res = solver(case)                  write_case(fo, i, res)    ################################################################################    def read_case(f):      B = read_arr(f, 4, read_letters)      read_word(f)      return B    def write_case(f, i, res):      f.write('Case #%d: '%i)      f.write('%s'%res)      f.write('\n')    ################################################################################    def test(a):      if '.' not in a and 'O' not in a:          return 'X won'      if '.' not in a and 'X' not in a:          return 'O won'    def solve_small(case):      draw = True      for row in case:          if '.' in row:              draw = False          res = test(row)          if res:              return res      for i in range(len(case[0])):          col = [row[i] for row in case]          res = test(col)          if res:              return res      diag = [case[i][i] for i in range(len(case))]      res = test(diag)      if res:          return res      diag = [case[i][-i-1] for i in range(len(case))]      res = test(diag)      if res:          return res      if draw:          return 'Draw'      return 'Game has not completed'    def solve_large(case):      return solve_small(case)    DEBUG = 'i'    from run import *  <CODESPLIT> 2
  import math  import itertools  import numpy as NP    def read_word(f):      return next(f).strip()    def read_int(f, b=10):      return int(read_word(f), b)    def read_letters(f):      return list(read_word(f))    def read_digits(f, b=10):      return [int(x, b) for x in read_letters(f)]    def read_words(f, d=' '):      return read_word(f).split(d)    def read_ints(f, b=10, d=' '):      return [int(x, b) for x in read_words(f, d)]    def read_floats(f, d=' '):      return [float(x) for x in read_words(f, d)]    def read_arr(f, R, reader=read_ints, *args, **kwargs):      return [reader(f, *args, **kwargs) for i in range(R)]    def solve(solver, fn, out_fn=None):      in_fn = fn + '.in'      if out_fn is None:          out_fn = fn + '.out'      with open(in_fn, 'r') as fi:          with open(out_fn, 'w') as fo:              T = read_int(fi)              for i in range(T):                  case = read_case(fi)                  res = solver(case)                  write_case(fo, i, res)    ################################################################################    def read_case(f):      return read_ints(f)    def write_case(f, i, res):      f.write('Case #%d: '%i)      if isinstance(res, list):          res[0][0] = 'c'          res = '\n'.join(''.join(c for c in r) for r in res)      f.write('\n%s'%res)      f.write('\n')    ################################################################################    def solve_small(case):      (R, C, M) = case      if R == 1:          return 'c' + '.'*(C-M-1) + '*'*M      if C == 1:          return '\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)      m = R*C - M      res = [['*']*C for r in range(R)]      if m == 1:          return res      for r in range(2, R+1):          c = m // r          z = m % r          if c < 2 or c + (z>0) > C:              continue          if z == 1 and (r < 3 or c < 3):              continue          for x in range(r):              for y in range(c):                  res[x][y] = '.'          for y in range(z):              res[y][c] = '.'          if z == 1:              res[z][c] = '.'              res[r-1][c-1] = '*'          return res      return 'Impossible'    def solve_large(case):      return solve_small(case)    DEBUG = 'f'    from run import *  <CODESPLIT> 2
  import sys  import os  import itertools  import math  import numpy    __file__ = sys.argv[0]  __path__ = os.path.dirname(__file__)  __prob__ = os.path.basename(__path__)    def pout(s, back=0):      f = sys._getframe(back+1)      d = 0      if 'depth' in f.f_locals:          d = f.f_locals['depth']      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))    def perr(s, back=0):      f = sys._getframe(back+1)      d = 0      if 'depth' in f.f_locals:          d = f.f_locals['depth']      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))    def argmin(f, s=None):      a = f      if s is None:          s = range(len(a))          f = lambda i: a[i]      res = None      for x in s:          y = f(x)          if res is None or best > y:              best = y              res = x      return res    def argmax(f, s=None):      a = f      if s is None:          s = range(len(a))          f = lambda i: a[i]      res = None      for x in s:          y = f(x)          if res is None or best < y:              best = y              res = x      return res    def read_word(f):      return next(f).strip()    def read_int(f, b=10):      return int(read_word(f), b)    def read_words(f, d=' '):      return read_word(f).split(d)    def read_ints(f, b=10, d=' '):      return [int(x, b) for x in read_words(f, d)]    def read_word_arr(f, R):      res = []      for i in range(R):          res.append(read_word(f))      return res    def read_ints_arr(f, R, dtype=int, *args, **kwargs):      res = []      for i in range(R):          res.append(read_ints(f, *args, **kwargs))      return numpy.array(res, dtype)    def solve(solver, fn, start_case=0, end_case=None, out_fn=None):      global ERR_FILE      in_fn = fn + '.in'      if out_fn is None:          out_fn = fn + '.out'      err_fn = fn + '.err'      if start_case == 0:          append = True          if os.path.exists(out_fn):              with open(out_fn, 'r') as f:                  for l in f:                      if l[:6] == 'Case #':                          start_case = int(l[6:l.index(':')])+1      else:          append = False      with open(in_fn, 'r') as fi:          with open(out_fn, 'a' if append else 'w') as fo:              with open(err_fn, 'w') as ERR_FILE:                  T = read_int(fi)                  for i in range(T):                      case = read_case(fi)                      if i+1 < start_case:                          continue                      print('Case #%d of %d'%(i+1, T))                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))                      perr('case')                      res = solver(case)                      perr('res')                      write_case(fo, i, res)                      fo.flush()                      if end_case is not None and i+1 == end_case:                          break    def test(start_case=1, end_case=None):      fn = os.path.join(__path__, 'test')      solve(solve_small, fn, start_case, end_case)    def small(start_case=1, end_case=None):      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)      solve(solve_small, fn, start_case, end_case)    def small2(start_case=1, end_case=None):      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)      solve(solve_large, fn, start_case, end_case, fn + '2.out')    def large(start_case=0, end_case=None):      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)      solve(solve_large, fn, start_case, end_case)    ################################################################################    def read_case(f):      (A, B) = read_ints(f)      return (A, B)    def write_case(f, i, res):      f.write('Case #%d: '%(i+1))      f.write('%s'%res)      f.write('\n')    FAIL = 'NO SOLUTION'    def aux(n, a, b):      res = 0      s = set()      for i in range(1, len(n)):          m = n[i:]+n[:i]          if m > n and m >= a and m <= b and m not in s:              res += 1              s.add(m)      return res    def solve_small(case):      (A, B) = case      a = str(A)      b = str(B)      res = 0      for n in range(A, B+1):          res += aux(str(n), a, b)      return res    solve_large = solve_small    ##perr = pout  ##pout = lambda s: None  pout = perr  <CODESPLIT> 2
#include <cstdio>  #include <cstdlib>  #include <cmath>  #include <climits>  #include <cfloat>  #include <map>  #include <utility>  #include <set>  #include <iostream>  #include <memory>  #include <string>  #include <vector>  #include <algorithm>  #include <functional>  #include <sstream>  #include <complex>  #include <stack>  #include <queue>  #include <cstring>      using namespace std;    string ltos( long long i){    stringstream ss;    ss << i;    string num = ss.str();    return num;  }  bool palstr( string str){    int size = str.size();    bool ok = true;    for( int i = 0 ; i < (size+1)/2;i++){      if( str[i] != str[size-1-i] ){        ok = false;        break;      }    }    return ok;  }  bool pal( long long i ){    string num = ltos(i);    return palstr(num );  }  int main(){     vector< long long > pals;     for( long long  i = 1 ; i* i <= 100000000000000LL ; i++ ){      if( pal(i) && pal(i*i) ){        pals.push_back( i*i );        cerr << i * i << ", ";      }     }     cerr << "Finished" << endl;     int n_case;     cin >> n_case;     for( int loop = 0 ; loop < n_case ; loop++ ){       long long A,B;       cin >> A >> B;       cout << "Case #" << loop+1 << ": "<<(upper_bound(pals.begin(),pals.end(),B)-upper_bound(pals.begin(),pals.end(),A-1)) <<endl;     }     return 0;  }  <CODESPLIT> 3
#include <cstdio>  #include <cstdlib>  #include <cmath>  #include <climits>  #include <cfloat>  #include <map>  #include <utility>  #include <set>  #include <iostream>  #include <memory>  #include <string>  #include <vector>  #include <algorithm>  #include <functional>  #include <sstream>  #include <complex>  #include <stack>  #include <queue>  #include <cstring>  #include <iomanip>     using namespace std;  static const double EPS = 1e-5;  typedef long long ll;  int main(){    int n_case;    cin >> n_case;    int scores[101];    for( int i = 0 ; i < n_case ; i++ ){      int N,S,p;      cin >> N >> S >>p;      int possible=0;      int surprise_possible=0;      //not suprising... [a, a, a](a) or [a, a, a+1]...(a+1) or [a, a+1, a+1]...(a+1)      //surprising... [a, a, a+2] or [a, a+1, a+2] or [a, a+2, a+2]       for( int j = 0 ; j < N; j++ ){        cin >> scores[j];        if( scores[j]%3==0 ){          //[a,a,a] or [a-1,a,a+1]          if( scores[j]/3 >= p ) possible++;          else if( scores[j]/3 +1 >= p && scores[j]/3-1 >= 0 )surprise_possible++;        }        else if( scores[j]%3 == 1){          //[a,a,a+1] or [a-1, a+1, a+1]          if( scores[j]/3+1 >= p ) possible++;        }        else{          //[a,a+1,a+1] or [a, a, a+2]          if( scores[j]/3+1 >= p ) possible++;          else if( scores[j]/3 + 2 >= p ) surprise_possible++;        }      }      //cout << possible << "," << surprise_possible<< "," <<S << endl;;      cout << "Case #" << i+1 << ": " << possible+min(surprise_possible,S)<<endl;    }    return 0;  }    <CODESPLIT> 3
#include <cstdio>  #include <cstdlib>  #include <cmath>  #include <climits>  #include <cfloat>  #include <map>  #include <utility>  #include <set>  #include <iostream>  #include <memory>  #include <string>  #include <vector>  #include <algorithm>  #include <functional>  #include <sstream>  #include <complex>  #include <stack>  #include <queue>  #include <cstring>      using namespace std;    int calcScore(vector<double> A, vector<double> B){    int N =  A.size();    int seriousScore = N;    for( int i = 0 ; i < N ; i++ ){      if( lower_bound( B.begin(), B.end(), A[i] ) != B.end() ){        seriousScore--;        B.erase(lower_bound(B.begin(),B.end(),A[i]));       }      else{        B.erase(B.begin());       }    }    return seriousScore;  }    int main(){    int n_case;    cin >> n_case;    for( int loop = 0 ; loop < n_case ; loop++ ){      int N;      cin >> N;      vector<double> A;      vector<double> B;      for( int ai = 0 ; ai < N ; ai++ ){        double a;        cin >> a;        A.push_back(a);      }      for( int bi = 0 ; bi < N ; bi++ ){        double b;        cin >> b;        B.push_back(b);      }      sort( A.begin(), A.end() );      sort( B.begin(), B.end() );      int cheatScore = N-calcScore(B,A);      int seriousScore = calcScore(A,B);      cout << "Case #" << loop+1 << ": " <<cheatScore << " " << seriousScore << endl;    }    return 0;  }  <CODESPLIT> 3
#include <cstdio>  #include <cstdlib>  #include <cmath>  #include <climits>  #include <cfloat>  #include <map>  #include <utility>  #include <set>  #include <iostream>  #include <memory>  #include <string>  #include <vector>  #include <algorithm>  #include <functional>  #include <sstream>  #include <complex>  #include <stack>  #include <queue>  #include <cstring>      using namespace std;    int main(){     int n_case;     cin >> n_case;     for( int loop = 0 ; loop < n_case ; loop++ ){       int h,w;       cin >> h>>w;       int map[h][w];       for( int i = 0 ; i < h; i++ )for( int j = 0 ; j < w; j++ ){        cin >> map[i][j];       }       int hmax[h];       int wmax[w];       memset( hmax , 0 , sizeof(hmax));       memset( wmax, 0 , sizeof(wmax));       for( int i = 0 ; i < h; i++ ){        for( int j = 0 ; j < w; j++ ){          hmax[i] = max( hmax[i], map[i][j] );          wmax[j] = max( wmax[j], map[i][j] );        }       }       bool ok = true;       for( int i = 0 ; i < h; i++ )for( int j = 0 ; j < w; j++){        if( map[i][j] != min( hmax[i], wmax[j] ) ){          ok = false;          break;        }       }       string ans = "YES";       if( !ok ) ans = "NO";       cout << "Case #" << loop+1 << ": " <<ans<< endl;     }     return 0;  }  <CODESPLIT> 3
#include <cstdio>  #include <cstdlib>  #include <cmath>  #include <climits>  #include <cfloat>  #include <map>  #include <utility>  #include <set>  #include <iostream>  #include <memory>  #include <string>  #include <vector>  #include <algorithm>  #include <functional>  #include <sstream>  #include <complex>  #include <stack>  #include <queue>  #include <cstring>  #include <iomanip>    using namespace std;    int main(){     int n_case;     cin >> n_case;     for( int loop = 0 ; loop < n_case ; loop++ ){       double C,F,X;       cin >> C>>F>>X;       double K = 2.0;       double time = 0.0;       while( (K+F)*(X-C) >= K*X ){        time += C/K;        K+=F;       }       time += X/K;       cout << "Case #" << loop+1 << ": " <<fixed << setprecision(7) <<time<< endl;     }     return 0;  }  <CODESPLIT> 3
#include <cstdio>  #include <cstdlib>  #include <cmath>  #include <climits>  #include <cfloat>  #include <map>  #include <utility>  #include <set>  #include <iostream>  #include <memory>  #include <string>  #include <vector>  #include <algorithm>  #include <functional>  #include <sstream>  #include <complex>  #include <stack>  #include <queue>  #include <cstring>      using namespace std;    int main(){    int n_case;    cin >> n_case;    int cnt[17];    for( int loop = 0 ; loop < n_case ; loop++ ){      memset(cnt,0,sizeof(cnt));      int n;      for( int question = 0 ; question < 2; question++ ){        cin >> n;        for( int row = 1; row <=4 ; row++ ){          for( int col = 1 ; col <= 4 ; col++ ){            int curnum;            cin >>curnum;            if( n == row ){              cnt[curnum]++;            }          }        }      }      vector<int> num;      for( int i = 1; i <= 16 ; i++ ){        if( cnt[i] == 2 ) num.push_back(i);      }      if( num.size() == 0 ){        cout << "Case #" << loop+1 << ": " <<"Volunteer cheated!"<< endl;      }      else if( num.size() == 1 ){        cout << "Case #" << loop+1 << ": " <<num[0]<< endl;      }      else{        cout << "Case #" << loop+1 << ": " <<"Bad magician!"<< endl;      }      }    return 0;  }  <CODESPLIT> 3
#include <cstdio>  #include <cstdlib>  #include <cmath>  #include <climits>  #include <cfloat>  #include <map>  #include <utility>  #include <set>  #include <iostream>  #include <memory>  #include <string>  #include <vector>  #include <algorithm>  #include <functional>  #include <sstream>  #include <complex>  #include <stack>  #include <queue>  #include <cstring>  #include <iomanip>     using namespace std;  static const double EPS = 1e-5;  typedef long long ll;  int main(){    int n_case;    cin >> n_case;    string line;    getline( cin, line );    map<char,char> map_of_alphabet;    map_of_alphabet['a'] ='y';    map_of_alphabet['b'] ='h';    map_of_alphabet['c'] ='e';    map_of_alphabet['d'] ='s';    map_of_alphabet['e'] ='o';    map_of_alphabet['f'] ='c';    map_of_alphabet['g'] ='v';    map_of_alphabet['h'] ='x';    map_of_alphabet['i'] ='d';    map_of_alphabet['j'] ='u';    map_of_alphabet['k'] ='i';    map_of_alphabet['l'] ='g';    map_of_alphabet['m'] ='l';    map_of_alphabet['n'] ='b';    map_of_alphabet['o'] ='k';    map_of_alphabet['p'] ='r';    map_of_alphabet['q'] ='z';    map_of_alphabet['r'] ='t';    map_of_alphabet['s'] ='n';    map_of_alphabet['t'] ='w';    map_of_alphabet['u'] ='j';    map_of_alphabet['v'] ='p';    map_of_alphabet['w'] ='f';    map_of_alphabet['x'] ='m';    map_of_alphabet['y'] ='a';    map_of_alphabet['z'] ='q';    for( int i = 0; i  < n_case ; i++ ){      getline( cin, line );      int size = line.size();      for( int j = 0 ; j < size; j++ ){        if( line[j] >= 'a' && line[j] <= 'z' ){          line[j] = map_of_alphabet[line[j]];        }      }      cout << "Case #" << i+1 << ": " << line<<endl;    }    return 0;  }    <CODESPLIT> 3
#include <cstdio>  #include <cstdlib>  #include <cmath>  #include <climits>  #include <cfloat>  #include <map>  #include <utility>  #include <set>  #include <iostream>  #include <memory>  #include <string>  #include <vector>  #include <algorithm>  #include <functional>  #include <sstream>  #include <complex>  #include <stack>  #include <queue>  #include <cstring>      using namespace std;    char check( char a, char b, char c, char d ){    if( a == 'T' ) a = b;    if( b == 'T' ) b = a;    if( c == 'T' ) c = a;    if( d == 'T' ) d = a;    if( a == b && b == c && c == d && c!= '.' ) return a;    else return 'T';  }  int main(){     int n_case;     cin >> n_case;     for( int loop = 0 ; loop < n_case ; loop++ ){       string field[4];       for( int i = 0 ; i < 4 ; i++ ){        cin >> field[i];       }       char winner = 'T';       bool draw=true;       for( int i = 0 ; i < 4; i++ )for( int j = 0 ; j < 4; j++ ){        if( field[i][j] == '.' ){          draw = false;          break;        }       }       for( int i =0; i < 4; i++ ){         if( (winner = check( field[i][0],field[i][1],field[i][2],field[i][3] ))!= 'T' ){          break;         }         if( (winner = check( field[0][i],field[1][i],field[2][i],field[3][i] ))!= 'T' ){          break;         }       }       if( winner == 'T' ){         winner = check( field[0][0], field[1][1], field[2][2], field[3][3] );         if( winner == 'T' ) winner = check( field[0][3], field[1][2], field[2][1], field[3][0] );       }       cout << "Case #" << loop+1 << ": " ;       if( winner != 'T' ){         cout << winner << " won";       }       else{         if( draw ) cout << "Draw";         else cout << "Game has not completed";       }       cout << endl;     }     return 0;  }  <CODESPLIT> 3
#include <cstdio>  #include <cstdlib>  #include <cmath>  #include <climits>  #include <cfloat>  #include <map>  #include <utility>  #include <set>  #include <iostream>  #include <memory>  #include <string>  #include <vector>  #include <algorithm>  #include <functional>  #include <sstream>  #include <complex>  #include <stack>  #include <queue>  #include <cstring>      using namespace std;    int main(){     int n_case;     cin >> n_case;     for( int loop = 0 ; loop < n_case ; loop++ ){       int R,C,M;       cin >> R >> C >> M;       bool swaped = false;       if( R > C ){         //make sure C is larger than R         swap(R,C);         swaped=true;       }       bool table[R][C];       memset( table, false, sizeof(table));       int i,j;       for( i = 0 ; i+2 < R ; i++ ){        if( M >= C ){          for( j = 0 ; j < C ; j++ ){            table[i][j] = true;          }          M-=C;        }        else{          int n_to_write = min(M,C-2);          if( (M-n_to_write)%2 == 1 ) n_to_write--;          for( j = 0 ; j < n_to_write ; j++ ){            table[i][j] = true;          }          M -=n_to_write;        }       }       if( i+1 < R ){        for( j = 0 ; j+2 < C; j++ ){          if( M < 2 ) break;          table[i][j] = true;          table[i+1][j] = true;          M-=2;        }        if( M == 3 ){          table[i+1][j] = true;          table[i][j] = true;          table[i][j+1] = true;          M-=3;        }       }       else{        for( int j = 0 ; j < M ; j++){          table[i][j]=true;          M--;        }       }       cout << "Case #" << loop+1 << ": " <<endl;       if( M > 0 ){        cout << "Impossible"<< endl;       }       else{        if( swaped == false ){          for( int i = 0 ; i < R ; i++ ){            for( int j = 0 ; j < C ; j++ ){              if( i == R-1 && j == C-1 ){                cout << "c";              }              else if(table[i][j]){                cout << "*";              }              else{                cout << ".";              }            }            cout << endl;          }        }        else{          for( int i = 0 ; i < C ; i++ ){            for( int j = 0 ; j < R ; j++ ){              if( i == C-1 && j == R-1 ){                cout << "c";              }              else if(table[j][i]){                cout << "*";              }              else{                cout << ".";              }            }            cout << endl;          }          }       }       }     return 0;  }  <CODESPLIT> 3
#include <cstdio>  #include <cstdlib>  #include <cmath>  #include <climits>  #include <cfloat>  #include <map>  #include <utility>  #include <set>  #include <iostream>  #include <memory>  #include <string>  #include <vector>  #include <algorithm>  #include <functional>  #include <sstream>  #include <complex>  #include <stack>  #include <queue>  #include <cstring>  #include <iomanip>     using namespace std;  static const double EPS = 1e-5;  typedef long long ll;  int length(int j ){    int i = 0;    while( j != 0 ){      i++;      j /= 10;    }    return i;  }  int main(){    int n_case;    cin >> n_case;    bool checked[2000001];    for( int i = 0 ; i < n_case ; i++ ){      int A,B;      cin >> A >> B;      ll ans = 0;      memset( checked, false, sizeof( checked ) );      for( int j = A ; j <=B ; j++ ){        if( checked[j] ) continue;        else{          ll sum = 1;          int l = length(j);          int num = j;          int mask=1;          for( int k = 0 ; k+1 < l; k++ ){ mask *= 10;}          checked[num] = true;          for( int k = 0 ; k < l ; k++ ){              int bit = num/mask;            num = (num-bit*mask)*10+bit;            if( num < mask || num > B || num < A ) continue;            if( !checked[num] ){              sum++;              checked[num] = true;            }          }          ans += sum*(sum-1)/2;        }      }      cout << "Case #" << i+1 << ": " << ans << endl;    }    return 0;  }    <CODESPLIT> 3
def esPal(x):  	return str(x) == str(x)[::-1]    t = int(raw_input())    for case in range(t):  	line = raw_input().split(' ')  	a = int(line[0])  	b = int(line[1])    	i = int(a**.5)  	if i*i != a:  		i += 1  	max = int(b**.5)  	cantidad = 0  	while i <= max:  		if esPal(i) and esPal(i*i):  			cantidad += 1  		i += 1    	print 'Case #'+str(case+1)+':', cantidad  <CODESPLIT> 4
t = int(raw_input())    max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]    for i in range(t):  	line = raw_input().split(' ')  	n = int(line[0])  	s = int(line[1])  	p = int(line[2])    	total = 0    	for j in range(3, len(line)):  		t = int(line[j])  		if t == 0:  			if p == 0:  				total += 1  		elif t%3 == 0:  			if t/3 >= p:  				total +=1  			elif t/3 + 1 >= p and s>0:  				total +=1  				s -=1  		elif t%3 == 1:  			if (t+2)/3 >= p:  				total +=1  		else:  			if (t+1)/3 >= p:  				total +=1  			elif (t+1)/3 + 1 >= p and s>0:  				total +=1  				s -=1        	print 'Case #'+str(i+1)+':', total      <CODESPLIT> 4
t = int(raw_input())    for case in range(t):  	n = int(raw_input())  	naomi = [float(i) for i in raw_input().split()]  	ken = [float(i) for i in raw_input().split()]    	naomi.sort()  	ken.sort()  	y = 0  	z = 0    	#print naomi  	#print ken    	na = naomi[:]  	ke = ken[:]  	while len(na) > 0:  		nc = na.pop(0)  		kc = -1  		for i in range(len(ke)):  			if ke[i] > nc:  				kc = ke.pop(i)  				break  		if kc == -1:  			kc = ke.pop(0)  		if nc > kc:  			z += 1      	na = naomi[:]  	ke = ken[:]  	while len(ke) > 0:  		kc = ke.pop(0)  		nc = -1  		for i in range(len(na)):  			if na[i] > kc:  				nc = na.pop(i)  				break  		if nc == -1:  			nc = na.pop(0)  		if nc > kc:  			y += 1  		#print nc, kc    	print 'Case #'+str(case+1)+':', y, z  	#print ''  <CODESPLIT> 4
t = int(raw_input())    for case in range(t):  	line = raw_input().split(' ')  	n = int(line[0])  	m = int(line[1])    	l = []  	for j in range(n):  		a = raw_input().split(' ')  		b = []  		for x in a:  			b.append(int(x))  		l.append(b)    	# para cada valor, revisar que la fila o columna que lo contenga sea de alto menor o igual    	cumple = True  	for i in range(n):  		for j in range(m):  			col = True  			fil = True  			for x in range(n):  				if l[x][j] > l[i][j]:  					col = False  					break  			for x in range(m):  				if l[i][x] > l[i][j]:  					fil = False  					break    			if not col and not fil:  				cumple = False  				break    		if not cumple:  			break    	if cumple:  		print 'Case #'+str(case+1)+': YES'  	else:  		print 'Case #'+str(case+1)+': NO'  <CODESPLIT> 4
t = int(raw_input())    for case in range(t):    	c, f, x = raw_input().split()  	c = float(c)  	f = float(f)  	x = float(x)    	t = 0  	cps = 2.0  	while c/cps < x/cps and t+x/cps > t+c/cps + x/(cps+f):  		# print t, c/cps, x/cps  		t += c/cps  		cps += f  		# raw_input()    	t += x/cps    	print 'Case #'+str(case+1)+':', t  <CODESPLIT> 4
t = int(raw_input())    for case in range(t):  	r1 = int(raw_input())  	c1 = []  	for j in range(4):  		c1.append([int(i) for i in raw_input().split()])    	r2 = int(raw_input())  	c2 = []  	for j in range(4):  		c2.append([int(i) for i in raw_input().split()])    	num = -1  	possibles = 0  	for j in c1[r1-1]:  		if c2[r2-1].count(j) == 1:  			num = j  			possibles += 1    	if possibles > 1:  		print 'Case #'+str(case+1)+': Bad magician!'  	elif possibles == 0:  		print 'Case #'+str(case+1)+': Volunteer cheated!'  	else:  		print 'Case #'+str(case+1)+': '+str(num)  <CODESPLIT> 4
t = int(raw_input())    code = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']    for i in range(t):  	line = raw_input()  	decoded = ''    	for c in line:  		if c==' ':  			decoded += c  		else:  			decoded += code[ord(c)-97]    	print 'Case #'+str(i+1)+':', decoded  <CODESPLIT> 4
t = int(raw_input())    code = 'yhesocvxduiglbkrztnwjpfmaq'    for i in range(t):  	l = []  	for j in range(4):  		l.append(raw_input())  	if i != t-1:  		raw_input()    	# filas  	v = False  	fin = False  	for li in l:  		x = True  		o = True  		for c in li:  			if c != 'X' and c != 'T':  				x = False  			if c != 'O' and c != 'T':  				o = False  			if c == '.':  				v = True  		if x:  			print 'Case #'+str(i+1)+': X won'  			fin = True  		if o:  			print 'Case #'+str(i+1)+': O won'  			fin = True    	if fin:  		continue    	#columnas  	for a in range(4):  		x = True  		o = True  		for b in range(4):  			if l[b][a] != 'X' and l[b][a] != 'T':  				x = False  			if l[b][a] != 'O' and l[b][a] != 'T':  				o = False  		if x:  			print 'Case #'+str(i+1)+': X won'  			fin = True  		if o:  			print 'Case #'+str(i+1)+': O won'  			fin = True  	if fin:  		continue    	#diagonales  	x = True  	o = True  	for j in range(4):  		if l[j][j] != 'X' and l[j][j] != 'T':  			x = False  		if l[j][j] != 'O' and l[j][j] != 'T':  			o = False  	if x:  		print 'Case #'+str(i+1)+': X won'  		continue  	if o:  		print 'Case #'+str(i+1)+': O won'  		continue  	x = True  	o = True  	for j in range(4):  		if l[3-j][j] != 'X' and l[3-j][j] != 'T':  			x = False  		if l[3-j][j] != 'O' and l[3-j][j] != 'T':  			o = False  	if x:  		print 'Case #'+str(i+1)+': X won'  		continue  	if o:  		print 'Case #'+str(i+1)+': O won'  		continue    	if v:  		print 'Case #'+str(i+1)+': Game has not completed'  	else:  		print 'Case #'+str(i+1)+': Draw'  <CODESPLIT> 4
t = int(raw_input())    for case in range(t):  	print 'Case #'+str(case+1)+':'  	r, c, m = raw_input().split()  	r = int(r)  	c = int(c)  	m = int(m)    	if m==0:  		print 'c' + ('.'*(c-1))  		for i in range(r-1):  			print '.'*c  	elif r == 1:  		print 'c'+('.'*(c-m-1))+('*'*(m))  	elif c == 1:  		print 'c'  		for i in range(r-m-1):  			print '.'  		for i in range(m):  			print '*'  	elif r == 2:  		if m%2==0 and c>2 and m<r*c-2:  			print 'c'+('.'*(c-m/2-1))+('*'*(m/2))  			print ('.'*(c-m/2))+('*'*(m/2))  		elif m == r*c - 1:  			print 'c'+('*'*(c-1))  			print '*'*c  		else:  			print 'Impossible'  	elif c == 2:  		if m%2==0 and r>2 and m<r*c-2:  			print 'c.'  			for i in range(r-m/2-1):  				print '..'  			for i in range(m/2):  				print '**'  		elif m == r*c - 1:  			print 'c*'  			for i in range(r-1):  				print '**'  		else:  			print 'Impossible'  	elif c == 3 and r == 3:  		if m == 1:  			print 'c..'  			print '...'  			print '..*'  		elif m == 2:  			print 'Impossible'  		elif m == 3:  			print 'c..'  			print '...'  			print '***'  		elif m == 4:  			print 'Impossible'  		elif m == 5:  			print 'c.*'  			print '..*'  			print '***'  		elif m == 6:  			print 'Impossible'  		elif m == 7:  			print 'Impossible'  		elif m == 8:  			print 'c**'  			print '***'  			print '***'  	elif c == 3 and r == 4:  		if m == 1:  			print 'c..'  			print '...'  			print '...'  			print '..*'  		elif m == 2:  			print 'c..'  			print '...'  			print '..*'  			print '..*'  		elif m == 3:  			print 'c..'  			print '...'  			print '...'  			print '***'  		elif m == 4:  			print 'c.*'  			print '..*'  			print '..*'  			print '..*'  		elif m == 5:  			print 'Impossible'  		elif m == 6:  			print 'c..'  			print '...'  			print '***'  			print '***'  		elif m == 7:  			print 'Impossible'  		elif m == 8:  			print 'c.*'  			print '..*'  			print '***'  			print '***'  		elif m == 9:  			print 'Impossible'  		elif m == 10:  			print 'Impossible'  		elif m == 11:  			print 'c**'  			print '***'  			print '***'  			print '***'  	elif c == 3 and r == 5:  		if m == 1:  			print 'c..'  			print '...'  			print '...'  			print '...'  			print '..*'  		elif m == 2:  			print 'c..'  			print '...'  			print '...'  			print '..*'  			print '..*'  		elif m == 3:  			print 'c..'  			print '...'  			print '..*'  			print '..*'  			print '..*'  		elif m == 4:  			print 'c..'  			print '...'  			print '...'  			print '..*'  			print '***'  		elif m == 5:  			print 'c.*'  			print '..*'  			print '..*'  			print '..*'  			print '..*'  		elif m == 6:  			print 'c..'  			print '...'  			print '...'  			print '***'  			print '***'  		elif m == 7:  			print 'c..'  			print '...'  			print '..*'  			print '***'  			print '***'  		elif m == 8:  			print 'Impossible'  		elif m == 9:  			print 'c..'  			print '...'  			print '***'  			print '***'  			print '***'  		elif m == 10:  			print 'Impossible'  		elif m == 11:  			print 'c.*'  			print '..*'  			print '***'  			print '***'  			print '***'  		elif m == 12:  			print 'Impossible'  		elif m == 13:  			print 'Impossible'  		elif m == 14:  			print 'c**'  			print '***'  			print '***'  			print '***'  			print '***'  	elif c == 4 and r == 3:  		if m == 1:  			print 'c...'  			print '....'  			print '...*'  		elif m == 2:  			print 'c...'  			print '...*'  			print '...*'  		elif m == 3:  			print 'c..*'  			print '...*'  			print '...*'  		elif m == 4:  			print 'c...'  			print '....'  			print '****'  		elif m == 5:  			print 'Impossible'  		elif m == 6:  			print 'c.**'  			print '..**'  			print '..**'  		elif m == 7:  			print 'Impossible'  		elif m == 8:  			print 'c.**'  			print '..**'  			print '****'  		elif m == 9:  			print 'Impossible'  		elif m == 10:  			print 'Impossible'  		elif m == 11:  			print 'c***'  			print '****'  			print '****'  	elif c == 4 and r == 4:  		if m == 1:  			print 'c...'  			print '....'  			print '....'  			print '...*'  		elif m == 2:  			print 'c...'  			print '....'  			print '....'  			print '..**'  		elif m == 3:  			print 'c...'  			print '....'  			print '...*'  			print '..**'  		elif m == 4:  			print 'c...'  			print '....'  			print '....'  			print '****'  		elif m == 5:  			print 'c...'  			print '....'  			print '...*'  			print '****'  		elif m == 6:  			print 'c...'  			print '....'  			print '..**'  			print '****'  		elif m == 7:  			print 'c..*'  			print '...*'  			print '...*'  			print '****'  		elif m == 8:  			print 'c...'  			print '....'  			print '****'  			print '****'  		elif m == 9:  			print 'Impossible'  		elif m == 10:  			print 'c.**'  			print '..**'  			print '..**'  			print '****'  		elif m == 11:  			print 'Impossible'  		elif m == 12:  			print 'c.**'  			print '..**'  			print '****'  			print '****'  		elif m == 13:  			print 'Impossible'  		elif m == 14:  			print 'Impossible'  		elif m == 15:  			print 'c***'  			print '****'  			print '****'  			print '****'  	elif c == 4 and r == 5:  		if m == 1:  			print 'c...'  			print '....'  			print '....'  			print '....'  			print '...*'  		elif m == 2:  			print 'c...'  			print '....'  			print '....'  			print '....'  			print '..**'  		elif m == 3:  			print 'c...'  			print '....'  			print '...*'  			print '...*'  			print '...*'  		elif m == 4:  			print 'c...'  			print '....'  			print '....'  			print '....'  			print '****'  		elif m == 5:  			print 'c..*'  			print '...*'  			print '...*'  			print '...*'  			print '...*'  		elif m == 6:  			print 'c...'  			print '....'  			print '....'  			print '..**'  			print '****'  		elif m == 7:  			print 'c..*'  			print '...*'  			print '...*'  			print '..**'  			print '..**'  		elif m == 8:  			print 'c...'  			print '....'  			print '....'  			print '****'  			print '****'  		elif m == 9:  			print 'c..*'  			print '...*'  			print '...*'  			print '..**'  			print '****'  		elif m == 10:  			print 'c.**'  			print '..**'  			print '..**'  			print '..**'  			print '..**'  		elif m == 11:  			print 'c..*'  			print '...*'  			print '...*'  			print '****'  			print '****'  		elif m == 12:  			print 'c...'  			print '....'  			print '****'  			print '****'  			print '****'  		elif m == 13:  			print 'Impossible'  		elif m == 14:  			print 'c..*'  			print '...*'  			print '****'  			print '****'  			print '****'  		elif m == 15:  			print 'Impossible'  		elif m == 16:  			print 'c.**'  			print '..**'  			print '****'  			print '****'  			print '****'  		elif m == 17:  			print 'Impossible'  		elif m == 18:  			print 'Impossible'  		elif m == 19:  			print 'c***'  			print '****'  			print '****'  			print '****'  			print '****'  	elif c == 5 and r == 3:  		if m == 1:  			print 'c....'  			print '.....'  			print '....*'  		elif m == 2:  			print 'c....'  			print '.....'  			print '...**'  		elif m == 3:  			print 'c....'  			print '.....'  			print '..***'  		elif m == 4:  			print 'c...*'  			print '....*'  			print '...**'  		elif m == 5:  			print 'c....'  			print '.....'  			print '*****'  		elif m == 6:  			print 'c..**'  			print '...**'  			print '...**'  		elif m == 7:  			print 'c..**'  			print '...**'  			print '..***'  		elif m == 8:  			print 'Impossible'  		elif m == 9:  			print 'c.***'  			print '..***'  			print '..***'  		elif m == 10:  			print 'Impossible'  		elif m == 11:  			print 'c.***'  			print '..***'  			print '*****'  		elif m == 12:  			print 'Impossible'  		elif m == 13:  			print 'Impossible'  		elif m == 14:  			print 'c****'  			print '*****'  			print '*****'  	elif c == 5 and r == 4:  		if m == 1:  			print 'c....'  			print '.....'  			print '.....'  			print '....*'  		elif m == 2:  			print 'c....'  			print '.....'  			print '.....'  			print '...**'  		elif m == 3:  			print 'c....'  			print '.....'  			print '.....'  			print '..***'  		elif m == 4:  			print 'c...*'  			print '....*'  			print '....*'  			print '....*'  		elif m == 5:  			print 'c....'  			print '.....'  			print '.....'  			print '*****'  		elif m == 6:  			print 'c...*'  			print '....*'  			print '....*'  			print '..***'  		elif m == 7:  			print 'c....'  			print '.....'  			print '...**'  			print '*****'  		elif m == 8:  			print 'c..**'  			print '...**'  			print '...**'  			print '...**'  		elif m == 9:  			print 'c...*'  			print '....*'  			print '...**'  			print '*****'  		elif m == 10:  			print 'c....'  			print '.....'  			print '*****'  			print '*****'  		elif m == 11:  			print 'c..**'  			print '...**'  			print '...**'  			print '*****'  		elif m == 12:  			print 'c.***'  			print '..***'  			print '..***'  			print '..***'  		elif m == 13:  			print 'Impossible'  		elif m == 14:  			print 'c.***'  			print '..***'  			print '..***'  			print '*****'  		elif m == 15:  			print 'Impossible'  		elif m == 16:  			print 'c.***'  			print '..***'  			print '*****'  			print '*****'  		elif m == 17:  			print 'Impossible'  		elif m == 18:  			print 'Impossible'  		elif m == 19:  			print 'c****'  			print '*****'  			print '*****'  			print '*****'  	elif c == 5 and r == 5:  		if m == 1:  			print 'c....'  			print '.....'  			print '.....'  			print '.....'  			print '....*'  		elif m == 2:  			print 'c....'  			print '.....'  			print '.....'  			print '.....'  			print '...**'  		elif m == 3:  			print 'c....'  			print '.....'  			print '.....'  			print '.....'  			print '..***'  		elif m == 4:  			print 'c....'  			print '.....'  			print '.....'  			print '...**'  			print '...**'  		elif m == 5:  			print 'c....'  			print '.....'  			print '.....'  			print '.....'  			print '*****'  		elif m == 6:  			print 'c....'  			print '.....'  			print '.....'  			print '..***'  			print '..***'  		elif m == 7:  			print 'c....'  			print '.....'  			print '.....'  			print '...**'  			print '*****'  		elif m == 8:  			print 'c....'  			print '.....'  			print '.....'  			print '..***'  			print '*****'  		elif m == 9:  			print 'c...*'  			print '....*'  			print '....*'  			print '....*'  			print '*****'  		elif m == 10:  			print 'c....'  			print '.....'  			print '.....'  			print '*****'  			print '*****'  		elif m == 11:  			print 'c....'  			print '.....'  			print '....*'  			print '*****'  			print '*****'  		elif m == 12:  			print 'c....'  			print '.....'  			print '...**'  			print '*****'  			print '*****'  		elif m == 13:  			print 'c....'  			print '.....'  			print '..***'  			print '*****'  			print '*****'  		elif m == 14:  			print 'c..**'  			print '...**'  			print '...**'  			print '..***'  			print '*****'  		elif m == 15:  			print 'c....'  			print '.....'  			print '*****'  			print '*****'  			print '*****'  		elif m == 16:  			print 'c..**'  			print '...**'  			print '...**'  			print '*****'  			print '*****'  		elif m == 17:  			print 'c..**'  			print '...**'  			print '..***'  			print '*****'  			print '*****'  		elif m == 18:  			print 'Impossible'  		elif m == 19:  			print 'c..**'  			print '...**'  			print '*****'  			print '*****'  			print '*****'  		elif m == 20:  			print 'Impossible'  		elif m == 21:  			print 'c.***'  			print '..***'  			print '*****'  			print '*****'  			print '*****'  		elif m == 22:  			print 'Impossible'  		elif m == 23:  			print 'Impossible'  		elif m == 24:  			print 'c****'  			print '*****'  			print '*****'  			print '*****'  			print '*****'  	else:  		print 'Impossible'    <CODESPLIT> 4
t = int(raw_input())    def mover(n, i):  	s = str(n)  	return int(s[i:] + s[:i])    for i in range(t):  	s = raw_input().split(' ')  	a = int(s[0])  	b = int(s[1])  	total = 0  	for n in range(a, b):  		ms = []  		for k in range(len(s[0])):  			m = mover(n, k+1)  			if m <= b and m > n and not m in ms:  			#	print n, mover(n, k+1), k+1  				ms.append(m)  				total +=1      	print 'Case #'+str(i+1)+':', total <CODESPLIT> 4
'''  Created on Apr 12, 2013    @author: Moatasem  '''    import math      def isPalindrome(word):      isPalin=False      if(len(word)%2==0):          f_half=word[0:len(word)/2];          s_half=word[len(word)/2:len(word)][::-1]          if( f_half==s_half):              isPalin= True      else:          f_half=word[0:len(word)/2]          s_half=word[(len(word)/2)+1:len(word)][::-1]          if( f_half==s_half):              isPalin= True      return isPalin        def getNumberOfFairAndSquare(range_):      start=range_[0]      end=range_[1]      count_=0      for i in range(start,end+1):          root=math.sqrt(i);          if(root.is_integer() and isPalindrome(str(int(root))) and isPalindrome(str(i))):              count_+=1      return count_                              f_r = open('C.in',"r")  n_test=int(f_r.readline().strip())   f_w = open("C.out", "w")  for i in range(n_test):      range_ =map(int,f_r.readline().split())      result=getNumberOfFairAndSquare(range_)      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)      f_w.write(output_str+'\n')  f_r.close()  f_w.close() <CODESPLIT> 5
'''  Created on Apr 14, 2012    @author: moatasem  '''      def isSurprising(t):      if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):          return True      else:          return False      def getAllTriplets(n):      h=[]      for i in xrange(11):          for j in xrange(i,11):              for  k in xrange(j,11):                  if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):                      h.append((i,j,k))                    return  h    def getInfo(p,total,S):      g= getAllTriplets(total)      #print total      #print g      if(S):          s_=len(g)          indcies=[]          for i in xrange (s_):              if(isSurprising(g[i])):                  indcies.append(i)          for i in xrange (len(indcies)):                g.remove(g[indcies[i]])      #print g      equ=False      sur=False      sur_equ=False      for i in xrange(len(g)):          if(max(g[i])>=p):              if(isSurprising(g[i])):                  #print g[i]                  sur_equ=True              else:                  equ=True          elif(isSurprising(g[i])):                  sur=True      return sur_equ,equ,sur               f = open("b_.in", "r")  n=int(f.readline().strip())  for k  in xrange(n):      d=f.readline().strip()      googlers=[]      g=[int(i) for i in d.split(" ")]      N=g[0]      S=g[1]      noSu=False      if(S==0):          noSu=True      p=g[2]      count=0      equ_count=0;      both_count=0;      sur_count=0;      first_count=0;      googlers=g[3:len(g)]      for o in xrange(N):          info=getInfo(p,googlers[o],noSu)          #print info          if(info[0]==True and info[1]==False and S<>0): #101 /100              count+=1              S-=1          elif(info[0]==True and info[1]==True):#110 / 111              first_count+=1          elif(info[1]==True and info[2]==True):#011              both_count+=1          elif(info[1]==True):#010              count+=1          elif(info[2]==True):#001              sur_count+=1      count+=first_count      if(S>0):          if(first_count>S):              S=0          elif(first_count <=S) :              S-=first_count              if(S>0):                   if(both_count>S):                      both_count-=S                      S=0                   else:                      both_count=0      count+=both_count            print 'Case #'+str((k+1))+": "+str(count)                              #f=getAllTriplets(18)  #print f  #for i in xrange(len(f)):  #    print isSurprising(f[i]) <CODESPLIT> 5
'''  Created on Apr 11, 2014    @author: mostasem  '''  def solveWar(Naomi, Ken):      NPoints = 0      while(len(Naomi) <> 0):          Nmax = max(Naomi)          Kmax = max(Ken)          Kmin = min(Ken)          if(Nmax > Kmax):              NPoints += 1              Naomi.remove(Nmax)              Ken.remove(Kmin)          else:              Naomi.remove(Nmax)              Ken.remove(Kmax)      return NPoints      def getKeyWithMaxValue(dict_):         keys = dict_.keys()      currentKey = 0.0      min_val = 10000000000000000      for i in range(len(keys)):           if(min_val > dict_.get(keys[i])):              min_val = dict_.get(keys[i])              currentKey = keys[i]          elif(min_val == dict_.get(keys[i])):              if(currentKey > keys [i]):                  currentKey = keys[i]                    return currentKey              def updateWeights(Naomi, Ken):        NaomiHash = {}           for i in range(len(Naomi)):          if(NaomiHash.get(Naomi[i]) == None):                  NaomiHash[Naomi[i]] = 0          for j in range(len(Ken)):              if(Naomi[i] > Ken [j]):                      NaomiHash[Naomi[i]] += 1      return NaomiHash      def checkIFAllBigger(NaomiHash,Ken):      k = len(Ken)      allBigger = True      values = list(NaomiHash.values());      for i in range(k):          found = False          for j in range(len(values)):              if(values [j] >= k - i):                  #print values                  values.remove(values[j])                  found = True                  break          if(not found):              allBigger = False              break      return allBigger    def solveDecitfulWar(Naomi, Ken):      NPoints = 0      NaomiHash = updateWeights(Naomi, Ken)      while(len(Naomi) <> 0):          #print NaomiHash          #print "Ken",len(Ken)          if(checkIFAllBigger(NaomiHash,Ken)):              NPoints += len(Ken)              break          NChoice = getKeyWithMaxValue(NaomiHash)          print NChoice          Kmax = max(Ken)          Kmin = min(Ken)          if(NChoice > Kmax):              NPoints += 1              Naomi.remove(NChoice)              NaomiHash[NChoice] = 10000000000000000              Ken.remove(Kmin)          else:              Naomi.remove(NChoice)              NaomiHash[NChoice] = 10000000000000000              Ken.remove(Kmax)          NaomiHash = updateWeights(Naomi, Ken)                return NPoints         f_r = open('D.in',"r")  n_test=int(f_r.readline().strip())   f_w = open("D.out", "w")  result = ""  for i in range(n_test):      list_len = int(f_r.readline().strip())       Naomi = map(float,f_r.readline().split())      Ken = map(float,f_r.readline().split())            Naomi2 = list(Naomi)      Ken2 = list(Ken)      #print Naomi ,Ken      p1 =  solveWar(Naomi, Ken)      p2 =  solveDecitfulWar(Naomi2, Ken2)      result = str(p2)+" "+str(p1)      #print result      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)      f_w.write(output_str+'\n')        f_r.close() <CODESPLIT> 5
'''  Created on Apr 12, 2013    @author: Moatasem  '''    import math          def markMax(max_,start,end,marked,isRow,lawn):      for i in range(end):              if(isRow):                  if( lawn[start][i]==max_):                      marked[start][i]=-1              else:                   if( lawn[i][start]==max_):                      marked[i][start]=-1                                                      def mowerLawn(lawn,m,n,marked):      #marked= [[0] *n]*m      for i in range(m):          max_=max(lawn[i])          markMax(max_,i,n,marked,True,lawn)             for i in range(n):          colList=[]          for j in range(m):              colList.append(lawn[j][i])          max_=max(colList)          markMax(max_,i,m,marked,False,lawn)                    done=True      for i in range(m):          for j in range(n):              if(marked[i][j]!=-1):                  done=False                  break          if(not done):              break      if(done):          return 'YES'      else:          return 'NO'                          f_r = open('B.in',"r")  n_test=int(f_r.readline().strip())   f_w = open("B.out", "w")  for i in range(n_test):      lawn=[]            range_ =map(int,f_r.readline().split())      #marked= [[0] *range_[1]]*range_[0]      marked=[[0]*range_[1] for x in xrange(range_[0])]      for j in range(range_[0]):          temp=[map(int,f_r.readline().split())]          lawn.extend(temp)      result=mowerLawn(lawn,range_[0],range_[1],marked)      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)      f_w.write(output_str+'\n')  f_r.close()  f_w.close() <CODESPLIT> 5
'''  Created on Apr 11, 2014    @author: mostasem  '''      def getSeconds(C,F,X):      seconds = 0.0      cookie_rate = 2      solved =False      while (not solved):          choice1 = X/cookie_rate          choice2 = C/cookie_rate + X/(cookie_rate + F)          if(choice1 < choice2):              seconds += choice1              solved = True          else :              seconds += C/cookie_rate              cookie_rate += F            return seconds    f_r = open('B.in',"r")  n_test=int(f_r.readline().strip())   f_w = open("B.out", "w")  result = ""  for i in range(n_test):      C,F,X = map(float,f_r.readline().split())      seconds = getSeconds(C,F,X)      result = str(seconds)      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)      f_w.write(output_str+'\n')        f_r.close()  f_w.close()    <CODESPLIT> 5
'''  Created on Apr 11, 2014    @author: mostasem  '''        def getIntersection(A,B):      intersect_list = []      dict = {};      for i in range(4):          if(dict.get(A[i]) <> None):              dict[A[i]] += 1              if(intersect_list.count(A[i]) == 0):                  intersect_list.append(A[i])          else:              dict[A[i]] = 1          if(dict.get(B[i]) <> None):              dict[B[i]] += 1              if(intersect_list.count(B[i]) == 0):                  intersect_list.append(B[i])          else:              dict[B[i]] = 1        return intersect_list    f_r = open('A.in',"r")  n_test=int(f_r.readline().strip())   f_w = open("A.out", "w")  result = ""  for i in range(n_test):      cards1 = []      row_index_1 = int(f_r.readline()) - 1      for j in range(4):          cards1.append(map(int,f_r.readline().split()))      cards2 = []      row_index_2 = int(f_r.readline()) - 1      for j in range(4):          cards2.append(map(int,f_r.readline().split()))   #     print cards1   #     print cards2  #     print cards1[row_index_1] ,cards2[row_index_2]      int_list =  getIntersection(cards1[row_index_1], cards2[row_index_2])  #     print int_list      result = ""      if(len(int_list) == 0):          result = "Volunteer cheated!"      elif(len(int_list)  == 1):          result = str(int_list[0])      else:          result = "Bad magician!"      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)      print output_str      f_w.write(output_str+'\n')  f_r.close()  f_w.close() <CODESPLIT> 5
'''  Created on Apr 14, 2012    @author: moatasem  '''  lan={'z':'q','q':'z',' ':' '}    s1=list("ejp mysljylc kd kxveddknmc re jsicpdrysi")  e1=list ("our language is impossible to understand")  s2=list("rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd")  e2=list ("there are twenty six factorial possibilities")  s3=list("de kr kd eoya kw aej tysr re ujdr lkgc jv")  e3=list ("so it is okay if you want to just give up")  for i in xrange(len(s1)):      if(lan.get(s1[i])==None and s1[i]!=" "):          lan[s1[i]]=e1[i]      if(lan.get(s2[i])==None and s2[i]!=" "):          lan[s2[i]]=e2[i]      if(lan.get(s3[i])==None and s3[i]!=" "):          lan[s3[i]]=e3[i]            f = open("A-small-attempt0.in", "r")  n=int(f.readline().strip())  for i  in xrange(n):      line=f.readline().strip()      res='Case #'+str((i+1))+": "      for j in xrange(len(line)):          res+=str(lan.get(line[j]))      print res                    <CODESPLIT> 5
'''  Created on Apr 12, 2013    @author: Moatasem  '''    def getStatus(board):      status=""       solved=False      n_dotted=0      #checking for columns and rows      for i in range(4):          result= checkBoard(board[i])          if(result!="None"):              status=result              solved=True          else:              columnlist=[]              for j in range(4):                  if(board[i][j]=='.'):                      n_dotted+=1                  columnlist.append(board[j][i])              result= checkBoard(columnlist)              if(result!="None"):                   solved=True                  status=result                  break          if(solved):              break                #checking for diagonals      result_l=checkBoard([board[x][x] for x in range(4)]) #leftDiagonal      result_r=checkBoard([board[0][3],board[1][2],board[2][1],board[3][0]]) #rightDiagonal      if(result_l!="None"):               solved=True              status=result_l      if(result_r!="None"):               solved=True              status=result_r                        if(solved==False):          if(n_dotted==0):              status="Draw"          else:               status="Game has not completed"           return status      def checkBoard(board):          status="None"          x_count=board.count('X')          o_count=board.count('O')          t_count=board.count('T')          if(x_count==4 or (x_count==3 and t_count==1)):              status="X won"          elif(o_count==4 or (o_count==3 and t_count==1)):              status="O won"          return status      f_r = open('A.in',"r")  n_test=int(f_r.readline().strip())     f_w = open("A.out", "w")  for i in range(n_test):      board=[]      for j in range(4):          board.append(f_r.readline().strip())      result= getStatus(board)      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)      f_w.write(output_str+'\n')      f_r.readline()  f_r.close()  f_w.close()  <CODESPLIT> 5
'''  Created on Apr 12, 2014    @author: mostasem  '''    import math  def getFloorRoots(m):      r1 = -1 + math.sqrt(1 + (8 * m))/2      r2 = -1 - math.sqrt(1 + (8 * m))/2      return int(math.floor(r1))        def boardHasZero(R,C,M):      if(R > 1 and C > 1):          S = M/C          Sr = M % C          print S,Sr          return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)      else :          return M <= ((R*C) - 2)      def generateMineSweeperCase(R,C,M):        board = ""        if( R > 1 and C > 1 ): # generate special          S = M/C          Sr = M % C          print S,Sr          if(S): # all rows of *              board +="\n"              if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):                  board += (S - 1) * ((C*"*") + "\n")              else:                  board += (S - 2) * ((C*"*") + "\n")              board +=  ((C*"*"))                        if(R >= S+3):              if(Sr):                  board +="\n"                  board += ((Sr *"*") + ((C - Sr) *"."))              Rm = R - (S + 1)              if(Rm):                  board +="\n"                  board += (Rm - 1) * ((C*".") + "\n")                  board +=  ((C*"."))                            elif(R == S + 2):              Sm = 0              if(Sr % 2 == 0):                  board +="\n"                  board += (((Sr / 2) *"*") + ((C - (Sr / 2)) *".") +"\n")                  board += ((Sr / 2) *"*") + ((C - (Sr / 2)) *".")              else:                  board +="\n"                  board += (((Sr / 3) *"*") + ((C - (Sr / 3)) *".") +"\n")                  board += ((Sr / 3) *"*") + ((C - (Sr / 3)) *".")          else :              Sm = Sr + C              board +="\n"              board += (((Sm / 2) *"*") + ((C - (Sm / 2)) *".") +"\n")              board += ((Sm / 2) *"*") + ((C - (Sm / 2)) *".")                            list_board = list(board)          list_board[len(list_board) - 1] = 'c'          board = "".join(list_board)      else:          board +="\n"          if(C == 1):              board += M * "*\n"              board += (R-M-1) * ".\n"              board +=  "c"          else:              board += M * "*"              board += (C-M-1) * "."              board += "c"                    return board                               f_r = open('C.in',"r")  n_test=int(f_r.readline().strip())   f_w = open("C.out", "w")  result = ""  for i in range(n_test):      R,C,M = map(int,f_r.readline().split())      print R,C,M      if(boardHasZero(R,C,M)):          result = generateMineSweeperCase(R,C,M)      else :          result ="\nImpossible"      print result      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)      f_w.write(output_str+'\n')        f_r.close() <CODESPLIT> 5
'''  Created on Apr 14, 2012    @author: moatasem  '''    def getNumRecycle(n,A,B,h):          c=0          x=list(str(n))          for i in xrange(1,len(x)):              t1="".join(x[0:i])              t2="".join(x[i:len(x)])              num=int(t2+t1)              if((num>=A and num<=B) and num<>n and h.get((num,n))==None and h.get((n,num))==None):                  #print "(",str(n),",",str(num),")"                  h[(num,n)]=0;                  c+=1          return c              f = open("C-small-attempt0.in", "r")  n=int(f.readline().strip())  for k  in xrange(n):      d=f.readline().strip()      A,B=[int(i) for i in d.split(" ")]      count=0      h={}      for j in range(A,B+1):          count+= getNumRecycle(j,A,B,h)      print 'Case #'+str((k+1))+": "+str(count) <CODESPLIT> 5
from math import *    def read_line():      return raw_input().strip()    def read_words():      return read_line().split()    def read_integer():      return int( read_line() )    def read_integers():      return [ int( x ) for x in read_words() ]    T = read_integer()  for t in range( T ):      A, B = read_integers()      A_root = int( ceil( sqrt( A ) ) )      B_root = int( floor( sqrt( B ) ) )      count = 0      for root in range( A_root, B_root + 1 ):          word = str( root )          if word == word[ : : -1 ]:              word = str( root*root )              if word == word[ : : -1 ]:                  count += 1      print 'Case #%i:' % ( t + 1 ), count  <CODESPLIT> 6
def read_line():      return raw_input().strip()    def read_words():      return read_line().split()    def read_integer():      return int( read_line() )    def read_integers():      return [ int( x ) for x in read_words() ]    T = read_integer()  for t in range( T ):      print 'Case #%i:' % ( t + 1 ),      line = iter( read_integers() )      N = line.next()      S = line.next()      p = line.next()      t = sorted( line )      count = 0      while t and ( t[ -1 ] + 2 )/3 >= p:          t.pop()          count += 1      if p > 1:          while S and t and ( t[ -1 ] + 4 )/3 >= p:              t.pop()              S -= 1              count += 1      print count  <CODESPLIT> 6
import sys    def read_line():      return sys.stdin.readline().rstrip( '\n' )    def read_integer():      return int( read_line() )    def read_floats():      return [ float( x ) for x in read_line().split() ]    T = read_integer()  for t in range( T ):      N = read_integer()      naomi = sorted( read_floats() )      ken = sorted( read_floats() )      k = len( ken ) - 1      h = 0      for n in reversed( naomi ):          if ken[ k ] > n:              k -= 1          else:              h += 1      d = 0      n = len( naomi ) - 1      for k in reversed( ken ):          if naomi[ n ] > k:              d += 1              n -= 1      print 'Case #%i:' % ( t + 1 ), d, h  <CODESPLIT> 6
from numpy import *    def read_line():      return raw_input().strip()    def read_words():      return read_line().split()    def read_integer():      return int( read_line() )    def read_integers():      return [ int( x ) for x in read_words() ]    T = read_integer()  for t in range( T ):      N, M = read_integers()      lawn = array( [ read_integers() for n in range( N ) ] )      valid = zeros( lawn.shape, bool )      for row in range( N ):          valid[ row ][ lawn[ row ] == amax( lawn[ row ] ) ] = True      for column in range( M ):          valid[ :, column ][ lawn[ :, column ] == amax( lawn[ :, column ] ) ] = 1      print 'Case #%i:' % ( t + 1 ), 'YES' if all( valid ) else 'NO'  <CODESPLIT> 6
import sys    def read_line():      return sys.stdin.readline().rstrip( '\n' )    def read_integer():      return int( read_line() )    def read_float():      return float( read_line() )    def read_floats():      return [ float( x ) for x in read_line().split() ]    T = read_integer()  for t in range( T ):      C, F, X = read_floats()      rate = 2      cookies = 0      s = 0      while True:          t1 = X/rate          t2 = C/rate + X/( rate + F )          if t1 < t2:              s += t1              break          s += C/rate          rate += F      print 'Case #%i: %.7f' % ( t + 1, s )  <CODESPLIT> 6
import sys    def read_line():      return sys.stdin.readline().rstrip( '\n' )    def read_integer():      return int( read_line() )    def read_integers():      return [ int( x ) for x in read_line().split() ]    def read_string():      return read_line().strip()    def read_strings():      return read_line().split()    def input_string_stack():      data = []      for line in sys.stdin.readlines():          data.extend( line.split() )      data.reverse()      return data    def input_integer_stack():      return [ int( x ) for x in read_string_stack() ]    class memoized( object ):     def __init__( self, function ):        self.function = function        self.cache = {}     def __call__( self, *arguments ):        try:           return self.cache[ arguments ]        except KeyError:           value = self.function( *arguments )           self.cache[ arguments ] = value           return value    T = read_integer()  for t in range( T ):      row = read_integer()      candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )      row = read_integer()      candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )      print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'  <CODESPLIT> 6
def read_line():      return raw_input().strip()    def read_words():      return read_line().split()    def read_integer():      return int( read_line() )    def read_integers():      return [ int( x ) for x in read_words() ]      ciphers = 'y qee', 'ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv'  plaintexts = 'a zoo', 'our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up'    mapping = {}  for cipher, plaintext in zip( ciphers, plaintexts ):      for key, value in zip( cipher, plaintext ):          mapping[ key.lower() ] = value.lower()  mapping[ 'z' ] = 'q'    T = read_integer()  for t in range( T ):      print 'Case #%i:' % ( t + 1 ), ''.join( mapping[ key.lower() ].upper() if key.isupper() else mapping[ key ] for key in read_line() )  <CODESPLIT> 6
def read_line():      return raw_input().strip()    def read_integer():      return int( read_line() )    T = read_integer()  for t in range( T ):      board = [ read_line() for index in range( 4 ) ]      read_line()      print 'Case #%i:' % ( t + 1 ),      blank_count = 0      for row, column, row_increment, column_increment in ( ( 0, 0, 0, 1 ),                                                            ( 1, 0, 0, 1 ),                                                            ( 2, 0, 0, 1 ),                                                            ( 3, 0, 0, 1 ),                                                            ( 0, 0, 1, 0 ),                                                            ( 0, 1, 1, 0 ),                                                            ( 0, 2, 1, 0 ),                                                            ( 0, 3, 1, 0 ),                                                            ( 0, 0, 1, 1 ),                                                            ( 0, 3, 1, -1 ) ):          O_count = 0          X_count = 0          for index in range( 4 ):              value = board[ row ][ column ]              if value == 'O':                  O_count += 1              elif value == 'X':                  X_count += 1              elif value == 'T':                  O_count += 1                  X_count += 1              else:                  blank_count += 1              row += row_increment              column += column_increment          result = 'O' if O_count == 4 else 'X' if X_count == 4 else None          if result:              break      else:          print 'Game has not completed' if blank_count else 'Draw'          continue      print result, 'won'  <CODESPLIT> 6
import sys    def read_line():      return sys.stdin.readline().rstrip( '\n' )    def read_integer():      return int( read_line() )    def read_integers():      return [ int( x ) for x in read_line().split() ]    def flip( grid ):      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]    def grow( R, C, M ):      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]      b = R*C - M      if C > R:          R, C, grid = C, R, flip( grid )          flipped = True      else:          flipped = False      if b < 2*C:          if b == 1:              grid[ 0 ][ 0 ] = 'c'          elif b == 3 and C >= 3:              grid[ 0 ][ : 3 ] = bytearray( '.c.' )          elif b % 2:              return          else:              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )              grid[ 0 ][ 0 ] = 'c'      else:          r = 0          while b >= C:              grid[ r ] = bytearray( C*[ '.' ] )              b -= C              r += 1          if b:              if b >= 2:                  grid[ r ][ : b ] = b*'.'              elif C > 2 and r > 2:                  grid[ r - 1 ][ -1 ] = '*'                  grid[ r ][ : 2 ] = '..'              else:                  return          grid[ 0 ][ 0 ] = 'c'      return flip( grid ) if flipped else grid        T = read_integer()  for t in range( T ):      print 'Case #%i:' % ( t + 1 )      R, C, M = read_integers()      grid = grow( R, C, M )      print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'  <CODESPLIT> 6
def read_line():      return raw_input().strip()    def read_words():      return read_line().split()    def read_integer():      return int( read_line() )    def read_integers():      return [ int( x ) for x in read_words() ]    T = read_integer()  for t in range( T ):      print 'Case #%i:' % ( t + 1 ),      A, B = read_integers()      length = len( str( A ) )      pairs = set()      for n in range( A, B ):          digits = str( n )          for start in range( 1, length ):              m = int( digits[ start : ] + digits[ : start ] )              if n < m <= B:                  pairs.add( ( n, m ) )      print len( pairs )  <CODESPLIT> 6
#!/usr/bin/python    import sys  import functools  import operator  import math    def isPal(n):      l = str(n)      return l == l[::-1]    def solve(a, b):      l = int(math.ceil(math.sqrt(a)))      u = int(math.floor(math.sqrt(b)))        count = 0      for x in range(l, u + 1):          if isPal(x):              if isPal(x*x):                  count += 1      return str(count)    def main():      N = int(sys.stdin.readline()) # number of testcases      for i in range(N):          [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]          result = solve(a, b)          print ("Case #%s: %s" % (i+1, result))            # use something like:          # sys.stdin.readline()          # [int(x) for x in sys.stdin.readline().split()]      if __name__ == '__main__':      main()  <CODESPLIT> 7
#!/usr/bin/python    import sys  import functools  import operator      def solve(num_surprises, p, ts):      s = 0      u = 0      for t in ts:          a = int(t/3)          r = t % 3          if a+1 >= p and not r == 0:              u += 1          elif a >= p and r == 0:              u += 1          elif a > 0 and a+1 >= p and r == 0:              s += 1          elif a+2 >= p and r == 2:              s += 1        return min(num_surprises, s) + u                        def main():      N = int(sys.stdin.readline()) # number of testcases      for i in range(N):          line = [int(x) for x in sys.stdin.readline().split()]          num_surprises = line[1]          p = line[2]          ts = line[3:]          result = solve(num_surprises, p, ts)          print ("Case #%s: %s" % (i+1, result))      if __name__ == '__main__':      main()  <CODESPLIT> 7
#!/usr/bin/python    import sys  import functools  import operator  import math  from itertools import chain, combinations  from heapq import heappop, heappush, _siftup    def solveWar(n_weights, k_weights):      nweights = sorted(n_weights)      kweights = sorted(k_weights)      score = 0            # while nweights:      #     w = nweights.pop(0)      #     res = [kweight for kweight in kweights if kweight > w]      #     if res:      #         kweights.remove(min(res))      #     else:      #         score += len(nweights) + 1      #         break        for w in nweights:          while kweights and kweights[0] < w:              kweights.pop(0)              score += 1            if not kweights:              break          else:              kweights.pop(0)                    return score    def solveDWar(n_weights, k_weights):      nweights = sorted(n_weights)      kweights = sorted(k_weights)      score = 0        for w in nweights:          if w > kweights[0]:              score += 1              kweights.pop(0)          else:              kweights.pop(-1)            return score    def solve(nweights, kweights):      return ("%s %s" % (solveDWar(nweights, kweights), solveWar(nweights, kweights)))    def main():      N = int(sys.stdin.readline()) # number of testcases      for i in range(N):          sys.stdin.readline()          nweights = [float(x) for x in sys.stdin.readline().rstrip().split()]          kweights = [float(x) for x in sys.stdin.readline().rstrip().split()]            result = solve(nweights, kweights)          print ("Case #%s: %s" % (i+1, result))    if __name__ == '__main__':      main()  <CODESPLIT> 7
#!/usr/bin/python    import sys  import functools  import operator    def solve(M, a, b):      rowmax = [max(r) for r in M]      colmax = [max([M[j][i] for j in range(a)]) for i in range(b)]      rowmin = [min(r) for r in M]      colmin = [min([M[j][i] for j in range(a)]) for i in range(b)]        for i in range(a):          for j in range(b):              if M[i][j] != min(rowmax[i], colmax[j]):                  return 'NO'      return 'YES'    def main():      N = int(sys.stdin.readline()) # number of testcases      for i in range(N):          [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]          M = []          for j in range(a):              M += [[int(x) for x in sys.stdin.readline().split()]]          result = solve(M, a, b)          print ("Case #%s: %s" % (i+1, result))      if __name__ == '__main__':      main()  <CODESPLIT> 7
#!/usr/bin/python    import sys  import functools  import operator  import math  from itertools import chain, combinations  from heapq import heappop, heappush, _siftup    def solve(C, F, X):      rate = 2.0      time_to_win = X / rate        time_used = C / rate      rate += F      time_to_win_new = time_used + X / rate        while time_to_win_new < time_to_win:          time_to_win = time_to_win_new                    time_used += C / rate          rate += F          time_to_win_new = time_used + X / rate        return time_to_win    def main():      N = int(sys.stdin.readline()) # number of testcases      for i in range(N):          [C, F, X] = [float(x) for x in sys.stdin.readline().rstrip().split()]            result = solve(C, F, X)          print ("Case #%s: %.7f" % (i+1, result))    if __name__ == '__main__':      main()  <CODESPLIT> 7
#!/usr/bin/python    import sys  import functools  import operator  import math  from itertools import chain, combinations  from heapq import heappop, heappush, _siftup    def solve(row1, row2):      common = [x for x in row1 if x in row2]      num_common = len(common)      if num_common == 0:          return 'Volunteer cheated!'      elif num_common > 1:          return 'Bad magician!'      else:          return common[0]    def main():      N = int(sys.stdin.readline()) # number of testcases      for i in range(N):          row_index1 = int(sys.stdin.readline())          row1 = list()          for j in range(4):              if row_index1 == j + 1:                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]              else:                  sys.stdin.readline()            row_index2 = int(sys.stdin.readline())          row2 = list()          for j in range(4):              if row_index2 == j + 1:                  row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]              else:                  sys.stdin.readline()            result = solve(row1, row2)          print ("Case #%s: %s" % (i+1, result))    if __name__ == '__main__':      main()  <CODESPLIT> 7
#!/usr/bin/python    import sys  import functools  import operator      table = {'a': 'y',           'b': 'h',           'c': 'e',           'd': 's',           'e': 'o',           'f': 'c',           'g': 'v',           'h': 'x',           'i': 'd',           'j': 'u',           'k': 'i',           'l': 'g',           'm': 'l',           'n': 'b',           'o': 'k',           'p': 'r',           'q': 'z',           'r': 't',           's': 'n',           't': 'w',           'u': 'j',           'v': 'p',           'w': 'f',           'x': 'm',           'y': 'a',           'z': 'q',           ' ': ' ',           '\n': ''}    def solve(s):      return ''.join([table[c] for c in s])              def main():      N = int(sys.stdin.readline()) # number of testcases      for i in range(N):          # use something like:          # sys.stdin.readline()          # [int(x) for x in sys.stdin.readline().split()]          result = solve(sys.stdin.readline())          print ("Case #%s: %s" % (i+1, result))      if __name__ == '__main__':      main()  <CODESPLIT> 7
#!/usr/bin/python    import sys  import functools  import operator    def result(l):      xcount = 0      ocount = 0      empty = False      for field in l:          if field == 'X' or field == 'T':              xcount += 1          if field == 'O' or field == 'T':              ocount += 1          if field == '.':              empty = True        if xcount == 4:          return 'X'      if ocount == 4:          return 'O'      if empty:          return '.'      else:          return ''    def solve(M):      # check rows      empty = False      for i in range(4):          r = result(M[i])          if (r == 'X' or r == 'O'):              return r + ' won'          if r == '.':              empty = True        # check columns      for i in range(4):          r = result([M[j][i] for j in range(4)])          if (r == 'X' or r == 'O'):              return r + ' won'        # check diagonals      r = result([M[i][i] for i in range(4)])      if (r == 'X' or r == 'O'):          return r + ' won'      r = result([M[i][3-i] for i in range(4)])      if (r == 'X' or r == 'O'):          return r + ' won'        # determine whether it's a draw      if empty:          return 'Game has not completed'      else:          return 'Draw'    def main():      N = int(sys.stdin.readline()) # number of testcases      for i in range(N):          M = []          for j in range(4):              M += [list(sys.stdin.readline().rstrip())]          sys.stdin.readline()          result = solve(M)          print ("Case #%s: %s" % (i+1, result))    if __name__ == '__main__':      main()  <CODESPLIT> 7
#!/usr/bin/python    import sys  import functools  import operator  import math  from itertools import chain, combinations  from heapq import heappop, heappush, _siftup    def neighbours(grid, (i, j), n, m):      for a in range(max(i-1, 0), min(i+2, n)):          for b in range(max(j-1, 0), min(j+2, m)):              if (a != i or b != j):                  yield (a, b)    def isGridCorrect(grid):      g = list(grid)      n = len(g)      m = len(g[0])      queue = [(0, 0)]        while queue:          v = queue.pop(0)          g[v[0]][v[1]] = 'r'          bomb = False          for (i, j) in neighbours(g, v, n, m):              if g[i][j] == '*':                  bomb = True          if not bomb:              for (i, j) in neighbours(g, v, n, m):                  if g[i][j] != 'r':                      #print('append')                      queue.append((i, j))        for i in range(n):          for j in range(m):              if g[i][j] != 'r' and g[i][j] != '*':                  #print draw(g)                  return 'WRONG'        return 'Right'    def createGrid(R, C, s):      field = []      for i in range(R):          field.append([s] * C)      field[0][0] = 'c'      return field    def draw(grid):      s = ""      for row in grid:          s += "\n" + ''.join(row)      return s    def reduceRows(grid, k, l, M):      if k <= 2:          return (grid, k, l, M)            #num_rows = M / l      #lowest = max(k - num_rows, 2)      #num_rows = k - lowest        #print('k: ' + str(k))      #print('l: ' + str(l))      for j in range(l):          #print grid          #print i, j          grid[k-1][j] = '*'      k -= 1      M -= l      return (grid, k, l, M)    def reduceCols(grid, k, l, M):      if l <= 2:          return (grid, k, l, M)            #num_cols = M / k      #lowest = max(l - num_cols, 2)      #num_cols = l - lowest        for i in range(k):          grid[i][l-1] = '*'      l -= 1      M -= k      return (grid, k, l, M)    def solve(R, C, M):      mp = M      if M == 0:          f = createGrid(R, C, '.')          #print(isGridCorrect(f))          return draw(f)      elif M == R*C - 1:          f = createGrid(R, C, '*')          #print(isGridCorrect(f))          return draw(f)      elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):          return "\n" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)      elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):          return "\n" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)      else:          grid = createGrid(R, C, '.')            #print('R: ' + str(R))          #print('C: ' + str(C))            k = R          l = C            while (M >= l and k > 2) or (M >= k and l > 2):              if l >= k:                  #print('l >= k')                  (grid, k, l, M) = reduceCols(grid, k, l, M)                  #print grid                  #print k, l, M              elif k > l:                  #print('k > l')                  (grid, k, l, M) = reduceRows(grid, k, l, M)                  #print grid                  #print k, l, M            #print(grid)          #print M            if M == 0:              #print(isGridCorrect(grid))              return draw(grid)          if M < l - 1 and k > 2:              for j in range(l - M, l):                  grid[k-1][j] = '*'          elif M < k - 1 and l > 2:              for i in range(k - M, k):                  grid[i][l-1] = '*'          elif l > 3 and k > 3:              for i in range(2, k):                  grid[i][l-1] = '*'              M -= k - 2              for j in range(l - M - 1, l - 1):                  grid[k-1][j] = '*'          else:              return "\n" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)            #print(isGridCorrect(grid))          return draw(grid)    def main():      N = int(sys.stdin.readline()) # number of testcases      for i in range(N):          [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]            result = solve(R, C, M)          print ("Case #%s:%s" % (i+1, result))    if __name__ == '__main__':      main()  <CODESPLIT> 7
#!/usr/bin/python    import sys  import functools  import operator      def solve(a,b):      num_recycled = 0      for n in range(a, b+1):          s = str(n)          pairs = []          for i in range(1,len(s)):              m = int(s[i:] + s[:i])              #print("checking " + str(m))              if n < m and m <= b and m not in pairs:                  num_recycled += 1                  pairs.append(m)      return num_recycled              def main():      N = int(sys.stdin.readline()) # number of testcases      for i in range(N):          [a, b] = [int(x) for x in sys.stdin.readline().split()]          result = solve(a,b)          print ("Case #%s: %s" % (i+1, result))      if __name__ == '__main__':      main()  <CODESPLIT> 7
from bisect import bisect_right    def generateTable(N):      msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]      nums = revnums = [1, 2]        digsums = [1, 4]        for i in xrange(2, N+1):          a, b, d = [], [], []          p = 10**(i-1)          for j in xrange(len(nums)):              for k in xrange(3):                  n, rn, ds = 10*nums[j] + k, revnums[j] + k*p, digsums[j] + k*k                  if ds < 5:                      a.append(n)                      b.append(rn)                      d.append(ds)                      msq.append(10*p*n + rn) # even length                      if i == N:                          continue                      for l in xrange(3): # odd length                          if 2*ds + l*l < 10:                              msq.append(100*p*n + 10*p*l + rn)          nums, revnums, digsums = a, b, d        msq.sort()      return msq    def getNum(A, B):      return bisect_right(tab2, B) - bisect_right(tab2, A-1)    N = 10  tab = generateTable(N)  tab2 = map(lambda n: n**2, tab)    T = int(raw_input())  for z in xrange(T):      A, B = map(int, raw_input().split())      print "Case #%d: %d" % (z+1, getNum(A, B))  <CODESPLIT> 8
T = int(raw_input())    for z in xrange(1, T+1):      a = map(int, raw_input().split())      s, p = a[1:3]      a = a[3:]      A = 0 if p == 0 else 3*p - 2      B = 0 if p == 0 else 1 if p == 1 else 3*p-4      x = len(filter(lambda x: x >= A, a))      y = len(filter(lambda x: x >= B, a)) - x      res = x + min(s, y)      print "Case #%d:" % z, res <CODESPLIT> 8
T = int(raw_input())    def solve(a, b):      n = len(a)      a.sort()      b.sort()      i = j = m = M = 0      while i < n:          if a[i] > b[j]:              M += 1              i += 1              j += 1          else:              i += 1      i = j = 0      while j < n:          if b[j] > a[i]:              m += 1              i += 1              j += 1          else:              j += 1      return str(M) + " " + str(n-m)    for z in xrange(T):      n = int(raw_input())      a = map(float, raw_input().split())      b = map(float, raw_input().split())      print "Case #%d: %s" % (z+1, solve(a, b)) <CODESPLIT> 8
T = int(raw_input())    def readMatrix(nlines):      return [map(int, raw_input().split(' ')) for i in xrange(nlines)]    def transpose(A):      return map(lambda i: map(lambda line: line[i], A), xrange(len(A[0])))    for z in xrange(T):      M, N = map(int, raw_input().split(' '))      A = readMatrix(M)      b = map(max, A)      c = map(max, transpose(A))      fl = True      for i in xrange(M):          for j in xrange(N):              if A[i][j] != min(b[i], c[j]):                  fl = False      print "Case #%d: %s" % (z+1, "YES" if fl else "NO") <CODESPLIT> 8
T = int(raw_input())    def solve(C, F, X):      best = x/2      buildTime, speed = 0, 2      while True:          buildTime += C/speed          if buildTime > best:              break          speed += F          best = min(best, buildTime + X/speed)      return best    for z in xrange(T):      c, f, x = map(float, raw_input().split())      print "Case #%d: %.7f" % (z+1, solve(c, f, x)) <CODESPLIT> 8
T = int(raw_input())    def readSq(n):      res = []      for i in xrange(n):          res.append(set(map(int, raw_input().split())))      return res    def solve():      a1 = int(raw_input())      s1 = readSq(4)      a2 = int(raw_input())      s2 = readSq(4)      ans = s1[a1-1] & s2[a2-1]      if len(ans) == 0:          return "Volunteer cheated!"      if len(ans) > 1:          return "Bad magician!"      return str(list(ans)[0])    for z in xrange(T):      print "Case #%d: %s" % (z+1, solve())  <CODESPLIT> 8
inps = ["ejp mysljylc kd kxveddknmc re jsicpdrysi", "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd", "de kr kd eoya kw aej tysr re ujdr lkgc jv"]  outs = ["our language is impossible to understand","there are twenty six factorial possibilities", "so it is okay if you want to just give up"]    d = {'z':'q', 'q':'z'}    for i in xrange(3):      inp, out = inps[i], outs[i]      for j in xrange(len(inp)):          d[inp[j]] = out[j]    n = int(raw_input())  for i in xrange(n):      s = raw_input()      print "Case #%d:" % (i+1), "".join(map(lambda c: d[c], s)) <CODESPLIT> 8
n = int(raw_input())    d = {'X':2, 'O': 0, 'T':1, '.':-10}    def readGame():      return [map(lambda c:d[c], raw_input().strip()) for i in xrange(4)]    def check(game):      s = []      for i in xrange(4): # horizontal          s.append(sum(game[i]))      for i in xrange(4): # vertical          s.append(sum(map(lambda li: li[i], game)))      d1 = d2 = 0 # diagonal      for i in xrange(4):          d1 += game[i][i]          d2 += game[i][3-i]      s.append(d1)      s.append(d2)      if max(s) >= 7:          return "X won";      gr0 = filter(lambda n: n >= 0, s)      if len(gr0) > 0 and min(gr0) <= 1:          return "O won"      if min(s) < 0:          return "Game has not completed"      return "Draw"    for i in xrange(n):      game = readGame()      if i + 1 < n:          raw_input()        print "Case #%d: %s" % (i+1, check(game)) <CODESPLIT> 8
from cStringIO import StringIO    T = int(raw_input())    def generate(R, C, a, sw):      if sw:          R, C = C, R      res = [['*']*C for i in xrange(R)]      for i in xrange(len(a)):          for j in xrange(a[i]):              if sw:                  res[j][i] = '.'              else:                  res[i][j] = '.'      res[0][0] = 'c'      return str(res)[2:-2].replace(' ', '').replace("'",'').replace('[', '').replace('],','\n').replace(',', '')      def solveEq(k, s, x1):      if 2*(x1 + k - 2) > s or k*x1 < s:          return None      r = [0]*k      r[0] = r[1] = x1      s -= 2*x1      for i in xrange(k-2, 0, -1):          t = min(x1, s - 2*i + 2)          r[k-i] = t          s -= t      return r    def solve(R, C, M):      S = R*C      nm = S - M      if R == 1 or C == 1:          if R == 1:              return '*'*M + '.'*(S-M-1) + 'c'          else:              return '*\n'*M + '.\n'*(S-M-1) + 'c'      else:          sw = False          if R > C:              R, C = C, R              sw = True          if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):              return "Impossible"          if nm == 1:              return generate(R, C, [1], sw)          for k in xrange(2, R+1):              for x1 in xrange(2, C+1):                  r = solveEq(k, nm, x1)                  if r != None:                      return generate(R, C, r, sw)          return "Something wrong"    for z in xrange(T):      c, f, x = map(int, raw_input().split())      print "Case #%d:\n%s" % (z+1, solve(c, f, x)) <CODESPLIT> 8
T = int(raw_input())    def isRecycle(x, y, d):      k = 10**(d-1)      for i in xrange(ndigits):          y = k*(y%10) + y/10          if x == y:              return True      return False    for z in xrange(1, T+1):      res = 0      A, B = map(int, raw_input().split())      ndigits = len(str(A))      for i in xrange(A, B):          for j in xrange(i+1, B+1):             if isRecycle(i, j, ndigits):                 res += 1      print "Case #%d:" % z, res <CODESPLIT> 8
import math  import sys    def ispal(n):      s = str(n)      return s == s[::-1]    def ispalsq(n):      sqrt = int(math.sqrt(n) + .01)      if sqrt ** 2 != n:          return False      return ispal(n) and ispal(sqrt)    def search(s, l, idx):      if l % 2 == 0:          m = s + s[::-1]      else:          m = s[:-1] + s[::-1]      assert ispal(m)      n = int(m) ** 2      if not ispal(n):          # print m, False          return 0      # print m, int(m)**2        r = 1 if (a <= n <= b) else 0      for i in xrange(idx, len(s)):          s2 = list(s)          s2[i] = str(int(s2[i])+1)          s2 = ''.join(s2)          r += search(s2, l, i)      return r      if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in xrange(t):          a, b = map(int, f.readline().split())            total = 0          for l in xrange(1, 150):              if 10 ** (l-1) > b:                  break              total += search("1" + "0" * ((l-1)/2), l, 0)          print "Case #%d: %d" % (_t+1, total)    <CODESPLIT> 9
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in xrange(t):          ns = map(int, f.readline().split())          n = ns[0]          s = ns[1]          p = ns[2]          assert len(ns) == n + 3          scores = ns[3:3+n]            sure = 0          if_surprising = 0          for x in scores:              not_surprising = (x + 2) / 3              is_surprising = (x + 4) / 3              if not_surprising >= p:                  sure += 1              elif (2 <= x <= 28) and is_surprising >= p:                  if_surprising += 1          print "Case #%d: %d" % (_t+1, sure + min(if_surprising, s))  <CODESPLIT> 9
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        T = int(f.readline())      for _T in xrange(T):          N = int(f.readline())          naomi = map(float, f.readline().split())          ken = map(float, f.readline().split())          assert len(ken) == len(naomi) == N            naomi = [(w, 1) for w in naomi]          ken = [(w, 0) for w in ken]            blocks = ken + naomi          blocks.sort(reverse=True)          blocks = [p[1] for p in blocks]          # print blocks            honest = 0          adv = 0          for b in blocks:              if b == 1:                  adv += 1                  honest = max(honest, adv)              else:                  adv -= 1            deceitful = 0          kept = 0          for b in blocks:              if b == 1:                  kept += 1              else:                  if kept:                      kept -= 1                      deceitful += 1          print "Case #%d: %d %d" % (_T+1, deceitful, honest)  <CODESPLIT> 9
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in xrange(t):          n, m = map(int, f.readline().split())          b = []          for i in xrange(n):              b.append(map(int, f.readline().split()))              assert len(b[-1]) == m          # print b            max_h = [0] * n          max_v = [0] * m            for i in xrange(n):              for j in xrange(m):                  t = b[i][j]                  max_h[i] = max(max_h[i], t)                  max_v[j] = max(max_v[j], t)          can = True          for i in xrange(n):              if not can:                  break              for j in xrange(m):                  t = b[i][j]                  if max_h[i] > t and max_v[j] > t:                      can = False                      break            print "Case #%d: %s" % (_t+1, "YES" if can else "NO")  <CODESPLIT> 9
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        T = int(f.readline())      for _T in xrange(T):          C, F, X = map(float, f.readline().split())            cps = 2.0          t = 0.0          best_t = X / cps            while True:              t += C / cps              if t >= best_t:                  break                cps += F              best_t = min(best_t, t + X / cps)            print "Case #%d: %.7f" % (_T+1, best_t)  <CODESPLIT> 9
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        T = int(f.readline())      for _T in xrange(T):          a1 = int(f.readline())          l1 = [map(int, f.readline().split()) for _ in xrange(4)]          a2 = int(f.readline())          l2 = [map(int, f.readline().split()) for _ in xrange(4)]            poss = list(set(l1[a1-1]) & set(l2[a2-1]))            print "Case #%d:" % (_T + 1),          if len(poss) == 0:              print "Volunteer cheated!"          elif len(poss) == 1:              print poss[0]          else:              print "Bad magician!"  <CODESPLIT> 9
import sys    d = {          'a':'y',          'o':'e',          'z':'q',          ' ':' ',          'r':'p',          'l':'m',          'n':'s',          'g':'l',          'u':'j',          'e':'c',          'i':'k',          's':'d',          'm':'x',          'p':'v',          't':'r',          'd':'i',          'b':'n',          'h':'b',          'w':'t',          'y':'a',          'x':'h',          'f':'w',          'c':'f',          'k':'o',          'j':'u',          'v':'g',          'q':'z',          '\n':'\n',          }    r = dict((v,k) for (k,v) in d.items())    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        f.readline()      i = 1      for l in f:          sys.stdout.write("Case #%d: " % i)          for c in l:              # sys.stdout.write(r.get(c, '?'))              sys.stdout.write(r[c])          i += 1    <CODESPLIT> 9
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in xrange(t):          m = []          for i in xrange(4):              l = f.readline().strip()              assert len(l) == 4              m.append(l)          f.readline()            def check(x, y, dx, dy):              s = set()              for i in xrange(4):                  s.add(m[x][y])                  x += dx                  y += dy              # print x, y, dx, dy, s              if 'T' in s:                  s.remove('T')              if '.' in s:                  return None              if len(s) == 1:                  return list(s)[0]              return None            winner = None          for i in xrange(4):              winner = winner or check(0, i, 1, 0)              winner = winner or check(i, 0, 0, 1)          winner = winner or check(0, 0, 1, 1)          winner = winner or check(0, 3, 1, -1)            print "Case #%d:" % (_t+1),          if winner:              print "%s won" % winner          elif any('.' in l for l in m):              print "Game has not completed"          else:              print "Draw"  <CODESPLIT> 9
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        T = int(f.readline())      for _T in xrange(T):          R, C, M = map(int, f.readline().split())            # print R, C, M          print "Case #%d:" % (_T+1)            left = R * C - M            if R == 1:              s = 'c'              s += '.' * (left - 1)              s += '*' * M              print s              continue          if C == 1:              print 'c'              for i in xrange(left - 1):                  print '.'              for i in xrange(M):                  print '*'              continue            if left == 1:              print 'c' + '*' * (C-1)              for i in xrange(R-1):                  print '*' * C              continue            if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):              print "Impossible"              continue          if R == 2:              assert left not in (2, 3, 5, 7)              assert left >= 4              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)              print '.' + '.' * (left/2 - 1) + '*' * (M/2)              continue          if C == 2:              assert left >= 4              assert left not in (2, 3, 5, 7)              print 'c.'              left -= 2              R -= 1              while left:                  print '..'                  left -= 2                  R -= 1              assert R >= 0              while R:                  print '**'                  R -= 1              continue            assert R >= 3          assert C >= 3            if left == 4:              print 'c.' + '*' * (C-2)              print '..' + '*' * (C-2)              for i in xrange(R-2):                  print '*' * C              continue            if left in (2, 3, 5, 7):              print "Impossible"              continue            assert left >= 6            cols = max(3, (left + R-1) // R)            if left % cols == 1:              assert left >= 10                print 'c' + '.' * (cols - 1) + '*' * (C - cols)              left -= cols              R -= 1                while left > cols + 1:                  print '.' * cols + '*' * (C - cols)                  left -= cols                  R -= 1              assert left == cols + 1              print '.' * (cols - 1) + '*' * (C - cols + 1)              print '.' * (2) + '*' * (C - 2)              R -= 2                assert R >= 0                while R:                  print '*' * C                  R -= 1              continue          else:              assert left >= 6                print 'c' + '.' * (cols - 1) + '*' * (C - cols)              left -= cols              R -= 1                while left > cols:                  print '.' * cols + '*' * (C - cols)                  left -= cols                  R -= 1              assert left >= 2              print '.' * (left) + '*' * (C - left)              R -= 1                assert R >= 0                while R:                  print '*' * C                  R -= 1              continue            1/0  <CODESPLIT> 9
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in xrange(t):          a, b = map(int, f.readline().split())            total = 0          for i in xrange(a, b):              # print i              s = set()              cs = str(i)              for j in xrange(1, len(cs)):                  k = int(cs[j:] + cs[:j])                  if i < k <= b:                      s.add(k)              # print s              # print              total += len(s)            print "Case #%d: %d" % (_t + 1, total)  <CODESPLIT> 9
from sys import stdin    def read_ints():      return map(int, stdin.readline().rstrip().split(' '))    def is_palin(n):      s = str(n)      return s == s[::-1]        def find(n, fas):      for i in xrange(len(fas)):          if fas[i] >= n:              return i      return len(fas)        def gen_fas(max):      fas = []      fasappend = fas.append      square, base, d = 1, 1, 3      while square < max:          if is_palin(square) and is_palin(base):              fasappend(square)          square += d          d += 2          base += 1      return fas        def main():      MAX = 1000      fas = gen_fas(MAX)            T = int(stdin.readline())      for Ti in xrange(T):          A, B = read_ints()          answer = find(B + 1, fas) - find(A, fas)          print 'Case #{}: {}'.format(Ti + 1, answer)            main()  <CODESPLIT> 10
from sys import stdin    def program():  	T = int(stdin.readline())  	for Ti in xrange(T):  		numbers = a = map(int, stdin.readline().rstrip().split(' '))  		N, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]  		  		m = 0  		curr_S = S  		for i in xrange(N):  			t = totals[i]  			  			if t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):  				m += 1  			elif curr_S > 0 and t > 0:  				if (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):  					m += 1  					curr_S -= 1  		  		print 'Case #%d: %d' % (Ti + 1, m)	  	  if __name__ == '__main__':  	program() <CODESPLIT> 10
from sys import stdin      def read_str(): return stdin.readline().rstrip('\n')  def read_int(): return int(stdin.readline())  def read_ints(): return map(int, stdin.readline().split())  def read_floats(): return map(float, stdin.readline().split())          def war(N, K):      points = 0      j = 0      for i in range(len(N)):          while j < len(K) and K[j] < N[i]:              j += 1          if j == len(K):              points += 1          else:              j += 1      return points      def deceitful_war(N, K):      return len(N) - war(K, N)          def solve_case():      read_int()      N = sorted(read_floats())      K = sorted(read_floats())            return '{} {}'.format(deceitful_war(N, K), war(N, K))          def main():      cases = read_int()      for case in range(1, cases + 1):          print('Case #{}: {}'.format(case, solve_case()))              main()  <CODESPLIT> 10
from sys import stdin    def read_ints():      return map(int, stdin.readline().rstrip().split(' '))    def print_lawn(lawn):      for row in lawn:          print row            def is_higher(a, i, j, N, M):      s = a[i][j]      v, h = False, False      for ii in xrange(N):          if a[ii][j] > s:              v = True              break      for jj in xrange(M):          if a[i][jj] > s:              h = True              break      return v and h        def check(a, N, M):      if N == 1 or M == 1:          return True      else:          for i in xrange(N):              for j in xrange(M):                  h = is_higher(a, i, j, N, M)                  if h:                      return False          return True        def main():      T = int(stdin.readline())      for Ti in xrange(T):          N, M = read_ints()          a = []          for i in xrange(N):              a.append(read_ints())          answer = 'YES' if check(a, N, M) else 'NO'          #print_lawn(a)          print 'Case #{}: {}'.format(Ti + 1, answer)            main()  <CODESPLIT> 10
from sys import stdin    def read_str(): return stdin.readline().rstrip('\n')  def read_int(): return int(stdin.readline())  def read_ints(): return map(int, stdin.readline().split())  def read_floats(): return map(float, stdin.readline().split())      def solve_case():      C, F, X = read_floats()      rate = 2      current = 0      best = X / rate            while True:          current += C / rate          rate += F          next = current + X / rate          if next < best:              best = next          else:              break            return best          def main():      cases = read_int()      for case in range(1, cases + 1):          print('Case #{}: {:.7f}'.format(case, solve_case()))              main()  <CODESPLIT> 10
from sys import stdin    def read_str(): return stdin.readline().rstrip('\n')  def read_int(): return int(stdin.readline())  def read_ints(): return map(int, stdin.readline().split())    def read_cards():      cards = []      for i in range(4):          cards.append(read_ints())      return cards    def main():      cases = read_int()      for case in range(1, cases + 1):          row = read_int() - 1          cards = read_cards()          candidates1 = set(cards[row])                    row = read_int() - 1          cards = read_cards()          candidates2 = set(cards[row])                    candidates = candidates1.intersection(candidates2)          if len(candidates) == 1:              ans = list(candidates)[0]          elif len(candidates) == 0:              ans = 'Volunteer cheated!'          else:              ans = 'Bad magician!'                    print('Case #{}: {}'.format(case, ans))            main()  <CODESPLIT> 10
from sys import stdin    def get_mapping():  	d = ord('a')  	mapping = [ None ] * 26  	inputs = [ 'ejp mysljylc kd kxveddknmc re jsicpdrysi',   		'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',   		'de kr kd eoya kw aej tysr re ujdr lkgc jv' ]  	outputs = [ 'our language is impossible to understand',   		'there are twenty six factorial possibilities',   		'so it is okay if you want to just give up' ]  	  	for i in xrange(len(inputs)):  		input = inputs[i]  		output = outputs[i]  		for j in xrange(len(input)):  			if input[j] == ' ':  				continue  			k = ord(input[j]) - d  			if mapping[k] is None:  				mapping[k] = output[j]  	mapping[ord('q') - d] = 'z'  	mapping[ord('z') - d] = 'q'  				  	return mapping  			    def program():  	T = int(stdin.readline())  	mapping = get_mapping()  	d = ord('a')  	for i in xrange(T):  		s = stdin.readline().rstrip()  		t = ''  		  		for ss in s:  			if ss == ' ':  				t += ' '  			else:  				t += mapping[ord(ss) - d]  		print 'Case #%d: %s' % (i + 1, t)  	  if __name__ == '__main__':  	program() <CODESPLIT> 10
from sys import stdin    def won(x, o, t):      if x == 4 or (x == 3 and t == 1):          return 1      elif o == 4 or (o == 3 and t == 1):          return 2    def check(board, BOARD_SIZE, RESULTS):      d = 0      for i in xrange(BOARD_SIZE):          x = board[i].count('X')          o = board[i].count('O')          t = board[i].count('T')          d += board[i].count('.')          w = won(x, o, t)          if w:              return w      for i in xrange(BOARD_SIZE):          vertical = [ board[j][i] for j in xrange(BOARD_SIZE) ]          x = vertical.count('X')          o = vertical.count('O')          t = vertical.count('T')          w = won(x, o, t)          if w:              return w      x, o, t = 0, 0, 0      for i in xrange(BOARD_SIZE):          if board[i][i] == 'X':              x += 1          elif board[i][i] == 'O':              o += 1          elif board[i][i] == 'T':              t += 1      w = won(x, o, t)      if w:          return w          x, o, t = 0, 0, 0      for i in xrange(BOARD_SIZE):          if board[i][BOARD_SIZE - i - 1] == 'X':              x += 1          elif board[i][BOARD_SIZE - i - 1] == 'O':              o += 1          elif board[i][BOARD_SIZE - i - 1] == 'T':              t += 1      w = won(x, o, t)      if w:          return w      if d == 0:          return 3      else:          return 4        def main():      BOARD_SIZE = 4      RESULTS = 'X won', 'O won', 'Draw', 'Game has not completed'        T = int(stdin.readline())      for Ti in xrange(T):          board = []          for i in xrange(BOARD_SIZE):              board.append(list(stdin.readline().rstrip()))          print 'Case #{}: {}'.format(Ti + 1, RESULTS[check(board, BOARD_SIZE, RESULTS) - 1])              stdin.readline()            main()  <CODESPLIT> 10
from sys import stdin      def read_str(): return stdin.readline().rstrip('\n')  def read_int(): return int(stdin.readline())  def read_ints(): return map(int, stdin.readline().split())  def read_floats(): return map(float, stdin.readline().split())      def atos(A):      return '\n'.join([''.join(row) for row in A])          def get_field(r, c):      field = [['.'] * c for i in range(r)]      field[0][0] = 'c'      return field              def is_forbidden(i, j):      return i == 0 and j == 0 or i == 0 and j == 1 or \          i == 1 and j == 0 or i == 1 and j == 1              def fill(field, r, c, m):      left = m      for ii in range(r - 1, -1, -1):          i = ii          j = c - 1          while i < r and j >= 0:              if is_forbidden(i, j):                  i += 1                  j -= 1                  continue              if left == 0:                  return 0              field[i][j] = '*'              left -= 1                            i += 1              j -= 1                        if ii == 0:              for jj in range(c - 2, 1, -1):                  i = ii                  j = jj                  while i < r and j >= 0:                      if is_forbidden(i, j):                          i += 1                          j -= 1                          continue                      if left == 0:                          return 0                      field[i][j] = '*'                      left -= 1                                            i += 1                      j -= 1                    if r * c == m + 1:          if r > 1:              field[1][0] = '*'          if c > 1:              field[0][1] = '*'          if r > 1 and c > 1:              field[1][1] = '*'          return 0                    return left          def solve_case():      r, c, m = read_ints()      #print('\n', r, c, m)            field = get_field(r, c)                left = fill(field, r, c, m)                return 'Impossible' if left != 0 else atos(field)              def main():      cases = read_int()      for case in range(1, cases + 1):          print('Case #{}:\n{}'.format(case, solve_case()))              main()  <CODESPLIT> 10
from sys import stdin    def program():  	T = int(stdin.readline())  	for Ti in xrange(T):  		A, B =  map(int, stdin.readline().rstrip().split(' '))  		  		ss = set()  		for n in xrange(A, B + 1):  			sn = str(n)  			for i in xrange(1, len(sn)):  				sm = sn[i:] + sn[:i]  				if sm[0] != '0':  					m = int(sm)  					if m > n and m <= B:  						ss.add((n, m))  		  		print 'Case #%d: %d' % (Ti + 1, len(ss))	  	  if __name__ == '__main__':  	program() <CODESPLIT> 10
import sys  import math      fairsquares = []      def read_fairsquares():      global fairsquares      f = open('fairsquares.txt')      for x in f:          fairsquares.append(int(x.strip()))      def count_less_than(A):      left = 0      right = len(fairsquares)      # fairsquares[left - 1] < A <= fairsquares[right]      while left < right:          middle = (left + right) // 2          if fairsquares[middle] < A:              left = middle + 1          else:              right = middle      return left      def compute(A, B):      count_b = count_less_than(B + 1)      count_a = count_less_than(A)      return count_b - count_a      def parse():      return map(int, sys.stdin.readline().strip().split())      if __name__ == "__main__":      read_fairsquares()      T = int(sys.stdin.readline().strip())      count = 1      part = 0      if len(sys.argv) == 3:          part = int(sys.argv[1])          count = int(sys.argv[2])      for i in xrange(T):          data = parse()          if i * count >= part * T and i * count < (part + 1) * T:              result = compute(*data)              print "Case #%d: %s" % (i + 1, result)  <CODESPLIT> 11
import sys      if __name__ == "__main__":      T = int(sys.stdin.readline().strip())      for i in xrange(T):          values = map(int, sys.stdin.readline().strip().split(' '))          _N, S, p = values[0:3]          t = values[3:]          min_normal = p + 2 * max(0, p - 1)          min_surprising = p + 2 * max(0, p - 2)          cnt_normal = len(filter(lambda x : x >= min_normal, t))          cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal          print "Case #%d: %s" % (i + 1, cnt_normal + min(cnt_surprising, S))  <CODESPLIT> 11
import sys      def dw(a, b):      a = sorted(a)      b = sorted(b)      cnt = 0      k = 0      for i in a:          if b[k] < i:              cnt += 1              k += 1      return cnt      def w(a, b):      a = sorted(a, reverse=True)      b = sorted(b, reverse=True)      cnt = 0      k = 0      for i in a:          if i > b[k]:              cnt += 1          else:              k += 1      return cnt      def compute(a, b):      x = dw(a, b)      y = w(a, b)      return "%s %s" % (x, y)      def parse():      N = int(sys.stdin.readline().strip())      a = map(float, sys.stdin.readline().strip().split())      b = map(float, sys.stdin.readline().strip().split())      return a, b      if __name__ == "__main__":      sys.setrecursionlimit(100000)      T = int(sys.stdin.readline().strip())      for i in xrange(T):          data = parse()          result = compute(*data)          print "Case #%d: %s" % (i + 1, result)  <CODESPLIT> 11
import sys      def compute(N, M, a):      rows = [0] * N      cols = [0] * M      for r in xrange(N):          rows[r] = 0          for c in xrange(M):              if a[r][c] > rows[r]:                  rows[r] = a[r][c]      for c in xrange(M):          cols[c] = 0          for r in xrange(N):              if a[r][c] > cols[c]:                  cols[c] = a[r][c]      for r in xrange(N):          for c in xrange(M):              if a[r][c] < rows[r] and a[r][c] < cols[c]:                  return "NO"      return "YES"      def parse():      N, M = map(int, sys.stdin.readline().strip().split())      a = []      for i in xrange(N):          a.append(map(int, sys.stdin.readline().strip().split()))      return N, M, a,      if __name__ == "__main__":      sys.setrecursionlimit(100000)      T = int(sys.stdin.readline().strip())      count = 1      part = 0      if len(sys.argv) == 3:          part = int(sys.argv[1])          count = int(sys.argv[2])      for i in xrange(T):          data = parse()          if i * count >= part * T and i * count < (part + 1) * T:              result = compute(*data)              print "Case #%d: %s" % (i + 1, result)  <CODESPLIT> 11
import math  import sys      def compute(C, F, X):      k = int(math.floor(X / C - 2.0 / F))      if k <= 0:          return X / 2      total = 0.0      for i in xrange(k):          total += 1.0 / (2.0 + i * F)      return C * total + X / (2.0 + k * F)      def parse():      C, F, X = map(float, sys.stdin.readline().strip().split())      return C, F, X      if __name__ == "__main__":      sys.setrecursionlimit(100000)      T = int(sys.stdin.readline().strip())      for i in xrange(T):          data = parse()          result = compute(*data)          print "Case #%d: %0.7f" % (i + 1, result)  <CODESPLIT> 11
import sys      def compute(r1, m1, r2, m2):      valid1 = set(m1[r1 - 1])      valid2 = set(m2[r2 - 1])      valid = valid1 & valid2      if len(valid) == 0:          return 'Volunteer cheated!'      if len(valid) > 1:          return 'Bad magician!'      return valid.pop()      def parse_single():      r = int(sys.stdin.readline().strip())      m = []      for i in xrange(4):          m.append(map(int, sys.stdin.readline().strip().split()))      return r, m    def parse():      r1, m1 = parse_single()      r2, m2 = parse_single()      return r1, m1, r2, m2      if __name__ == "__main__":      sys.setrecursionlimit(100000)      T = int(sys.stdin.readline().strip())      for i in xrange(T):          data = parse()          result = compute(*data)          print "Case #%d: %s" % (i + 1, result)  <CODESPLIT> 11
import sys    mapping = {}    def init_mapping():      encoded = ["ejp mysljylc kd kxveddknmc re jsicpdrysi",              "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",              "de kr kd eoya kw aej tysr re ujdr lkgc jv",              "y qee z"              ]      decoded = ["our language is impossible to understand",              "there are twenty six factorial possibilities",              "so it is okay if you want to just give up",              "a zoo q"              ]      for i in xrange(len(encoded)):          for j in xrange(len(encoded[i])):              if encoded[i][j] in mapping and mapping[encoded[i][j]] != decoded[i][j]:                  raise Exception("Multiple mapping for %s" % encoded[i][j])              mapping[encoded[i][j]] = decoded[i][j]      def decode(sentence):      return ''.join(map(lambda x : mapping.get(x, x), sentence))      if __name__ == "__main__":      init_mapping()      T = int(sys.stdin.readline().strip())      for i in xrange(T):          result = decode(sys.stdin.readline().strip())          print "Case #%d: %s" % (i + 1, result)  <CODESPLIT> 11
import sys  import string      def won(board, mapping):      val = int(board.translate(string.maketrans(mapping, "1100")), 2)      for v in [0x000f, 0x00f0, 0x0f00, 0xf000,                0x1111, 0x2222, 0x4444, 0x8888,                0x1248, 0x8421]:          if (val & v) == v:              return True      return False      def finished(board):      return '.' not in board      def compute(board):      if won(board, 'XTO.'):          return "X won"      if won(board, 'OTX.'):          return "O won"      if finished(board):          return "Draw"      return "Game has not completed"      def parse():      board = []      for i in xrange(4):          board.append(sys.stdin.readline().strip())      sys.stdin.readline()      return (''.join(board),)      if __name__ == "__main__":      sys.setrecursionlimit(100000)      T = int(sys.stdin.readline().strip())      count = 1      part = 0      if len(sys.argv) == 3:          part = int(sys.argv[1])          count = int(sys.argv[2])      for i in xrange(T):          data = parse()          if i * count >= part * T and i * count < (part + 1) * T:              result = compute(*data)              print "Case #%d: %s" % (i + 1, result)  <CODESPLIT> 11
import sys      DX = (-1, -1, -1, 0, 1, 1, 1, 0)  DY = (-1, 0, 1, 1, 1, 0, -1, -1)      def compute(R, C, M):      if M == 0:          return empty(R, C)      free = R * C - M      if free == 1:          return single_free(R, C)      if R == 1:          return single_row(C, M)      if C == 1:          return single_column(R, M)      if R == 2:          return two_rows(C, M)      if C == 2:          return two_columns(R, M)      if free in (2,3,5,7):          return "\nImpossible"      return at_least_three(R, C, M)      def make_board(R, C, default='.'):      return [[default for j in xrange(C)] for i in xrange(R)]      def to_string(board):      s = ""      for i in xrange(len(board)):          s += '\n' + ''.join(board[i])      return s              def empty(R, C):      board = make_board(R, C)      board[0][0] = 'c'      return to_string(board)      def single_free(R, C):      board = make_board(R, C, default='*')      board[0][0] = 'c'      return to_string(board)      def single_row(C, M):      board = make_board(1, C)      board[0][0] = 'c'      for i in xrange(M):          board[0][C - 1 - i] = '*'      return to_string(board)      def single_column(R, M):      board = make_board(R, 1)      board[0][0] = 'c'      for i in xrange(M):          board[R - 1 - i][0] = '*'      return to_string(board)      def two_rows(C, M):      if M % 2 != 0:          return "\nImpossible"      if 2 * C - M < 4:          return "\nImpossible"      board = make_board(2, C)      for i in xrange(M / 2):          board[0][C - 1 - i] = '*'          board[1][C - 1 - i] = '*'      board[0][0] = 'c'      return to_string(board)      def two_columns(R, M):      if M % 2 != 0:          return "\nImpossible"      if 2 * R - M < 4:          return "\nImpossible"      board = make_board(R, 2)      for i in xrange(M / 2):          board[R - 1 - i][0] = '*'          board[R - 1 - i][1] = '*'      board[0][0] = 'c'      return to_string(board)      def finalize(R, C, M, board):      mines = 0      for i in xrange(R):          for j in xrange(C):              if board[i][j] == '0':                  continue              empty = False              for d in xrange(8):                  if i + DX[d] < 0 or i + DX[d] >= R or j + DY[d] < 0 or j + DY[d] >= C:                      continue                  if board[i + DX[d]][j + DY[d]] == '0':                      empty = True                      break              if empty:                  board[i][j] = '.'              else:                  board[i][j] = '*'                  mines += 1      for i in xrange(R):          for j in xrange(C):              if board[i][j] == '0':                  board[i][j] = '.'      board[0][0] = 'c'      if mines != M:          sys.stderr.write("mines:%s expected:%s\n" % (mines, M))      return to_string(board)      def at_least_three(R, C, M):      board = make_board(R, C)      board[0][0] = '0'      free = R * C - M      count = 4      if count == free:          return finalize(R, C, M, board)      board[0][1] = '0'      count += 2      if count == free:          return finalize(R, C, M, board)      board[1][0] = '0'      count += 2      if count == free:          return finalize(R, C, M, board)      for j in xrange(2, C - 1):          if count + 2 > free:              break          board[0][j] = '0'          count += 2      for i in xrange(2, R - 1):          if count + 2 > free:              break          board[i][0] = '0'          count += 2      for i in xrange(1, R - 1):          for j in xrange(1, C - 1):              if count == free:                  return finalize(R, C, M, board)              board[i][j] = '0'              count += 1      sys.stderr.write("empty board?\n")      return finalize(board)      def parse():      R, C, M = map(int, sys.stdin.readline().strip().split())      return R, C, M      if __name__ == "__main__":      sys.setrecursionlimit(100000)      T = int(sys.stdin.readline().strip())      for i in xrange(T):          sys.stderr.write("case:%s\n" % (i + 1))          data = parse()          result = compute(*data)          print "Case #%d: %s" % (i + 1, result)  <CODESPLIT> 11
import sys    MAX_LIMIT = 2000000      def get_min_mapped(n):      n_min = n      x = str(n)      for i in xrange(1, len(x)):          x = x[1:] + x[0]          if x[0] == '0':              continue          n_min = min(n_min, int(x))      return n_min      if __name__ == "__main__":      T = int(sys.stdin.readline().strip())      min_mapped = [0] * (MAX_LIMIT + 1)      for i in xrange(1, MAX_LIMIT + 1):          min_mapped[i] = get_min_mapped(i)        for r in xrange(T):          values = map(int, sys.stdin.readline().strip().split(' '))          A, B = values          cnt_mapped = [0] * (B + 1)          for i in xrange(A, B + 1):              cnt_mapped[min_mapped[i]] += 1          total = 0          for i in xrange(B + 1):              if cnt_mapped[i] > 1:                  total += (cnt_mapped[i] * (cnt_mapped[i] - 1)) / 2          print "Case #%d: %s" % (r + 1, total)  <CODESPLIT> 11
directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'      def is_palindrome (n):      l = list(str(n))      return list(reversed(l)) == l    def prepare ():      global fair_and_squares      fair_and_squares = []            for i in range(1,10**7):          if is_palindrome(i):              sqr = i**2              if is_palindrome(sqr):                  fair_and_squares.append(sqr)      return              def solve (f_in, f_out):      prepare()      T = int(f_in.readline())      for testcase in range(1,T+1):          A,B = [int(x) for x in f_in.readline().split()]          count = len([x for x in fair_and_squares if (x>=A and x<=B)])          f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\n')        def main_run():      import os      import time      filenames = [x for x in os.listdir (directory)]      filenames = [x for x in filenames if x.endswith('.in')]      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]      chosen_filename =  sorted(l1)[-1][1][:-3]        print ('Directory : ', directory)      print ('Chosen Filename : ',chosen_filename)      print()      print ('Start : ', time.ctime())      print()            f_in = open(directory+chosen_filename+'.in')      f_out = open(directory+chosen_filename+'.out', 'w')      solve(f_in,f_out)      f_in.close()      f_out.close()        print ()      print ('End : ', time.ctime())      main_run()  <CODESPLIT> 12
directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'      def solve (f_in, f_out):      T = int(f_in.readline())      print ('Test cases : ',T)      for i in range(1,T+1):          line = f_in.readline()          nnn = [int(x) for x in line.split()]          S = nnn[1]          p = nnn[2]          t = nnn[3:]          if p > 1:              A = 0              B = 0              for t_i in t:                  if t_i >=3*p-2:                      A += 1                  elif t_i >= 3*p-4:                      B += 1              result = A + min(B,S)          if p == 1:              result = len([x for x in t if x>=1])          if p == 0:              result=  len(t)          f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')                      def main_run():      import os      filenames = [x for x in os.listdir (directory)]      filenames = [x for x in filenames if x.endswith('.in')]      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]      chosen_filename =  sorted(l1)[-1][1][:-3]        print ('Directory : ', directory)      print ('Chosen Filename : ',chosen_filename)      print()      f_in = open(directory+chosen_filename+'.in')      f_out = open(directory+chosen_filename+'.out', 'w')      solve(f_in,f_out)      f_in.close()      f_out.close()          main_run()  <CODESPLIT> 12
directory = 'C:/users/me/desktop/google code jam/2014/qualification/D/'    from copy import deepcopy  import itertools      from random import choice    INCREASING = 501  DECREASING = 502  NO_ORDER = 503    def play_war (l_n, l_k, inc_val):      assert inc_val in [INCREASING, DECREASING, NO_ORDER]      assert len(l_n) == len(l_k)      if inc_val == INCREASING:          l_n = list(sorted(l_n))      if inc_val == DECREASING:          l_n = list(reversed(sorted(l_n)))      l_k = list(sorted(l_k))      naomi_wins = 0      for i in range(len(l_n)):          val = l_n[0]          l_n = l_n[1:]          if l_k[-1] < val:              l_k = l_k[1:]              naomi_wins += 1          else:              for j in range(len(l_k)):                  if l_k[j] > val:                      del l_k[j]                      break        return naomi_wins      def play_deceitful (l_n, l_k):      l_n = list(sorted(l_n))      l_k = list(sorted(l_k))      naomi_wins = 0      assert len(l_n) == len(l_k)      while len(l_n):          if l_n[-1] < l_k[-1]:              l_n = l_n[1:]              l_k = l_k[:-1]          else:              l_n = l_n[:-1]              l_k = l_k[:-1]              naomi_wins += 1      return naomi_wins                              def solve (f_in, f_out):      T = int(f_in.readline())      for testcase in range(1,T+1):          N = int(f_in.readline())          l_n = [float(x) for x in f_in.readline().split()]          l_k = [float(x) for x in f_in.readline().split()]            a1 = play_war (l_n, l_k, INCREASING)          a2 = play_war (l_n, l_k, DECREASING)          a3 = play_war (l_n, l_k, NO_ORDER)          assert a1 == a2          assert a2 == a3          b = play_deceitful (l_n, l_k)            f_out.write('Case #' + str(testcase) + ': ' + str(b) + ' ' + str(a1) + '\n')                                  def main_run():      import os      import time      filenames = [x for x in os.listdir (directory)]      filenames = [x for x in filenames if x.endswith('.in')]      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]      chosen_filename =  sorted(l1)[-1][1][:-3]        print ('Directory : ', directory)      print ('Chosen Filename : ',chosen_filename)      print()      print ('Start : ', time.ctime())      print()            f_in = open(directory+chosen_filename+'.in')      f_out = open(directory+chosen_filename+'.out', 'w')      solve(f_in,f_out)      f_in.close()      f_out.close()        print ()      print ('End : ', time.ctime())      main_run()    def randomize_arrs (n):      l = []      for i in range(2*n):          r = choice(range(2**30))          while r in l:              r = choice(range(2**30))          l.append(r)      return l[:n], l[n:]    <CODESPLIT> 12
directory = 'C:/users/hai/my projects/google code jam/2013/qualification/B/'      from copy import deepcopy    def solve (f_in, f_out):      T = int(f_in.readline())      for testcase in range(1,T+1):          print (testcase)          N,M = [int(x) for x in f_in.readline().split()]          sqr = []          for i in range(N):              sqr.append([int(x) for x in f_in.readline().split()])          res = get_result(sqr)          f_out.write('Case #' + str(testcase) + ': ' + res + '\n')      def get_result (sqr):      while len(sqr) > 1 and len(sqr[0]) > 1:          print (sqr)          r,c = 0,0          for row in range(len(sqr)):              for col in range(len(sqr[0])):                  if sqr[row][col] < sqr[r][c]:                      r,c = row, col          min_val = sqr[r][c]          whole_row = list(sqr[r])          whole_col = []          for row in range(len(sqr)):              whole_col.append(sqr[row][c])          assert min(whole_row) == min_val          assert min(whole_col) == min_val          if max(whole_row) == min_val:              sqr = remove_row(sqr,r)          elif max(whole_col) == min_val:              sqr = remove_col(sqr,c)          else:              return 'NO'        return 'YES'                  def remove_row (sqr, row):      cpy = deepcopy(sqr)      del cpy[row]      return cpy    def remove_col (sqr,col):      cpy = deepcopy(sqr)      for row in cpy:          del row[col]      return cpy            def main_run():      import os      import time      filenames = [x for x in os.listdir (directory)]      filenames = [x for x in filenames if x.endswith('.in')]      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]      chosen_filename =  sorted(l1)[-1][1][:-3]        print ('Directory : ', directory)      print ('Chosen Filename : ',chosen_filename)      print()      print ('Start : ', time.ctime())      print()            f_in = open(directory+chosen_filename+'.in')      f_out = open(directory+chosen_filename+'.out', 'w')      solve(f_in,f_out)      f_in.close()      f_out.close()        print ()      print ('End : ', time.ctime())      main_run()  <CODESPLIT> 12
directory = 'C:/users/me/desktop/google code jam/2014/qualification/B/'        def solve (f_in, f_out):      T = int(f_in.readline())      for testcase in range(1,T+1):          line = f_in.readline()          C,F,X = [float(q) for q in line.split()]          result = compute (C,F,X)          f_out.write('Case #' + str(testcase) + ': ' + str(result) + '\n')      def compute(C,F,X):      cps = 2      farms = 0      timespent = 0      while X / cps > C/cps + X/(cps+F):          farms += 1          timespent += C/cps          cps += F        return timespent + X/cps            def main_run():      import os      import time      filenames = [x for x in os.listdir (directory)]      filenames = [x for x in filenames if x.endswith('.in')]      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]      chosen_filename =  sorted(l1)[-1][1][:-3]        print ('Directory : ', directory)      print ('Chosen Filename : ',chosen_filename)      print()      print ('Start : ', time.ctime())      print()            f_in = open(directory+chosen_filename+'.in')      f_out = open(directory+chosen_filename+'.out', 'w')      solve(f_in,f_out)      f_in.close()      f_out.close()        print ()      print ('End : ', time.ctime())      main_run()  <CODESPLIT> 12
directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'        def solve (f_in, f_out):      T = int(f_in.readline())      for testcase in range(1,T+1):                    c1 = int(f_in.readline())          l1 = []          for i in range(4):              l1.append(f_in.readline())                    c2 = int(f_in.readline())          l2 = []          for i in range(4):              l2.append(f_in.readline())            d1 = l1[c1-1].split()          d2 = l2[c2-1].split()            foundFlag = False          chosenCard = None          badMagician = False          for card in d1:              if card in d2:                  if not foundFlag:                      foundFlag = True                      chosenCard = card                  else:                      badMagician = True            f_out.write('Case #' + str(testcase) + ': ')          if badMagician:              f_out.write('Bad magician!\n')          elif not foundFlag:              f_out.write('Volunteer cheated!\n')          else:              f_out.write(chosenCard + '\n')          def main_run():      import os      import time      filenames = [x for x in os.listdir (directory)]      filenames = [x for x in filenames if x.endswith('.in')]      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]      chosen_filename =  sorted(l1)[-1][1][:-3]        print ('Directory : ', directory)      print ('Chosen Filename : ',chosen_filename)      print()      print ('Start : ', time.ctime())      print()            f_in = open(directory+chosen_filename+'.in')      f_out = open(directory+chosen_filename+'.out', 'w')      solve(f_in,f_out)      f_in.close()      f_out.close()        print ()      print ('End : ', time.ctime())      main_run()  <CODESPLIT> 12
directory = 'C:/users/hai/my projects/google code jam/2012/qualification/A/'      t= '''ay  bh  ce  ds  eo  fc  gv  hx  id  ju  ki  lg  ml  nb  ok  pr  qz  rt  sn  tw  uj  vp  wf  xm  ya  zq'''    table = {}  for line in t.split():      table[line[0]] = line[1]    def translate (line):      l = list(line)      for i in range(len(l)):          if l[i] in table:              l[i] = table[l[i]]      return ''.join(l)    def solve (f_in, f_out):      T = int(f_in.readline())      for i in range(1,T+1):          line = f_in.readline()          out_line = translate(line)          f_out.write('Case #' + str(i) + ': ' + out_line)                      def main_run():      import os      filenames = [x for x in os.listdir (directory)]      filenames = [x for x in filenames if x.endswith('.in')]      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]      chosen_filename =  sorted(l1)[-1][1][:-3]        print ('Directory : ', directory)      print ('Chosen Filename : ',chosen_filename)      print()      f_in = open(directory+chosen_filename+'.in')      f_out = open(directory+chosen_filename+'.out', 'w')      solve(f_in,f_out)      f_in.close()      f_out.close()          main_run()  <CODESPLIT> 12
directory = 'C:/users/hai/my projects/google code jam/2013/qualification/A/'      def solve (f_in, f_out):      N = int(f_in.readline())      for testcase in range(1,N+1):          sqr = []          for i in range(4):              sqr.append(list(f_in.readline().split()[0]))          assert len(f_in.readline().split()) == 0            f_out.write('Case #' + str(testcase) + ': ' + get_square_winner(sqr) +'\n')          def get_all_lines(sqr):      lines = []      for line in sqr:          lines.append(list(line))      for column in range(4):          line = []          for row in range(4):              line.append(sqr[row][column])          lines.append(list(line))        diag1 = []      diag2 = []      for  i in range(4):          diag1.append(sqr[i][i])          diag2.append(sqr[i][3-i])      lines.append(diag1)      lines.append(diag2)        return lines        def get_square_winner (sqr):      for line in get_all_lines(sqr):          if get_line_winner (line):              return get_line_winner (line)        for row in sqr:          if '.' in row:              return "Game has not completed"      return "Draw"          def get_line_winner (line):      if line.count('X') == 4:          return "X won"      if line.count('X') == 3 and 'T' in line:          return "X won"            if line.count('O') == 4:          return "O won"      if line.count('O') == 3 and 'T' in line:          return "O won"          return None                def main_run():      import os      import time      filenames = [x for x in os.listdir (directory)]      filenames = [x for x in filenames if x.endswith('.in')]      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]      chosen_filename =  sorted(l1)[-1][1][:-3]        print ('Directory : ', directory)      print ('Chosen Filename : ',chosen_filename)      print()      print ('Start : ', time.ctime())      print()            f_in = open(directory+chosen_filename+'.in')      f_out = open(directory+chosen_filename+'.out', 'w')      solve(f_in,f_out)      f_in.close()      f_out.close()        print ()      print ('End : ', time.ctime())      main_run()  <CODESPLIT> 12
directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'    from copy import deepcopy  import itertools      def solve_one_case (R,C,M):          l = []          for i in range(R):              for j in range(C):                  l.append((i,j))            empty_mat = []          for i in range(R):              empty_mat.append(['.']*C)            found = False            assert (0,0) in l          l = l[1:]          l = l[::-1]          assert (0,0) not in l                    output = ''                    for mine_placement in itertools.combinations(l,M):              mat = deepcopy(empty_mat)              for cell in mine_placement:                  mat[cell[0]][cell[1]] = '*'              if isOneClick(mat, R, C, M):                  mat[0][0] = 'c'                  for line in mat:                      output += ''.join(line) + '\n'                  found = True                  return output                        if not found:              return 'Impossible\n'                    assert ValueError()            def solve (f_in, f_out):      T = int(f_in.readline())      for testcase in range(1,T+1):          line = f_in.readline()          R,C,M = [int(q) for q in line.split()]          print (testcase,R,C,M)            output = solve_one_case (R,C,M)          f_out.write('Case #' + str(testcase) + ':\n')          f_out.write(output)                  def isOneClick (mat, R, C, M):  ##    if mat[0][0] != '.':  ##        return False  ##    assert len(mat) == R  ##    lens = [len(l) for l in mat]  ##    assert min(lens) == C  ##    assert max(lens) == C  ##    assert sum([l.count('*') for l in mat]) == M        mat_cpy = deepcopy(mat)      oneclickcells = [(0,0)]      while oneclickcells:          node = oneclickcells.pop()          mat_cpy[node[0]][node[1]] = 'v'          if noNearbyMines(mat_cpy,node):              oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))        #print (mat_cpy)      return sum([l.count('.') for l in mat_cpy]) == 0          def getNearbyUnvisited(mat, node):      R = len(mat)      C = len(mat[0])      deltas_r = [0]      deltas_c = [0]      if node[0] > 0:          deltas_r.append(-1)      if node[1] > 0:          deltas_c.append(-1)      if node[0] < R-1:          deltas_r.append(1)      if node[1] < C-1:          deltas_c.append(1)        ret_list = []      for delta_r in deltas_r:          for delta_c in deltas_c:              next_node = (node[0]+delta_r, node[1] + delta_c)              if mat[next_node[0]][next_node[1]] not in ['*','v']:                  ret_list.append((next_node[0],next_node[1]))        return ret_list    def noNearbyMines(mat,node):      R = len(mat)      C = len(mat[0])      deltas_r = [0]      deltas_c = [0]      if node[0] > 0:          deltas_r.append(-1)      if node[1] > 0:          deltas_c.append(-1)      if node[0] < R-1:          deltas_r.append(1)      if node[1] < C-1:          deltas_c.append(1)        for delta_r in deltas_r:          for delta_c in deltas_c:              if mat[node[0] + delta_r][node[1] + delta_c] == '*':                  return False      return True        def main_run():      import os      import time      filenames = [x for x in os.listdir (directory)]      filenames = [x for x in filenames if x.endswith('.in')]      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]      chosen_filename =  sorted(l1)[-1][1][:-3]        print ('Directory : ', directory)      print ('Chosen Filename : ',chosen_filename)      print()      print ('Start : ', time.ctime())      print()            f_in = open(directory+chosen_filename+'.in')      f_out = open(directory+chosen_filename+'.out', 'w')      solve(f_in,f_out)      f_in.close()      f_out.close()        print ()      print ('End : ', time.ctime())      main_run()    ##bads = []  ##goods = []  ##  ##for R in range(1,6):  ##    for C in range(1,6):  ##        for M in range(1,R*C+1):  ##            print (R,C,M)  ##            output = solve_one_case (R,C,M)  ##            if output[0] == 'I':  ##                bads.append((R,C,M))  ##            else:  ##                goods.append((R,C,M))  ##  <CODESPLIT> 12
directory = 'C:/users/hai/my projects/google code jam/2012/qualification/C/'      def solve (f_in, f_out):      pre_calc = prepare()      T = int(f_in.readline())      for i in range(1,T+1):          A,B = [int(x) for x in f_in.readline().split()]          c = 0          for m in range(A,B+1):              c += len ([n for n in pre_calc[m] if n >=A])          f_out.write('Case #' + str(i) + ': ' + str(c) + '\n')              def prepare ():      l = [None]* 2000001      for n in range(1,2000001):          recycled = []          s = str(n)          for c in range(1, len(s)):              s2 = s[c:] + s[:c]              if s2[0] != '0':                  n2 = int(s2)                  if n2 < n and n2 not in recycled:                      recycled.append(n2)          #recycled.sort()          l [n] = recycled      return l      def main_run():      import os      import time      filenames = [x for x in os.listdir (directory)]      filenames = [x for x in filenames if x.endswith('.in')]      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]      chosen_filename =  sorted(l1)[-1][1][:-3]        print ('Directory : ', directory)      print ('Chosen Filename : ',chosen_filename)      print()      print ('Start : ', time.ctime())      print()            f_in = open(directory+chosen_filename+'.in')      f_out = open(directory+chosen_filename+'.out', 'w')      solve(f_in,f_out)      f_in.close()      f_out.close()        print ()      print ('End : ', time.ctime())      main_run()  <CODESPLIT> 12
'''  Created on 13 Apr 2013    @author: mengda  '''  import math    ls = []    def isP(num):      num = str(int(num))      for i in range(len(num) / 2):          if num[i] <> num[-1 - i]:              return False      return True    def createP(root, half_digits):      root = str(root)      for i in range(half_digits):          ls[i] = root[i]          ls[-1 - i] = root[i]      return int(''.join(ls))    def process(A, B):      rlt = 0      a = int(math.ceil(math.sqrt(A)))      b = int(math.floor(math.sqrt(B)))      str_a = str(a)      half_digits = int(math.ceil(len(str_a) / 2.0))      root = int(str_a[:half_digits])      next_root = 10 ** half_digits      digits = len(str_a)      for _ in range(digits - len(ls)):          ls.append('')      while True:          if root == next_root:              if digits % 2 == 0:                  next_root *= 10                  half_digits += 1              else:                  root /= 10              digits += 1              ls.append('')          p = createP(root, half_digits)          print p,          if p > b:              print 'too large'              break          if isP(math.pow(p, 2)):              print 'right one!'              rlt += 1          else:              print           root += 1      return rlt    def process1(A, B):      rlt = 0      a = int(math.ceil(math.sqrt(A)))      b = int(math.floor(math.sqrt(B)))      for i in range(a, b + 1):          if not isP(i):              continue          power = math.pow(i, 2)          if isP(power):              rlt += 1      return rlt    f = open('C-small-attempt1.in', 'r')  T = int(f.readline())  outLine = []    for i in range(1, T + 1):      (A, B) = map(int, f.readline().split())      outLine.append('Case #%d: %s\n' % (i, process1(A, B)))      print outLine[-1],    f.close()  outFile = open('C-S.out', 'w')  outFile.writelines(outLine)  outFile.close()  <CODESPLIT> 13
'''  Created on 2012-4-14    @author: hemnd  '''  def cal(args):      rslt = 0      N = int(args[0])      S = int(args[1])      p = int(args[2])      for i in range(N):          s = int(args[i + 3])          e = s / 3          r = s % 3          if e >= p:              rslt += 1          elif r == 1:              if e + 1 >= p:                  rslt += 1          elif r == 0:              if e == 0:                  continue              if S > 0 and e + 1 >= p:                  rslt += 1                  S -= 1          elif r == 2:              if e + 1 >= p:                  rslt += 1              elif S > 0 and e + 2 >= p:                  rslt += 1                  S -= 1      return rslt    inputFile = open('B-small-attempt0.in', 'r')  #inputFile = open('test.txt', 'r')  inputLines = inputFile.readlines()  inputFile.close()    T = int(inputLines[0])  outputLines = []    for i in range(1, T + 1):      args = inputLines[i].strip().split(' ')      outputLines.append('Case #%d: %d\n' % (i, cal(args)))      print outputLines[i - 1],    outputFile = open('B-small.out', 'w')  outputFile.writelines(outputLines)  outputFile.close()  <CODESPLIT> 13
#!/usr/bin/env python  import sys      def process(N, naomi, ken):  	pointer_n = pointer_k = 0  	score0 = 0  	score1 = N  	for i in range(N):  		if naomi[i] > ken[pointer_k]:  			score0 += 1  			pointer_k += 1  		if ken[i] > naomi[pointer_n]:  			score1 -= 1  			pointer_n +=1  	return str(score0) + ' ' + str(score1)    input_file = open(sys.argv[1], 'r')  T = int(input_file.readline())  for i in range(T):  	N = int(input_file.readline())  	naomi = sorted(map(float, input_file.readline().split()))  	ken = sorted(map(float, input_file.readline().split()))  	print 'Case #%d:' % (i + 1), process(N, naomi, ken)  <CODESPLIT> 13
'''  Created on 13 Apr 2013    @author: mengda  '''  expected = []    def process(N, M):      lawn = []      for n in range(N):          lawn.append([100] * M)      for n in range(N):          highest = 0          for m in range(M):              if expected[n][m] > highest:                  highest = expected[n][m]          for m in range(M):              if lawn[n][m] > highest:                  lawn[n][m] = highest      for m in range(M):          highest = 0          for n in range(N):              if expected[n][m] > highest:                  highest = expected[n][m]          for n in range(N):              if lawn[n][m] > highest:                  lawn[n][m] = highest      for n in range(N):          for m in range(M):              if lawn[n][m] <> expected[n][m]:                  return 'NO'      return 'YES'    f = open('B-small-attempt0.in', 'r')  T = int(f.readline())  outLine = []    for i in range(1, T + 1):      expected = []      (N, M) = map(int, f.readline().split())      for _ in range(N):          expected.append(map(int, f.readline().split()))      outLine.append('Case #%d: %s\n' % (i, process(N, M)))      print outLine[-1],    f.close()  outFile = open('b.s.out', 'w')  outFile.writelines(outLine)  outFile.close()  <CODESPLIT> 13
#!/usr/bin/env python  import sys      def process(C, F, X):  	speed = 2.0  	time = 0.0  	while True:  		if C / speed + X / (speed + F) > X / speed:  			time += X / speed  			break  		time += C / speed  		speed += F  	return round(time, 7)    input_file = open(sys.argv[1], 'r')  T = int(input_file.readline())  for i in range(T):  	(C, F, X) = map(float, input_file.readline().split())  	print 'Case #%d:' % (i + 1), process(C, F, X)  <CODESPLIT> 13
#!/usr/bin/env python  import sys      def process(chosen_row_1, arrange_1, chosen_row_2, arrange_2):  	rlt = 'Volunteer cheated!'  	found = False  	for i in arrange_1[chosen_row_1]:  		if i in arrange_2[chosen_row_2]:  			if not found:  				rlt = i  				found = True  			else:  				rlt = 'Bad magician!'  				break  	return rlt    input_file = open(sys.argv[1], 'r')  T = int(input_file.readline())  for i in range(T):  	chosen_row_1 = int(input_file.readline()) - 1  	arrange_1 = []  	arrange_1.append(map(int, input_file.readline().split()))  	arrange_1.append(map(int, input_file.readline().split()))  	arrange_1.append(map(int, input_file.readline().split()))  	arrange_1.append(map(int, input_file.readline().split()))  	chosen_row_2 = int(input_file.readline()) - 1  	arrange_2 = []  	arrange_2.append(map(int, input_file.readline().split()))  	arrange_2.append(map(int, input_file.readline().split()))  	arrange_2.append(map(int, input_file.readline().split()))  	arrange_2.append(map(int, input_file.readline().split()))  	print 'Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2)  <CODESPLIT> 13
'''  Created on 2012-4-14    @author: hemnd  '''  dict = {}  strs1 = ['our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up']  strs0 = ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv']    for i in range(3):      for j in range(len(strs1[i])):          c = strs0[i][j]          if c == ' ':              continue          e = strs1[i][j]          try:              dict[c]              print c, '=', dict[c], e          except:              dict[c] = e              print c, '=', e    for k in dict.keys():      print k, dict[k]        dict['q'] = 'z'  dict['z'] = 'q'  dict[' '] = ' '    def trans(s):      rslt = ''      for i in range(len(s) - 1):          rslt += dict[s[i]]      return rslt    #inputFile = open('A-small-practice.in', 'r')  inputFile = open('A-small-attempt0.in', 'r')  inputLines = inputFile.readlines()  inputFile.close()    N = int(inputLines[0])  outputLines = []    for i in range(1, N + 1):      outputLines.append('Case #%d: %s\n' % (i, trans(inputLines[i])))      print outputLines[i - 1],    outputFile = open('A-small-practice.out', 'w')  outputFile.writelines(outputLines)  outputFile.close()  <CODESPLIT> 13
'''  Created on 13 Apr 2013    @author: mengda  '''  board = []    def whoIsWinner(num):      if num == 4000 or num == 3010:          return 'X'      if num == 400 or num == 310:          return 'O'      return False    def process(board):      full = True      newboard = []      for i in range(4):          line = []          for j in range(4):              c = board[i][j]              if   c == 'X':                  line.append(1000)              elif c == 'O':                  line.append(100)              elif c == 'T':                  line.append(10)              elif c == '.':                  line.append(1)                  full = False          newboard.append(line)      board = newboard      for i in range(4):          sumH = 0          sumV = 0          for j in range(4):              sumH += board[i][j]              sumV += board[j][i]          winner = whoIsWinner(sumH)          if winner:              return winner + ' won'          winner = whoIsWinner(sumV)          if winner:              return winner + ' won'      sumD0 = board[0][0] + board[1][1] + board[2][2] + board[3][3]      winner = whoIsWinner(sumD0)      if winner:          return winner + ' won'      sumD1 = board[3][0] + board[2][1] + board[1][2] + board[0][3]      winner = whoIsWinner(sumD1)      if winner:          return winner + ' won'      if full:          return 'Draw'      return 'Game has not completed'    f = open('A-small-attempt0.in', 'r')  N = int(f.readline())  outLine = []    for i in range(1, N + 1):      board = []      for j in range(4):          board.append(f.readline())      outLine.append('Case #%d: %s\n' % (i, process(board)))      f.readline()      print outLine[-1],    f.close()  outFile = open('1.out', 'w')  outFile.writelines(outLine)  outFile.close()  <CODESPLIT> 13
#!/usr/bin/env python  import sys    def put_mines_last_step(R, C, M, grid):  	if M == 0:  		return  	R -= 1  	C -= 1  	grid[R][C] = '*'  	M -= 1  	r = R - 1  	c = C - 1  	while M > 0:  		if r > c:  			grid[r][C] = '*'  			r -= 1  		else:  			grid[R][c] = '*'  			c -= 1  		M -= 1    def put_mines(R, C, M, grid):  	if R > C:  		if M < C:  			put_mines_last_step(R, C, M, grid)  			return  		for i in range(C):  			grid[R - 1][i] = '*'  		put_mines(R - 1, C, M - C, grid)  		return  	if M < R:  		put_mines_last_step(R, C, M, grid)  		return  	for i in range(R):  		grid[i][C - 1] = '*'  	put_mines(R, C - 1, M - R, grid)  	return    def process(R, C, M):  	rlt = ''  	grid = []  	for i in range(R):  		grid.append(['.'] * C)  	put_mines(R, C, M, grid)  	if not C == 1:  		for i in range(R):  			if not grid[i][0] == '.':  				break  			if not grid[i][1] == '.':  				return '\nImpossible'  	if not R == 1:  		for i in range(C):  			if not grid[0][i] == '.':  				break  			if not grid[1][i] == '.':  				return '\nImpossible'  	grid[0][0] = 'c'  	for i in grid:  		rlt += '\n' + ''.join(i)  	return rlt    input_file = open(sys.argv[1], 'r')  T = int(input_file.readline())  for i in range(T):  	(R, C, M) = map(int, input_file.readline().split())  	print 'Case #%d:' % (i + 1), process(R, C, M)  <CODESPLIT> 13
'''  Created on 2012-4-14    @author: hemnd  '''  def cal(A, B):      rslt = 0      tmp = []      for i in range(1, len(A)):          min = max = 0          for j in range(int(A[0:i]), int(B[0:i]) + 1):              sJ = str(j)              sMin = (sJ * (len(A) - i))[0:len(A) - i]              min = int(sMin)              if int(sMin + sJ) <= int(sJ + sMin):                  min += 1              if int(B[-i:]) >= j:                  max = int(B[:(len(A) - i)])              else:                  max = int(B[:(len(A) - i)]) - 1              if max < min:                  continue              for k in range(min, max + 1):                  if (sJ + str(k), str(k) + sJ) in tmp:                      print (sJ + str(k), str(k) + sJ), 'already there'                      continue                  else:                      tmp.append((sJ + str(k), str(k) + sJ))                      rslt += 1    #            rslt = rslt + max - min + 1      return rslt    inputFile = open('C-small-attempt2.in', 'r')  #inputFile = open('test.txt', 'r')  inputLines = inputFile.readlines()  inputFile.close()    T = int(inputLines[0])  outputLines = []    for i in range(1, T + 1):      args = inputLines[i].strip().split(' ')      outputLines.append('Case #%d: %d\n' % (i, cal(args[0], args[1])))      print outputLines[i - 1],    outputFile = open('C-small.out', 'w')  outputFile.writelines(outputLines)  outputFile.close()  <CODESPLIT> 13
import sys  import bisect    N = 10**4    # [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]  # [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001, 100220141022001, 102012040210201, 102234363432201, 121000242000121, 121242363242121, 123212464212321, 123456787654321, 400000080000004, 10000000200000001, 10002000300020001, 10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, 10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, 10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, 12122232623222121, 12124434743442121, 12321024642012321, 12323244744232321, 12343456865434321, 12345678987654321, 40000000800000004, 40004000900040004, 1000000002000000001, 1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, 1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, 1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, 1232344458544432321, 1234323468643234321, 4000000008000000004, 100000000020000000001L, 100002000030000200001L, 100004000060000400001L, 100020201040102020001L, 100022201252102220001L, 100024201484102420001L, 100200120040021002001L, 100202122050221202001L, 100204124080421402001L, 100220341262143022001L, 100222343474343222001L, 102010002040200010201L, 102012022050220210201L, 102014042080240410201L, 102030405060504030201L, 102032425272524230201L, 102212122262221212201L, 102214144272441412201L, 102232545484545232201L, 102234567696765432201L, 121000000242000000121L, 121002200252002200121L, 121004400282004400121L, 121022221262122220121L, 121024421474124420121L, 121220122262221022121L, 121222324272423222121L, 121242363484363242121L, 121244565696565442121L, 123210002464200012321L, 123212222474222212321L, 123232425484524232321L, 123234645696546432321L, 123432124686421234321L, 123434346696643434321L, 400000000080000000004L, 400004000090000400004L, 10000000000200000000001L, 10000220001410002200001L, 10002002100400120020001L, 10002222123632122220001L, 10020010200400201002001L, 10020230421612403202001L, 10022014302620341022001L, 10022234545854543222001L, 10201000020402000010201L, 10201222221612222210201L, 10203022140604122030201L, 10203244363836344230201L, 10221210222622201212201L, 10221432643834623412201L, 10223234344844343232201L, 12100000002420000000121L, 12100242003630024200121L, 12102202302620320220121L, 12102444325852344420121L, 12122010222622201022121L, 12122252443834425222121L, 12124214524842541242121L, 12321000024642000012321L, 12321244225852244212321L, 12323222344844322232321L, 12343210246864201234321L, 40000000000800000000004L]  def isp(n):      s = str(n)      return s == s[::-1]    fs = []  for i in range(N):      s = str(i)      n1 = int(s + s[::-1])**2      n2 = int(s[:-1] + s[::-1])**2        if isp(n1):          fs.append(n1)      if isp(n2):          fs.append(n2)    fs.sort()    print(fs, file=sys.stderr)      fin = sys.stdin  T = int(fin.readline())  for case in range(1,T+1):      board = []      A, B = map(int, fin.readline().split())        i = bisect.bisect_left(fs, A)      j = bisect.bisect_right(fs, B)        print("Case #%d: %s" % (case, j-i))      <CODESPLIT> 14
# -*- coding: utf-8 -*-  import sys  fin = sys.stdin  T = int(fin.readline())  for case in range(1,T+1):      numbers = map(int, fin.readline().split())      N, S, p = numbers[:3]      T = numbers[3:]      normal_limit = p + 2*max(0, (p-1))      surpising_limit = p + 2*max(0, (p-2))        normal_count = 0      surprising_count = 0        for t in T:          if t >= normal_limit:              normal_count += 1          elif t >= surpising_limit:              surprising_count += 1        result = normal_count + min(surprising_count, S)        print "Case #%d: %s" % (case, result)    <CODESPLIT> 14
#!/usr/bin/env python3  # -*- coding: utf-8 -*-  # Uses https://github.com/rkistner/contest-algorithms    # Naomi and Ken sometimes play games together. Before they play, each of them gets N identical-looking blocks of wood with masses between 0.0kg and 1.0kg (exclusive). All of the blocks have different weights. There are lots of games they could play with those blocks, but they usually play something they call War. Here is how War works:    # Each player weighs each of his or her own blocks, so each player knows the weights of all of his or her own blocks, but not the weights of the other player's blocks.  # They repeat the following process N times:  # Naomi chooses one of her own blocks, with mass ChosenNaomi.  # Naomi tells Ken the mass of the block she chose.  # Ken chooses one of his own blocks, with mass ChosenKen.  # They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.  # Both blocks are destroyed in a fire.  # Naomi has realized three things about War. First, she has realized that she loses a lot. Second, she has realized that there is a unique strategy that Ken can follow to maximize his points without assuming anything about Naomi's strategy, and that Ken always uses it. Third, she has realized that she hates to lose. Naomi has decided that instead of playing War, she will play a game she calls Deceitful War. The great thing about Deceitful War is that Ken will think they're playing War!    # Here is how Deceitful War works, with differences between Deceitful War and War in bold:    # Each player weighs each of his or her own blocks. Naomi also weighs Ken's blocks while he isn't looking, so Naomi knows the weights of all blocks and Ken only knows the weights of his own blocks.  # They repeat the following process N times:  # Naomi chooses one of her own blocks, with mass ChosenNaomi.  # Naomi tells Ken a number, ToldNaomi, between 0.0kg and 1.0kg exclusive. Ken, who thinks they're playing War, thinks the number Naomi just told him is ChosenNaomi.  # Ken chooses one of his own blocks, with mass ChosenKen.  # They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.  # Both blocks are destroyed in a fire.  # Naomi doesn't want Ken to know that she isn't playing War; so when she is choosing which block to play, and what mass to tell Ken, she must make sure that the balance scale won't reveal that ChosenNaomi  ToldNaomi. In other words, she must make decisions so that:    # ChosenNaomi > ChosenKen if, and only if, ToldNaomi > ChosenKen, and  # ToldNaomi is not equal to the mass of any of Ken's blocks, because he knows that isn't possible.  # It might seem like Naomi won't win any extra points by being deceitful, because Ken might discover that she wasn't playing War; but Naomi knows Ken thinks both players are playing War, and she knows what he knows, and she knows Ken will always follow his unique optimal strategy for War, so she can always predict what he will play.    # You'll be given the masses of the blocks Naomi and Ken started with. Naomi will play Deceitful War optimally to gain the maximum number of points. Ken will play War optimally to gain the maximum number of points assuming that both players are playing War. What will Naomi's score be? What would it have been if she had played War optimally instead?    # Examples    # If each player has a single block left, where Naomi has 0.5kg and Ken has 0.6kg, then Ken is guaranteed to score the point. Naomi can't say her number is  0.6kg, or Ken will know she isn't playing War when the balance scale shows his block was heavier.    # If each player has two blocks left, where Naomi has [0.7kg, 0.2kg] and Ken has [0.8kg, 0.3kg], then Naomi could choose her 0.2kg block, and deceive Ken by telling him that she chose a block that was 0.6kg. Ken assumes Naomi is telling the truth (as in how the War game works) and will play his 0.8kg block to score a point. Ken was just deceived, but he will never realize it because the balance scale shows that his 0.8kg block is, like he expected, heavier than the block Naomi played. Now Naomi can play her 0.7kg block, tell Ken it is 0.7kg, and score a point. If Naomi had played War instead of Deceitful War, then Ken would have scored two points and Naomi would have scored zero.    # Input    # The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with a line containing a single integer N, the number of blocks each player has. Next follows a line containing N space-separated real numbers: the masses of Naomi's blocks, in kg. Finally there will be a line containing N space-separated real numbers: the masses of Ken's blocks, in kg.    # Each of the masses given to Ken and Naomi will be represented as a 0, followed by a decimal point, followed by 1-5 digits. Even though all the numbers in the input have 1-5 digits after the decimal point, Ken and Naomi don't know that; so Naomi can still tell Ken that she played a block with mass 0.5000001kg, and Ken has no reason not to believe her.    # Output    # For each test case, output one line containing "Case #x: y z", where x is the test case number (starting from 1), y is the number of points Naomi will score if she plays Deceitful War optimally, and z is the number of points Naomi will score if she plays War optimally.    # Limits    # 1  T  50.  # All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.  # Small dataset    # 1  N  10.  # Large dataset    # 1  N  1000.      import sys      def debug(*args):      print(*args, file=sys.stderr)    fin = sys.stdin  T = int(fin.readline())  for case in range(1, T + 1):      N = int(fin.readline())      numbers1 = list(map(float, fin.readline().split()))      numbers2 = list(map(float, fin.readline().split()))        numbers1.sort(reverse=True)      numbers2.sort()        # Normal      naomi = 0      remaining = numbers2[:]      for n in numbers1:          lost = False          for i, r in enumerate(remaining):              if r > n:                  del remaining[i]                  lost = True                  break          if not lost:              naomi += 1        cheat = 0      remaining = numbers2[:]      numbers1.sort()      # debug(numbers1)      # debug(remaining)      while numbers1:          n = numbers1[0]          if n > remaining[0]:              cheat += 1              del remaining[0]              del numbers1[0]          else:              del remaining[-1]              del numbers1[0]        print("Case #%d: %d %d" % (case, cheat, naomi))    <CODESPLIT> 14
  import sys  fin = sys.stdin  T = int(fin.readline())  for case in range(1,T+1):      board = []      N, M = map(int, fin.readline().split())      for i in range(N):          board.append(list(map(int, fin.readline().split())))            row_min = [100]*N      row_max = [0]*N      col_min = [100]*M      col_max = [0]*M        for i in range(N):          for j in range(M):              v = board[i][j]              row_min[i] = min(v, row_min[i])              row_max[i] = max(v, row_max[i])              col_min[j] = min(v, col_min[j])              col_max[j] = max(v, col_max[j])          possible = True      for i in range(N):          for j in range(M):              v = board[i][j]              if v != row_max[i] and v != col_max[j]:                  possible = False                  break          print("Case #%d: %s" % (case, possible and "YES" or "NO"))        <CODESPLIT> 14
#!/usr/bin/env python3  # -*- coding: utf-8 -*-  # Uses https://github.com/rkistner/contest-algorithms    # Cookie Clicker is a Javascript game by Orteil, where players click on a picture of a giant cookie. Clicking on the giant cookie gives them cookies. They can spend those cookies to buy buildings. Those buildings help them get even more cookies. Like this problem, the game is very cookie-focused. This problem has a similar idea, but it does not assume you have played Cookie Clicker. Please don't go play it now: it might be a long time before you come back.    # Problem    # In this problem, you start with 0 cookies. You gain cookies at a rate of 2 cookies per second, by clicking on a giant cookie. Any time you have at least C cookies, you can buy a cookie farm. Every time you buy a cookie farm, it costs you C cookies and gives you an extra F cookies per second.    # Once you have X cookies that you haven't spent on farms, you win! Figure out how long it will take you to win if you use the best possible strategy.    # Example    # Suppose C=500.0, F=4.0 and X=2000.0. Here's how the best possible strategy plays out:    # You start with 0 cookies, but producing 2 cookies per second.  # After 250 seconds, you will have C=500 cookies and can buy a farm that produces F=4 cookies per second.  # After buying the farm, you have 0 cookies, and your total cookie production is 6 cookies per second.  # The next farm will cost 500 cookies, which you can buy after about 83.3333333 seconds.  # After buying your second farm, you have 0 cookies, and your total cookie production is 10 cookies per second.  # Another farm will cost 500 cookies, which you can buy after 50 seconds.  # After buying your third farm, you have 0 cookies, and your total cookie production is 14 cookies per second.  # Another farm would cost 500 cookies, but it actually makes sense not to buy it: instead you can just wait until you have X=2000 cookies, which takes about 142.8571429 seconds.  # Total time: 250 + 83.3333333 + 50 + 142.8571429 = 526.1904762 seconds.  # Notice that you get cookies continuously: so 0.1 seconds after the game starts you'll have 0.2 cookies, and  seconds after the game starts you'll have 2 cookies.    # Input    # The first line of the input gives the number of test cases, T. T lines follow. Each line contains three space-separated real-valued numbers: C, F and X, whose meanings are described earlier in the problem statement.    # C, F and X will each consist of at least 1 digit followed by 1 decimal point followed by from 1 to 5 digits. There will be no leading zeroes.    # Output    # For each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1) and y is the minimum number of seconds it takes before you can have X delicious cookies.      # Limits    # 1  T  100.    # Small dataset    # 1  C  500.  # 1  F  4.  # 1  X  2000.  # Large dataset    # 1  C  10000.  # 1  F  100.  # 1  X  100000.    import sys      def debug(*args):      print(*args, file=sys.stderr)    fin = sys.stdin  T = int(fin.readline())  for case in range(1, T + 1):      C, F, X = map(float, fin.readline().split())          rate = 2      time = 0        best = 10**20        while time < best:          result = X / rate + time          if result < best:              best = result          time += C / rate          rate += F            print("Case #%d: %.7f" % (case, best))    <CODESPLIT> 14
#!/usr/bin/env python3  # -*- coding: utf-8 -*-  # Uses https://github.com/rkistner/contest-algorithms    # Recently you went to a magic show. You were very impressed by one of the tricks, so you decided to try to figure out the secret behind it!    # The magician starts by arranging 16 cards in a square grid: 4 rows of cards, with 4 cards in each row. Each card has a different number from 1 to 16 written on the side that is showing. Next, the magician asks a volunteer to choose a card, and to tell him which row that card is in.    # Finally, the magician arranges the 16 cards in a square grid again, possibly in a different order. Once again, he asks the volunteer which row her card is in. With only the answers to these two questions, the magician then correctly determines which card the volunteer chose. Amazing, right?    # You decide to write a program to help you understand the magician's technique. The program will be given the two arrangements of the cards, and the volunteer's answers to the two questions: the row number of the selected card in the first arrangement, and the row number of the selected card in the second arrangement. The rows are numbered 1 to 4 from top to bottom.    # Your program should determine which card the volunteer chose; or if there is more than one card the volunteer might have chosen (the magician did a bad job); or if there's no card consistent with the volunteer's answers (the volunteer cheated).    # Solving this problem    # Usually, Google Code Jam problems have 1 Small input and 1 Large input. This problem has only 1 Small input. Once you have solved the Small input, you have finished solving this problem.    # Input    # The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with a line containing an integer: the answer to the first question. The next 4 lines represent the first arrangement of the cards: each contains 4 integers, separated by a single space. The next line contains the answer to the second question, and the following four lines contain the second arrangement in the same format.    # Output    # For each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1).    # If there is a single card the volunteer could have chosen, y should be the number on the card. If there are multiple cards the volunteer could have chosen, y should be "Bad magician!", without the quotes. If there are no cards consistent with the volunteer's answers, y should be "Volunteer cheated!", without the quotes. The text needs to be exactly right, so consider copying/pasting it from here.    # Limits    # 1  T  100.  # 1  both answers  4.  # Each number from 1 to 16 will appear exactly once in each arrangement.      import sys      def debug(*args):      print(*args, file=sys.stderr)    fin = sys.stdin  T = int(fin.readline())  for case in range(1, T + 1):      answer1 = int(fin.readline())      rows1 = []      for i in range(4):          rows1.append(set(map(int, fin.readline().split())))      answer2 = int(fin.readline())      rows2 = []      for i in range(4):          rows2.append(set(map(int, fin.readline().split())))        possibilities1 = rows1[answer1-1]      possibilities2 = rows2[answer2-1]        numbers = possibilities1.intersection(possibilities2)      result = None      if len(numbers) == 1:          result = list(numbers)[0]      elif len(numbers) == 0:          result = 'Volunteer cheated!'      else:          result = 'Bad magician!'          print("Case #%d: %s" % (case, result))    <CODESPLIT> 14
# -*- coding: utf-8 -*-  import sys    input = """ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jv"""    output = """our language is impossible to understand  there are twenty six factorial possibilities  so it is okay if you want to just give up"""    mapping = {'a': 'y', 'o': 'e', 'z': 'q', 'q': 'z'}    for i, c in enumerate(input):      mapping[c] = output[i]      fin = sys.stdin  T = int(fin.readline())  for case in range(1,T+1):      line = fin.readline().strip()        result = ""      for c in line:          result += mapping[c]  #    N, M = map(int, fin.readline().split())        print "Case #%d: %s" % (case, result)    <CODESPLIT> 14
  import sys  fin = sys.stdin  T = int(fin.readline())  for case in range(1,T+1):      board = []      for i in range(4):          row = list(fin.readline().strip())          board.append(row)        fin.readline()        rows = [[], [], [], []]      cols = [[], [], [], []]      diags = [[], []]        for i in range(4):          for j in range(4):              v = board[i][j]              rows[i].append(v)              cols[j].append(v)              if i == j:                  diags[0].append(v)              if i + j == 3:                  diags[1].append(v)        buckets = rows + cols + diags      result = 'Draw'      filled = True      for bucket in buckets:          d = {'T': 0, 'X': 0, 'O': 0, '.': 0}          for v in bucket:              d[v] += 1          if d['T'] + d['X'] == 4:              result = 'X won'              break          if d['T'] + d['O'] == 4:              result = 'O won'              break          if d['.'] > 0:              result = 'Game has not completed'        print("Case #%d: %s" % (case, result))        <CODESPLIT> 14
#!/usr/bin/env python3  # -*- coding: utf-8 -*-  # Uses https://github.com/rkistner/contest-algorithms    # Minesweeper is a computer game that became popular in the 1980s, and is still included in some versions of the Microsoft Windows operating system. This problem has a similar idea, but it does not assume you have played Minesweeper.    # In this problem, you are playing a game on a grid of identical cells. The content of each cell is initially hidden. There are M mines hidden in M different cells of the grid. No other cells contain mines. You may click on any cell to reveal it. If the revealed cell contains a mine, then the game is over, and you lose. Otherwise, the revealed cell will contain a digit between 0 and 8, inclusive, which corresponds to the number of neighboring cells that contain mines. Two cells are neighbors if they share a corner or an edge. Additionally, if the revealed cell contains a 0, then all of the neighbors of the revealed cell are automatically revealed as well, recursively. When all the cells that don't contain mines have been revealed, the game ends, and you win.    # For example, an initial configuration of the board may look like this ('*' denotes a mine, and 'c' is the first clicked cell):    # *..*...**.  # ....*.....  # ..c..*....  # ........*.  # ..........  # There are no mines adjacent to the clicked cell, so when it is revealed, it becomes a 0, and its 8 adjacent cells are revealed as well. This process continues, resulting in the following board:  # *..*...**.  # 1112*.....  # 00012*....  # 00001111*.  # 00000001..  # At this point, there are still un-revealed cells that do not contain mines (denoted by '.' characters), so the player has to click again in order to continue the game.  # You want to win the game as quickly as possible. There is nothing quicker than winning in one click. Given the size of the board (R x C) and the number of hidden mines M, is it possible (however unlikely) to win in one click? You may choose where you click. If it is possible, then print any valid mine configuration and the coordinates of your click, following the specifications in the Output section. Otherwise, print "Impossible".    # Input    # The first line of the input gives the number of test cases, T. T lines follow. Each line contains three space-separated integers: R, C, and M.    # Output    # For each test case, output a line containing "Case #x:", where x is the test case number (starting from 1). On the following R lines, output the board configuration with C characters per line, using '.' to represent an empty cell, '*' to represent a cell that contains a mine, and 'c' to represent the clicked cell.    # If there is no possible configuration, then instead of the grid, output a line with "Impossible" instead. If there are multiple possible configurations, output any one of them.    # Limits    # 0  M < R * C.  # Small dataset    # 1  T  230.  # 1  R, C  5.  # Large dataset    # 1  T  140.  # 1  R, C  50.         import sys      def debug(*args):      print(*args, file=sys.stderr)    fin = sys.stdin  T = int(fin.readline())  for case in range(1, T + 1):      RR, CC, M = map(int, fin.readline().split())      R, C = None, None      blocks = RR*CC - M      inverse = False      if RR > CC:          inverse = True          R, C = CC, RR      else:          R, C = RR, CC      result = None      # Now R <= C      if R == 1:          # Always possible          result = [('.' * blocks) + ('*' * M)]      elif R == 2:          # Possible if blocks == 1 or blocks % 2 == 0          if blocks == 1:              result = ['.' + ('*' * (C-1)), '*' * C]          elif blocks % 2 == 0 and blocks != 2:              cc = blocks // 2              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))]           else:              result = None      else:          if blocks == 1:              result = ['*' * C] * R          elif blocks == 4:              result = ['..' + (C-2)*'*']*2              result += ['*'*C] * (R-2)          elif blocks == 6:              result = ['...' + (C-3)*'*']*2              result += ['*'*C] * (R-2)          for rows in range(3, R+1):              for columns in range(rows, C+1):                  size = rows * columns                  if size - blocks >= 0:                      if size - blocks <= columns - 2:                           result = []                          for r in range(rows):                              if r < rows - 1:                                  result.append(('.' * columns) + ('*' * (C - columns)))                              else:                                  cc = columns - (size - blocks)                                  result.append(('.' * cc) + ('*' * (C - cc)))                          for r in range(R - rows):                              result.append('*' * C)                      elif size - blocks == columns - 1 and rows >= 4:                          result = []                          for r in range(rows):                              if r < rows - 2:                                  result.append(('.' * columns) + ('*' * (C - columns)))                              elif r == rows - 2:                                  cc = columns - 1                                  result.append(('.' * cc) + ('*' * (C - cc)))                              else:                                  cc = 2                                  result.append(('.' * cc) + ('*' * (C - cc)))                          for r in range(R - rows):                              result.append('*' * C)                                  print("Case #%d: " % (case))      if result is None:          debug('impossible', blocks, RR, CC)          print("Impossible")      else:          mines = 0          for r in range(RR):              row = ''              for c in range(CC):                  rr, cc = r, c                  if inverse:                      rr, cc = c, r                  if rr == 0 and cc == 0:                      row += 'c'                  else:                      row += result[rr][cc]                      if result[rr][cc] == '*':                          mines += 1              print(row)          if mines != M:              raise Exception("%d != %d %d x %d" % (mines, M, RR, CC))                    <CODESPLIT> 14
# -*- coding: utf-8 -*-  import sys  fin = sys.stdin  T = int(fin.readline())  for case in range(1,T+1):      A, B = map(int, fin.readline().split())        total = 0        for i in range(A, B+1):          n = str(i)          pairs = set()          for shift in range(1, len(n)):              m = n[shift:] + n[:shift]              j = int(m)              if j > i and j <= B:                  pairs.add(m)          total += len(pairs)          print "Case #%d: %s" % (case, total)    <CODESPLIT> 14
# -*- coding: utf-8 -*-    import sys    def is_palindrome(num):      s1 = str(num)      s2 = s1[::-1]      return s1 == s2    fair_numbers = []  for i in range(pow(10, 7)+1):      if is_palindrome(i):          num = i*i          if is_palindrome(num):              fair_numbers.append(num)    N = int(sys.stdin.readline())  for T in range(1, N+1):      min_val, max_val = map(int, sys.stdin.readline().strip().split())        ans = 0      for num in fair_numbers:          if num < min_val:              continue          if num > max_val:              break          ans += 1      print 'Case #%(T)s: %(ans)s' % locals()  <CODESPLIT> 15
#!/usr/bin/python  # -*- coding: utf-8 -*-    import sys    for i, line in enumerate(sys.stdin):      if i == 0:          continue        params = [int(n) for n in line.split(' ')]      (N, S, p) = params[:3]      scores = params[3:]        (clear, possible) = (0, 0)      normal_min = max(p * 3 - 2, 0)      suprising_min = max(p * 3 - 4, 0)      for score in scores:          if p > score:              continue          elif score >= normal_min:              clear += 1          elif score >= suprising_min:              possible += 1        ans = clear + min(possible, S)      print 'Case #%(i)s: %(ans)s' % locals()  <CODESPLIT> 15
# -*- coding: utf-8 -*-    import sys  import copy    T = int(sys.stdin.readline())    for T in range(1, T+1):      N = int(sys.stdin.readline())      naomi_blocks = map(float, sys.stdin.readline().split(' '))      ken_blocks = map(float, sys.stdin.readline().split(' '))        # # War      naomi_blocks_w = sorted(copy.deepcopy(naomi_blocks))      ken_blocks_w = sorted(copy.deepcopy(ken_blocks))      naomi_score_w, ken_score_w = (0, 0)      for i in range(N):          naomi = naomi_blocks_w.pop()            ken = None          for k in ken_blocks_w:              if k > naomi:                  ken = k                  break          if not ken:              ken = ken_blocks_w[0]          ken_blocks_w.remove(ken)            if naomi > ken:              naomi_score_w += 1          else:              ken_score_w += 1            # Deceitful War          naomi_blocks_dw = sorted(copy.deepcopy(naomi_blocks), reverse=True)      ken_blocks_dw = sorted(copy.deepcopy(ken_blocks))      naomi_score_dw, ken_score_dw = (0, 0)      for i in range(N):          naomi = naomi_blocks_dw.pop()          ken = min(ken_blocks_dw)          if ken > naomi:              ken = max(ken_blocks_dw)          ken_blocks_dw.remove(ken)                      if naomi > ken:              naomi_score_dw += 1          else:              ken_score_dw += 1            ans = '%s %s' % (naomi_score_dw, naomi_score_w)      print 'Case #%(T)s: %(ans)s' % locals()  <CODESPLIT> 15
# -*- coding: utf-8 -*-    import sys  import copy    def next_pos(grass, goal, elems):      while elems:          val = elems[0]          for n in range(len(goal)):              for m in range(len(goal[0])):                  if goal[n][m] == val and goal[n][m] < grass[n][m]:                      return (n, m)          elems.remove(val)      return None    def check(grass, goal):      possible = True      completed = True      for n in range(len(grass)):          for m in range(len(grass[0])):              if grass[n][m] > goal[n][m]:                  completed = False              elif grass[n][m] < goal[n][m]:                  possible = False        return possible, completed    def cut(grass, goal, pos, h, elems):            def _cut(grass, goal, pos, h, is_horizontal):          if is_horizontal:              for m in range(len(grass[0])):                  grass[pos[0]][m] = h          else:              for n in range(len(grass)):                  grass[n][pos[1]] = h          possible, completed = check(grass, goal)          if completed and possible:              return 'YES'          elif not completed and possible:              pos = next_pos(grass, goal, elems)              if not pos:                  return 'NO'              h = goal[pos[0]][pos[1]]              return cut(grass, goal, pos, h, elems)          elif not possible:              return 'NO'        ans1 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=True)      if ans1 == 'YES':          return 'YES'      ans2 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=False)      if ans2 == 'YES':          return 'YES'      return 'NO'      def calc(grass, goal):      def _elems(goal):          elems = set()          for n in range(len(goal)):              for m in range(len(goal[0])):                  elems.add(goal[n][m])          return sorted(list(elems), reverse=True)        elems = _elems(goal)      pos = next_pos(grass, goal, elems)      h = goal[pos[0]][pos[1]]      return cut(grass, goal, pos, h, elems)      N = int(sys.stdin.readline())  for T in range(1, N+1):      N, M = map(int, sys.stdin.readline().strip().split())        goal = []      for i in range(N):          goal.append(map(int, sys.stdin.readline().strip().split()))        grass = []      for i in range(N):          line = [100] * M          grass.append(line)        ans = calc(grass, goal)      print 'Case #%(T)s: %(ans)s' % locals()  <CODESPLIT> 15
# -*- coding: utf-8 -*-    import sys    N = int(sys.stdin.readline())    for T in range(1, N+1):      C, F, X = map(float, sys.stdin.readline().split(' '))        # find N      N = 0      for i in range(int(X)):          diff = (2 + F * i) * C - F * X          if diff >= 0: break          N = i        # calc seconds      total = 0      for i in range(N):          val = C / (2 + i * F)          total += val      val = X / (2.0 + N * F)      total += val                ans = '%s' % (total)      print 'Case #%(T)s: %(ans)s' % locals()  <CODESPLIT> 15
# -*- coding: utf-8 -*-    import sys    N = int(sys.stdin.readline())    for T in range(1, N+1):      first_ans = int(sys.stdin.readline())      first_grid = []      for i in range(4):          row = [int(v) for v in sys.stdin.readline().split(' ')]          first_grid.append(row)      first_list = set(first_grid[first_ans-1])            second_ans = int(sys.stdin.readline())      second_grid = []      for i in range(4):          row = [int(v) for v in sys.stdin.readline().split(' ')]          second_grid.append(row)      second_list = set(second_grid[second_ans-1])        intersection = first_list.intersection(second_list)        if len(intersection) == 1:          ans = intersection.pop()      elif len(intersection) == 0:          ans = 'Volunteer cheated!'      else:          ans = 'Bad magician!'        print 'Case #%(T)s: %(ans)s' % locals()  <CODESPLIT> 15
#!/usr/bin/python  # -*- coding: utf-8 -*-    import sys    alphabet = 'abcdefghijklmnopqrstuvwxyz'  gog = 'ejp mysljylc kd kxveddknmc re jsicpdrysi' + \        'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' + \        'de kr kd eoya kw aej tysr re ujdr lkgc jv' + \        'y qee'    eng = 'our language is impossible to understand' + \        'there are twenty six factorial possibilities' + \        'so it is okay if you want to just give up' + \        'a zoo'    rule = {}  for i, c in enumerate(gog):     rule[c] = eng[i]    gog_alphabet = rule.keys()  eng_alphabet = rule.values()  missing_key = None  missing_val = None  for c in alphabet:      if not c in gog_alphabet:          missing_key = c      if not c in eng_alphabet:          missing_val = c  rule[missing_key] = missing_val    for i, line in enumerate(sys.stdin):      if i == 0:          continue        orig = line.strip()      ans = ''.join([rule[c] for c in orig])      print 'Case #%(i)s: %(ans)s' % locals()    <CODESPLIT> 15
# -*- coding: utf-8 -*-    import sys    N = int(sys.stdin.readline())    for T in range(1, N+1):      lines = []      completed = True      for i in range(4):          line = sys.stdin.readline().strip()          if '.' in line:              completed = False          lines.append(line)      sys.stdin.readline() # empty line        ans = 'Draw' if completed else 'Game has not completed'      # horizontal      for row in range(4):          X, O = 0, 0          for col in range(4):              spot = lines[row][col]              if spot == 'O':                  O += 1              elif spot == 'X':                  X += 1              if spot == 'T':                  O += 1                  X += 1          if X == 4:              ans = 'X won'          elif O == 4:              ans = 'O won'        # vertical      for col in range(4):          X, O = 0, 0          for row in range(4):              spot = lines[row][col]              if spot == 'O':                  O += 1              elif spot == 'X':                  X += 1              if spot == 'T':                  O += 1                  X += 1          if X == 4:              ans = 'X won'          elif O == 4:              ans = 'O won'        # diagonal      X1, X2, O1, O2 = 0, 0, 0, 0      for i in range(4):          spot1 = lines[i][i]          spot2 = lines[4-i-1][i]            if spot1 == 'O':              O1 += 1          elif spot1 == 'X':              X1 += 1          elif spot1 == 'T':              O1 += 1              X1 += 1            if spot2 == 'O':              O2 += 1          elif spot2 == 'X':              X2 += 1          elif spot2 == 'T':              O2 += 1              X2 += 1        if X1 == 4 or X2 == 4:          ans = 'X won'      elif O1 == 4 or O2 == 4:          ans = 'O won'                  print 'Case #%(T)s: %(ans)s' % locals()  <CODESPLIT> 15
# -*- coding: utf-8 -*-    import sys      def show_board(board):      for row in board:          print ''.join(row)      N = int(sys.stdin.readline())    for T in range(1, N+1):      (R, C, M) = map(int, sys.stdin.readline().split(' '))      E = R*C-M # empty      possible, reverse, need_adjust, column_base = (False, False, False, False)      if C > R:          (R, C) = (C, R)          reverse = True        #      # judgement      #      W = 0      lastRow = 0      if E == 0:          pass      elif E == 1 or M == 0:          W = C          possible = True      elif C == 1:          W = 1          if E > 0:              possible = True      elif C == 2:          W = 2          lastRow = int(E / 2) + 1   # 1 base          if E % 2 == 0 and E >= 4:              possible = True      elif C >= 3:          for w in range(2, C+1):              lastRow = int(E / w) + 1   # 1 base              if lastRow > R: continue              lastRowNum = E % w                            if lastRow == 2 and lastRowNum == 0:                  pass              elif lastRow == 2:   # lastRow == 1 => impossible                  if lastRowNum == 0:                      W = w                      possible = True                      break              elif lastRow >= 3:                  if lastRowNum >= 2 or lastRowNum == 0:                      W = w                      possible = True                      break                  elif C >= 4 and lastRowNum == 1 and R >= 3:                      W = w                      possible = True                      need_adjust = True                      break          if not possible:              for w in range(2, R+1):                  lastRow = int(E / w) + 1   # 1 base                  if lastRow > R: continue                  lastRowNum = E % w                  if lastRow == 2 and lastRowNum == 0:                      pass                  elif lastRow == 2:   # lastRow == 1 => impossible                      if lastRowNum == 0:                          W = w                          possible = True                          column_base = True                          break                  elif lastRow >= 3:                      if lastRowNum >= 2 or lastRowNum == 0:                          W = w                          possible = True                          column_base = True                          break                      elif C >= 4 and lastRowNum == 1 and R >= 3:                          W = w                          possible = True                          need_adjust = True                          column_base = True                          break                                        if not possible:          if reverse:              R, C = (C, R)                  ans = 'Impossible %sx%s M=%s' % (R, C, M)          # ans = 'Impossible'          print 'Case #%(T)s: %(ans)s' % locals()          continue        #      # make board      #      board = [['*'] * C for i in range(R)]      for i in range(E):          if not column_base:              c = i % W              r = i / W          else:              r = i % W              c = i / W                      board[r][c] = '.'      if need_adjust:          board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]      if reverse:          board = map(list, zip(*board))          R, C = (C, R)        clicked = False      for r in range(R):          if clicked: break          for c in range(C):              cell = board[r][c]              if cell != '.': continue              if E == 1:                  board[r][c] = 'c'                  clicked = True                  break                            if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue              if r >= 1              and board[r-1][c]   == '*': continue              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue              if             c >= 1  and board[r][c-1]   == '*': continue              if             c < C-1 and board[r][c+1]   == '*': continue              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue              if r < R-1             and board[r+1][c]   == '*': continue              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue              board[r][c] = 'c'              clicked = True              break        #      # show answer      #      ans = 'Possible' if possible else 'Impossible'      print 'Case #%(T)s:' % locals()      show_board(board)  <CODESPLIT> 15
#!/usr/bin/python  # -*- coding: utf-8 -*-    import sys    def recycled_numbers(num):      result = []      num_text = str(num)      for i in range(1, len(num_text)):          rotated = int(num_text[i:] + num_text[:i])          if num != rotated:              result.append(rotated)      return result    for T, line in enumerate(sys.stdin):      if T == 0:          continue        results = []      params = [int(n) for n in line.split(' ')]      (A, B) = params      for i in range(A, B):          candidates = recycled_numbers(i)          for c in candidates:              pair = (i, c)              if pair not in results and A <= c and c <= B and i < c:                  results.append(pair)      # print results      ans = len(results)      print 'Case #%(T)s: %(ans)s' % locals()  <CODESPLIT> 15
import sys  import numpy as np    def isPalindrome(x):      x = str(x)      if x[0] != x[-1]:          return 0      y = x[::-1]      if x == y:          return 1      return 0    def generate():      digits = [str(x) for x in range(0,10)]      dplus = digits + [""]        for x in range(1,10):          y = x**2          if isPalindrome(y):              print y        for x in range(1,10**4):          x = str(x)          y = x[::-1]          pals = [ int(x+z+y)**2 for z in dplus ]          for p in pals:              if isPalindrome(p):                  print p    if __name__ == "__main__":      #generate()      #break      f = open( sys.argv[1] )      sqpals = np.array([int(l) for l in f])      sqpals.sort()      f.close()        f = open( sys.argv[2] )      t = int(f.readline())      t = 1      for l in f:          a,b = [int(x) for x in l.split()]          mt = sqpals >= a          lt = sqpals <= b          output = sum( mt&lt )          print "Case #%s: %s"%(t,output)          t += 1        <CODESPLIT> 16
import sys  from collections import deque    ##all_trips = {}  ##  ##for i in range(10+1):  ##    for j in range(i,min(i+3,10+1)):  ##        for k in range(i,min(i+3,10+1)):  ##            trip = [i,j,k]  ##            trip.sort()  ##            trip = tuple(trip)  ##            isSurp = 0  ##            if max(trip)-min(trip) > 2:  ##                sys.stderr.write( "Err in trip.")  ##                break  ##            if max(trip)-min(trip) == 2:  ##                isSurp = 1  ##            points = sum(trip)  ##            try:  ##                all_trips[points].add( (max(trip),isSurp,trip) )  ##            except KeyError:  ##                all_trips[points] = set()  ##                all_trips[points].add( (max(trip),isSurp,trip) )  ##  ##for x in all_trips:  ##    all_trips[x] = list(all_trips[x])  ##    all_trips[x].sort()  ##    print x, (x+2)/3, (x+2)%3, all_trips[x]    if __name__ == "__main__":        f = open( "B-small-attempt1.in.txt" )      g = open( "output_small.txt", "w" )        f.readline()      line = f.readline()      caseI = 1      while line != "":          line = [ int(x) for x in line.split() ]          N = line[0]          surprise = line[1]          p = line[2]          points = line[3:]          points.sort()          points.reverse()            maxp = 0          either = 0          make_surprise = 0          for x in points:              this_p = (x+2)/3              if x in [0,1,29,30]:                  if this_p >= p:                      maxp += 1              elif this_p >= p:                  either += 1                  maxp += 1              elif this_p == p-1 and (x+2)%3 > 0:                  make_surprise += 1              else:                  either += 1            if make_surprise >= surprise:              make_surprise -= surprise              maxp += surprise              make_surprise = 0          else:              maxp += make_surprise            g.write( "Case #%s: %s\n"%(caseI,maxp) )            line = f.readline()          caseI += 1        f.close()      g.close()        <CODESPLIT> 16
import sys  from collections import deque    f = open(sys.argv[1])  f.readline()    numCase = 1  l = f.readline()  while l != "":  	n = [float(x) for x in f.readline().split()]  	k = [float(x) for x in f.readline().split()]    	n.sort()  	nd = deque(n)  	k.sort()  	kd = deque(k)    	war = 0  	while len(nd) > 0:  		nblock = nd.pop()  		if nblock > kd[-1]:  			kd.popleft()  			war += 1  		else:  			kd.pop()    	all = [ (x,1) for x in n ]  	all.extend( [(x,2) for x in k] )  	all.sort()    	dwar = 0  	nd = deque(n)  	kd = deque(k)  	while len(nd) > 0:  		if nd[0] < kd[0]:  			kd.pop()  		else:  			kd.popleft()  			dwar += 1  		nd.popleft()  		  	print "Case #"+str(numCase)+ ": "+str(dwar)+" "+str(war)  	    	numCase += 1  	l = f.readline() <CODESPLIT> 16
import sys    f = open( sys.argv[1] )  t = int(f.readline())    t = 1  l = f.readline()  while l != "":      n,m = [int(x) for x in l.split()]      lawn = [ [int(x) for x in f.readline().split()] for y in range(n)]        rowMax = [ max(x) for x in lawn ]      colMax = [ max([x[y] for x in lawn]) for y in range(m) ]        output = "YES"        for i in range(n):          for j in range(m):              if lawn[i][j] < rowMax[i]:                  if lawn[i][j] < colMax[j]:                      output = "NO"            print "Case #%s: %s"%(t,output)      t += 1      l = f.readline()  <CODESPLIT> 16
import sys  import heapq    f = open( sys.argv[1] )  f.readline()    numcases = 1  input = f.readline()  while input != "":  	inC,inF,inX = [float(x) for x in input.split()]    	start = (0.0,0.0,2.0)  	h = [start]  	checked =set()    	while h[0][1] < inX:  		x = heapq.heappop(h)    		if x in checked:  			continue  		else:  			checked.add(x)	    		time,numCookies,rate = x  		#time to win  		timeW = (inX - numCookies) / rate  		heapq.heappush( h,(time+timeW,numCookies+rate*timeW,rate) )    		#time to new farm  		timeF = (inC - numCookies) / rate  		newC = numCookies + rate*timeF  		newT = time + timeF  		heapq.heappush( h,(newT,(newC - inC),rate+inF) )  		heapq.heappush( h,(newT,newC,rate) )  		#print h    	output = "{:.7f}".format(h[0][0])    	print "Case #"+str(numcases)+": "+output  	input = f.readline()  	numcases += 1  	 <CODESPLIT> 16
import sys    if __name__ == "__main__":  	f = open( sys.argv[1] )  	int(f.readline())  		  	num = 1  	l = f.readline()  	while l != "":  		row1 = int(l)  		rows = [ f.readline() for x in range(4) ]  		row1 = [int(x) for x in rows[row1-1].split()]    		row2 = int(f.readline())  		rows = [f.readline() for x in range(4)]  		row2 = [int(x) for x in rows[row2-1].split()]    		result = set(row1) & set(row2)  		if len(result) == 1:  			output = str(result.pop())  		elif len(result) > 1:  			output = "Bad magician!"  		else:  			output = "Volunteer cheated!"    		print "Case #"+str(num)+": "+output  		num += 1  		l = f.readline()  		 <CODESPLIT> 16
import string    s1 = "ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jvyeqz"  s2 = "our language is impossible to understand there are twenty six factorial possibilitiesso it is okay if you want to just give upaozq"    mapd = string.maketrans(s1,s2)  #print "abcdefghijklmnopqrstuvwxyz"  #print "abcdefghijklmnopqrstuvwxyz".translate(mapd)    f = open( "A-small-attempt0.in.txt" )  g = open( "output_small.txt","w")    f.readline()  l = f.readline()  caseI = 1  while l != "":      output = l.translate(mapd)        g.write( "Case #%s: %s"%(caseI,output) )      l = f.readline()      caseI += 1  f.close()  g.close()  <CODESPLIT> 16
import sys    f = open( sys.argv[1] )  t = f.readline()    t = 1  line = f.readline()  while line != "":      board = [line.strip(),               f.readline().strip(),               f.readline().strip(),               f.readline().strip()]        output = ""        cols = [ "".join([x[y] for x in board]) for y in range(4)]      diags = ["".join([x[y] for x,y in zip(board,range(4))]),               "".join([x[y] for x,y in zip(board,range(-1,-5,-1))])]            rows = board + cols + diags        for row in rows:          x = [1 for z in row if z is "X" or z is "T"]          if sum(x) == 4:              output = "X won"              break          o = [1 for z in row if z is "O" or z is "T"]          if sum(o) == 4:              output = "O won"              break      if output == "":          finished = sum([ y.count(".") for y in board ])          if finished == 0:              output = "Draw"          else:              output = "Game has not completed"            print "Case #%s: %s"%(t,output)      t += 1      line = f.readline()      line = f.readline()  <CODESPLIT> 16
import sys  from collections import deque    def makeBoardR(b):  	numR, numC, numMines, filledR, filledC = b  	q = numMines / numR  	r = numMines % numR    	if q <= numC-2 and r == 0:  		board = ["*"*(filledC + numC) for x in range (filledR)]  		board.append( "*"*(filledC+q)+"."*(numC-q) )  		board.append( "*"*(filledC+q)+"."*(numC-q-1)+"c" )  		output = "\n".join(board)  	elif numMines == numR * numC - 1:  		board = ["*"*(filledC + numC) for x in range (filledR+1)]  		board.append( "*"*(filledC+numC-1)+"c" )  		output = "\n".join(board)  	else:  		output = "Impossible"    	return output    def makeBoardC(b):  	numR, numC, numMines, filledR, filledC = b  	q = numMines / numC  	r = numMines % numC    	if q <= numR-2 and r == 0:  		board = ["*"*(filledC+numC) for x in range(filledR+q)]  		for x in range( numR-1-q ):  			board.append( "*"*filledC + ".." )  		board.append( "*"*filledC + ".c" )  		output = "\n".join(board)  	elif numMines == numR * numC - 1:  		board = ["*"*(filledC+numC) for x in range(filledR+numR-1)]  		board.append( "*"*(filledC+numC-1) + "c" )  		output = "\n".join(board)  	else:  		output = "Impossible"  	return output    def makeBoard(b):  	numR, numC, numMines, filledR, filledC = b  	q = numMines / (numC-2)  	r = numMines % (numC-2)    	board = ["*"*(numC+filledC) for x in range(filledR)]  	for x in range(q):  		board.append( "*"*(numC-2+filledC)+".." )  	board.append( "*"*(r+filledC)+"."*(numC-r) )  	for x in range(numR-q-2):  		board.append( "*"*filledC+"."*numC )  	board.append( "*"*filledC + "."*(numC-1) + "c" )  	return "\n".join(board)    def makeBoard0(b):  	numR,numC,numMines,filledR,filledC = b  	board = ["*"*(numC+filledC) for x in range(filledR)]  	for x in range(numR-1):  		board.append( "*"*(filledC)+"."*numC )  	board.append( "*"*(filledC) + "."*(numC-1) + "c" )  	return "\n".join(board)    f = open( sys.argv[1] )  f.readline()    numCase = 1  l = f.readline()  while l != "":  	numR, numC, numMines = [int(x) for x in l.split()]    	boards = deque()  	if numR == 1:  		if numC == 1 and numMines == 0:  			output = "c"  		elif numC == 1 and numMines > 0:  			output = "Impossible"  		else:  			output = "*"*numMines + "."*(numC-numMines-1) + "c"  	elif numC == 1:  		output = "\n".join("*"*numMines + "."*(numR-numMines-1) + "c")  	else:  		boards.append( (numR,numC,numMines,0,0) )  		output = "Impossible"    	while output == "Impossible" and len(boards) > 0:  		b = boards.popleft()  		#print b  		numR,numC,numMines,filledR,filledC = b  		if numMines == 0:  			output = makeBoard0(b)  			break    		if numMines >= numC and numR > 2:  			boards.append( (numR-1,numC,numMines-numC,filledR+1,filledC) )  		if numMines >= numR and numC > 2:  			boards.append( (numR,numC-1,numMines-numR,filledR,filledC+1) )    		if numMines <= (numR-2)*(numC-2):  			output = makeBoard(b)    		if numR == 2:  			output = makeBoardR(b)    		if numC == 2:  			output = makeBoardC(b)  		  	print "Case #"+str(numCase)+":\n"+output  	#print "Case #"+str(numCase)+": " +l+output  	l = f.readline()  	numCase += 1  <CODESPLIT> 16
import sys  from collections import deque    if __name__ == "__main__":      f = open( "C-small-attempt0.in.txt" )      g = open( "output_small.txt", "w" )        numcases = int(f.readline())        caseI = 1      line = f.readline()      while line != "":          A,B = [int(x) for x in line.split()]            matched = [0]*(B+1)          pairs = deque()            for x in range(A,B+1):              if matched[x]:                  continue              a = str(x)              allcycle = deque()              allcycle.append(x)              for i in range(1,len(a)):                  yL,yR = a[:i],a[i:]                  y = int( yR+yL )                  if y >= A and y <= B:                      allcycle.append(y)              allcycle = list(set(allcycle))              allcycle.sort()              for y in allcycle:                  matched[y] = 1              for i in range(len(allcycle)):                  for j in range(i+1,len(allcycle)):                      pairs.append( (allcycle[i],allcycle[j]) )          g.write( "Case #%s: %s\n"%(caseI,len(pairs)) )          line = f.readline()          caseI += 1      f.close()      g.close()  <CODESPLIT> 16
import os, re, sys, math  import unittest    class Test(unittest.TestCase):  	def test_1(self):  		self.assertEqual(main(1, 4), 2)  	def test_2(self):  		self.assertEqual(main(10, 120), 0)  	def test_3(self):  		self.assertEqual(main(100, 100000000000000), 2)    #tCase = sys.stdin.readline().split()  tCase = int(sys.stdin.readline())      def main(M, N):  	fns = 0  	num = M  	maior = math.sqrt(N)  	int_maior = 0  	  	if maior.is_integer():  		int_maior = int(maior) - 1  		if fair(N):  			if fair(int(maior)):  				fns += 1  	else:  		int_maior = int(maior)  		  	while int_maior >= 1:  		if fair(int_maior):  			quadrado = int_maior * int_maior  			if quadrado >= M:  				if fair(quadrado):  					fns += 1  		int_maior -= 1  	return fns    def main2(M, N):  	fns = 0  	num = M  	#for num in xrange(M, N + 1):  	while num <= N:  		result = raiz(num)  		if result:  			if fair(num):  			  				if fair(result):  					fns += 1  					#print num  		#yield i  		num += 1  		#print raiz(num)  	return fns  	  def fair(num):  	return str(num) == str(num)[::-1]  	#return True  	  def raiz(num):  	result = math.sqrt(num)  	#result = 1.0  	if result.is_integer():  		return int(result)  	else:  		return False  	  if __name__ == '__main__':  	#unittest.main()  	for i in xrange(tCase):	  		#l1 = [str(x) for x in sys.stdin.readline().split(' ')]		  		#print "Case #%d: %s" % (i + 1, main(l1[0], l2[0], l3[0], l4[0]))  		  		##Numbers  		N,M = [int(x) for x in sys.stdin.readline().split(' ')]	  		print "Case #%d: %d" % (i + 1, main(N,M)) <CODESPLIT> 17
import sys, os  import re    tCase = int(sys.stdin.readline())    def alien(frases,case):  	  	case = case.replace('(','[')  	case = case.replace(')',']')  	#print frases,case  	  	ER1 = re.compile(case, re.I)  	count = 0  	for frase in frases:  		#print ER1.search(frase)  		if ER1.search(frase):  			count += 1  	return count      for i in xrange(tCase):	  	linha = sys.stdin.readline().split()  	#S = linha[0]  	P = int(linha[1])  	T = int(linha[2])  	list = []  	for j in range (3,len(linha)):  		list.append(int(linha[j]))  	list.sort(reverse=True)  	#print S,P,T,list  	realT = T*3 - 2  	supT = realT - 2  	  	count = 0  	for item in list:  		if item >= realT:  			count += 1  		elif P > 0 and item >= supT and T >= 2:  			count += 1  			P -= 1  		elif P > 0 and item >= realT and T == 1:  			count += 1  			P -= 1  		elif T == 0:  			count += 1  		else:  			break  		  	#case.append(frase)  	print "Case #%d: %d" % (i+1, count)  	  	    <CODESPLIT> 17
import os, re, sys  import unittest      #tCase = sys.stdin.readline().split()  tCase = int(sys.stdin.readline())    def ken(bet, list):  	for i in list:  		if i >= bet:  			list.remove(i)  			return i, list  	  	x = list[0]  	list.remove(x)  	return x, list  	  def naomi(YList, ZList):  	l1 = list(YList)  	l2 = list(ZList)  	  	while len(l1) > 0:  		cy = l1.pop()  		cz = l2.pop()    		if (cy < cz):  			#if len(l2) > 0:  				return YList[0], ZList[len(ZList)-1]  			#else:  			#	return cz, cy  		  	return YList[len(YList)-1], ZList[len(ZList)-1]  		  def main(YList, ZList):  	dnp = 0  	np = 0  	#YList.sort(reverse=True)  	YList.sort()  	ZList.sort()  	  	YList2 = list(YList)  	ZList2 = list(ZList)  	  	YList.sort()  	#print YList  	#print ZList  	  	while len(YList) > 0:  		cy, ty = naomi(YList, ZList)  		YList.remove(cy)		  		cz, ZList = ken(ty, ZList)  	#	print cy, ty,  cz  		if (cy > cz):  			dnp += 1  			  	while len(YList2) > 0:  		cy = YList2.pop()  		cz, ZList2 = ken(cy, ZList2)  		#print cy, cz  		if (cy > cz):  			np += 1  			  			  	    	return str(dnp) + " " + str(np)  		     if __name__ == '__main__':  	#unittest.main()  	for i in xrange(tCase):	  		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	  		#print "Case #%d: %s" % (i + 1, main(frase[0]))  		  		##Numbers  		N = [int(x) for x in sys.stdin.readline().split(' ')]  		YList = [float(x) for x in sys.stdin.readline().split(' ')]  		ZList = [float(x) for x in sys.stdin.readline().split(' ')]  		#print E,R,N, NList  		print "Case #%d: %s" % (i + 1, main(YList, ZList)) <CODESPLIT> 17
import os, re, sys, math  import unittest  from numpy import *    class Test(unittest.TestCase):  	def test_1(self):  		self.assertEqual(main(1, 4), 2)  	def test_2(self):  		self.assertEqual(main(10, 120), 0)  	def test_3(self):  		self.assertEqual(main(100, 100000000000000), 2)    tCase = int(sys.stdin.readline())      def main(matriz, M, N):  	#print matriz  	  	for i in xrange(M):  		for j in xrange(N):  			ana = matriz[i + 1, j + 1]  			#print ana  			maiores_linha = 0  			for x in xrange(M + 2):  				if matriz[x, j + 1] > ana:  					maiores_linha += 1  			  			if maiores_linha == 0:  				continue  			  			maiores_coluna = 0   			for y in xrange(N + 2):  				if matriz[i + 1, y] > ana:  					maiores_coluna += 1  					  			if maiores_linha >= 1 and maiores_coluna >= 1:  				#print ana, maiores_linha, maiores_coluna  				return 'NO'  				  	return 'YES'  	      	  if __name__ == '__main__':  	#unittest.main()  	for i in xrange(tCase):	  		##Numbers  		N,M = [int(x) for x in sys.stdin.readline().split(' ')]  		  		matriz = zeros((N + 2, M + 2), dtype=int)  		  		for j in xrange(N + 2):  			matriz[j][0] = 0  			matriz[j][M + 1] = 0  			  		for j in xrange(M + 2):  			matriz[0][j] = 0  			matriz[N + 1][j] = 0  		  		for k in xrange(N):  			j = 1  			line = [str(x) for x in sys.stdin.readline().split(' ')]  			for n in line:  				matriz[k + 1][j] = n		  				j += 1  		#matriz = zeros((N + 2, M + 2), dtype=int)  		  		print "Case #%d: %s" % (i + 1, main(matriz, N, M)) <CODESPLIT> 17
import unittest    import sys        #tCase = sys.stdin.readline().split()  tCase = int(sys.stdin.readline())    def calcTemp(taxa, X):  	return X/taxa;    def main(C, F, X):    	taxa = 2.0  	resp = 0  	  	  	while True:  		#print calcTemp(taxa, X), C/taxa + calcTemp(taxa + F, X), resp  		if C/taxa + calcTemp(taxa + F, X) < calcTemp(taxa, X):  			resp += C/taxa  			taxa += F			  		else:  			resp += calcTemp(taxa, X)  			return resp  	  	  	return 0  		     if __name__ == '__main__':  	#unittest.main()  	for i in xrange(tCase):	  		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	  		#print "Case #%d: %s" % (i + 1, main(frase[0]))  		  		##Numbers  		C, F, X = [float(x) for x in sys.stdin.readline().split(' ')]  		#print A, B, NList, BList  		print "Case #%d: %s" % (i + 1, main(C, F, X)) <CODESPLIT> 17
import unittest    import sys      class Test(unittest.TestCase):  	def test_1(self):  		self.assertEqual(main(5, 2, 2, [2,1]), 12)  	def test_2(self):  		self.assertEqual(main(5,2,2,[1,2]), 12)  	def test_3(self):  		self.assertEqual(main(3,3,4,[4,1,3,5]), 39)  	def test_4(self):  		self.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)      #tCase = sys.stdin.readline().split()  tCase = int(sys.stdin.readline())    def main(A, B, AList, BList):  	resp = 0  	A = A - 1  	B = B - 1  	Alist = AList[A*4:A*4+4]  	BList = BList[B*4:B*4+4]  	cont = 0  	#print Alist, BList  	for aa in Alist:  		if aa in BList:  			resp = aa  			cont += 1  		  	if cont == 1:  		return resp  	elif cont == 0:  		return "Volunteer cheated!"  	else:  		return "Bad magician!"  		     if __name__ == '__main__':  	#unittest.main()  	for i in xrange(tCase):	  		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	  		#print "Case #%d: %s" % (i + 1, main(frase[0]))  		  		##Numbers  		A = [int(x) for x in sys.stdin.readline().split(' ')][0]  		NList = [int(x) for x in sys.stdin.readline().split(' ')]  		NList += [int(x) for x in sys.stdin.readline().split(' ')]  		NList += [int(x) for x in sys.stdin.readline().split(' ')]  		NList += [int(x) for x in sys.stdin.readline().split(' ')]  		B = [int(x) for x in sys.stdin.readline().split(' ')][0]  		BList = [int(x) for x in sys.stdin.readline().split(' ')]  		BList += [int(x) for x in sys.stdin.readline().split(' ')]  		BList += [int(x) for x in sys.stdin.readline().split(' ')]  		BList += [int(x) for x in sys.stdin.readline().split(' ')]  		#print A, B, NList, BList  		print "Case #%d: %s" % (i + 1, main(A, B, NList, BList)) <CODESPLIT> 17
import sys, os  import re    fLine = sys.stdin.readline().split()  tCase = int(fLine[0])      dic = {		'a':'y',  			'b':'h',  			'c':'e',  			'd':'s',  			'e':'o',  			'f':'c',  			'g':'v',  			'h':'x',  			'i':'d',  			'j':'u',  			'k':'i',  			'l':'g',  			'm':'l',  			'n':'b',  			'o':'k',  			'p':'r',  			'q':'z',  			'r':'t',  			's':'n',  			't':'w',  			'u':'j',  			'v':'p',  			'w':'f',  			'x':'m',  			'y':'a',  			'z':'q',  			'\n':'',  			' ':' '}      def alien(frase):  	resul = ""  	for c in frase:  		resul += dic[c]    	return resul        frases = []  for i in xrange(tCase):  	frase = sys.stdin.readline().replace("\n","")  	frases.append(frase)  	    for i in xrange(tCase):	  	#case.append(frase)  	print "Case #%d: %s" % (i+1, alien(frases[i]))  	  	    <CODESPLIT> 17
import os, re, sys  import unittest    class Test(unittest.TestCase):  	def test_1(self):  		self.assertEqual(main('XXXT', '....', 'OO..', '....'), 'X won')  	def test_2(self):  		self.assertEqual(main('XOXT', 'XXOO', 'OXOX', 'XXOO'), 'Draw')  	def test_3(self):  		self.assertEqual(main('XOX.', 'OX..', '....', '....'), 'Game has not completed')  	def test_4(self):  		self.assertEqual(main('OOXX', 'OXXX', 'OX.T', 'O..O'), 'O won')  	def test_5(self):  		self.assertEqual(main('XXXO', '..O.', '.O..', 'T...'), 'O won')  	def test_6(self):  		self.assertEqual(main('OXXX', 'XO..', '..O.', '...O'), 'O won')    #tCase = sys.stdin.readline().split()  tCase = int(sys.stdin.readline())    def main(l1, l2, l3, l4):  	  	resul = ganhador(l1[0], l1[1], l1[2], l1[3])  	  	if resul == 0:  		return 'X won'  	elif resul == 1:  		return 'O won'  		  	resul = ganhador(l2[0], l2[1], l2[2], l2[3])  	  	if resul == 0:  		return 'X won'  	elif resul == 1:  		return 'O won'  		  	resul = ganhador(l3[0], l3[1], l3[2], l3[3])  	  	if resul == 0:  		return 'X won'  	elif resul == 1:  		return 'O won'  		  	resul = ganhador(l4[0], l4[1], l4[2], l4[3])  	  	if resul == 0:  		return 'X won'  	elif resul == 1:  		return 'O won'  		  	# coluna  	resul = ganhador(l1[0], l2[0], l3[0], l4[0])  	  	if resul == 0:  		return 'X won'  	elif resul == 1:  		return 'O won'    	resul = ganhador(l1[1], l2[1], l3[1], l4[1])  	  	if resul == 0:  		return 'X won'  	elif resul == 1:  		return 'O won'    	resul = ganhador(l1[2], l2[2], l3[2], l4[2])  	  	if resul == 0:  		return 'X won'  	elif resul == 1:  		return 'O won'    	resul = ganhador(l1[3], l2[3], l3[3], l4[3])  	  	if resul == 0:  		return 'X won'  	elif resul == 1:  		return 'O won'    	# /  	resul = ganhador(l1[3], l2[2], l3[1], l4[0])  	  	if resul == 0:  		return 'X won'  	elif resul == 1:  		return 'O won'    	# \  	resul = ganhador(l1[0], l2[1], l3[2], l4[3])  	  	if resul == 0:  		return 'X won'  	elif resul == 1:  		return 'O won'  	  	if '.' in l1 or '.' in l2 or '.' in l3 or '.' in l4:  		return 'Game has not completed'  	else:  		return 'Draw'  	  	  def ganhador(a, b, c, d):  	x = 0  	o = 0  	p = 0  	if a == 'X':  		x += 1  		p += 1  	if a == 'O':  		o += 1  		p += 1  	if a == 'T':  		x += 1  		o += 1  		p += 1  	if b == 'X':  		x += 1  		p += 1  	if b == 'O':  		o += 1  		p += 1  	if b == 'T':  		x += 1  		o += 1  		p += 1  	if c == 'X':  		x += 1  		p += 1  	if c == 'O':  		o += 1  		p += 1  	if c == 'T':  		x += 1  		o += 1  		p += 1  	if d == 'X':  		x += 1  		p += 1  	if d == 'O':  		o += 1  		p += 1  	if d == 'T':  		x += 1  		o += 1  		p += 1	  	if x == 4:  		return 0  	elif o == 4:  		return 1  	elif p == 4:  		return 2  	else: # incompleto  		return 3     if __name__ == '__main__':  	#unittest.main()  	for i in xrange(tCase):	  		l1 = [str(x) for x in sys.stdin.readline().split(' ')]  		l2 = [str(x) for x in sys.stdin.readline().split(' ')]	  		l3 = [str(x) for x in sys.stdin.readline().split(' ')]	  		l4 = [str(x) for x in sys.stdin.readline().split(' ')]  		nulo = [str(x) for x in sys.stdin.readline().split(' ')]		  		print "Case #%d: %s" % (i + 1, main(l1[0], l2[0], l3[0], l4[0]))  		  		##Numbers  		#N,M = [int(x) for x in sys.stdin.readline().split(' ')]	  		#print "Case #%d: %d" % (i + 1, main(N,M)) <CODESPLIT> 17
import os, re, sys  import unittest      #tCase = sys.stdin.readline().split()  tCase = int(sys.stdin.readline())      def map(R, C, Bombs):  	m = [["." for x in xrange(C)] for x in xrange(R)]  	print Bombs  	m[R-1][C-1] = 'c'  	lastSkip = False  	#for b in xrange(Bombs):  	for i in xrange(R):  		for j in xrange(C):  			if Bombs == 0:  				break  			  			if lastSkip:  				m[i][j] = 'f'  				continue  			  			if R - i == 2 or C - j == 2:  				if Bombs == 1:  					m[i][j] = 'f'  					lastSkip = True  					continue  			  				  			m[i][j] = '*'  			Bombs -= 1  			lastSkip = False  		lastSkip = False  				  	  	  	for line in m:  		for c in line:  			print c,  		print  		  		  def imprimir(m):  	for line in m:  		for c in line:  			print c,  		print  		  def map2(R, C, Bombs):  	m = [["." for x in xrange(C)] for x in xrange(R)]  	#print Bombs  	m[R-1][C-1] = 'c'  	lastSkip = False  	#for b in xrange(Bombs):  	  	ii = 0  	jj = 0  	while Bombs > 0:  		for j in xrange(jj, C):  			if Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:  				m[ii][j] = '*'  				Bombs -= 1  			else:  				continue  		  		  		for i in xrange(ii+1, R):  			if Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:  				m[i][jj] = '*'  				Bombs -= 1  			else:  				if Bombs > 0:  					print "Impossible"  					#imprimir(m)  					return  				continue  		jj += 1  		ii += 1  	#print "b", Bombs  	imprimir(m)  	  				  	  	    		  def main(R, C, M):  	vazios = R * C - M    	if R == 1 or C == 1 or vazios == 1 or vazios >= 4:  		map2(R, C, M)  	else:  		print "Impossible"    	#print vazios  	return ""  		     if __name__ == '__main__':  	#unittest.main()  	for i in xrange(tCase):	  		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	  		#print "Case #%d: %s" % (i + 1, main(frase[0]))  		  		##Numbers  		R, C, M = [int(x) for x in sys.stdin.readline().split(' ')]  		#YList = [float(x) for x in sys.stdin.readline().split(' ')]  		#ZList = [float(x) for x in sys.stdin.readline().split(' ')]  		#print E,R,N, NList  		print "Case #%d:" % (i + 1)  		main(R, C, M) <CODESPLIT> 17
import sys, os  import re    tCase = int(sys.stdin.readline())    def alien(numbers):  	resul = 0  	A = int(numbers[0])  	B = int(numbers[1])    	for n in range(A,B-1):  		for m in range(n+1,B+1):  			#print n,m  			if (len(str(n)) == len(str(m))):  				resul += isRecycled(str(n),str(m))  	      	return resul  	  def isRecycled(n,m):  	if len(n) < 2:  		return 0  		  	for c in m:  		if c not in n:  			return 0    	for i in range (1, len(n)):  		mi = m[i:] + m[-len(m):-(len(m)-i)]  		if n == mi:  			return 1  	  	return 0      lines = []  for i in xrange(tCase):  	line = sys.stdin.readline().split()  	lines.append((line[0],line[1]))  	    for i in xrange(tCase):	  	#case.append(frase)  	print "Case #%d: %s" % (i+1, alien(lines[i]))  	  	    <CODESPLIT> 17
#!/usr/bin/env python    from math import sqrt    FILE_NAME_BASE = 'C-small-attempt0'  NUM_PROCESSES = 0  MEM_LIMIT_GB = 1.5 # per worker process  RECURSION_LIMIT = 1000    def parse(inp):  	a, b = (int(x) for x in inp.readline().split())  	return a, b    def isFair(x):  	l1 = list(str(x))  	l2 = list(l1)  	l2.reverse()  	return l1 == l2    def solve(a, b):  	c = 0  	for i in xrange(a, b + 1):  		r = int(sqrt(i))  		if r * r == i and isFair(i) and isFair(r):  			c += 1    	return str(c)    def main():  	import sys  	sys.setrecursionlimit(RECURSION_LIMIT)    	import resource  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))    	inp = open(FILE_NAME_BASE + '.in', 'r')  	numCases = int(inp.readline())  	if NUM_PROCESSES == 0:  		results = [  			solve(*parse(inp))  			for _ in range(numCases)  			]  	else:  		from multiprocessing import Pool  		pool = Pool(NUM_PROCESSES)  		results = [  			pool.apply_async(solve, parse(inp))  			for _ in range(numCases)  			]  	inp.close()  	out = open(FILE_NAME_BASE + '.out', 'w')  	for case, result in enumerate(results):  		value = result if NUM_PROCESSES == 0 else result.get()  		out.write('Case #%d: %s\n' % (case + 1, value))  		out.flush()  	out.close()    if __name__ == '__main__':  	main()  <CODESPLIT> 18
#!/usr/bin/env python    FILE_NAME_BASE = 'B-small-attempt0'  NUM_PROCESSES = 0    def parse(inp):  	data = tuple(int(x) for x in inp.readline().split())  	dancers, surprises, points = data[ : 3]  	totals = data[3 : ]  	assert len(totals) == dancers  	return totals, surprises, points    def totalAtDist():  	'''  	If a dancer's best result is b, the total can be:  	  distance 0: 3b  	  distance 1: [3b-2..3b-1]  	  distance 2: [3b-4..3b-2]  	Note: distance d is only possible if d <= b.    	total 15:  	b = 0..4:  impossible  	b = 5:     dist = 0  	b = 6:     dist = 2  	b = 7..10: impossible    	For every total we have a number of explanations, which are  	(b, d) pairs where b is the best result and d is the distance.    	The output of this function shows:    	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:  	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)  	In other words, always one surprise option and one normal option.  	The surprise option can have a result one higher than the normal one or  	equal to it.  	'''    	print '  ',  	for b in xrange(0, 11):  		print 'b=%d' % b,  	print  	for total in xrange(0, 31):  		print '%2d' % total,  		for b in xrange(0, 11):  			s = '0' if total == b * 3 else '.'  			s += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'  			s += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'  			print s,  		print    #totalAtDist()    def solve(totals, surprises, points):  	countCertain = 0  	countSurprise = 0  	for total in totals:  		if (total + 2) / 3 >= points:  			# A non-surprising score has a best result >= p.  			countCertain += 1  		elif 2 <= total <= 28 and (total + 4) / 3 >= points:  			# Only a surprising score has a best result >= p.  			countSurprise += 1  		else:  			# The best result cannot be >= p.  			pass    	# Replacing a non-surprise interpretation of a total by a surprise  	# interpretation is always possible for totals in [2..28] and will never  	# lower the best result, so it will not put a score in a different  	# category. Therefore, it is always possible to assign leftover surprise  	# slots to dancers without changing the outcome.    	return countCertain + min(countSurprise, surprises)    if __name__ == '__main__':  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')  	numCases = int(inp.readline())  	if NUM_PROCESSES == 0:  		results = [  			solve(*parse(inp))  			for _ in range(numCases)  			]  	else:  		from multiprocessing import Pool  		pool = Pool(NUM_PROCESSES)  		results = [  			pool.apply_async(solve, parse(inp))  			for _ in range(numCases)  			]  	inp.close()  	out = open(FILE_NAME_BASE + '.out.txt', 'w')  	for case, result in enumerate(results):  		value = result if NUM_PROCESSES == 0 else result.get()  		out.write('Case #%d: %s\n' % (case + 1, value))  		out.flush()  	out.close()  <CODESPLIT> 18
#!/usr/bin/env python    FILE_NAME_BASE = 'D-small-attempt0'  NUM_PROCESSES = 0  MEM_LIMIT_GB = 1.5 # per worker process  RECURSION_LIMIT = 1000    from itertools import chain    def parse(inp):  	numBlocks, = (int(x) for x in inp.readline().split())  	naomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))  	kenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))  	assert len(naomiBlocks) == numBlocks  	assert len(kenBlocks) == numBlocks  	return naomiBlocks, kenBlocks    def solve(naomiBlocks, kenBlocks):  	numBlocks = len(naomiBlocks)    	# greedy strategy for honest play:  	# play the block that is heavier by the smallest margin (if you have one)  	# ('honest' meaning sticking to the rules; 'fair' is something else)  	kenPointsHonest = 0  	naomiLowerBlocks = 0  	for _, owner in sorted(chain(  			((b, 'n') for b in naomiBlocks),  			((b, 'k') for b in kenBlocks)  			)):  		if owner == 'n':  			naomiLowerBlocks += 1  		elif naomiLowerBlocks != 0:  			naomiLowerBlocks -= 1  			kenPointsHonest += 1  	naomiPointsHonest = numBlocks - kenPointsHonest    	# strategy for deceitful play:  	# moves:  	# + lie and win:  	#   when Ken can't match the told number, he'll play his lightest block  	#   so you can lie and win if you play a block heavier than his lightest  	# + lie and lose:  	#   name a weight just below Ken's heaviest block, forcing him to play that  	# - truth and win:  	#   when you play a block that is actually heavier than anything Ken has  	#   is just a special case of lie and win  	# - truth and lose:  	#   never optimal  	# optimal order of play:  	#   always play your lightest block: if it can't win now, it can never win  	#   in the future either, nor can it be more effective in the future than  	#   pulling his current heaviest block  	naomiLoIdx = 0  	naomiHiIdx = numBlocks - 1  	kenLoIdx = 0  	kenHiIdx = numBlocks - 1  	naomiPointsDeceit = 0  	while naomiLoIdx <= naomiHiIdx:  		assert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx  		naomiLo = naomiBlocks[naomiLoIdx]  		#naomiHi = naomiBlocks[naomiHiIdx]  		kenLo = kenBlocks[kenLoIdx]  		#kenHi = kenBlocks[kenHiIdx]  		if naomiLo > kenLo:  			naomiPointsDeceit += 1  			kenLoIdx += 1  		else:  			kenHiIdx -= 1  		naomiLoIdx += 1    	#print naomiBlocks  	#print kenBlocks  	#print    	return '%d %d' % (naomiPointsDeceit, naomiPointsHonest)    def main():  	import sys  	sys.setrecursionlimit(RECURSION_LIMIT)    	import resource  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))    	inp = open(FILE_NAME_BASE + '.in', 'r')  	numCases = int(inp.readline())  	if NUM_PROCESSES == 0:  		results = [  			solve(*parse(inp))  			for _ in range(numCases)  			]  	else:  		from multiprocessing import Pool  		pool = Pool(NUM_PROCESSES)  		results = [  			pool.apply_async(solve, parse(inp))  			for _ in range(numCases)  			]  	inp.close()  	out = open(FILE_NAME_BASE + '.out', 'w')  	for case, result in enumerate(results):  		value = result if NUM_PROCESSES == 0 else result.get()  		out.write('Case #%d: %s\n' % (case + 1, value))  		out.flush()  	out.close()    if __name__ == '__main__':  	main()  <CODESPLIT> 18
#!/usr/bin/env python    FILE_NAME_BASE = 'B-small-attempt0'  NUM_PROCESSES = 0  MEM_LIMIT_GB = 1.5 # per worker process  RECURSION_LIMIT = 1000    def parse(inp):  	rows, cols = (int(x) for x in inp.readline().split())  	return tuple(  		tuple(int(x) for x in inp.readline().split())  		for row in xrange(rows)  		),    def solve(lawn):  	#print lawn    	rowMax = tuple(max(row) for row in lawn)  	colMax = tuple(max(row[i] for row in lawn) for i in xrange(len(lawn[0])))  	#print rowMax, colMax    	def possible():  		for y, row in enumerate(lawn):  			for x, cell in enumerate(row):  				h = min(rowMax[y], colMax[x])  				if cell != h:  					return False  		return True    	return 'YES' if possible() else 'NO'    def main():  	import sys  	sys.setrecursionlimit(RECURSION_LIMIT)    	import resource  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))    	inp = open(FILE_NAME_BASE + '.in', 'r')  	numCases = int(inp.readline())  	if NUM_PROCESSES == 0:  		results = [  			solve(*parse(inp))  			for _ in range(numCases)  			]  	else:  		from multiprocessing import Pool  		pool = Pool(NUM_PROCESSES)  		results = [  			pool.apply_async(solve, parse(inp))  			for _ in range(numCases)  			]  	inp.close()  	out = open(FILE_NAME_BASE + '.out', 'w')  	for case, result in enumerate(results):  		value = result if NUM_PROCESSES == 0 else result.get()  		out.write('Case #%d: %s\n' % (case + 1, value))  		out.flush()  	out.close()    if __name__ == '__main__':  	main()  <CODESPLIT> 18
#!/usr/bin/env python    FILE_NAME_BASE = 'B-small-attempt0'  NUM_PROCESSES = 0  MEM_LIMIT_GB = 1.5 # per worker process  RECURSION_LIMIT = 1000    def parse(inp):  	cost, prod, goal = (float(x) for x in inp.readline().split())  	return cost, prod, goal    def solve(cost, prod, goal):  	rate = 2  	now = 0  	while True:  		nobuyEnd = goal / rate  		buyEnd = cost / rate + goal / (rate + prod)  		if buyEnd < nobuyEnd:  			now += cost / rate  			rate += prod  		else:  			return '%0.7f' % (now + nobuyEnd)    def main():  	import sys  	sys.setrecursionlimit(RECURSION_LIMIT)    	import resource  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))    	inp = open(FILE_NAME_BASE + '.in', 'r')  	numCases = int(inp.readline())  	if NUM_PROCESSES == 0:  		results = [  			solve(*parse(inp))  			for _ in range(numCases)  			]  	else:  		from multiprocessing import Pool  		pool = Pool(NUM_PROCESSES)  		results = [  			pool.apply_async(solve, parse(inp))  			for _ in range(numCases)  			]  	inp.close()  	out = open(FILE_NAME_BASE + '.out', 'w')  	for case, result in enumerate(results):  		value = result if NUM_PROCESSES == 0 else result.get()  		out.write('Case #%d: %s\n' % (case + 1, value))  		out.flush()  	out.close()    if __name__ == '__main__':  	main()  <CODESPLIT> 18
#!/usr/bin/env python    FILE_NAME_BASE = 'A-small-attempt0'  NUM_PROCESSES = 0  MEM_LIMIT_GB = 1.5 # per worker process  RECURSION_LIMIT = 1000    def parseBoard(inp):  	rowSel, = (int(x) for x in inp.readline().split())  	board = tuple(  		tuple(int(x) for x in inp.readline().split())  		for _ in xrange(4)  		)  	return board, rowSel - 1    def parse(inp):  	before, beforeSel = parseBoard(inp)  	after, afterSel = parseBoard(inp)  	return before, beforeSel, after, afterSel    def solve(before, beforeSel, after, afterSel):  	candidates = set(before[beforeSel]) & set(after[afterSel])    	if len(candidates) == 0:  		return "Volunteer cheated!"  	elif len(candidates) == 1:  		return candidates.pop()  	else:  		return "Bad magician!"    def main():  	import sys  	sys.setrecursionlimit(RECURSION_LIMIT)    	import resource  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))    	inp = open(FILE_NAME_BASE + '.in', 'r')  	numCases = int(inp.readline())  	if NUM_PROCESSES == 0:  		results = [  			solve(*parse(inp))  			for _ in range(numCases)  			]  	else:  		from multiprocessing import Pool  		pool = Pool(NUM_PROCESSES)  		results = [  			pool.apply_async(solve, parse(inp))  			for _ in range(numCases)  			]  	inp.close()  	out = open(FILE_NAME_BASE + '.out', 'w')  	for case, result in enumerate(results):  		value = result if NUM_PROCESSES == 0 else result.get()  		out.write('Case #%d: %s\n' % (case + 1, value))  		out.flush()  	out.close()    if __name__ == '__main__':  	main()  <CODESPLIT> 18
#!/usr/bin/env python    FILE_NAME_BASE = 'A-small'  NUM_PROCESSES = 0    def findMapping(knowledge):  	# Build Googlerese to English mapping from example text.  	mapping = {}  	for english, googlerese in knowledge:  		assert len(english) == len(googlerese)  		for engChar, gooChar in zip(english, googlerese):  			if ord('a') <= ord(engChar) <= ord('z'):  				assert ord('a') <= ord(gooChar) <= ord('z')  				if gooChar in mapping:  					assert mapping[gooChar] == engChar  				else:  					mapping[gooChar] = engChar  			else:  				assert engChar == gooChar    	# If one letter is not be specified in the example text, we can still  	# complete the mapping.  	alphabet = set(chr(i) for i in xrange(ord('a'), ord('z') + 1))  	gooMissing = alphabet - set(mapping.iterkeys())  	engMissing = alphabet - set(mapping.itervalues())  	assert len(gooMissing) == len(engMissing)  	if len(gooMissing) == 1:  		gooChar, = gooMissing  		engChar, = engMissing  		mapping[gooChar] = engChar  	else:  		assert len(gooMissing) == 0    	# Convert completed mapping to Python translate table.  	assert len(mapping) == 26, mapping  	return ''.join(mapping.get(chr(i), chr(i)) for i in xrange(256))    def parse(inp):  	return inp.readline().rstrip('\n'),    def solve(line):  	return line.translate(mapping)    knowledge = (  	( 'our language is impossible to understand',  	  'ejp mysljylc kd kxveddknmc re jsicpdrysi' ),  	( 'there are twenty six factorial possibilities',  	  'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' ),  	( 'so it is okay if you want to just give up',  	  'de kr kd eoya kw aej tysr re ujdr lkgc jv' ),  	( 'a zoo',  	  'y qee' ),  	)    mapping = findMapping(knowledge)    if __name__ == '__main__':  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')  	numCases = int(inp.readline())  	if NUM_PROCESSES == 0:  		results = [  			solve(*parse(inp))  			for _ in range(numCases)  			]  	else:  		from multiprocessing import Pool  		pool = Pool(NUM_PROCESSES)  		results = [  			pool.apply_async(solve, parse(inp))  			for _ in range(numCases)  			]  	inp.close()  	out = open(FILE_NAME_BASE + '.out.txt', 'w')  	for case, result in enumerate(results):  		value = result if NUM_PROCESSES == 0 else result.get()  		out.write('Case #%d: %s\n' % (case + 1, value))  		out.flush()  	out.close()  <CODESPLIT> 18
#!/usr/bin/env python    FILE_NAME_BASE = 'A-small-attempt0'  NUM_PROCESSES = 0  MEM_LIMIT_GB = 1.5 # per worker process  RECURSION_LIMIT = 1000    def parse(inp):  	board = tuple( inp.readline().rstrip() for _ in xrange(4) )  	empty = inp.readline().rstrip()  	assert empty == '', empty  	return board,    def solve(board):    	def scan(start, delta):  		x, y = start  		dx, dy = delta  		for _ in xrange(4):  			yield board[y][x]  			x += dx  			y += dy    	# Look for a winner.  	for start, delta in (  		# horizontal  		((0, 0), (1, 0)),  		((0, 1), (1, 0)),  		((0, 2), (1, 0)),  		((0, 3), (1, 0)),  		# vertical  		((0, 0), (0, 1)),  		((1, 0), (0, 1)),  		((2, 0), (0, 1)),  		((3, 0), (0, 1)),  		# diagonal  		((0, 0), (1, 1)),  		((3, 0), (-1, 1)),  		):  		chars = set(scan(start, delta))  		if chars == set(['X']) or chars == set(['X', 'T']):  			return 'X won'  		elif chars == set(['O']) or chars == set(['O', 'T']):  			return 'O won'    	# No winner; draw or unfinished game?  	if any('.' in row for row in board):  		return 'Game has not completed'  	else:  		return 'Draw'    def main():  	import sys  	sys.setrecursionlimit(RECURSION_LIMIT)    	import resource  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))    	inp = open(FILE_NAME_BASE + '.in', 'r')  	numCases = int(inp.readline())  	if NUM_PROCESSES == 0:  		results = [  			solve(*parse(inp))  			for _ in range(numCases)  			]  	else:  		from multiprocessing import Pool  		pool = Pool(NUM_PROCESSES)  		results = [  			pool.apply_async(solve, parse(inp))  			for _ in range(numCases)  			]  	inp.close()  	out = open(FILE_NAME_BASE + '.out', 'w')  	for case, result in enumerate(results):  		value = result if NUM_PROCESSES == 0 else result.get()  		out.write('Case #%d: %s\n' % (case + 1, value))  		out.flush()  	out.close()    if __name__ == '__main__':  	main()  <CODESPLIT> 18
#!/usr/bin/env python    FILE_NAME_BASE = 'C-small-attempt0'  NUM_PROCESSES = 0  MEM_LIMIT_GB = 1.5 # per worker process  RECURSION_LIMIT = 1000    def parse(inp):  	rows, cols, mines = (int(x) for x in inp.readline().split())  	return rows, cols, mines    def search(rows, cols, mines):  	# Boundary cases:  	# TODO: Might be redundant once we have a generic solution.    	# Mine count extremes.  	assert 0 <= mines < rows * cols  	if mines == 0:  		return ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)  	if mines == rows * cols - 1:  		return ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)    	# One-dimensional board.  	if rows == 1:  		return ['c' + '.' * (cols - 1 - mines) + '*' * mines]  	if cols == 1:  		return ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines    	# Nearly-full two-dimensional board: the clicked cell must not have any  	# mines as neighbours or the flooding won't start.  	if mines > rows * cols - 4:  		return None    	# TODO: For now, we just give up.    	return None    class SearchBoard(object):    	def __init__(self, rows, cols):  		self.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]  		self.mineCount = 0    	def addMine(self, row, col):  		counts = self.counts  		assert counts[row + 1][col + 1] < 10  		top = counts[row + 0]  		top[col + 0] += 1  		top[col + 1] += 1  		top[col + 2] += 1  		mid = counts[row + 1]  		mid[col + 0] += 1  		mid[col + 1] += 10  		mid[col + 2] += 1  		bot = counts[row + 2]  		bot[col + 0] += 1  		bot[col + 1] += 1  		bot[col + 2] += 1  		self.mineCount += 1    	def removeMine(self, row, col):  		counts = self.counts  		assert counts[row + 1][col + 1] >= 10  		top = counts[row + 0]  		top[col + 0] -= 1  		top[col + 1] -= 1  		top[col + 2] -= 1  		mid = counts[row + 1]  		mid[col + 0] -= 1  		mid[col + 1] -= 10  		mid[col + 2] -= 1  		bot = counts[row + 2]  		bot[col + 0] -= 1  		bot[col + 1] -= 1  		bot[col + 2] -= 1  		self.mineCount -= 1    	def checkConnected(self):  		counts = self.counts  		cols = len(counts[0]) - 2  		rows = len(counts) - 2    		# Pick a cell to click on. Any zero cell will do: if all zeroes are  		# connected, clicking on any zero will reveal them all.  		for rowIdx, row in enumerate(counts):  			if rowIdx == 0 or rowIdx > rows:  				continue  			try:  				colIdx = row.index(0, 1, -1)  			except ValueError:  				pass  			else:  				click = (rowIdx, colIdx)  				break  		else:  			return None    		revealed = set()  		def reveal(row, col):  			if 1 <= row <= rows and 1 <= col <= cols:  				pos = (row, col)  				if pos not in revealed:  					revealed.add(pos)  					count = counts[row][col]  					if count == 0:  						for dr in (-1, 0, 1):  							for dc in (-1, 0, 1):  								if dr != 0 or dc != 0:  									reveal(row + dr, col + dc)  					else:  						assert count < 10  		reveal(*click)  		numNonMines = rows * cols - self.mineCount  		if len(revealed) != numNonMines:  			assert len(revealed) < numNonMines  			return None    		# Construct a board in the solution syntax.  		board = [  				['.' if cell < 10 else '*' for cell in row[1 : -1]]  				for row in counts[1 : -1]  				]  		board[click[0] - 1][click[1] - 1] = 'c'  		return [''.join(row) for row in board]    def searchBruteForce(rows, cols, mines):  	# This is the only case where there are no zero cells but there is a  	# solution.  	if mines == rows * cols - 1:  		return ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)    	searchBoard = SearchBoard(rows, cols)    	def searchRec(idx, remaining):  		if remaining == 0:  			return searchBoard.checkConnected()  		elif idx < remaining:  			return None  		else:  			pos = divmod(idx, cols)  			searchBoard.addMine(*pos)  			found = searchRec(idx - 1, remaining - 1)  			searchBoard.removeMine(*pos)  			if found is not None:  				return found  			return searchRec(idx - 1, remaining)    	return searchRec(rows * cols - 1, mines)    def solve(rows, cols, mines):  	board = search(rows, cols, mines)    	if board is None:  		board = searchBruteForce(rows, cols, mines)  		if board is None:  			return '\n' + 'Impossible'  		print 'ERROR: fast search missed solution for %dx%d board, %d mines:' \  				% (rows, cols, mines)  		for row in board:  			print row  		print    	# Perform sanity checks.  	assert len(board) == rows  	assert all(len(row) == cols for row in board)  	counts = { 'c': 0, '.': 0, '*': 0 }  	for row in board:  		for cell in row:  			counts[cell] += 1  	assert counts['c'] == 1  	assert counts['*'] == mines    	flowBoard = [  			['.' if cell == 'c' else cell for cell in row]  			for row in board  			]  	def countMinesOn(row, col):  		if 0 <= row < rows and 0 <= col < cols:  			return 1 if flowBoard[row][col] == '*' else 0  		else:  			return 0  	def countMinesNear(row, col):  		return sum(  			countMinesOn(row + dr, col + dc)  			for dr in (-1, 0, 1)  			for dc in (-1, 0, 1)  			)  	def reveal(row, col):  		if 0 <= row < rows and 0 <= col < cols:  			assert flowBoard[row][col] != '*'  			if flowBoard[row][col] == '.':  				count = countMinesNear(row, col)  				flowBoard[row][col] = str(count)  				if count == 0:  					for dr in (-1, 0, 1):  						for dc in (-1, 0, 1):  							reveal(row + dr, col + dc)  	clickRow, = [i for i, row in enumerate(board) if 'c' in row]  	clickCol = board[clickRow].index('c')  	reveal(clickRow, clickCol)  	assert all('.' not in row for row in flowBoard), flowBoard    	assert all(type(row) == str for row in board)  	return '\n' + ''.join('\n' + ''.join(row) for row in board)    def main():  	import sys  	sys.setrecursionlimit(RECURSION_LIMIT)    	import resource  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))    	inp = open(FILE_NAME_BASE + '.in', 'r')  	numCases = int(inp.readline())  	if NUM_PROCESSES == 0:  		results = [  			solve(*parse(inp))  			for _ in range(numCases)  			]  	else:  		from multiprocessing import Pool  		pool = Pool(NUM_PROCESSES)  		results = [  			pool.apply_async(solve, parse(inp))  			for _ in range(numCases)  			]  	inp.close()  	out = open(FILE_NAME_BASE + '.out', 'w')  	for case, result in enumerate(results):  		value = result if NUM_PROCESSES == 0 else result.get()  		out.write('Case #%d: %s\n' % (case + 1, value))  		out.flush()  	out.close()    if __name__ == '__main__':  	main()  <CODESPLIT> 18
#!/usr/bin/env python    FILE_NAME_BASE = 'C-small-attempt0'  NUM_PROCESSES = 0    def parse(inp):  	a, b = (int(x) for x in inp.readline().split())  	return a, b    def solve(a, b):  	count = 0  	for i in xrange(a, b):  		s = str(i)  		recycled = set()  		for d in xrange(1, len(s)):  			r = s[d : ] + s[ : d]  			if i < int(r) <= b:  				recycled.add(r)  		count += len(recycled)  	return count    if __name__ == '__main__':  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')  	numCases = int(inp.readline())  	if NUM_PROCESSES == 0:  		results = [  			solve(*parse(inp))  			for _ in range(numCases)  			]  	else:  		from multiprocessing import Pool  		pool = Pool(NUM_PROCESSES)  		results = [  			pool.apply_async(solve, parse(inp))  			for _ in range(numCases)  			]  	inp.close()  	out = open(FILE_NAME_BASE + '.out.txt', 'w')  	for case, result in enumerate(results):  		value = result if NUM_PROCESSES == 0 else result.get()  		out.write('Case #%d: %s\n' % (case + 1, value))  		out.flush()  	out.close()  <CODESPLIT> 18
#include <iostream>  using namespace std;    bool is_palindrome(long long x) {  	static char digits[15];  	int d = 0;  	while (x != 0) {  		digits[d] = x % 10;  		x /= 10;  		++d;  	}    	for (int i = 0; i <= d / 2 - 1; ++i) {  		if (digits[i] != digits[d - i - 1]) {  			return false;  		}  	}  	return true;  }    long long rec(int d, int digits, char* number, long long x, long long a, long long b, long long& count) {  	if (d <= (digits - 1) / 2) {  		for (char i = (d == 0 ? 1 : 0); i < 9; ++i) {  			number[d] = i;  			rec(d + 1, digits, number, x*10 + i, a, b, count);  		}  	} else {  		for (int d2 = digits / 2 - 1; d2 >= 0; --d2) {  			x = x*10 + number[d2];  		}    		long long x2 = x*x;  		if (a <= x2 && x2 <= b && is_palindrome(x2)) {  			++count;  		}  	}  }    int main() {  	int tests;  	cin >> tests;  	for (int test = 1; test <= tests; ++test) {  		long long a, b;  		cin >> a >> b;    		long long count = 0;  		long long pow10 = 1;  		for (int digits = 1; digits <= 7; ++digits, pow10 *= 10) {  			if (pow10*pow10 > b) {  				break;  			}  			if ((pow10*10 - 1)*(pow10*10 - 1) < a) {  				continue;  			}    			char number[7];  			rec(0, digits, number, 0, a, b, count);  		}    		cout << "Case #" << test << ": " << count << endl;  	}  }  <CODESPLIT> 19
#include <iostream>  using namespace std;    int main() {  	int test_count;  	cin >> test_count;  	for (int test = 1; test <= test_count; ++test) {  		int n, s, p;  		cin >> n >> s >> p;  		int c1 = 0, cs = 0;  		for (int i = 0; i < n; ++i) {  			int k;  			cin >> k;  			int a = k / 3;  			switch (k % 3) {  			case 0:  				if (a >= p) {  					++c1;  				} else if (a >= 1 && a == p - 1) {  					++cs;  				}  				break;  			case 1:  				if (a >= p - 1) {  					++c1;  				}  				break;  			case 2:  				if (a >= p - 1) {  					++c1;  				} else if (a == p - 2) {  					++cs;  				}  			}  		}    		int ans = min(s, cs) + c1;  		cout << "Case #" << test << ": " << ans << endl;  	}  }  <CODESPLIT> 19
#include <iostream>  #include <vector>  #include <string>  #include <set>  using namespace std;    int main() {  	int tests;  	cin >> tests;  	for (int test = 1; test <= tests; ++test) {  		int n;  		cin >> n;  		set<double> a, b;  		for (int i = 0; i < n; ++i) {  			double w;  			cin >> w;  			a.insert(w);  		}  		for (int i = 0; i < n; ++i) {  			double w;  			cin >> w;  			b.insert(w);  		}    		set<double> a1 = a, b1 = b;  		int war = 0;  		for (int i = 0; i < n; ++i) {  			double w = *a.begin();  			a.erase(a.begin());  			set<double>::iterator it = b.lower_bound(w);  			if (it == b.end()) {  				++war;  				b.erase(b.begin());  			} else {  				b.erase(it);  			}  		}    		a = a1; b = b1;  		int dec = 0;  		for (int i = 0; i < n; ++i) {  			if (*a.begin() > *b.begin()) {  				++dec;  				a.erase(a.begin());  				b.erase(b.begin());  			} else {  				a.erase(a.begin());  				set<double>::iterator it = b.end();  				--it;  				b.erase(it);  			}  		}    		cout << "Case #" << test << ": " << dec << " " << war << endl;  	}  }  <CODESPLIT> 19
#include <iostream>  #include <vector>  using namespace std;    int main() {  	int tests;  	cin >> tests;  	for (int test = 1; test <= tests; ++test) {  		int n, m;  		cin >> n >> m;  		vector<vector<int> > a(n);  		for (int i = 0; i < n; ++i) {  			a[i].resize(m);  			for (int j = 0; j < m; ++j) {  				cin >> a[i][j];  			}  		}    		vector<int> x(n), y(m);  		for (int i = 0; i < n; ++i) {  			x[i] = a[i][0];  			for (int j = 1; j < m; ++j) {  				x[i] = max(x[i], a[i][j]);  			}  		}  		for (int j = 0; j < m; ++j) {  			y[j] = a[0][j];  			for (int i = 1; i < n; ++i) {  				y[j] = max(y[j], a[i][j]);  			}  		}    		bool ok = true;  		for (int i = 0; i < n && ok; ++i) {  			for (int j = 0; j < m; ++j) {  				if (a[i][j] != min(x[i], y[j])) {  					ok = false;  					break;  				}  			}  		}    		cout << "Case #" << test << ": " << (ok ? "YES" : "NO") << endl;  	}  }  <CODESPLIT> 19
#include <iostream>  #include <iomanip>  #include <vector>  #include <string>  using namespace std;    int main() {  	int tests;  	cin >> tests;  	for (int test = 1; test <= tests; ++test) {  		double c, f, x;  		cin >> c >> f >> x;  		double y = x / c - 2 / f - 1;  		int n = (y < 0 ? 0 : static_cast<int>(y) + 1);  		double time = 0;  		for (int i = 0; i < n; ++i) {  			time += c / (2 + i*f);  		}  		time += x / (2 + n*f);  		cout << "Case #" << test << ": "  		     << fixed << setprecision(7) << time << endl;  	}  }  <CODESPLIT> 19
#include <iostream>  #include <vector>  #include <string>  using namespace std;    int main() {  	int tests;  	cin >> tests;  	for (int test = 1; test <= tests; ++test) {  		int row;  		cin >> row;  		int first[4];  		for (int i = 0; i < 4; ++i) {  			for (int j = 0; j < 4; ++j) {  				int card;  				cin >> card;  				if (i + 1 == row) {  					first[j] = card;  				}  			}  		}    		cin >> row;  		int count = 0;  		int match;  		for (int i = 0; i < 4; ++i) {  			for (int j = 0; j < 4; ++j) {  				int card;  				cin >> card;  				if (i + 1 == row) {  					for (int k = 0; k < 4; ++k) {  						if (first[k] == card) {  							++count;  							match = card;  						}  					}  				}  			}  		}    		cout << "Case #" << test << ": ";  		if (count == 1) {  			cout << match;  		} else if (count == 0) {  			cout << "Volunteer cheated!";  		} else {  			cout << "Bad magician!";  		}  		cout << endl;  	}  }  <CODESPLIT> 19
#include <iostream>  #include <string>  using namespace std;    char m[26] = {      'y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l',      'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q'  };    int main() {  	int n;  	cin >> n;    	string s;  	getline(cin, s);    	for (int i = 1; i <= n; ++i) {  		getline(cin, s);  		cout << "Case #" << i << ": ";  		for (size_t j = 0; j < s.size(); ++j) {  			if (s[j] >= 'a' && s[j] <= 'z') {  				cout << m[s[j] - 'a'];  			} else {  				cout << s[j];  			}  		}  		cout << endl;  	}  }  <CODESPLIT> 19
#include <iostream>  using namespace std;    int main() {  	int tests;  	cin >> tests;  	for (int test = 1; test <= tests; ++test) {  		char b[4][4];  		bool has_empty = false;  		for (int i = 0; i < 4; ++i) {  			for (int j = 0; j < 4; ++j) {  				cin >> b[i][j];  				if (b[i][j] == '.') {  					has_empty = true;  				}  			}  		}    		bool xwon = false, owon = false;  		for (int i = 0; i < 4; ++i) {  			char c = b[i][0];  			if (c == 'T') {  				c = b[i][1];  			}  			if (c == '.') {  				continue;  			}  			if ((b[i][0] == c || b[i][0] == 'T') &&  				(b[i][1] == c || b[i][1] == 'T') &&  				(b[i][2] == c || b[i][2] == 'T') &&  				(b[i][3] == c || b[i][3] == 'T'))  			{  				(c == 'X' ? xwon : owon) = true;  			}  		}    		for (int j = 0; j < 4; ++j) {  			char c = b[0][j];  			if (c == 'T') {  				c = b[1][j];  			}  			if (c == '.') {  				continue;  			}  			if ((b[0][j] == c || b[0][j] == 'T') &&  				(b[1][j] == c || b[1][j] == 'T') &&  				(b[2][j] == c || b[2][j] == 'T') &&  				(b[3][j] == c || b[3][j] == 'T'))  			{  				(c == 'X' ? xwon : owon) = true;  			}  		}    		{  			char c = b[0][0];  			if (c == 'T') {  				c = b[1][1];  			}  			if (c != '.' &&  				(b[0][0] == c || b[0][0] == 'T') &&  				(b[1][1] == c || b[1][1] == 'T') &&  				(b[2][2] == c || b[2][2] == 'T') &&  				(b[3][3] == c || b[3][3] == 'T'))  			{  				(c == 'X' ? xwon : owon) = true;  			}  		}    		{  			char c = b[3][0];  			if (c == 'T') {  				c = b[2][1];  			}  			if (c != '.' &&  				(b[3][0] == c || b[3][0] == 'T') &&  				(b[2][1] == c || b[2][1] == 'T') &&  				(b[1][2] == c || b[1][2] == 'T') &&  				(b[0][3] == c || b[0][3] == 'T'))  			{  				(c == 'X' ? xwon : owon) = true;  			}  		}    		if (xwon && owon || (!xwon && !owon && !has_empty)) {  			cout << "Case #" << test << ": Draw" << endl;  		} else if (xwon) {  			cout << "Case #" << test << ": X won" << endl;  		} else if (owon) {  			cout << "Case #" << test << ": O won" << endl;  		} else {  			cout << "Case #" << test << ": Game has not completed" << endl;  		}  	}  } <CODESPLIT> 19
#include <iostream>  #include <vector>  #include <string>  using namespace std;    int main() {  	int tests;  	cin >> tests;  	for (int test = 1; test <= tests; ++test) {  		char s[50][50];  		int r, c, m;  		cin >> r >> c >> m;  		int f = r*c - m;    		for (int i = 0; i < r; ++i) {  			for (int j = 0; j < c; ++j) {  				s[i][j] = '.';  			}  		}  		cout << "Case #" << test << ":" << endl;  		if (r == 1) {  			for (int j = c - m; j < c; ++j) {  				s[0][j] = '*';  			}  			s[0][0] = 'c';  		} else if (c == 1) {  			for (int i = r - m; i < r; ++i) {  				s[i][0] = '*';  			}  			s[0][0] = 'c';  		} else if (f == 0) {  			s[0][0] = 'c';  		} else if (f == 1) {  			for (int i = 0; i < r; ++i) {  				for (int j = 0; j < c; ++j) {  					s[i][j] = (i == 0 && j == 0 ? 'c' : '*');  				}  			}  		} else if (r == 2) {  			if (f == 2 || m % 2 != 0) {  				cout << "Impossible" << endl;  				continue;  			}  			for (int i = 0; i < r; ++i) {  				for (int j = c - m / 2; j < c; ++j) {  					s[i][j] = '*';  				}  			}  			s[0][0] = 'c';  		} else if (c == 2) {  			if (f == 2 || m % 2 != 0) {  				cout << "Impossible" << endl;  				continue;  			}  			for (int i = r - m / 2; i < r; ++i) {  				for (int j = 0; j < c; ++j) {  					s[i][j] = '*';  				}  			}  			s[0][0] = 'c';  		} else {  			if (f == 2 || f == 3 || f == 5 || f == 7) {  				cout << "Impossible" << endl;  				continue;  			}  			int r1 = r, m1 = m;  			while (r1 > 3 && m1 >= c) {  				for (int j = 0; j < c; ++j) {  					s[r1 - 1][j] = '*';  				}  				--r1;  				m1 -= c;  			}  			if (r1 > 3 && m1 > 0) {  				if (m1 <= c - 2) {  					for (int j = c - m1; j < c; ++j) {  						s[r1 - 1][j] = '*';  					}  					m1 = 0;  				} else {  					for (int j = 2; j < c; ++j) {  						s[r1 - 1][j] = '*';  					}  					s[r1 - 2][c - 1] = '*';  					m1 = 0;  				}  			}  			int c1 = c;  			while (c1 > 3 && m1 >= 3) {  				for (int i = 0; i < 3; ++i) {  					s[i][c1 - 1] = '*';  				}  				--c1;  				m1 -= 3;  			}  			if (c1 > 3 && m1 > 0) {  				if (m1 == 1) {  					s[2][c1 - 1] = '*';  					m1 = 0;  				} else {  					s[2][c1 - 1] = '*';  					s[2][c1 - 2] = '*';  					m1 = 0;  				}  			}  			if (m1 == 1) {  				s[2][2] = '*';  			} else if (m1 == 3) {  				s[0][2] = s[1][2] = s[2][2] = '*';  			} else if (m1 == 5) {  				s[0][2] = s[1][2] = s[2][2] = '*';  				s[2][0] = s[2][1] = '*';  			}  			s[0][0] = 'c';  		}    		for (int i = 0; i < r; ++i) {  			for (int j = 0; j < c; ++j) {  				cout << s[i][j];  			}  			cout << endl;  		}  	}  }  <CODESPLIT> 19
#include <iostream>  #include <tr1/unordered_set>  using namespace std;    int p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000};    int main() {  	int test_count;  	cin >> test_count;  	for (int test = 1; test <= test_count; ++test) {  		int a, b;  		cin >> a >> b;  		int digits = 0;  		int aa = a;  		while (aa > 0) {  			digits += 1;  			aa /= 10;  		}    		int count = 0;  		tr1::unordered_set<int> mm;  		for (int n = a; n < b; ++n) {  			mm.clear();  			for (int k = 1; k < digits; ++k) {  				int m = n / p10[k] + (n % p10[k]) * p10[digits - k];  				if (m > n && m <= b) {  					mm.insert(m);  				}  			}  			count += mm.size();  		}    		cout << "Case #" << test << ": " << count << endl;  	}  }  <CODESPLIT> 19
#!/usr/bin/python    import sys  import math    def readfile(file):    """      input:    		T (number of test cases)    		A B      """      tests = []      T = int(file.readline().strip())      for i in xrange(T):  		test = {}    		line = file.readline().strip()  		parts = line.split(" ")    		if len(parts) != 2:  			print "HORRIBLE ERROR IN TEST CASE %d" % (i+1,)  			return None    		test['A'] = int(parts[0])  		test['B'] = int(parts[1])        		tests.append(test)      return tests    def isPalindrome(s):  	"""  		Is s a palindrome.    		S must be a string.  	"""    	l = len(s)    	if (l % 2) == 0:  		# even  		frontHalf = s[0:l/2]  		backHalf = s[l/2:]  	else:  		# odd  		frontHalf = s[0:(l-1)/2]  		backHalf = s[(l+1)/2:]    	backHalf = backHalf[::-1]    	if frontHalf == backHalf:  		return True  	else:  		return False    def isFairAndSquare(n):    	sqrtN = int(math.sqrt(n))    	if (sqrtN * sqrtN) != n:  		#print "%d is not square" % (n, )  		return False    	if not isPalindrome(str(n)):  		#print "%d is not palindrome" % (n, )  		return False    	if not isPalindrome(str(sqrtN)):  		#print "sqrt(%d) = %d is not palindrome" % (n, sqrtN)  		return False    	return True    def run(test):  	"""  		Run a test and return output.  	"""    	count = 0    	for i in xrange(test['A'], test['B'] + 1):  		if isFairAndSquare(i):  			count = count + 1    	return count    	i = int(math.sqrt(test['A']))    	if (i * i) < test['A']:  		i = i + 1    	# Generate squares from palindromes  	while i < test['B']:  		#print "Checking %d" % (i, )  		if not isPalindrome(str(i)):  			i = i + 1  			continue    		# square it  		s = i * i    		if s <= test['B']:  			if isPalindrome(str(s)):  				#print "Counting %d" % (i * i, )  				count = count + 1  		else:  			# all done  			break    		i = i + 1    	return "%s" % (count, )    file = open(sys.argv[1], "rt")    tests = readfile(file)    file.close()    case = 1    for test in tests:  #if True:    #test = tests[0]    result = run(test)    print "Case #%d: %s" % (case, result)    case = case + 1  <CODESPLIT> 20
#!/usr/bin/python    def readfile(filename):  	"""  		The first line of the input gives the number of test  		cases, T. T test cases follow. Each test case consists of  		a single line containing integers separated by single  		spaces. The first integer will be N, the number of  		Googlers, and the second integer will be S, the number  		of surprising triplets of scores. The third integer will  		be p, as described above. Next will be N integers ti:  		the total points of the Googlers.  	"""    	file = open(filename, "rt")    	retval = {}    	T = int(file.readline().strip())  	retval['T'] = T    	tests = []    	for i in xrange(T):  		line = file.readline().strip()    		parts = line.split(" ")    		N = int(parts[0])  		S = int(parts[1])  		p = int(parts[2])  		t = []    		for j in xrange(N):  			t = t + [int(parts[3 + j]), ]    		test = { 'N' : N, 'S': S, 'p' : p, 't' : t }  		tests = tests + [test, ]    	retval['tests'] = tests  	return retval    def spread(triplet):  	return max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))    def bestresult(triplet):  	if triplet:  		return max(triplet)  	return 0    def getcombos(points):  	"""  		Returns ([unsurprising possibilities, ], [surprising possibilities])  	"""    	unsurps = []  	surps = []    	avg = points / 3.0    	# Go from (avg-2) to (avg+3) to account for rounding  	avg = int(avg)    	tested = []    	for i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):  		for j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):  			for k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):  				if (i + j + k) != points:  					continue    				scores = (i,j,k)  				scores = sorted(scores)    				if scores in tested:  					continue  				tested.append(scores)    				s = spread((i,j,k))    				if (s < 2):  					unsurps.append(scores)  				elif (s == 2):  					surps.append(scores)  				else:  					continue    	return (unsurps, surps)    def getbesttriplet(triplets):  	best = None    	for i in triplets:  		if best:  			if (bestresult(i) > bestresult(best)):  				best = i  		else:  			best = i    	return best  	    def getmulticombos(peeps):  	"""  		Return the best surprising and non-surprising possibility for  		each person.  	"""    	ret = []    	for p in peeps:  		u,s = getcombos(p)    		bestu = getbesttriplet(u)  		bests = getbesttriplet(s)    		ret.append((bestu, bests))    	return ret    def getbestresults(scores, best, numsur):  	"""  		Figure out the maximum number of people that could have gotten  		a single score >= best.  Limited to choosing only numsur surprising  		triplets.  	"""    	peeps = getmulticombos(scores)    	count = 0  	surcount = 0    	for p in peeps:  		if (bestresult(p[0]) >= best):  			# unsurprising is good  			count = count + 1  		elif ((bestresult(p[1]) >= best) and (surcount < numsur)):  			count = count + 1  			surcount = surcount + 1    	return count    def process(test):  	N = test['N']  	S = test['S']  	p = test['p']  	t = test['t']    	return getbestresults(t, p, S)    data = readfile("B-small-attempt0.in")    for i in xrange(data['T']):  	test = data['tests'][i]    	result = process(test)    	print "Case #%d: %d" % (i+1, result)  <CODESPLIT> 20
#!/usr/bin/python    import sys    import puzutils    class War_2014_QD(puzutils.CodeJamProblem):    def __init__(self, inputFilename):      puzutils.CodeJamProblem.__init__(self, inputFilename)        self.T = None      def load(self):      """        input:          T (number of test cases)          N (number of blocks)        N1 N2 N3 ... (mass of Naomi's blocks, real)        K1 K2 K3 ... (mass of Ken's blocks, real)        """        self.tests = []        with open(self.inputFilename, "rt") as file:        self.T = int(file.readline().strip())          for i in xrange(self.T):          N = int(file.readline().strip())          naomi = [float(x) for x in file.readline().split(' ')]          ken = [float(x) for x in file.readline().split(' ')]            test = {'N': N, 'Naomi': naomi, 'Ken': ken}            self.tests.append(test)        return True      def playWar(self, naomi, ken):      """        How many points does naomi get when playing standard War?      """        if (len(naomi) <= 0):        return 0        # Just choose the biggest?      maxN = max(naomi)        # Can ken win?      maxK = max(ken)        if maxK > maxN:        # Ken uses the smallest one that will beat her        k = min([x for x in ken if x > maxN])          #print "Ken wins (%.3f > %.3f), max %.3f" % (k, maxN, maxK)          naomi.remove(maxN)        ken.remove(k)          return 0 + self.playWar(naomi, ken)      else:        # Ken loses his smallest        k = min(ken)          #print "Ken loses (%.3f < %.3f), max %.3f" % (k, maxN, maxK)          naomi.remove(maxN)        ken.remove(k)          return 1 + self.playWar(naomi, ken)      def playDWar(self, naomi, ken):      """        How many points does naomi get when playing decietful war?      """        if (len(naomi) <= 0):        return 0        minN = min(naomi)      minK = min(ken)      maxK = max(ken)        if (minN < minK):        # This is a guaranteed loser, take a big one down with it        naomi.remove(minN)        ken.remove(maxK)        return 0 + self.playDWar(naomi, ken)        # Use our smallest one to beat his smallest one, by lying and      # saying ours is bigger than his biggest      naomi.remove(minN)      ken.remove(minK)      return 1 + self.playDWar(naomi, ken)      def executeTest(self, test):      """        Run a test and return output.      """        dwar = self.playDWar(list(test['Naomi']), list(test['Ken']))      war = self.playWar(list(test['Naomi']), list(test['Ken']))      return "%d %d" % (dwar, war)    with War_2014_QD(sys.argv[1]) as problem:    problem.load()      problem.run()  <CODESPLIT> 20
#!/usr/bin/python    import sys    def readfile(file):    """      input:    		T (number of test cases)    		N M  		N lines of M numbers (desired height of grass)      """      tests = []      T = int(file.readline().strip())      for i in xrange(T):  		test = {}    		line = file.readline().strip()  		parts = line.split(' ')    		if len(parts) != 2:  			print "HORRIBLE ERROR in TEST %d!" % (i+1, )  			return None    		N = int(parts[0])  		M = int(parts[1])    		test['N'] = N  		test['M'] = M  		test['desired'] = []        		for j in xrange(N):  			line = file.readline().strip()  			parts = line.split(' ')    			if len(parts) != M:  				print "TERRIBLE ERROR in TEST %d!" % (i+1, )  				return None    			for p in parts:  				k = int(p)  				test['desired'].append(k)    		tests.append(test)      return tests    def run(test):  	"""  		Run a test and return output.  	"""    	# Figure out row/col min and max  	test['row'] = []  	test['col'] = []    	for row in xrange(test['N']):  		r = []    		for col in xrange(test['M']):  			i = row * test['M'] + col    			r.append(test['desired'][i])    		test['row'].append({'min' : min(r), 'max' : max(r)})    	for col in xrange(test['M']):  		c = []    		for row in xrange(test['N']):  			i = row * test['M'] + col    			c.append(test['desired'][i])    		test['col'].append({'min' : min(c), 'max' : max(c)})    	for x in xrange(test['M']):  		for y in xrange(test['N']):  			i = y * test['M'] + x  			v = test['desired'][i]    			# If you are smaller than someone in both directions, it's impossible  			rowmax = test['row'][y]['max']  			colmax = test['col'][x]['max']  			if (v < rowmax) and (v < colmax):  				#print "(%d,%d) = %d, row = %d, col = %d" % (x, y, v, rowmax, colmax)  				return "NO"    	return "YES"    file = open(sys.argv[1], "rt")    tests = readfile(file)    file.close()    case = 1    for test in tests:  #if True:    #test = tests[0]    result = run(test)    print "Case #%d: %s" % (case, result)    case = case + 1  <CODESPLIT> 20
#!/usr/bin/python    import sys    import puzutils    class Cookie_2014_QB(puzutils.CodeJamProblem):    def __init__(self, inputFilename):      puzutils.CodeJamProblem.__init__(self, inputFilename)        self.T = None      def load(self):      """        input:          T (number of test cases)          C F X (real numbers)        """        self.tests = []        with open(self.inputFilename, "rt") as file:        self.T = int(file.readline().strip())          for i in xrange(self.T):          (C,F,X) = [float(x) for x in file.readline().split(' ')]            self.tests.append([C,F,X])        return True      def timeToNextFarm(self, C, rate):      """        How long in seconds until we get the next farm.      """        return (C * 1.0) / rate      def timeToTarget(self, C, X, rate):      """        How long in seconds until we hit the target.      """        return ( X * 1.0) / rate      def isFarmWorthIt(self, C, X, F, rate):      #print "C = %.2f, F = %.2f, X = %.2f, rate = %.2f" % (C, F, X, rate)        withoutFarm = self.timeToTarget(C, X, rate)      withFarm = self.timeToNextFarm(C, rate) + self.timeToTarget(C, X, rate + F)        #print "With farm = %.2f" % (withFarm,)      #print "Without farm = %.2f" % (withoutFarm,)        if (withFarm < withoutFarm):        return True      else:        return False      def executeTest(self, test):      """        Run a test and return output.      """        (C,F,X) = test      rate = 2      elapsed = 0.0        #print "C = %.2f, F = %.2f, X = %.2f, rate = %.2f" % (C, F, X, rate)        while True:        if self.isFarmWorthIt(C, X, F, rate):          #print "%.2f: Bought farm, rate = %d" % (elapsed, rate)          elapsed = elapsed + self.timeToNextFarm(C, rate)          rate = rate + F        else:          #print "%.2f: Giving up and finishing it out, rate = %d" % (elapsed, rate)          elapsed = elapsed + self.timeToTarget(C, X, rate)          return "%0.7f" % (elapsed, )    with Cookie_2014_QB(sys.argv[1]) as problem:    problem.load()      problem.run()  <CODESPLIT> 20
#!/usr/bin/python    import sys    import puzutils    class Magic_2014_QA(puzutils.CodeJamProblem):    def __init__(self, inputFilename):      puzutils.CodeJamProblem.__init__(self, inputFilename)        self.T = None      def load(self):      """        input:          T (number of test cases)          A (answer to first question)        x x x x        x x x x        x x x x        x x x x        B (answer to second question)        x x x x        x x x x        x x x x        x x x x        """        self.tests = []        with open(self.inputFilename, "rt") as file:        self.T = int(file.readline().strip())          for i in xrange(self.T):          a = int(file.readline().strip())          test = {'a': a}          board = []                    for j in xrange(4):            line = file.readline().strip()            row = set([int(x) for x in line.split(' ')])            board.append(row)            test['aboard'] = board            b = int(file.readline().strip())          test['b'] = b          board = []                    for j in xrange(4):            line = file.readline().strip()            row = set([int(x) for x in line.split(' ')])            board.append(row)            test['bboard'] = board            self.tests.append(test)        return True      def executeTest(self, test):      """        Run a test and return output.      """        #print "Test: %s\n" % (test, )        rowA = test['aboard'][test['a'] - 1]      rowB = test['bboard'][test['b'] - 1]        #print "rowA: %s\nrowB: %s\n" % (rowA, rowB)        intersect = rowA.intersection(rowB)        #print "intersect: %s\n" % (intersect, )        if (len(intersect) == 1):        (element,) = intersect        return element      elif (len(intersect) == 0):        return "Volunteer cheated!"      else:        return "Bad magician!"    with Magic_2014_QA(sys.argv[1]) as problem:    problem.load()      problem.run()  <CODESPLIT> 20
#!/usr/bin/python    from string import maketrans    input = "aoz"  outpt = "yeq"    input = input + "our language is impossible to understand"  outpt = outpt + "ejp mysljylc kd kxveddknmc re jsicpdrysi"    input = input + "there are twenty six factorial possibilities"  outpt = outpt + "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"    input = input + "so it is okay if you want to just give up"  outpt = outpt + "de kr kd eoya kw aej tysr re ujdr lkgc jv"    input = input + "q"  outpt = outpt + "z"    togoog = maketrans(input, outpt)  ungoog = maketrans(outpt, input)    filename = "A-small-attempt1.in"    file = open(filename, "rt")    T = int(file.readline().strip())    for i in xrange(T):  	line = file.readline().strip()    	print "Case #%d: %s" % (i + 1, line.translate(ungoog))  <CODESPLIT> 20
#!/usr/bin/python    import sys    def readfile(file):    """      input:    		T (number of test cases)    		xxxx  		xxxx  		xxxx  		xxxx	(T boards, where x in [X,O,T,.]      """      tests = []      T = int(file.readline().strip())      for i in xrange(T):  		board = ""        		for j in xrange(4):  			line = file.readline().strip()    			board = board + line    		file.readline()    		tests.append(board)      return tests    def fourInARow(who, test):  	"""  		Find four of 'who' in a row (T wild).  	"""    	target = (who, 'T')    	# Horizontal/Vertical  	for i in range(4):  		horzWin = True  		vertWin = True    		for j in range(4):  			horzIndex = i * 4 + j  			vertIndex = j * 4 + i    			if not (test[horzIndex] in target):  				horzWin = False    			if not (test[vertIndex] in target):  				vertWin = False    		if horzWin or vertWin:  			return True    	# Diagonal  	slashWin = True  	bslashWin = True    	for i in range(4):  		x = y = i    		slashIndex = y * 4 + x  		bslashIndex = y * 4 + (3 - x)    		#print "Checking (%d,%d) = %s and (%d,%d) = %s" % (x, y, test[slashIndex], 3-x, y, test[bslashIndex])    		if not (test[slashIndex] in target):  			slashWin = False    		if not (test[bslashIndex] in target):  			bslashWin = False    	if slashWin or bslashWin:  		return True    	return False    def run(test):  	"""  		Run a test and return output.  	"""    	if fourInARow('X', test):  		return "X won"  	elif fourInARow('O', test):  		return "O won"  	elif '.' in test:  		return "Game has not completed"  	else:  		return "Draw"    file = open(sys.argv[1], "rt")    tests = readfile(file)    file.close()    case = 1    for test in tests:  #if True:    #test = tests[0]    result = run(test)    print "Case #%d: %s" % (case, result)    case = case + 1  <CODESPLIT> 20
#!/usr/bin/python    import sys    import puzutils    class Minesweeper_2014_QC(puzutils.CodeJamProblem):    def __init__(self, inputFilename):      puzutils.CodeJamProblem.__init__(self, inputFilename)        self.T = None      def load(self):      """        input:          T (number of test cases)          R C M (integers)        """        self.tests = []        with open(self.inputFilename, "rt") as file:        self.T = int(file.readline().strip())          for i in xrange(self.T):          (R,C,M) = [int(x) for x in file.readline().split(' ')]            self.tests.append([R,C,M])        return True      def boardToString(self, board):      retval = ""        for row in board:        retval = retval + "\n" + "".join(row)        return retval      def executeTest(self, test):      """        Run a test and return output.      """        (R,C,M) = test      #print "R: %d, C: %d, M: %d" % (R,C,M)        spaces = R * C      blanks = spaces - M        if (blanks <= 0):        #print "R: %d, C: %d, M: %d, spaces: %d, blanks: %d" % (R,C,M,spaces,blanks)        return "Impossible"        board = [['.' for x in range(C)] for y in range(R)]        board[R-1][C-1] = "c"        badpositions=[]      positions=[]        for x in xrange(C):        for y in xrange(R):          if (x == (C-1)) and (y == (R-1)):            continue          if (x == (C-1)) and (y == (R-2)):            badpositions.append((x,y))            continue          if (x == (C-2)) and (y == (R-1)):            badpositions.append((x,y))            continue          if (x == (C-2)) and (y == (R-2)):            badpositions.append((x,y))            continue            positions.append((x,y))        positions.reverse()        for x in badpositions:        positions.insert(0, x)        m = M        while (m > 0):        if len(positions) <= 0:          #return self.boardToString(board)          return "Impossible"          pos = positions.pop()        (x,y) = pos          if (board[y][x] != "."):          #return self.boardToString(board)          return "Impossible"          board[y][x] = '*'        m = m - 1        mines = sum([x.count('*') for x in board])        if (mines != M):        #return self.boardToString(board)        return "Impossible"        if (blanks > 1):        if (R > 1):          if board[R - 2][C - 1] == "*":            #return self.boardToString(board)            return "Impossible"          if (C > 1):          if board[R - 1][C - 2] == "*":            #return self.boardToString(board)            return "Impossible"          if (R > 1) and (C > 1):          if board[R - 2][C - 2] == "*":            #return self.boardToString(board)            return "Impossible"        #return "Possible"      return self.boardToString(board)    with Minesweeper_2014_QC(sys.argv[1]) as problem:    problem.load()      problem.run()  <CODESPLIT> 20
#!/usr/bin/python    def readfile(filename):  	"""  	The first line of the input gives the number of test cases,  	T. T test cases follow. Each test case consists of a single line  	containing the integers A and B.  	"""    	file = open(filename, "rt")    	retval = {}    	T = int(file.readline().strip())  	retval['T'] = T    	tests = []    	for i in xrange(T):  		line = file.readline().strip()    		parts = line.split(" ")    		A = int(parts[0])  		B = int(parts[1])    		test = {'A' : A, 'B' : B}    		tests = tests + [test, ]    	retval['tests'] = tests    	return retval    def isrecycled(n, m):  	if (len(n) != len(m)):  		return False    	for i in range(len(n)):  		left = n[:i]  		right = n[i:]    		flip = right + left    		if (flip == m):  			return True    	return False    def process(test):  	count = 0    	A = test['A']  	B = test['B']    	for n in xrange(A, B):  		for m in xrange(n + 1, B):  			if (isrecycled(str(n), str(m))):  				count = count + 1    	return count    def process2(test):  	count = 0    	A = test['A']  	B = test['B']    	for n in xrange(A, B):  		v = str(n)    		found = set()    		for i in xrange(len(v)):  			left = v[:i]  			right = v[i:]    			flip = right + left  			iflip = int(flip)    			if ((iflip > n) and (iflip <= B)):  				if (not iflip in found):  					count = count + 1  					found.add(iflip)    	return count    data = readfile("C-small-attempt0.in")    for i in xrange(data['T']):  	test = data['tests'][i]    	result = process2(test)    	print "Case #%d: %d" % (i + 1, result)  <CODESPLIT> 20
#!/usr/bin/python3  #  # Some notes:  # - It's better to find palindromes in the square rooted numbers (there will be a lot fewer)  # - It's also much faster to generate the palindromes than to detect if a random number is a palindrome  #   - Number of palindromes with n digits: 10^(ceil(n/2))  #   - E.g, 3 digits => 10^2  -  4 digits => 10^2  -  5 digits => 10^3  # - So the problem is reduced to generate the palindromes which are still palindromes when squared  #  # - And how to detect is a squared palindrome is still a palindrome? Easy, let's draw a multiplication:  #          1 2 1  #          1 2 1  #       --------  #          1 2 1  #        2 4 2  #      1 2 1  #      ---------  #      1 4 6 4 1  #  #   - The extreme case is the central column. If the sum is >=10, then resulting number will not be a palindrome  #   - As the original number is a palindrome, this central column will always be the sum of the squares of all  #     the digits in the number. E.g: 121 => 1^2 + 2^2 + 1^2 = 1 + 4 + 1 = 6 => less than 10 => square is a palindrome  #   - This means that palindromes with digits 4-9 can never become a palindrome when squared  #   - 3 can only appear once => 3 is the only valid number containing digit 3  #   - 2 can appear at most twice:  #     - 2 twos + 0/1 one (in this case 2 have to be the first and last digit)  #     - 1 two + 0/2/4 ones (in this case 2 has to be in the middle position)  #   - 1 can appear alone up to 9 times  #   - 0 can appear as many times as you want  #      import sys  import math    # This is the same as findpalindromes, but much faster (it just calculates the combinations  # instead of obtaining all the actual numbers)  def calculatepalindromes(ndigits):      # Special case: only 1 digit      if ndigits == 1:          return 3        result = 0      isEven = ndigits % 2 == 0      fillingdigits = math.floor((ndigits - 2)/2)        # Palindromes with 2's      if isEven:          result += 1      else:          result += 3        # Palindromes with only 1's      for numones in range(0, min(6, fillingdigits) + 1):          combinations = int(math.factorial(fillingdigits) / (math.factorial(fillingdigits-numones) * math.factorial(numones)))          result += combinations          if not isEven:              result += combinations        return result      def findpalindromes(ndigits):      # Special case: only 1 digit      if ndigits == 1:          return [1, 2, 3]        result = []      isEven = ndigits % 2 == 0      fillingdigits = math.floor((ndigits - 2)/2)        # Palindromes with 2's      if isEven:          result.append(int("2" + "0"*(fillingdigits*2) + "2"))      else:          result.append(int("2" + "0"*fillingdigits + "0" + "0"*fillingdigits + "2"))          result.append(int("2" + "0"*fillingdigits + "1" + "0"*fillingdigits + "2"))          result.append(int("1" + "0"*fillingdigits + "2" + "0"*fillingdigits + "1"))        # Palindromes with only 1's      for numones in range(0, min(6, fillingdigits)+1):          ones = fillOnes([], fillingdigits, numones)          for o in ones:              if isEven:                  result.append(int("1" + "".join(o) + "".join(list(reversed(o))) + "1"))              else:                  result.append(int("1" + "".join(o) + "0" + "".join(list(reversed(o))) + "1"))                  result.append(int("1" + "".join(o) + "1" + "".join(list(reversed(o))) + "1"))        return result    def fillOnes(combination, size, remainingOnes):      if len(combination) == size:          return [combination]      result = []      if remainingOnes > 0:          c = combination + ["1"]          result += fillOnes(c, size, remainingOnes - 1)      if remainingOnes < size - len(combination):          c = combination + ["0"]          result += fillOnes(c, size, remainingOnes)      return result        ncases = int(sys.stdin.readline())    for t in range(1, ncases+1):      fairsquare = 0      (a, b) = sys.stdin.readline().strip().split(" ")      intA = int(a)      intB = int(b)      ndigitsA = len(a)      ndigitsB = len(b)      ndigitsARooted = math.ceil(ndigitsA/2)      ndigitsBRooted = math.ceil(ndigitsB/2)        if ndigitsBRooted == ndigitsARooted:          palindromes = findpalindromes(ndigitsARooted)          for p in palindromes:              if p ** 2 >= intA and p ** 2 <= intB:                  fairsquare +=1      else:          palindromes = findpalindromes(ndigitsARooted)          for p in palindromes:              if p ** 2 >= intA:                  fairsquare +=1            for i in range(ndigitsARooted + 1, ndigitsBRooted):              fairsquare += calculatepalindromes(i)            palindromes = findpalindromes(ndigitsBRooted)          for p in palindromes:              if p ** 2 <= intB:                  fairsquare +=1        print("Case #%d: %d" % (t, fairsquare))  <CODESPLIT> 21
#!/usr/bin/python3    import sys  import math    def findbest(score):  	# Corner case  	if score == 0: return (0, 0)    	best = math.ceil(score / 3)  	bestsurp = round(score / 3) + 1    	return (best, bestsurp)  	  # Ignore the number of cases  sys.stdin.readline()    casenum = 0  for line in sys.stdin:  	casenum += 1    	data = line.strip().split(' ')  	maxsurprising = int(data[1])  	p = int(data[2])  	scores = data[3:]  	maxgooglers = 0    	for s in scores:  		(best, bestsurp) = findbest(int(s))  		if best >= p:  			maxgooglers += 1  		else:  			if bestsurp >= p and maxsurprising > 0:  				maxgooglers += 1  				maxsurprising -= 1    	print("Case #%d: %d" % (casenum, maxgooglers))  <CODESPLIT> 21
#!/usr/bin/python3  # Strategies:  # 0. Sort both lists of block weights  # Deceitful War:  # 1. Walk through her own blocks from the lightest to the heaviest one  # 2. If the block is lighter than the lightest one from Ken, Naomi will tell a weight slightly lower than Ken's biggest one. So Ken wins, but he loses his heaviest block  # 3. If the block is heavier than the lightest one from Ken, Naomi will tell a weight slightly higher than Ken's heaviest block. So Naomi wins, and Ken loses his lightest block  # Standard War:  # 1. Walk through her own blocks from the heaviest to the lightest one (there's no difference in the order for the result, but this way it's easier to compare)  # 2. If the block is heavier than the heaviest one from Ken, Naomi wins, and Ken loses his lightest block  # 3. If the block is lighter than the heaviest one from Ken, Ken wins, and Ken loses his heaviest block    import sys    ncases = int(sys.stdin.readline().strip())    for t in range(1, ncases+1):      nblocks = int(sys.stdin.readline().strip())      naomi_blocks = [float(x) for x in sys.stdin.readline().strip().split()]      ken_blocks = [float(x) for x in sys.stdin.readline().strip().split()]        naomi_blocks.sort()      ken_blocks.sort()        # Deceitful War      ken_lightest = 0      ken_heaviest = nblocks-1      points_deceitful = 0        for i in range(0, nblocks):          if naomi_blocks[i] > ken_blocks[ken_lightest]:              points_deceitful += 1              ken_lightest += 1          else:              ken_heaviest -= 1        # Standard War      ken_lightest = 0      ken_heaviest = nblocks-1      points_standard = 0        for i in range(nblocks-1, -1, -1):          if naomi_blocks[i] > ken_blocks[ken_heaviest]:              points_standard += 1              ken_lightest += 1          else:              ken_heaviest -= 1        print("Case #{0}: {1} {2}".format(t, points_deceitful, points_standard))  <CODESPLIT> 21
#!/usr/bin/python3    import sys    ncases = int(sys.stdin.readline())    for t in range(1, ncases+1):      (n, m) = [int(x) for x in sys.stdin.readline().strip().split(" ")]      lawn = []      cuttable = []      for row in range(0, n):          lawn.append([int(x) for x in sys.stdin.readline().strip().split(" ")])          cuttable.append([False for x in range(0, m)])        # Find cuttable squares in rows      for row in range(0, n):          rowdata = lawn[row]          maxheight = max(rowdata)          for col in range(0, m):              if lawn[row][col] == maxheight:                  cuttable[row][col] = True        # Find cuttable squares in columns      for col in range(0, m):          coldata = [x[col] for x in lawn]          maxheight = max(coldata)          for row in range(0, n):              if lawn[row][col] == maxheight:                  cuttable[row][col] = True        # Find if there's any square that is not cuttable      result = True      for row in range(0, n):          for col in range(0, m):              if not cuttable[row][col]:                  result = False                  break          if result == False:              break        if result == False:          print("Case #%d: NO" % t)      else:          print("Case #%d: YES" % t)  <CODESPLIT> 21
#!/usr/bin/python3    import sys    ncases = int(sys.stdin.readline().strip())    for t in range(1, ncases+1):      values = sys.stdin.readline().split()      c = float(values[0])      f = float(values[1])      x = float(values[2])      r = 2        time = 0        while True:          tdirect = x/r          tfactory = c/r + x/(r+f)            if tdirect<tfactory:              time += tdirect              break          else:              time += c/r              r += f        print("Case #{0}: {1:.7f}".format(t, time))  <CODESPLIT> 21
#!/usr/bin/python3    import sys    ncases = int(sys.stdin.readline().strip())    def read_arrangement():      arr = []      for row in range(0,4):          arr.append(sys.stdin.readline().strip().split(' '))      return arr    for t in range(1, ncases+1):      answer1 = int(sys.stdin.readline().strip())      arrang1 = read_arrangement()      answer2 = int(sys.stdin.readline().strip())      arrang2 = read_arrangement()        row1 = arrang1[answer1-1]      row2 = arrang2[answer2-1]        intersect = set(row1) & set(row2)        if len(intersect) == 1:          print("Case #{0}: {1}".format(t, intersect.pop()))      elif len(intersect) == 0:          print("Case #{0}: Volunteer cheated!".format(t))      else:          print("Case #{0}: Bad magician!".format(t))  <CODESPLIT> 21
#!/usr/bin/python3    import sys    reverseMappings = {  'a': 'y',  'b': 'h',  'c': 'e',  'd': 's',  'e': 'o',  'f': 'c',  'g': 'v',  'h': 'x',  'i': 'd',  'j': 'u',  'k': 'i',  'l': 'g',  'm': 'l',  'n': 'b',  'o': 'k',  'p': 'r',  'q': 'z',  'r': 't',  's': 'n',  't': 'w',  'u': 'j',  'v': 'p',  'w': 'f',  'x': 'm',  'y': 'a',  'z': 'q',  ' ': ' '  }    def reverse(string):  	return ''.join([reverseMappings[c] for c in string])    # Ignore number of tests  sys.stdin.readline()    casenum=0  for line in sys.stdin:  	casenum += 1  	reversed = reverse(line.strip())  	print("Case #%d: %s" % (casenum, reversed))  <CODESPLIT> 21
#!/usr/bin/python3    import sys    ncases = int(sys.stdin.readline())    for t in range(1, ncases+1):      board = []      winner = False      numDots = 0        # Fill the board while finding the winning rows      for row in range(0, 4):          rowdata = sys.stdin.readline().strip()          board.append([])          numX = 0          numO = 0          for col in range(0, 4):              value = rowdata[col]              if value == ".":                  numDots += 1              if value == "X":                  numX += 1              if value == "O":                  numO += 1              if value == "T":                  numX += 1                  numO += 1              board[row].append(value)          if numX == 4:              winner = True              print("Case #%d: X won" % t)              break          if numO == 4:              winner = True              print("Case #%d: O won" % t)              break      while sys.stdin.readline().strip() != "": pass        if winner == True: continue        # Find columns      for col in range(0, 4):          numX = 0          numO = 0          for row in range(0, 4):              value = board[row][col]              if value == "X":                  numX += 1              if value == "O":                  numO += 1              if value == "T":                  numX += 1                  numO += 1          if numX == 4:              winner = True              print("Case #%d: X won" % t)              break          if numO == 4:              winner = True              print("Case #%d: O won" % t)              break        if winner == True: continue        # Find first diagonal      numX = 0      numO = 0      for rowcol in range(0, 4):          value = board[rowcol][rowcol]          if value == "X":              numX += 1          if value == "O":              numO += 1          if value == "T":              numX += 1              numO += 1      if numX == 4:          print("Case #%d: X won" % t)          continue      if numO == 4:          print("Case #%d: O won" % t)          continue        # Find second diagonal      numX = 0      numO = 0      for rowcol in range(0, 4):          value = board[rowcol][3-rowcol]          if value == "X":              numX += 1          if value == "O":              numO += 1          if value == "T":              numX += 1              numO += 1      if numX == 4:          print("Case #%d: X won" % t)          continue      if numO == 4:          print("Case #%d: O won" % t)          continue        # Final case      if numDots == 0:          print("Case #%d: Draw" % t)      else:          print("Case #%d: Game has not completed" % t)    <CODESPLIT> 21
#!/usr/bin/python3  #  # Algorithm:  # - For boards with one row: you need at least 1 free cells  # - For boards with two rows, you need either 1 or at least 4 free cells  #   - It needs to be an even number!  # - For general boards, you need either 1 or at least 4 free cells (except 5 or 7)  #  # - To fill the board, you cannot have a row or a column with only one  #   free cell, so you fill it in groups of two.  #  #   - First you start with the minimum of 4:  #       c . * * * *  #       . . * * * *  #       * * * * * *  #  #   - Then you fill next columns and rows two by two:  #       c . % * * *  #       . . % * * *  #       * * * * * *  #  #       c . . * * *  #       . . . * * *  #       % % * * * *  #  #       c . . % * *  #       . . . % * *  #       . . * * * *  #  #   - In case there's a pending free cell, you simply fill it in the inner board:  #       c . . . * *  #       . . . . * *  #       . . % * * *  #  #   - In case you fill the outer border, you simply start filling the inner board:  #       c . . . . %  #       . . . . . %  #       . . * * * *  #  #       c . . . . .  #       . . . . . .  #       . . % * * *  #    import sys    ncases = int(sys.stdin.readline().strip())    def print_board(r, c, free):      board = {}      for row in range(0, r):          board[row] = {}          for col in range(0, c):              board[row][col] = '*'        pending = free        if free == 1:          board[0][0] = '.'      elif r == 1 or c == 1:          for row in range(0, r):              for col in range(0, c):                  if pending > 0:                      pending -= 1                      board[row][col] = '.'      else:          for row in range(0,2):              for col in range(0,2):                  board[row][col] = '.'          pending -= 4          col=2          row=2            # First fill the outer border with groups of two          while pending >= 2 and (col<c or row<r):              if pending >= 2 and col<c:                  board[0][col] = '.'                  board[1][col] = '.'                  col += 1                  pending -= 2              if pending >= 2 and row<r:                  board[row][0] = '.'                  board[row][1] = '.'                  row += 1                  pending -= 2            # Now fill the inner board with the remaining free cells          for row in range(2, r):              for col in range(2, c):                  if pending > 0:                      board[row][col] = '.'                      pending -= 1        # The clicked one is always on the top left corner      board[0][0] = 'c'        # Finally print the board      for row in range(0, r):          line = ''          for col in range(0, c):              line += board[row][col]          print(line)      for t in range(1, ncases+1):      values = sys.stdin.readline().strip().split()      r = int(values[0])      c = int(values[1])      m = int(values[2])        cells = r * c      free = cells - m        possible = False        if r == 1 or c == 1:          if free >= 1:              possible = True      elif r == 2 or c == 2:          if free == 1 or (free >= 4 and free%2 == 0):              possible = True      else:          if free == 1 or (free >= 4 and free != 5 and free != 7):              possible = True        print("Case #{0}:".format(t))        if possible:          print_board(r, c, free)      else:          print("Impossible")  <CODESPLIT> 21
#!/usr/bin/python3    import sys    def findrecycled(num, A, B):  	strnum = str(num)  	results = {}  	for i in range(1, len(strnum)):  		strrecycled = strnum[i:] + strnum[0:i]  		recycled = int(strrecycled)  		if recycled > num and recycled >= A and recycled <= B:  			results["%d_%d" % (num, recycled)] = 1  	return len(results)    # Ignore the number of cases  sys.stdin.readline()    casenum = 0  for line in sys.stdin:  	casenum += 1    	data = line.strip().split(' ')  	A = int(data[0])  	B = int(data[1])    	count = 0  	for num in range(A, B):  		count += findrecycled(num, A, B)    	print("Case #%d: %d" % (casenum, count))  <CODESPLIT> 21
def isPalindrome(number):      strNum = str(number)      for i in range(len(strNum)/2 + 1):          if strNum[i] != strNum[-1*(i+1)]:              return False      return True    '''for i in range(40):      if isPalindrome(i) and isPalindrome(i*i):          print i*i  '''      filename = "C-small-attempt0.in"  outputname = filename + "out.txt"    inFile = open(filename, 'r')  outFile = open(outputname, 'w')      fairAndSquareNums = [1,4,9,121,484]    numTests = int(inFile.readline())    for i in range(numTests):      line = inFile.readline().split()      count = 0      for j in range(int(line[0]), int(line[1])+1):          if j in fairAndSquareNums:              count += 1      outFile.write("Case #" + str(i+1) + ": " + str(count) + '\n')      print "Case #" + str(i+1) + ": " + str(count)    inFile.close()  outFile.close()  <CODESPLIT> 22
inputFile = open("B-small-attempt0 (3).in", 'r')  outputFile = open("dancingOutSmall.txt", 'w')  numTests = int(inputFile.readline())    def countDancers(n,s,p,totals):      guaranteed = 0      needSurprise = 0      if p == 1:          for total in totals:              if total != 0:                  guaranteed += 1          return guaranteed      for total in totals:          if total >= p*3 - 2:              guaranteed += 1          elif total >= p*3 - 4:              needSurprise += 1      if needSurprise > s:          return guaranteed + s      else:          return guaranteed + needSurprise    for i in range(numTests):      line = inputFile.readline().split()      n = int(line[0])      s = int(line[1])      p = int(line[2])      totals = []      for j in range(n):          totals += [int(line[3+j])]      outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\n')    outputFile.close()  <CODESPLIT> 22
inputFile = open('D-small-attempt0.in', 'r')  lines = inputFile.readlines()  inputFile.close()    outputFile = open('D-small-attempt0.out', 'w')    numTests = int(lines[0])    def scoreWar(naomiNums, kenNums):      naomiInd = 0      kenInd = 0      while naomiInd < len(naomiNums):          naomiPlay = naomiNums[naomiInd]          while kenInd < len(kenNums) and kenNums[kenInd] < naomiPlay:              kenInd += 1          if kenInd == len(kenNums):              break          naomiInd += 1          kenInd += 1      return len(naomiNums) - naomiInd    def scoreDeceit(naomiNums, kenNums):      naomiInd = 0      kenInd = 0      while kenInd < len(kenNums):          kenPlay = kenNums[kenInd]          while naomiInd < len(naomiNums) and naomiNums[naomiInd] < kenPlay:              naomiInd += 1          if naomiInd == len(naomiNums):              break          naomiInd += 1          kenInd += 1      return kenInd    for i in range(1, numTests+1):      naomiNums = map(lambda x: float(x), lines[3*i-1].split())      kenNums = map(lambda x: float(x), lines[3*i].split())      naomiNums.sort()      kenNums.sort()      deceitScore = scoreDeceit(naomiNums, kenNums)      warScore = scoreWar(naomiNums, kenNums)      outputFile.write('Case #'+str(i)+': ' + str(deceitScore) + ' ' + str(warScore) + '\n')    outputFile.close()  <CODESPLIT> 22
def isMowable(lawn):      for i in range(len(lawn)):          for j in range(len(lawn[i])):              cellHeight = lawn[i][j]              vertPossible = True              horizPossible = True              for k in range(len(lawn)):                  if lawn[k][j] > cellHeight:                      vertPossible = False                      break              for k in range(len(lawn[i])):                  if lawn[i][k] > cellHeight:                      horizPossible = False                      break              if not vertPossible and not horizPossible:                  return "NO"      return "YES"      filename = "B-small-attempt0.in"  outputname = filename + "out.txt"    inFile = open(filename, 'r')  outFile = open(outputname, 'w')      numTests = int(inFile.readline())            for i in range(numTests):      dimensions = inFile.readline().split()      n = int(dimensions[0])      m = int(dimensions[1])      lawn = []      for j in range(n):          line = inFile.readline().split()          for k in range(m):              line[k] = int(line[k])          lawn += [line]        answer = isMowable(lawn)                  outFile.write("Case #" + str(i+1) + ": " + answer + '\n')      print "Case #" + str(i+1) + ": " + answer    inFile.close()  outFile.close()  <CODESPLIT> 22
inputFile = open('B-small-attempt0.in', 'r')  lines = inputFile.readlines()  inputFile.close()    outputFile = open('B-small-attempt0.out', 'w')    numTests = int(lines[0])      def solveCookies(c, f, x):      accumTime = 0      farmRate = 0      while True:          # two options: Buy, or don't buy          timeToWait = x/(2.0+farmRate)          timeIfBuyFarm = (c/(2.0+farmRate) +   # Time to get a farm                           x/(2.0+farmRate+f))          if timeToWait <= timeIfBuyFarm:              return accumTime+timeToWait          else:              accumTime += c/(2.0+farmRate)              farmRate += f    for i in range(1, numTests+1):      [c, f, x] = map(lambda x: float(x), lines[i].split())        outputFile.write('Case #'+str(i)+': ' + str(solveCookies(c, f, x))+'\n')  outputFile.close()        <CODESPLIT> 22
inputFile = open('A-small-attempt0.in', 'r')  lines = inputFile.readlines()  inputFile.close()    outputFile = open('A-small-attempt0.out', 'w')    numTests = int(lines[0])      currLine = 1  for i in range(1, numTests+1):      firstRow = lines[int(lines[currLine])+currLine]      currLine += 5      secondRow = lines[int(lines[currLine])+currLine]      currLine += 5        firstNums = map(lambda x: int(x), firstRow.split())      secondNums = map(lambda x: int(x), secondRow.split())            intersect = [v for v in firstNums if v in secondNums]        outputFile.write('Case #'+str(i)+': ')      if len(intersect) == 1:          outputFile.write(str(intersect[0])+'\n')      elif len(intersect) == 0:          outputFile.write('Volunteer cheated!\n')      else:          outputFile.write('Bad magician!\n')    outputFile.close()        <CODESPLIT> 22
translator = {}  translator['a'] = 'y'  translator['b'] = 'h'  translator['c'] = 'e'  translator['d'] = 's'  translator['e'] = 'o'  translator['f'] = 'c'  translator['g'] = 'v'  translator['h'] = 'x'  translator['i'] = 'd'  translator['j'] = 'u'  translator['k'] = 'i'  translator['l'] = 'g'  translator['m'] = 'l'  translator['n'] = 'b'  translator['o'] = 'k'  translator['p'] = 'r'  translator['q'] = 'z'  translator['r'] = 't'  translator['s'] = 'n'  translator['t'] = 'w'  translator['u'] = 'j'  translator['v'] = 'p'  translator['w'] = 'f'  translator['x'] = 'm'  translator['y'] = 'a'  translator['z'] = 'q'    def translate(string, translator):      accum = ""      for i in range(len(string)):          if string[i] == ' ':              accum += ' '          elif string[i] == '\n':              break          else:              accum += translator[string[i]]      return accum    inputFile = open("A-small-attempt0.in", 'r')  outputFile = open("tonguesOut.txt", 'w')  numTests = int(inputFile.readline())    for i in range(numTests):      outputFile.write('Case #' + str(i+1) + ': ' + translate(inputFile.readline(), translator) + '\n')    inputFile.close()  outputFile.close()    <CODESPLIT> 22
filename = "A-small-attempt0 (3).in"  outputname = filename + "out.txt"    inFile = open(filename, 'r')  outFile = open(outputname, 'w')            def evalGame(lines):      board = []      gameOver = True            for line in lines:          bline = []          for i in range(len(line)):              if line[i] == 'X':                  bline += [1]              elif line[i] == 'O':                  bline += [2]              elif line[i] == 'T':                  bline += [3]              elif line[i] == '.':                  gameOver = False                  bline += [0]          board += [bline]        # Check down      for i in range(1):          for j in range(4):              startTile = board[i][j]              if startTile == 3 or startTile == 0:                  continue              winner = True              for k in range(1,4):                  if board[i+k][j] not in [startTile, 3]:                      winner = False                      break              if winner:                  return startTile        # Check right      for i in range(4):          for j in range(1):              startTile = board[i][j]              if startTile == 3 or startTile == 0:                  continue              winner = True              for k in range(1,4):                  if board[i][j+k] not in [startTile, 3]:                      winner = False                      break              if winner:                  return startTile        # Check up      for i in range(3,4):          for j in range(4):              startTile = board[i][j]              if startTile == 3 or startTile == 0:                  continue              winner = True              for k in range(1,4):                  if board[i-k][j] not in [startTile, 3]:                      winner = False                      break              if winner:                  return startTile        # Check left      for i in range(4):          for j in range(3,4):              startTile = board[i][j]              if startTile == 3 or startTile == 0:                  continue              winner = True              for k in range(1,4):                  if board[i][j-k] not in [startTile, 3]:                      winner = False                      break              if winner:                  return startTile             # Check down right      startTile = board[0][0]      if startTile != 3 and startTile != 0:          winner = True          for k in range(1,4):              if board[k][k] not in [startTile, 3]:                  winner = False                  break          if winner:              return startTile         # Check up right      startTile = board[3][0]      if startTile != 3 and startTile != 0:          winner = True          for k in range(1,4):              if board[3-k][k] not in [startTile, 3]:                  winner = False                  break          if winner:              return startTile         # Check up left      startTile = board[3][3]      if startTile != 3 and startTile != 0:          winner = True          for k in range(1,4):              if board[3-k][3-k] not in [startTile, 3]:                  winner = False                  break          if winner:              return startTile         # Check down left      startTile = board[0][3]      if startTile != 3 and startTile != 0:          winner = True          for k in range(1,4):              if board[k][3-k] not in [startTile, 3]:                  winner = False                  break          if winner:              return startTile          if gameOver:          return 0        else:          return -1                                          def resultToString(result):      if result == 0:          return "Draw"      elif result == 1:          return "X won"      elif result == 2:          return "O won"      else:          return "Game has not completed"      numCases = int(inFile.readline())    for i in range(numCases):      lines = []      for j in range(4):          lines += [inFile.readline().strip()]        result = evalGame(lines)        print "Case #" + str(i+1) + ": " + resultToString(result)      outFile.write("Case #" + str(i+1) + ": " + resultToString(result) + '\n')            if i < numCases -1:          inFile.readline()    inFile.close()  outFile.close()  <CODESPLIT> 22
inputFile = open('C-small-attempt8.in', 'r')  lines = inputFile.readlines()  inputFile.close()    outputFile = open('C-small-attempt8.out', 'w')    numTests = int(lines[0])    for i in range(1, numTests+1):      [r, c, m] = map(lambda x: int(x), lines[i].split())        openCells = r*c - m        works = False      matrix = [['*']*c for j in range(r)]      # Try case analysis first, see if my knowledge of minesweeper can cover everything      # This is getting painful :(      if r >= 3 and c >= 3:          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),                   (2,0), (2,1)]          if openCells == 1 or openCells == 4 or openCells == 6:              works = True              for (x,y) in order[:openCells]:                  matrix[x][y] = '.'              matrix[0][0] = 'c'                        elif openCells >= 8:              works = True              filledRows = openCells / c              if filledRows >= 2:                  if filledRows == r:                      matrix = [['.']*c for j in range(r)]                      matrix[0][0] = 'c'                  else:                      remainder = openCells%c                      if not remainder == 1:                          for j in range(filledRows):                              matrix[j] = ['.']*c                          matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)                      elif filledRows > 2:                          for j in range(filledRows-1):                              matrix[j] = ['.']*c                          matrix[filledRows-1] = ['.']*(c-1) + ['*']                          matrix[filledRows] = ['.', '.'] + ['*']*(c-2)                      else:                          matrix[0] = ['.']*(c-1) + ['*']                                                  matrix[1] = ['.']*(c-1) + ['*']                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)                      matrix[0][0] = 'c'                                else:                  for (x,y) in order:                      matrix[x][y] = '.'                  remainingOpen = openCells - 8                  if remainingOpen % 2 == 0:                      for j in range(remainingOpen/2):                          matrix[0][j+3] = '.'                          matrix[1][j+3] = '.'                  else:                      matrix[2][2] = '.'                      remainingOpen -= 1                      for j in range(remainingOpen/2):                          matrix[0][j+3] = '.'                          matrix[1][j+3] = '.'                  matrix[0][0] = 'c'        elif r == 1:          works = True          matrix[0] = ['.']*(c-m) + ['*']*m          matrix[0][0] = 'c'      elif c == 1:          works = True          for j in range(r-m):              matrix[j][0] = '.'          matrix[0][0] = 'c'        #Only cases left are one or both dimensions being two      elif r == 2 and c == 2:          if m == 3:              works = True              matrix[0][0] = 'c'          elif m == 0:              works = True              matrix = [['c', '.'], ['.', '.']]      elif r == 2:          if m % 2 == 0 and r*c-m > 2:              works = True              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)              matrix[0][0] = 'c'          elif r*c-m == 1:              works = True              matrix[0][0] = 'c'      elif c == 2:          if m % 2 == 0 and r*c-m > 2:              works = True              for j in range((r*c-m)/2):                  matrix[j] = ['.', '.']              matrix[0][0] = 'c'          elif r*c-m == 1:              works = True              matrix[0][0] = 'c'              outputFile.write('Case #'+str(i)+':\n')      '''if len(matrix) != r:          print i, matrix      count = 0      for j in range(len(matrix)):          for k in range(len(matrix[j])):              if matrix[j][k] == '*':                  count += 1      if count != m:          print i, matrix'''      if not works:          outputFile.write('Impossible\n')      else:          for x in range(len(matrix)):              for y in range(len(matrix[0])):                  outputFile.write(matrix[x][y])              outputFile.write('\n')  outputFile.close()                <CODESPLIT> 22
inputFile = open("C-small-attempt0.in", 'r')  outputFile = open("recycleOut.txt", 'w')  numTests = int(inputFile.readline())    def countRecycle(a,b):      count = 0      for n in range(a,b):          for m in range(n+1,b+1):              nStr = str(n)              canRecycle = False              for k in range(len(nStr)):                  if nStr[k:] + nStr[0:k] == str(m):                      canRecycle = True                      break              if canRecycle:                  count += 1      return count    for i in range(numTests):      line = inputFile.readline().split()      a = int(line[0])      b = int(line[1])      outputFile.write('Case #' + str(i+1) + ': ' + str(countRecycle(a,b)) + '\n')    inputFile.close()  outputFile.close()  <CODESPLIT> 22
import sys    lines = sys.stdin.readlines()  def parseCase(lines):      dims = map(int,lines[0].split(" "))      return 1, dims    def getCases(lines):      i =0      while i < len(lines):          lines_used, case = parseCase(lines[i:])          i += lines_used          yield case    import math    fands = []  phash = {1:True}  def isPalindrome(p):      return p in phash    def test(p):      square = p**.5      return square == int(square) and isPalindrome(int(square))    for i in range(1,10**5):      if i > 9:          small_p = int(i * 10 ** int(math.log(i,10)) + int("".join(reversed(str(i)[:-1]))))      else: small_p = i      phash[small_p]= test(small_p)      if phash[small_p]: fands.append(small_p)      big_p = int(i * 10 ** int(math.log(i,10)+1) + int("".join(reversed(str(i)))))      phash[big_p] = test(big_p)      if phash[big_p]: fands.append(big_p)  cNum =0    for c in getCases(lines[1:]):      cNum += 1      answer = []      for i in fands:          if i < c[0]: continue          if i > c[1]: break          if phash[i]: answer.append(i)      answer = str(len(answer))      print "Case #%d: %s" % ( cNum, answer)                <CODESPLIT> 23
#!/bin/env python         """  GCJ framework (gcj.fw.framework)   - Command Line and Package interface   - output redirection   - parsing case input   - executing problem code against cases   - testing framework  """  import sys  import unittest  import StringIO    class Framework(object):      class Case(object):          def __init__(self, caseNumber, caseData=None):              self.number = caseNumber              self.data = caseData              self.result = None                @classmethod          def parser(cls, f_in):              pass                def run(self):              pass                def execute(self, f_in=None):              if self.data is None:                  self.data = self.parser(f_in)              self.result = self.run(**self.data)                def __str__(self):              return "Case #%d: %s" % (self.number, self.result)                  class Result(object):          def __init__(self, resultData):              self.data = resultData                def __str__(self):              return str(self.ata)        def __init__(self, f_in, f_out):          sys.stdout = f_out          self.f_in = f_in if f_in is not None else sys.stdin        def run(self):          nCases = int(self.f_in.readline().strip())          for num in xrange(nCases):              case = type(self).Case(num+1)              case.execute( f_in=self.f_in)              print case          @classmethod      def __main__(cls):          f_in = sys.stdin          if len(sys.argv) > 1:              if sys.argv[1] == "-t":                  unittest.main()                  sys.exit()              f_in = open(sys.argv[1])          framework = cls(f_in, sys.stdout)          framework.run()        class Test(unittest.TestCase):      cases = []      case = None      c=[]            def setUp(self):          self.c = []          self.defineCases()          counter = 1          self.cases = []          for c in self.c:              case = self.case(counter)              case.data = case.parser(StringIO.StringIO(c[0]))              self.cases.append( [case, c[1]])            def defineCases(self):          pass            def tearDown(self):          pass         def test_Name(self):          self.setUp()          for case in self.cases:              print case[0].data, case[1]              case[0].execute()              self.assertEqual(case[0].result, case[1])  '''  Created on Apr 8, 2012    @author: Joe  '''      class B(Framework):      class Case(Framework.Case):          def parser(self, fh):              args = map(int, fh.readline().strip().split(" "))              N,S,p = args[:3]              scores = args[3:]               return {"N":N,"S":S,"p":p,"scores":scores}                    def run(self, N=None,S=None,p=None,scores=None):              ret = 0              surps = 0              for score in scores:                  if p > 0 and score == 0: continue                  if 3*p-2 <= score:                      ret += 1                  else:                      if 3*p - 4 <= score:                          surps += 1              return str(ret + min(surps,S))                class Test(Test):      def defineCases(self):          self.case = B.Case          self.c = [                    ["3 1 5 15 13 11","3"],                    ["3 0 8 23 22 21","2"],                    ["2 1 1 8 0","1"],                    ["6 2 8 29 20 8 18 18 21","3"],                    ["1 1 1 1", "1"]                    ]    if __name__ == "__main__":      B.__main__()        <CODESPLIT> 23
__author__ = 'jrokicki'    import sys  RL = lambda: sys.stdin.readline().strip()  IA = lambda: map(int, RL().split(" "))  LA = lambda: map(long, RL().split(" "))  FA = lambda: map(float, RL().split(" "))    T = int(sys.stdin.readline())    def war(N,K):      """      strategy: N plays lowest number first, K chooses next best number      """      if len(N) == 0: return 0      n = N[0]      if K[-1] > n:          # ken wins          k = len(K)-1          for k in range(len(K)-1):              if K[k] > n and K[k+1] > n:                  break          if K[k] < n: k += 1          K = K[:k] + K[k+1:]          return war(N[1:],K)      else:          ## N wins they both play their lowest numbers          return 1 + war(N[1:], K[1:])    def beawoman(N,K):      if len(N) == 0: return 0      n = N[0]      bad = False      for i in range(len(N)):          if N[i] < K[i]:              bad = True      if bad:          return beawoman(N[1:], K[:-1])      else:          return 1 + beawoman(N[:-1], K[:-1])    for CASE in range(T):      RL()      N = FA()      K = FA()      N.sort()      K.sort()      answer = "%d %d" % (beawoman(N,K), war(N,K))      print "Case #%d: %s" % (CASE+1, answer)    <CODESPLIT> 23
import sys    lines = sys.stdin.readlines()  def parseCase(lines):      dims = map(int,lines[0].split(" "))      return dims[0]+1, [map(int,l.split(" ")) for l in lines[1:dims[0]+1]]      def getCases(lines):      i =0      while i < len(lines):          lines_used, case = parseCase(lines[i:])          i += lines_used          yield case              cNum =0  for c in getCases(lines[1:]):      cNum += 1      answer = None      for i in range(len(c)):          if answer: break          for j in range(len(c[i])):              if answer: break              answer = max(c[i]) > c[i][j] and max([c[k][j] for k in range(len(c))]) > c[i][j]      print "Case #%d: %s" % ( cNum, "NO" if answer else "YES")                <CODESPLIT> 23
__author__ = 'jrokicki'    import sys  RL = lambda: sys.stdin.readline().strip()  IA = lambda: map(int, RL().split(" "))  LA = lambda: map(long, RL().split(" "))  FA = lambda: map(float, RL().split(" "))    T = int(sys.stdin.readline())    for CASE in range(T):      C,F,X = FA()      tick = 2.      answer = X/tick        game = 0      while True:          span = C / tick          tick += F          test = game + span + X/tick          game = game + span            if test < answer:              answer = test          else:              if tick > X:                  break        print "Case #%d: %s" % (CASE+1, answer)    <CODESPLIT> 23
__author__ = 'jrokicki'    import sys  RL = lambda: sys.stdin.readline().strip()  IA = lambda: map(int, RL().split(" "))  LA = lambda: map(long, RL().split(" "))    T = int(sys.stdin.readline())    for CASE in range(T):      g1 = IA()[0]-1      board1 = []      for i in range(4):          board1.append(IA())      g2 = IA()[0]-1      board2 = []      for i in range(4):          board2.append(IA())        r1 = board1[g1]      r2 = board2[g2]        answer = set(r1).intersection(r2)      if len(answer) > 1:          answer = "Bad magician!"      elif len(answer) == 0:          answer = "Volunteer cheated!"      else:          answer = list(answer)[0]        print "Case #%d: %s" % (CASE+1, answer)    <CODESPLIT> 23
         """  GCJ framework (gcj.fw.framework)   - Command Line and Package interface   - output redirection   - parsing case input   - executing problem code against cases   - testing framework  """  import sys  import unittest  import StringIO    class Framework(object):      class Case(object):          def __init__(self, caseNumber, caseData=None):              self.number = caseNumber              self.data = caseData              self.result = None                @classmethod          def parser(cls, f_in):              pass                def run(self):              pass                def execute(self, f_in=None):              if self.data is None:                  self.data = self.parser(f_in)              self.result = self.run(**self.data)                def __str__(self):              return "Case #%d: %s" % (self.number, self.result)                  class Result(object):          def __init__(self, resultData):              self.data = resultData                def __str__(self):              return str(self.ata)        def __init__(self, f_in, f_out):          sys.stdout = f_out          self.f_in = f_in if f_in is not None else sys.stdin        def run(self):          nCases = int(self.f_in.readline().strip())          for num in xrange(nCases):              case = type(self).Case(num+1)              case.execute( f_in=self.f_in)              print case          @classmethod      def __main__(cls):          f_in = sys.stdin          if len(sys.argv) > 1:              if sys.argv[1] == "-t":                  unittest.main()                  sys.exit()              f_in = open(sys.argv[1])          framework = cls(f_in, sys.stdout)          framework.run()        class Test(unittest.TestCase):      cases = []      case = None      c=[]            def setUp(self):          self.c = []          self.defineCases()          counter = 1          self.cases = []          for c in self.c:              case = self.case(counter)              case.data = case.parser(StringIO.StringIO(c[0]))              self.cases.append( [case, c[1]])            def defineCases(self):          pass            def tearDown(self):          pass         def test_Name(self):          self.setUp()          for case in self.cases:              print case[0].data, case[1]              case[0].execute()              self.assertEqual(case[0].result, case[1])    D={'a':'y','o':'e','z':'q','q':'z'}    a=["ejp mysljylc kd kxveddknmc re jsicpdrysi",     "our language is impossible to understand",     "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",     "there are twenty six factorial possibilities",     "de kr kd eoya kw aej tysr re ujdr lkgc jv",     "so it is okay if you want to just give up"]    for i in range(0,len(a),2):      for j in range(0,len(a[i])):          D[a[i][j]] = a[i+1][j]    class A(Framework):      class Case(Framework.Case):          def parser(self, fh):              statement = fh.readline().strip()               return {'secret': statement}                    def run(self, secret=None):              word = ""              for i in range(0,len(secret)):                  word += D[secret[i]]              return word            class Test(Test):      def defineCases(self):          self.case = A.Case          self.c = [["ejp mysljylc kd kxveddknmc re jsicpdrysi",     "our language is impossible to understand"],                    [   "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",     "there are twenty six factorial possibilities",],                    [ "de kr kd eoya kw aej tysr re ujdr lkgc jv",     "so it is okay if you want to just give up"],                    ]    if __name__ == "__main__":      A.__main__()        <CODESPLIT> 23
import sys    lines = sys.stdin.readlines()  def parseCase(lines):      return 5,lines[0:4]    def getCases(lines):      i =0      while i < len(lines):          lines_used, case = parseCase(lines[i:])          i += lines_used          yield case    def test(r):      if 'O' in r and '.' not in r and 'X' not in r:           return "O won"      elif 'X' in r and '.' not in r and 'O' not in r:           return "X won"      return None            cNum =0  for c in getCases(lines[1:]):      cNum += 1      answer = None      for i in range(0,4):          if answer: break          r = c[i]          answer = test(r) \              or test("".join(c[j][i] for j in range(4)))        if not answer:          answer = test("".join([c[j][3-j] for j in range(4)])) \              or test("".join(c[j][j] for j in range(4)))                    if not answer:          answer = any(["." in c[i] for i in range(4)]) and "Game has not completed"      if not answer:          answer = "Draw"      print "Case #%d: %s" % ( cNum, answer)                                  <CODESPLIT> 23
__author__ = 'jrokicki'    import sys  RL = lambda: sys.stdin.readline().strip()  IA = lambda: map(int, RL().split(" "))  LA = lambda: map(long, RL().split(" "))  FA = lambda: map(float, RL().split(" "))    T = int(sys.stdin.readline())    def clear(R,C,b, x, y):      b = b[:]      n = 0      for i in range(max(0,x-1), min(R,x+2)):          for j in range(max(0,y-1), min(C, y+2)):              if b[C*i+j] == '*':                  n += 1                  b = b[:C*i+j] + '.' + b[C*i+j+1:]      return b, n  mem = dict()  def pb(R,C,b):      for x in range(R):          print b[x*C:x*C+C]    def board(R,C,b,x,y,M,m):      global mem      print x      key = (R,C,b,M,x,y,m)      if key in mem: return mem[key]      if x >= R or y >= C:          mem[key] = None      else:          lb = b          n = 0          good = False          for i in range(y,C):              nb,nn = clear(R,C, lb, x, i)              n += nn              if m - n - M == 0:                  mem[key] = nb                  good = True                  break              elif m - n - M < 0:                  break              lb = bb          mem[key] = board(R,C,bb,M,x+1,0,m-n)      return mem[key]    for CASE in range(T):      R,C,M = IA()      IMPOSSIBLE = "Impossible"        b = ""      cleared = R*C-M      for x in range(R):          b += "*" * C      if M == R*C-1:          b = "c" + b[1:]          answer = b      else:          good = False          x,y = 0,0          q = [(b,0,0,0)]          mem = {}          while not good and q:              board,total_cleared,x,y = q.pop(0)              if (board,total_cleared,x,y) in mem:                  continue              mem[(board,total_cleared,x,y)] = True              if x >= R: continue              if y >= C:                  q.append((last_board,total_cleared,x+1,0))                  continue              last_board = board              new_board, cleared_mines = clear(R,C,last_board,x,y)              total_cleared += cleared_mines                if total_cleared == cleared:                  good = True                  last_board = new_board                  q = []                  break              elif total_cleared - cleared == -1:                  q.append((new_board,total_cleared,x,y+1))                  q.append((new_board,total_cleared,x+1,0))                  q.append((last_board,total_cleared-cleared_mines,x+1,0))              elif total_cleared > cleared:                  q.append((last_board,total_cleared-cleared_mines,x+1,0))              else:                  q.append((new_board,total_cleared,x,y+1))              last_board = new_board          if good:              answer = last_board          else:              answer = None      if not answer:          answer = "Impossible"      else:          b = ""          for x in range(R):              b += answer[x*C:x*C+C] + "\n"          answer = "c" + b[1:-1]      print "Case #%d:\n%s" % (CASE+1, answer)    <CODESPLIT> 23
         """  GCJ framework (gcj.fw.framework)   - Command Line and Package interface   - output redirection   - parsing case input   - executing problem code against cases   - testing framework  """  import sys  import unittest  import StringIO    class Framework(object):      class Case(object):          def __init__(self, caseNumber, caseData=None):              self.number = caseNumber              self.data = caseData              self.result = None                @classmethod          def parser(cls, f_in):              pass                def run(self):              pass                def execute(self, f_in=None):              if self.data is None:                  self.data = self.parser(f_in)              self.result = self.run(**self.data)                def __str__(self):              return "Case #%d: %s" % (self.number, self.result)                  class Result(object):          def __init__(self, resultData):              self.data = resultData                def __str__(self):              return str(self.ata)        def __init__(self, f_in, f_out):          sys.stdout = f_out          self.f_in = f_in if f_in is not None else sys.stdin        def run(self):          nCases = int(self.f_in.readline().strip())          for num in xrange(nCases):              case = type(self).Case(num+1)              case.execute( f_in=self.f_in)              print case          @classmethod      def __main__(cls):          f_in = sys.stdin          if len(sys.argv) > 1:              if sys.argv[1] == "-t":                  unittest.main()                  sys.exit()              f_in = open(sys.argv[1])          framework = cls(f_in, sys.stdout)          framework.run()        class Test(unittest.TestCase):      cases = []      case = None      c=[]            def setUp(self):          self.c = []          self.defineCases()          counter = 1          self.cases = []          for c in self.c:              case = self.case(counter)              case.data = case.parser(StringIO.StringIO(c[0]))              self.cases.append( [case, c[1]])            def defineCases(self):          pass            def tearDown(self):          pass         def test_Name(self):          self.setUp()          for case in self.cases:              print case[0].data, case[1]              case[0].execute()              self.assertEqual(case[0].result, case[1])  '''  Created on Apr 8, 2012    @author: Joe  '''    from math import log  class C(Framework):      class Case(Framework.Case):          def parser(self, fh):              args = map(int, fh.readline().strip().split(" "))              A,B = args[:2]              return {"A":A,"B":B}                    def run(self,A=None,B=None):              ret = 0              found = set()              for i in range(A,B+1):                  if i in found: continue                  n = int(log(i,10))                  nums = set([i])                  tmp = i                  for j in range(n):                      tmp = tmp / 10 + (tmp%10)*10**(n)                      if tmp <= B and tmp>= A:                          nums.add(tmp)                          found.add(tmp)                  ret += len(nums)*(len(nums)-1)/2              return str(ret)                class Test(Test):      def defineCases(self):          self.case = C.Case          self.c = [                    ["1 9", "0"],                    ["10 40", "3",                   ],                    ["10 99", "36"],                    ["100 500", "156"],                    ["1111 2222", "287"],                    ["1000000 2000000", "2000000"]                    ]    if __name__ == "__main__":      C.__main__()        <CODESPLIT> 23
import Data.Int  import Data.List.Split  import Text.Printf    main = do      interact (unlines . map showCase . zip [1..] . map (solve . interval) . tail . lines)      where      interval :: String -> (Int64, Int64)      interval l =          let [a, b] = map read $ splitOn " " l          in (a, b)        showCase :: (Int64, Int) -> String      showCase (i, r) = printf "Case #%d: %d" i r    solve :: (Int64, Int64) -> Int  solve (a, b) =      length $ takeWhile (<= b) $ dropWhile (< a) [ sq          | x <- [0..], palindrome x, let sq = x * x, palindrome sq          ]    where      square x = x * x      start = truncate $ sqrt $ double a    -- | Returns True if s is a palindrome.  palindrome s =      let s' = show s      in s' == reverse s'    double :: Int64 -> Double  double = fromIntegral <CODESPLIT> 24
import Data.List  import Data.Maybe    main = interact (unlines . map showCase . zip [1..] . tail . lines)    where      showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t    solve = show . solve' . map read . words    where      solve' (n:s:p:ts) =           let pts = map maxPoints ts              directs = filter ((>= p) . fst) pts              surps = filter (\(pd, ps) -> pd < p && ps >= p) pts          in length directs + min (length surps) s            maxPoints :: Int -> (Int, Int)  maxPoints tot =       (maxScore $ scores normal, maxScore $ scores surprising)    where      scores cond = [ (x, y, z) |          x <- [0..10], y <- [0..10], z <- [0..10]          , x + y + z == tot, cond (x, y, z)          ]      normal t = bestScore t - badScore t <= 1      surprising t = bestScore t - badScore t <= 2      maxScore = maximum . map bestScore     bestScore (x, y, z) = maximum [x, y, z]  badScore (x, y, z) = minimum [x, y, z] <CODESPLIT> 24
import Data.Int  import Data.List  import Text.Printf  import qualified Data.Set as S    import Debug.Trace    data Test = Test {        joueur     :: [Double]      , adversaire :: [Double]      } deriving Show    data Solution = Solution Int Int    instance Show Solution where      show (Solution a b) = show a ++ " " ++ show b    main = do      interact (unlines . map showCase . zip [1..] . map resoudre . goTest . tail . lines)      where      goTest [] = []      goTest (_:js:as:ls) =          Test (map read $ words js) (map read $ words as) : goTest ls        showCase :: (Int, Solution) -> String      showCase (i, s) = printf "Case #%d: %s" i (show s)    resoudre :: Test -> Solution  resoudre Test {..} =      let jou    = S.fromList joueur          adv    = S.fromList adversaire          war    = goWar adv (sort joueur)          deceit = goDeceit (reverse $ sort adversaire) jou      in Solution deceit war    where      goWar _   []     = 0      goWar adv (j:js) =          case S.lookupGT j adv of              Just e  -> goWar (S.delete e adv)               js     -- Perd ce jeu              Nothing -> goWar (S.delete (S.findMin adv) adv) js + 1 -- Gagne ce jeu        goDeceit []     _   = 0      goDeceit (a:as) jou =          -- Premire tape : tente d'liminer le plus gros chiffre restant de          -- l'adversaire.          case S.lookupGT a jou of              Just e  ->                  -- Elimine le plus gros pion de l'adversaire et gagne.                  goDeceit as (S.delete e jou) + 1              Nothing ->                  -- Deuxime tape: incapable de l'liminer, sacrifie un                  -- point en forcant l'adversaire  jouer ce pion, en                  -- utilisant le plus petit point et en mentant sur son                  -- poids.                  let minJou = S.findMin jou                  in goDeceit as (S.delete minJou jou)  <CODESPLIT> 24
import Control.Applicative  import Data.Array.Unboxed  import Data.List.Split  import Text.Printf    main = do      interact (unlines . map showCase . zip [1..] . go . tail . lines)      where      go :: [String] -> [Bool]      go []     = []      go (l:ls) =          let [h, w] = map read $ splitOn " " l              (ls', ls'') = splitAt h ls              table = map (map read . splitOn " ") ls'          in solve h w table : go ls''        showCase :: (Int, Bool) -> String      showCase (i, r) = printf "Case #%d: %s" i (if r then "YES" else "NO")    solve :: Int -> Int -> [[Int]] -> Bool  solve h w table = and [ cell >= (maxLgn ! y) || cell >= (maxCol ! x)      | y <- [0..h-1], x <- [0..w-1], let cell = arr ! (y, x)      ]    where      arr :: Array (Int, Int) Int      arr = listArray ((0, 0), (h-1, w-1)) $ concat table        maxLgn, maxCol :: Array Int Int      maxLgn = listArray (0, h-1) $ [ maximum [ arr ! (y, x) | x <- [0..w-1] ]          | y <- [0..h-1]          ]        maxCol = listArray (0, w-1) $ [ maximum [ arr ! (y, x) | y <- [0..h-1] ]          | x <- [0..w-1]          ] <CODESPLIT> 24
import Data.Int  import Data.List  import qualified Data.Foldable as F  import Text.Printf    import Debug.Trace    data Test = Test {        cout     :: Double      , bonus    :: Double      , objectif :: Double      } deriving Show    newtype Solution = Solution { temps :: Double }    instance Show Solution where      show (Solution t) = show t    main = do      interact (unlines . map showCase . zip [1..] . map resoudre . goTest . tail . lines)      where      goTest [] = []      goTest (l:ls) =          let [c, f, x] = map read $ words l          in Test c f x : goTest ls        showCase :: (Int, Solution) -> String      showCase (i, s) = printf "Case #%d: %s" i (show s)    resoudre :: Test -> Solution  resoudre Test {..} | premierAchat > sansAchat = Solution sansAchat                     | otherwise                = go premierAchat 2    where      go t prod | tempsAvecAchat >= tempsSansAchat = Solution (t + tempsSansAchat)                | otherwise                        =                    go (t + delaiProchainAchat) prod'        where          prod' = prod + bonus            tempsAvecAchat = objectif / prod'          tempsSansAchat = (objectif - cout) / prod            delaiProchainAchat = cout / prod'        premierAchat = cout / 2      sansAchat    = objectif / 2  <CODESPLIT> 24
import Data.Int  import Data.List  import qualified Data.Foldable as F  import Text.Printf    import Debug.Trace    data Test = Test {        choix1 :: Int      , table1 :: [[Int]]      , choix2 :: Int      , table2 :: [[Int]]      } deriving Show    data Solution = Bonne Int | BadMag | Cheat    instance Show Solution where      show (Bonne i) = show i      show BadMag    = "Bad magician!"      show Cheat     = "Volunteer cheated!"    main = do      interact (unlines . map showCase . zip [1..] . map (resoudre) . goTest . tail . lines)      where      goTest [] = []      goTest ls =          let (c1, t1, ls')  = goTable ls              (c2, t2, ls'') = goTable ls'          in Test c1 t1 c2 t2 : goTest ls''        goTable (n:ls) =          let c = read n              (t, ls') = splitAt 4 ls          in (c, map goLigne t, ls')        goLigne = map read . words        showCase :: (Int, Solution) -> String      showCase (i, s) = printf "Case #%d: %s" i (show s)    resoudre :: Test -> Solution  resoudre Test {..} =      let choisis1 = table1 !! (choix1 - 1)          choisis2 = table2 !! (choix2 - 1)          communs  = filter (`elem` choisis1) choisis2      in case communs of          [x]     -> Bonne x          (_:_:_) -> BadMag          []      -> Cheat  <CODESPLIT> 24
import Data.List  import Data.Maybe    alphabet = [(' ',' '),('a','y'),('b','h'),('c','e'),('d','s'),('e','o')       ,('f','c'),('g','v'),('h','x'),('i','d'),('j','u'),('k','i'),('l','g')      ,('m','l'),('n','b'),('o','k'),('p','r'),('q','z'),('r','t'),('s','n')      ,('t','w'),('u','j'),('v','p'),('w','f'),('x','m'),('y','a'),('z', 'q')      ]    main = interact (unlines . map showCase . zip [1..] . tail . lines)    where      showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t    solve = map (fromJust . flip lookup alphabet) <CODESPLIT> 24
t = int(input())    def win(lines, player):      for y in range(0, 4):          count = 0          for x in range(0, 4):              if lines[y][x] in [player, 'T']:                  count += 1                  if count >= 4:                      return True              else:                  break        for x in range(0, 4):          count = 0          for y in range(0, 4):              if lines[y][x] in [player, 'T']:                  count += 1                  if count >= 4:                      return True              else:                  break        count = 0      for i in range(0, 4):          if lines[i][i] in [player, 'T']:              count += 1              if count >= 4:                  return True        count = 0      for i in range(0, 4):          x = 3 - i          if lines[i][x] in [player, 'T']:              count += 1              if count >= 4:                  return True        return False    for i in range(0, t):      lines = []      for j in range(0, 4):          lines.append(input())      input()        if win(lines, 'X'):          sol = "X won"      elif win(lines, 'O'):          sol = "O won"      else:          void = False          for y in range(0, 4):              if any(c == '.' for c in lines[y]):                  void = True                  break            if void:              sol = "Game has not completed"          else:              sol = "Draw"          print ("Case #"+str(i+1)+": "+sol) <CODESPLIT> 24
t = int(input())    VIDE = 0  MINE = 1  CURSEUR = 2    def test_position(arr, lignes, cols, y, x):      def voisinage_libre(arr, y, x):          if y > 0:              if x > 0 and arr[y-1][x-1] == MINE:                  return False              if arr[y-1][x] == MINE:                  return False              if x < cols - 1 and arr[y-1][x+1] == MINE:                  return False            if x > 0 and arr[y][x-1] == MINE:              return False          if x < cols - 1 and arr[y][x+1] == MINE:              return False            if y < lignes - 1:              if x > 0 and arr[y+1][x-1] == MINE:                  return False              if arr[y+1][x] == MINE:                  return False              if x < cols - 1 and arr[y+1][x+1] == MINE:                  return False            return True        def remplissage_rec(arr, y, x):          if x < 0 or y < 0 or x >= cols or y >= lignes:              return          elif arr[y][x] == CURSEUR:              return            arr[y][x] = CURSEUR          if voisinage_libre(arr, y, x):              remplissage_rec(arr, y-1, x-1)              remplissage_rec(arr, y-1, x)              remplissage_rec(arr, y-1, x+1)              remplissage_rec(arr, y, x-1)              remplissage_rec(arr, y, x+1)              remplissage_rec(arr, y+1, x-1)              remplissage_rec(arr, y+1, x)              remplissage_rec(arr, y+1, x+1)        if arr[y][x] != VIDE:          return False        # Copie arr and arr2      arr2 = [ [ arr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]        remplissage_rec(arr2, y, x)        for i in range(0, lignes):          for j in range(0, cols):              if arr2[i][j] == VIDE:                  return False      return True    def dfs(arr, lignes, cols, mines, y, x):      cases_restantes = (cols - x) + ((lignes - y) * cols)        if cases_restantes < mines:          return None      elif mines <= 0:          for i in range(0, lignes):              for j in range(0, cols):                  if test_position(arr, lignes, cols, i, j):                      return (i, j)      elif x >= cols:          return dfs(arr, lignes, cols, mines, y+1, 0)      elif y >= lignes:          return None      else:          res = dfs(arr, lignes, cols, mines, y, x+1)          if res != None:              return res            arr[y][x] = MINE          res = dfs(arr, lignes, cols, mines-1, y, x+1)          if res != None:              return res            arr[y][x] = VIDE          return None    for i in range(0, t):      ligne  = input().split(" ")      lignes = int(ligne[0])      cols   = int(ligne[1])      mines  = int(ligne[2])        arr = [ [VIDE] * cols for _ in range(0, lignes) ]        res = dfs(arr, lignes, cols, mines, 0, 0)        print ("Case #"+str(i+1)+":")        if res == None:          print ("Impossible")      else:          (y, x) = res            for i in range(0, lignes):              for j in range(0, cols):                  if i == y and j == x:                      print('c', end='')                  elif arr[i][j] == VIDE:                      print('.', end='')                  else:                      print('*', end='')                print('', end='\n')  <CODESPLIT> 24
import Data.List  import Data.Maybe    import Debug.Trace    main = interact (unlines . map showCase . zip [1..] . tail . lines)    where      showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t    solve = show . solve'' . map read . words  solve' [a, b] = length [ () |           x <- [a..b]      , let digits = nDigits x, let lastY = min b (10^digits - 1)      , y <- [x+1..lastY]      , isRecycled x y digits      ]        solve'' [a, b] = sum [ nRecycled |         x <- [a..b]      , let digits = nDigits x      , let nRecycled = length [ () |                y <- nub $ sort $ moves x digits              , y <= b, y > x              ]      ]    isRecycled :: Int -> Int -> Int -> Bool  isRecycled n m digits = any (== n) (m : moves m digits)    nDigits :: Int -> Int  nDigits n = nDigits' n 0    where      nDigits' 0 acc = acc      nDigits' x acc = nDigits' (x `div` 10) (acc+1)    moves :: Int -> Int -> [Int]  moves n digits = [ dep n d digits | d <- [1..digits-1] ]  dep x d digits = x * 10^d `rem` (10^digits) + x `div` 10^(digits - d) <CODESPLIT> 24
import math    def get_number_of_test_case():      return int(raw_input().strip())    def solve_case(t):      A, B = [int(x) for x in raw_input().strip().split()]        print 'Case #%d: %d' % (t, get_number_of_palindrome(B) - get_number_of_palindrome(A - 1),)    def get_number_of_palindrome(n):      ret = 0        nt = int(math.floor(math.sqrt(n)))      total_column = int(math.ceil(math.ceil(math.log10(nt + 1)) / 2.0))      upper_limit = 10 ** total_column        counter = 0      while counter < upper_limit:          c_str = [c for c in str(counter)]          c_str.reverse()            number = str(counter)          for c in c_str:              number += c          number = int(number)          number = number ** 2          if number <= n and is_palindrome(number):              ret += 1            number = str(counter)          for c in c_str[1:]:              number += c          number = int(number)          number = number ** 2          if number <= n and is_palindrome(number):              ret += 1                    counter += 1        return ret    def is_palindrome(n):      if n == 0:          return False      num = str(n)      check_len = len(num) / 2      ret = True      for i in range(check_len):          ret &= num[i] == num[-i - 1]      return ret    T = get_number_of_test_case()  t = 1  while t <= T:      solve_case(t)      t += 1    <CODESPLIT> 25
t = int(raw_input().strip())  t_count = 1  while t_count <= t:  	line = raw_input().strip().split()  	n = int(line[0])  	s = int(line[1])  	p = int(line[2])  	ti_list = line[3:]  	p_min = max(p * 3 - 2, p)  	p_min_surprise = max(p * 3 - 4, p)  	result = 0  	for ti in ti_list:  		ti = int(ti)  		if ti >= p_min:  			result += 1  		elif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:  			result += 1  			s -= 1  	print 'Case #%d: %d' % (t_count, result,)  	t_count += 1  <CODESPLIT> 25
def solve_case(t):      n = int(raw_input().strip())      naomi = sorted([float(num) for num in raw_input().strip().split()])      ken = sorted([float(num) for num in raw_input().strip().split()])        #print naomi      #print ken        i, j = 0, 0      while j < n:          if ken[j] > naomi[i]:              i += 1          j += 1      optimal_result = n - i        deceit_result = 0      while n > 0:          if naomi[0] < ken[0]:              ken.pop()          else:              deceit_result += 1              ken = ken[1:]          naomi = naomi[1:]          n -= 1            #deceit_result = 0      #while n > 0 and naomi[-1] > ken[-1]:      #    deceit_result += 1      #    naomi.pop()      #    ken.pop()      #    n -= 1        #k, l = 0, n - 1      #while k < n and l >= 0 and naomi[k] < ken[l]:      #    l -= 1      #    k += 1        #deceit_result += n - k        print 'Case #%d: %d %d' % (t, deceit_result, optimal_result,)    def main():      t = int(raw_input().strip())      for i in range(1, t + 1):          solve_case(i)    if __name__ == '__main__':      main()  <CODESPLIT> 25
def get_number_of_test_case():      return int(raw_input().strip())    def solve_case(t):      N, M = [int(x) for x in raw_input().strip().split()]            matrix = [[int(x) for x in raw_input().strip().split()] for y in range(N)]        s_list = list()      for i in range(N):          for j in range(M):              s_list.append([matrix[i][j], i, j,])      s_list.sort(cmp = lambda x, y: x[0] - y[0])        outcome = 'YES'      for s in s_list:          if matrix[s[1]][s[2]] == 0:              continue            row, col = s[1], s[2]            can_do = True          for i in range(N):              can_do &= matrix[i][col] <= s[0]          if can_do:              for i in range(N):                  matrix[i][col] = 0              continue            can_do = True          for j in range(M):              can_do &= matrix[row][j] <= s[0]          if can_do:              for j in range(M):                  matrix[row][j] = 0          else:              outcome = 'NO'              break            print 'Case #%d: %s' % (t, outcome,)      T = get_number_of_test_case()  t = 1  while t <= T:      solve_case(t)      t += 1    <CODESPLIT> 25
def solve_case(t):      c, f, x = [float(num) for num in raw_input().strip().split()]      current_time_usage = x / 2.0        n = 1      build_farm_time = c / (2.0 + float((n - 1) * f))      attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time        while attemp_time_usage < current_time_usage:          current_time_usage = attemp_time_usage            n += 1          build_farm_time += c / (2.0 + float((n - 1) * f))          attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time        print 'Case #%d: %.7f' % (t, current_time_usage,)    def main():      t = int(raw_input().strip())      for i in range(1, t + 1):          solve_case(i)    if __name__ == '__main__':      main()  <CODESPLIT> 25
def solve_case(t):      interested_row = int(raw_input().strip())      i = 1      while i <= 4:          row = raw_input()          if i == interested_row:              first_set = set(row.strip().split())          i += 1      interested_row = int(raw_input().strip())      i = 1      while i <= 4:          row = raw_input()          if i == interested_row:              second_set = set(row.strip().split())          i += 1      ans_set = first_set & second_set      if len(ans_set) == 1:          print 'Case #%d: %s' % (t, ans_set.pop(),)      elif len(ans_set) > 1:          print 'Case #%d: Bad magician!' % (t,)      else:          print 'Case #%d: Volunteer cheated!' % (t,)    def main():      t = int(raw_input().strip())      for i in range(1, t + 1):          solve_case(i)    if __name__ == '__main__':      main()  <CODESPLIT> 25
"""  num = int(raw_input('num: ').strip())    c_map = [None for x in range(0, 26)]    while num > 0:  	googleres = raw_input('googleres: ').strip()  	original = raw_input('original: ').strip()      	ord_a = ord('a')  	ord_z = ord('z')    	i = 0  	for c in googleres:  		ord_c = ord(c)  		if ord_a <= ord_c and ord_c <= ord_z:  			c_map[ord_c - ord_a] = ord(original[i]) - ord_c  		i += 1  	  	num -= 1    print c_map  """    """  c_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]  i = 0  original_list = list()  while i < 25:  	original_list.append(c_map[i] + i)  	i += 1  original_list.sort()  print original_list  """    c_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]    t = int(raw_input().strip())  t_count = 1  while t_count <= t:  	ord_a = ord('a')  	ord_z = ord('z')  	googleres = raw_input().strip()  	original = ''  	for c in googleres:  		ord_c = ord(c)  		if ord_a <= ord_c and ord_c <= ord_z:  			original += chr(c_map[ord_c - ord_a] + ord_c)  		else:  			original += c  	print 'Case #%d: %s' % (t_count, original,)  	t_count += 1    <CODESPLIT> 25
def get_number_of_test_case():      return int(raw_input().strip())    def solve_case(t):      lines = [list(raw_input().strip()) for i in range(4)]      raw_input()        i = 0      j = 0        p_list = list()      while i < 4:          j = 0          s = ''          while j < 4:              s += lines[i][j]              j += 1          p_list.append(s.replace('T', 'X'))          p_list.append(s.replace('T', 'O'))          i += 1        j = 0      while j < 4:          i = 0          s = ''          while i < 4:              s += lines[i][j]              i += 1          p_list.append(s.replace('T', 'X'))          p_list.append(s.replace('T', 'O'))          j += 1            s = lines[0][0] + lines[1][1] + lines[2][2] + lines[3][3]      p_list.append(s.replace('T', 'X'))      p_list.append(s.replace('T', 'O'))        s = lines[0][3] + lines[1][2] + lines[2][1] + lines[3][0]      p_list.append(s.replace('T', 'X'))      p_list.append(s.replace('T', 'O'))        has_empty = False      outcome = ''      for p in p_list:          has_empty |= '.' in p          if p == 'XXXX':              outcome = 'X won'              break          elif p == 'OOOO':              outcome = 'O won'              break      if not outcome:          if has_empty:              outcome = 'Game has not completed'          else:              outcome = 'Draw'            print 'Case #%d: %s' % (t, outcome,)    T = get_number_of_test_case()  t = 1  while t <= T:      solve_case(t)      t += 1    <CODESPLIT> 25
class Sweeper(object):      def __init__(self, r, c, m):          self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]          self.matrix[0][0] = 'c'            self.r = r          self.c = c          self.m = m          self.current_r = r          self.current_c = c          self.current_m = m        def fill_row(self):          if self.current_r >= 3 and self.current_m >= self.current_c:              for i in range(0, self.current_c):                  self.matrix[self.current_r - 1][i] = '*'              self.current_r -= 1              self.current_m -= self.current_c              return True          return False        def fill_col(self):          if self.current_c >= 3 and self.current_m >= self.current_r:              for i in range(0, self.current_r):                  self.matrix[i][self.current_c - 1] = '*'              self.current_c -= 1              self.current_m -= self.current_r              return True          return False        def fill_partial(self):          if self.current_r >= 3:              fill_num = min(self.current_m, self.current_c - 2)              for i in range(0, fill_num):                  self.matrix[self.current_r - 1][self.current_c - 1 - i] = '*'              self.current_m -= fill_num              if fill_num > 0:                  self.current_r -= 1          if self.current_c >= 3:              fill_num = min(self.current_m, self.current_r - 2)              for i in range(0, fill_num):                  self.matrix[self.current_r - 1 - i][self.current_c - 1] = '*'              self.current_m -= fill_num              if fill_num > 0:                  self.current_c -= 1          if self.current_m > 0:              return False          else:              return True        def fill_special_one(self):          if self.current_r * self.current_c == self.current_m + 1:              for i in range(0, self.current_r):                  for j in range(0, self.current_c):                      self.matrix[i][j] = '*'              self.matrix[0][0] = 'c'              self.current_r = 0              self.current_c = 0              self.current_m = 0              return True          return False        def fill_special_col(self):          if self.current_c == 1 and self.current_r > self.current_m:              for i in range(0, self.current_m):                  self.matrix[self.current_r - 1 - i][0] = '*'              self.matrix[0][0] = 'c'              self.current_m = 0              self.current_r = 0              self.current_c = 0              return True          return False        def fill_special_row(self):          if self.current_r == 1 and self.current_c > self.current_m:              for i in range(0, self.current_m):                  self.matrix[0][self.current_c - 1 - i] = '*'              self.matrix[0][0] = 'c'              self.current_m = 0              self.current_r = 0              self.current_c = 0              return True          return False    def print_matrix(matrix):      for row in matrix:          s = ''          for col in row:              s += col          print s    #def check_matrix(matrix, m):  #    for row in matrix:  #        for col in row:  #            if col == '*':  #                m -= 1  #    if m > 0 or matrix[0][0] != 'c':  #        print '>>>>>>>>>>>> BUG <<<<<<<<<<<'        def solve_case(t):      r, c, m = [int(num) for num in raw_input().strip().split()]      sweeper = Sweeper(r, c, m)      print 'Case #%d:' % (t,)      if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():          #check_matrix(sweeper.matrix, m)          print_matrix(sweeper.matrix)          return      f_result = True      while sweeper.current_m > 0 and f_result:          f_result = False          f_result |= sweeper.fill_row()          f_result |= sweeper.fill_col()      if sweeper.current_m > 0:          sweeper.fill_partial()      if sweeper.current_m > 0:          print 'Impossible'      else:          #check_matrix(sweeper.matrix, m)          print_matrix(sweeper.matrix)    def main():      t = int(raw_input().strip())      for i in range(1, t + 1):          solve_case(i)    if __name__ == '__main__':      main()  <CODESPLIT> 25
def count_between(a, b):  	count = 0  	for item in range(a, b + 1):  		rotate = len(str(item)) - 1  		watch_list = [item,]  		rotate_count = 0  		item_len = len(str(item))  		while rotate_count < rotate:  			r_item = str(item)  			r_item = r_item[rotate_count + 1:] + r_item[:rotate_count + 1]  			r_item_len = len(r_item)  			r_item = int(r_item)  			if r_item not in watch_list and r_item > item and r_item <= b and r_item >= a and item_len == r_item_len:  				watch_list.append(r_item)  				count +=1  			rotate_count += 1  	return count    pre_computed = [0, 36, 801, 12060, 161982, 2023578, 299997,]    t = int(raw_input().strip())  t_count = 1  while t_count <= t:  	a, b = [int(x) for x in raw_input().strip().split()]  	#len_a = len(str(a))  	#len_b = len(str(b))  	#result = reduce(lambda x, y: x + y, pre_computed[len_a - 1:len_b -1], 0)  	#print result  	#result -= count_between(pow(10, len_a - 1), a)  	#print result  	#result += count_between(pow(10, len_b - 1), b)  	#print result  	#print 'Case #%d: %d' % (t_count, result,)  	print 'Case #%d: %d' % (t_count, count_between(a, b),)  	t_count += 1    <CODESPLIT> 25
#!/usr/bin/env python3    from itertools import count  from math import sqrt      def next_range(stream):      line = stream.readline()      if not line:          return None      return [int(x) for x in line.split()]      def is_palindrome(n):      n = str(n)      return all(n[i] == n[len(n)-1-i] for i in range(len(n) // 2))    def mysqrt(n):      """Return -1 if not an integer"""      rt = int(sqrt(n))      return rt if rt * rt == n else -1      def is_fas(n):      rt = mysqrt(n)      return rt != -1 and is_palindrome(n) and is_palindrome(rt)      def main():      with open('C-small-attempt0.in', encoding='utf-8') as f:          f.readline()            for case in count(1):              r = next_range(f)              if r is None:                  break                cnt = 0              for n in range(r[0], r[1] + 1):                  if is_fas(n):                      cnt += 1                print('Case #{}: {}'.format(case, cnt))      main()  <CODESPLIT> 26
#!/usr/bin/env python      def best(total):      """Return the best possible score for the given `total`.  Assume      the total is computed by summing exactly three scores (each in the      interval of 0 to 10 inclusive) and no score can be 2 points apart      from another.            Arguments:      - `total`:      """      m = total % 3      if m == 2:          b = total // 3 + 2      else:          b = total // 3 + 1      if b > 10:          b = 10      return b    def best_non_surprising(total):      """Return the best possible score for the given `total`, but      assume that there should be no more than 1 point difference      between the scores.        Arguments:      - `total`:      """      if total % 3 == 0:          return total // 3      else:          return total // 3 + 1    def max_num_gte_p(totals, S, p):      """Return the maximum number of Googlers that could have had a      best result of at least p.            Arguments:      - `totals`:      - `S`: number of surprising triplets of scores      - `p`:      """      res = 0      for total in totals:          if total == 0:              if p == 0:                  res += 1              continue            if best_non_surprising(total) >= p:              # print total, 'non_surp --> ', best_non_surprising(total)              res += 1          elif S > 0 and best(total) >= p:              # print total, 'surp --> ', best(total)              res += 1              S -= 1        return res    def main():      import sys      with open(sys.argv[1], 'r') as f:          f.readline()            # skip T            n = 0          for line in f:              n += 1                line = [int(s) for s in line.split()]              N = line[0]              S = line[1]              p = line[2]              totals = line[3:]                # print 'S=%d, p=%d, Totals: ' % (S, p), totals              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))              # print    if __name__ == '__main__':      main()  <CODESPLIT> 26
import copy  import sys      def ken(naomi_told, kens_blocks):  	heavier = list(filter(lambda b: b > naomi_told, kens_blocks))  	if heavier:  		chosen = min(heavier)  	else:  		chosen = min(kens_blocks)  	kens_blocks.remove(chosen)  	return chosen      def remove_lightest(blocks):  	lightest = sorted(blocks)[0]  	blocks.remove(lightest)  	return lightest      def remove_heaviest(blocks):  	heaviest = sorted(blocks)[-1]  	blocks.remove(heaviest)  	return heaviest      def dwar(naomis_blocks, kens_blocks):  	wins = 0  	kens_blocks = copy.copy(kens_blocks)  	for block in sorted(naomis_blocks):  		if any(map(lambda x: x < block, kens_blocks)):  			# Ken got a lighter block  			wins += 1  			remove_lightest(kens_blocks)    		elif any(map(lambda x: x > block, kens_blocks)):  			# Ken got a heavier block  			remove_heaviest(kens_blocks)  	return wins      def war(naomis_blocks, kens_blocks):  	wins = 0  	kens_blocks = copy.copy(kens_blocks)  	for block in naomis_blocks:  		k = ken(block, kens_blocks)  		if block > k:  			wins += 1  	return wins      def read_case(f):  	N = int(f.readline())  	naomis_blocks = list(map(float, f.readline().split()))  	kens_blocks = list(map(float, f.readline().split()))  	return N, naomis_blocks, kens_blocks      def solve(n, k):  	return '{} {}'.format(dwar(n, k), war(n, k))      def main():  	fn = sys.argv[1]  	with open(fn, encoding='utf-8') as f:  		ncases = int(f.readline())  		for case in range(1, ncases + 1):  			N, naomi, ken = read_case(f)  			solution = solve(naomi, ken)  			print('Case #{}: {}'.format(case, solution))      if __name__ == '__main__':  	main() <CODESPLIT> 26
#!/usr/bin/env python    from itertools import count  import sys      def next_lawn(stream):      init = stream.readline()      if not init:          return None        N, _ = map(int, init.split())      lawn = []      for i in range(N):          line = stream.readline()          lawn.append([int(x) for x in line.split()])      return lawn      def test_hor(lawn, i, j):      me = lawn[i][j]      return all(lawn[i][col] <= me for col in range(len(lawn[i])))      def test_ver(lawn, i, j):      me = lawn[i][j]      return all(lawn[row][j] <= me for row in range(len(lawn)))      def test_square(lawn, i, j):      return test_hor(lawn, i, j) or test_ver(lawn, i, j)      def is_possible(lawn):      return all(test_square(lawn, i, j) for i in range(len(lawn))                 for j in range(len(lawn[i])))      def main():      with open('B-small-attempt0.in', encoding='utf-8') as f:          f.readline()            # Skip the first line            for i in count(1):              lawn = next_lawn(f)              if lawn is None:                  break              ans = is_possible(lawn)              print('Case #{}: {}'.format(i, 'YES' if ans else 'NO'))              main()  <CODESPLIT> 26
import sys      def read_case(f):  	return map(float, f.readline().split())      def solve(C, F, X, rate=2.0):  	accum = 0  	while 1:  		goal1 = X / rate  	  		farm = C / rate  		goal2 = farm + (X / (rate + F))    		if goal1 <= goal2:  			return accum + goal1  		else:  			accum += farm  			rate += F    			  def trunc(x, p=7):  	m = 10 ** p  	return round(x * m) / m      def main():  	fn = sys.argv[1]  	with open(fn, encoding='utf-8') as f:  		ncases = int(f.readline())  		for case in range(1, ncases + 1):  			C, F, X = read_case(f)  			solution = solve(C, F, X)  			print('Case #{}: {}'.format(case, trunc(solution)))      if __name__ == '__main__':  	main()  <CODESPLIT> 26
# -*- coding: utf-8 -*-    import sys      def read_grid(f):  	return [  		[int(x) for x in line.split()]  		for line in [f.readline() for _ in range(4)]  	]    def read_case(f):  	answer1 = int(f.readline())  	grid1 = read_grid(f)  	answer2 = int(f.readline())  	grid2 = read_grid(f)  	return (grid1[answer1 - 1], grid2[answer2 - 1])      def solve(r1, r2):  	res = set(r1) & set(r2)  	if len(res) == 0:  		return 'Volunteer cheated!'  	if len(res) == 1:  		return list(res)[0]  	return 'Bad magician!'        def main():  	fn = sys.argv[1]  	with open(fn, encoding='utf-8') as f:  		ncases = int(f.readline())  		for case in range(1, ncases + 1):  			row1, row2 = read_case(f)  			solution = solve(row1, row2)  			print('Case #{}: {}'.format(case, solution))      if __name__ == '__main__':  	main() <CODESPLIT> 26
#!/usr/bin/env python      _inp = (      'ejp mysljylc kd kxveddknmc re jsicpdrysi',      'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',      'de kr kd eoya kw aej tysr re ujdr lkgc jv',  )    _out = (      'our language is impossible to understand',      'there are twenty six factorial possibilities',      'so it is okay if you want to just give up',  )    def compute_lang_map(inp, out):      lang_map = {}      for gs, ss in zip(inp, out):          for gl, sl in zip(gs, ss):              lang_map[gl] = sl      lang_map['q'] = 'z'      lang_map['z'] = 'q'      return lang_map    _lang_map = compute_lang_map(_inp, _out)  def conv(s):      out = ''      for l in s:          out += _lang_map[l]      return out    def main():      with open('input-file', 'r') as f:          f.readline()            # skip T          n = 0          for line in f:              n += 1              print 'Case #%d: %s' % (n, conv(line.strip()))    if __name__ == '__main__':      main()  <CODESPLIT> 26
#!/usr/bin/env python    import itertools  import sys      def next_board(stream=None):      """"""      if stream is None:          stream = sys.stdin      board = []      for line in filter(lambda line: len(line) and line[0] in '.OTX', stream):          board.append([c for c in line.rstrip()])          if len(board) == 4:              break      return board if len(board) else None      def scan_not_completed(board):      if any(board[i][j] == '.'             for j in range(len(board))             for i in range(len(board))):          return '.'      def check_set(s):      s.discard('T')      return s.pop() if len(s) == 1 and '.' not in s else None      scan_diagonal1 = lambda board: check_set({board[i][i]          for i in range(len(board))})    scan_diagonal2 = lambda board: check_set({board[i][len(board)-1-i]          for i in range(len(board))})    scan_col = lambda board, col: check_set({board[i][col]      for i in range(len(board))})    scan_row = lambda board, row: check_set(set(board[row]))      def determine_state(board):      """"""      for i in range(4):          for s in (scan_col, scan_row):              ret = s(board, i)              if ret:                  return ret      for s in (scan_diagonal1, scan_diagonal2, scan_not_completed):          ret = s(board)          if ret:              return ret      return 'draw'      def main():      """"""      with open('A-small-attempt0.in', encoding='utf-8') as f:          for i in itertools.count(1):              board = next_board(f)              if board is None:                  break              state = determine_state(board)              if state == 'X':                  line = 'X won'              elif state == 'O':                  line = 'O won'              elif state == 'draw':                  line = 'Draw'              elif state == '.':                  line = 'Game has not completed'              print('Case #{}: {}'.format(i, line))      main()  <CODESPLIT> 26
import copy  import sys      FREE = '.'  BOMB = '*'  CLICK = 'c'      class Board:    	def __init__(self, R, C, M):  		self.initial_M = M  		self.R = R  		self.C = C  		self.M = M  		self.matrix = [[FREE for c in range(C)] for r in range(R)]  		# A rectangle that says what's the current subarea we work on  		self.endx = len(self.matrix[0])  		self.endy = len(self.matrix)  # 0 < R * C  		self.startx = 0  		self.starty = 0    	def fill_row(self, row):  		for c in self.range_active_cols:  			self.matrix[row][c] = BOMB  		self.starty += 1  		self.M -= self.active_cols    	def fill_col(self, col):  		for r in self.range_active_rows:  			self.matrix[r][col] = BOMB  		self.startx += 1  		self.M -= self.active_rows    	def pprint(self):  		# print('startx={}, endx={}, starty={}, endy={}, M={}'  		# 		.format(self.startx, self.endx, self.starty, self.endy, self.M))  		for row in self.matrix:  			for cell in row:  				print(cell, end='')  			print()    	@property  	def active_rows(self):  		return self.endy - self.starty    	@property  	def active_cols(self):  		return self.endx - self.startx    	def optimize(self):  		while 1:  			if (self.active_cols <= self.active_rows  					and self.active_cols <= self.M):  				self.fill_row(self.starty)  			elif (self.active_rows < self.active_cols  					and self.active_rows <= self.M):  				self.fill_col(self.startx)  			else:  				break    	@property  	def range_active_cols(self):  		return range(self.startx, self.endx)    	@property  	def range_active_rows(self):  		return range(self.starty, self.endy)    	def is_free(self, row, col):  		return self.matrix[row][col] == FREE    	def place_bomb(self):  		for row in self.range_active_rows:  			for col in self.range_active_cols:  				if (self.is_free(row, col)   						and row + 2 < self.R  						and col + 2 < self.C):  					self.matrix[row][col] = BOMB  					self.M -= 1   					return True  		for col in self.range_active_cols:  			for row in self.range_active_rows:  				if (self.is_free(row, col)  						and row + 2 < self.R  						and col + 2 < self.C):  					self.matrix[row][col] = BOMB  					self.M -= 1  					return True  		return False    	def mark_click(self):  		self.matrix[-1][-1] = 'c'    	def win_condition(self):  		click_row = len(self.matrix) - 1  		click_col = len(self.matrix[0]) - 1  		# Check the cell left of the click  		if (click_col - 1 >= 0  				and not self.is_free(click_row, click_col - 1)):  			return False    		if (click_row - 1 >= 0  				and not self.is_free(click_row - 1, click_col)):  			return False    		if (click_row -1 >= 0  				and click_col -1 >= 0  				and not self.is_free(click_row - 1, click_col - 1)):  			return False  		  		return True    	def win_cond2(self):  		if self.initial_M + 1 == self.C * self.R:  			return True  		return False    	def solve(self):  		self.optimize()  		while self.M > 0 and self.place_bomb():  			pass  		if self.M == 0 and (self.win_condition() or self.win_cond2()):  			self.mark_click()  			self.pprint()  		else:  			print('Impossible')      def read_case(f):  	return map(int, f.readline().split())      def main():  	fn = sys.argv[1]  	with open(fn, encoding='utf-8') as f:  		ncases = int(f.readline())  		for case in range(1, ncases + 1):  			R, C, M = read_case(f)  			print('Case #{}:'.format(case))  			b = Board(R, C, M)  			b.solve()      def main1():  	b = Board(2, 1, 1)  	import pdb; pdb.set_trace()  	b.solve()      if __name__ == '__main__':  	main()  <CODESPLIT> 26
#!/usr/bin/env python      def rotate(i, ndigits):      s = str(i)      s = s[-ndigits:] + s[:-ndigits]      return int(s)    def pairs(A, B):      for n in range(A, B + 1):          for i in range(1, len(str(n))):              m = rotate(n, i)              if n >= m or m > B: continue              yield n, m    def main():      import sys      with open(sys.argv[1], 'r') as f:          f.readline()          n = 0          for line in f:              n += 1                A, B = [int(x) for x in line.split(' ')]              unique = set()              for pair in pairs(A, B):                  unique.add(pair)              print 'Case #%d: %d' % (n, len(unique))    if __name__ == '__main__':      main()  <CODESPLIT> 26
#!/usr/bin/env python3  # -*- encoding: utf-8 -*-    from math import sqrt    def is_palindromic(i):      n = i      rev = 0      while i > 0:          dig = i % 10          rev = rev * 10 + dig          i = i // 10      return n == rev    def is_square(i):      if i == 1:          return True      x = i // 2      seen = set([x])      while x * x != i:          x = (x + (i // x)) // 2          if x in seen:              return False          seen.add(x)      return True    def f(a, b):      tot = 0        sra = a      while not is_square(sra):          sra += 1      srb = b      while not is_square(srb):          srb -= 1        sra = int(sqrt(sra))      srb = int(sqrt(srb))        for i in range(sra, srb+1):          if is_palindromic(i) and is_palindromic(i ** 2):              tot += 1        return tot    if __name__ == '__main__':      T = int(input())      for i in range(T):          a, b = map(int, input().split())          r = f(a, b)          print('Case #{}: {}'.format(i+1, r))  <CODESPLIT> 27
#!/usr/bin/env python2.7    T = int(raw_input())  for i in xrange(T):      values = map(int, raw_input().split())      [N,s,p] = values[0:3]      t = values[3:]      answer = 0      for note in t:          if note < 2:              if note >= p:                  answer += 1          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:              answer += 1          elif note % 3 == 0:              n = note / 3              if n >= p:                  answer += 1              elif s > 0 and n + 1 >= p:                  answer += 1                  s -= 1          elif note % 3 == 2:              n = (note - 2) / 3              if n + 1 >= p:                  answer += 1              elif s > 0 and n + 2 >= p:                  answer += 1                  s -= 1      print 'Case #{0}: {1}'.format(i+1, answer)  <CODESPLIT> 27
import bisect    T = int(input())    for t in range(T):      N = int(input())      naomi = sorted(list(map(float, input().split())))      ken = sorted(list(map(float, input().split())))      naomi_dw = naomi[:]      ken_dw = ken[:]      war = 0      dwar = 0      for pn in naomi:          pk = bisect.bisect_left(ken, pn)          if pk == len(ken):              war += 1              ken.pop(0)          else:              ken.pop(pk)      for pn in naomi_dw:          if pn > ken_dw[0]:              dwar += 1              ken_dw.pop(0)          else:              ken_dw.pop()      print('Case #{}: {} {}'.format(t + 1, dwar, war))  <CODESPLIT> 27
#!/usr/bin/env python3  # -*- encoding: utf-8 -*-      def f(m):      max_cols = []      for e in zip(*m):          max_cols.append(max(e))        for r in m:          max_row = max(r)          for y, c in enumerate(r):              if c != max_row and c != max_cols[y]:                  return 'NO'      return 'YES'    if __name__ == '__main__':      T = int(input())      for i in range(T):          n, m = map(int, input().split())          r = f([input().split() for i in range(n)])          print('Case #{}: {}'.format(i+1, r))  <CODESPLIT> 27
import sys    sys.setrecursionlimit(9299999)    def min_time(C, F, X, speed, nb_cookies):  	if (X - nb_cookies) / speed < (X - (nb_cookies - C)) / (speed + F):  		return (X - nb_cookies) / speed  	elif nb_cookies >= C:  		return min_time(C, F, X, speed + F, nb_cookies - C)  	else:  		return (C - nb_cookies) / speed + min_time(C, F, X, speed, C)    T = int(raw_input())  for i in range(T):  	C, F, X = map(float, raw_input().split())  	print 'Case #%d: %f' % (i + 1, min_time(C, F, X, 2, 0))  <CODESPLIT> 27
T = int(input())    for i in range(T):      a1 = int(input())      mat1 = [list(map(int, input().split())) for k in range(4)]      a2 = int(input())      mat2 = [list(map(int, input().split())) for k in range(4)]      final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])      if not len(final_set):          s = 'Volunteer cheated!'      elif len(final_set) > 1:          s = 'Bad magician!'      else:          s = list(final_set)[0]      print('Case #{}: {}'.format(i + 1, s))  <CODESPLIT> 27
#!/usr/bin/env python2.6    translate = {'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'q': 'z', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm', 'z': 'q'}    nb = int(raw_input())  for i in xrange(nb):      s = ''.join([translate[char] if char in translate.keys() else char for char in str(raw_input())])      print 'Case #{0}:'.format(i+1), s  <CODESPLIT> 27
#!/usr/bin/env python3  # -*- encoding: utf-8 -*-      def who_won(l):      current = None      for i in l:          if i == '.':              return None          if not current and i in 'OX':              current = i          if current and current != i and i != 'T':              return None      return current      def f(m):      still = False      for i in m:          for j in i:              if j == '.':                  still = True        rows = m # [[m[i][j] for i in range(4)] for j in range(4)]      cols = [[m[i][j] for i in range(4)] for j in range(4)]      diag = [[m[i][i] for i in range(4)], [m[3-i][i] for i in range(4)]]        winner = None        for l in rows + cols + diag:          c = who_won(l)          if c:              winner = c + ' won'        if not winner:          if still:              winner = 'Game has not completed'          else:              winner = 'Draw'      return winner    if __name__ == '__main__':      T = int(input())      for i in range(T):          m = [list(input()) for k in range(4)]          if i != T- 1:              input()          r = f(m)          print('Case #{}: {}'.format(i+1, r))  <CODESPLIT> 27
CACHE = {(1, 1, 0): ['c'],   (1, 2, 0): ['c.'],   (1, 2, 1): ['*c'],   (1, 3, 0): ['c..'],   (1, 3, 1): ['*.c'],   (1, 3, 2): ['**c'],   (1, 4, 0): ['c...'],   (1, 4, 1): ['*.c.'],   (1, 4, 2): ['**.c'],   (1, 4, 3): ['***c'],   (1, 5, 0): ['c....'],   (1, 5, 1): ['*.c..'],   (1, 5, 2): ['**.c.'],   (1, 5, 3): ['***.c'],   (1, 5, 4): ['****c'],   (2, 1, 0): ['c', '.'],   (2, 1, 1): ['*', 'c'],   (2, 2, 0): ['c.', '..'],   (2, 2, 1): None,   (2, 2, 2): None,   (2, 2, 3): ['**', '*c'],   (2, 3, 0): ['c..', '...'],   (2, 3, 1): None,   (2, 3, 2): ['*.c', '*..'],   (2, 3, 3): None,   (2, 3, 4): None,   (2, 3, 5): ['***', '**c'],   (2, 4, 0): ['c...', '....'],   (2, 4, 1): None,   (2, 4, 2): ['*.c.', '*...'],   (2, 4, 3): None,   (2, 4, 4): ['**.c', '**..'],   (2, 4, 5): None,   (2, 4, 6): None,   (2, 4, 7): ['****', '***c'],   (2, 5, 0): ['c....', '.....'],   (2, 5, 1): None,   (2, 5, 2): ['*.c..', '*....'],   (2, 5, 3): None,   (2, 5, 4): ['**.c.', '**...'],   (2, 5, 5): None,   (2, 5, 6): ['***.c', '***..'],   (2, 5, 7): None,   (2, 5, 8): None,   (2, 5, 9): ['*****', '****c'],   (3, 1, 0): ['c', '.', '.'],   (3, 1, 1): ['*', '.', 'c'],   (3, 1, 2): ['*', '*', 'c'],   (3, 2, 0): ['c.', '..', '..'],   (3, 2, 1): None,   (3, 2, 2): ['**', '..', 'c.'],   (3, 2, 3): None,   (3, 2, 4): None,   (3, 2, 5): ['**', '**', '*c'],   (3, 3, 0): ['c..', '...', '...'],   (3, 3, 1): ['*.c', '...', '...'],   (3, 3, 2): None,   (3, 3, 3): ['***', '...', 'c..'],   (3, 3, 4): None,   (3, 3, 5): ['***', '*..', '*.c'],   (3, 3, 6): None,   (3, 3, 7): None,   (3, 3, 8): ['***', '***', '**c'],   (3, 4, 0): ['c...', '....', '....'],   (3, 4, 1): ['*.c.', '....', '....'],   (3, 4, 2): ['**.c', '....', '....'],   (3, 4, 3): ['*.c.', '*...', '*...'],   (3, 4, 4): ['****', '....', 'c...'],   (3, 4, 5): None,   (3, 4, 6): ['****', '*...', '*.c.'],   (3, 4, 7): None,   (3, 4, 8): ['****', '**..', '**.c'],   (3, 4, 9): None,   (3, 4, 10): None,   (3, 4, 11): ['****', '****', '***c'],   (3, 5, 0): ['c....', '.....', '.....'],   (3, 5, 1): ['*.c..', '.....', '.....'],   (3, 5, 2): ['**.c.', '.....', '.....'],   (3, 5, 3): ['***.c', '.....', '.....'],   (3, 5, 4): ['**.c.', '*....', '*....'],   (3, 5, 5): ['*****', '.....', 'c....'],   (3, 5, 6): ['**.c.', '**...', '**...'],   (3, 5, 7): ['*****', '*....', '*.c..'],   (3, 5, 8): None,   (3, 5, 9): ['*****', '**...', '**.c.'],   (3, 5, 10): None,   (3, 5, 11): ['*****', '***..', '***.c'],   (3, 5, 12): None,   (3, 5, 13): None,   (3, 5, 14): ['*****', '*****', '****c'],   (4, 1, 0): ['c', '.', '.', '.'],   (4, 1, 1): ['*', '.', 'c', '.'],   (4, 1, 2): ['*', '*', '.', 'c'],   (4, 1, 3): ['*', '*', '*', 'c'],   (4, 2, 0): ['c.', '..', '..', '..'],   (4, 2, 1): None,   (4, 2, 2): ['**', '..', 'c.', '..'],   (4, 2, 3): None,   (4, 2, 4): ['**', '**', '..', 'c.'],   (4, 2, 5): None,   (4, 2, 6): None,   (4, 2, 7): ['**', '**', '**', '*c'],   (4, 3, 0): ['c..', '...', '...', '...'],   (4, 3, 1): ['*.c', '...', '...', '...'],   (4, 3, 2): ['*.c', '*..', '...', '...'],   (4, 3, 3): ['***', '...', 'c..', '...'],   (4, 3, 4): ['***', '*..', '..c', '...'],   (4, 3, 5): None,   (4, 3, 6): ['***', '***', '...', 'c..'],   (4, 3, 7): None,   (4, 3, 8): ['***', '***', '*..', '*.c'],   (4, 3, 9): None,   (4, 3, 10): None,   (4, 3, 11): ['***', '***', '***', '**c'],   (4, 4, 0): ['c...', '....', '....', '....'],   (4, 4, 1): ['*.c.', '....', '....', '....'],   (4, 4, 2): ['**.c', '....', '....', '....'],   (4, 4, 3): ['**.c', '*...', '....', '....'],   (4, 4, 4): ['****', '....', 'c...', '....'],   (4, 4, 5): ['****', '*...', '..c.', '....'],   (4, 4, 6): ['****', '**..', '...c', '....'],   (4, 4, 7): ['****', '*...', '*.c.', '*...'],   (4, 4, 8): ['****', '****', '....', 'c...'],   (4, 4, 9): None,   (4, 4, 10): ['****', '****', '*...', '*.c.'],   (4, 4, 11): None,   (4, 4, 12): ['****', '****', '**..', '**.c'],   (4, 4, 13): None,   (4, 4, 14): None,   (4, 4, 15): ['****', '****', '****', '***c'],   (4, 5, 0): ['c....', '.....', '.....', '.....'],   (4, 5, 1): ['*.c..', '.....', '.....', '.....'],   (4, 5, 2): ['**.c.', '.....', '.....', '.....'],   (4, 5, 3): ['***.c', '.....', '.....', '.....'],   (4, 5, 4): ['***.c', '*....', '.....', '.....'],   (4, 5, 5): ['*****', '.....', 'c....', '.....'],   (4, 5, 6): ['*****', '*....', '..c..', '.....'],   (4, 5, 7): ['*****', '**...', '...c.', '.....'],   (4, 5, 8): ['*****', '***..', '....c', '.....'],   (4, 5, 9): ['*****', '**...', '*..c.', '*....'],   (4, 5, 10): ['*****', '*****', '.....', 'c....'],   (4, 5, 11): ['*****', '**...', '**.c.', '**...'],   (4, 5, 12): ['*****', '*****', '*....', '*.c..'],   (4, 5, 13): None,   (4, 5, 14): ['*****', '*****', '**...', '**.c.'],   (4, 5, 15): None,   (4, 5, 16): ['*****', '*****', '***..', '***.c'],   (4, 5, 17): None,   (4, 5, 18): None,   (4, 5, 19): ['*****', '*****', '*****', '****c'],   (5, 1, 0): ['c', '.', '.', '.', '.'],   (5, 1, 1): ['*', '.', 'c', '.', '.'],   (5, 1, 2): ['*', '*', '.', 'c', '.'],   (5, 1, 3): ['*', '*', '*', '.', 'c'],   (5, 1, 4): ['*', '*', '*', '*', 'c'],   (5, 2, 0): ['c.', '..', '..', '..', '..'],   (5, 2, 1): None,   (5, 2, 2): ['**', '..', 'c.', '..', '..'],   (5, 2, 3): None,   (5, 2, 4): ['**', '**', '..', 'c.', '..'],   (5, 2, 5): None,   (5, 2, 6): ['**', '**', '**', '..', 'c.'],   (5, 2, 7): None,   (5, 2, 8): None,   (5, 2, 9): ['**', '**', '**', '**', '*c'],   (5, 3, 0): ['c..', '...', '...', '...', '...'],   (5, 3, 1): ['*.c', '...', '...', '...', '...'],   (5, 3, 2): ['*.c', '*..', '...', '...', '...'],   (5, 3, 3): ['***', '...', 'c..', '...', '...'],   (5, 3, 4): ['***', '*..', '..c', '...', '...'],   (5, 3, 5): ['***', '*..', '*.c', '...', '...'],   (5, 3, 6): ['***', '***', '...', 'c..', '...'],   (5, 3, 7): ['***', '***', '*..', '..c', '...'],   (5, 3, 8): None,   (5, 3, 9): ['***', '***', '***', '...', 'c..'],   (5, 3, 10): None,   (5, 3, 11): ['***', '***', '***', '*..', '*.c'],   (5, 3, 12): None,   (5, 3, 13): None,   (5, 3, 14): ['***', '***', '***', '***', '**c'],   (5, 4, 0): ['c...', '....', '....', '....', '....'],   (5, 4, 1): ['*.c.', '....', '....', '....', '....'],   (5, 4, 2): ['**.c', '....', '....', '....', '....'],   (5, 4, 3): ['**.c', '*...', '....', '....', '....'],   (5, 4, 4): ['****', '....', 'c...', '....', '....'],   (5, 4, 5): ['****', '*...', '..c.', '....', '....'],   (5, 4, 6): ['****', '**..', '...c', '....', '....'],   (5, 4, 7): ['****', '**..', '*..c', '....', '....'],   (5, 4, 8): ['****', '****', '....', 'c...', '....'],   (5, 4, 9): ['****', '****', '*...', '..c.', '....'],   (5, 4, 10): ['****', '****', '**..', '...c', '....'],   (5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],   (5, 4, 12): ['****', '****', '****', '....', 'c...'],   (5, 4, 13): None,   (5, 4, 14): ['****', '****', '****', '*...', '*.c.'],   (5, 4, 15): None,   (5, 4, 16): ['****', '****', '****', '**..', '**.c'],   (5, 4, 17): None,   (5, 4, 18): None,   (5, 4, 19): ['****', '****', '****', '****', '***c'],   (5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],   (5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],   (5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],   (5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],   (5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],   (5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],   (5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],   (5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],   (5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],   (5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],   (5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],   (5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],   (5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],   (5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],   (5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],   (5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],   (5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],   (5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],   (5, 5, 18): None,   (5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],   (5, 5, 20): None,   (5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],   (5, 5, 22): None,   (5, 5, 23): None,   (5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}      T = int(input())  for i in range(T):  	R, C, M = map(int, input().split())  	print('Case #{}:'.format(i + 1))  	try:  		print('\n'.join(CACHE[(R, C, M)]))  	except:  		print('Impossible')  <CODESPLIT> 27
#!/usr/bin/env python2.7    T = int(raw_input())  for i in xrange(T):      values = map(int, raw_input().split())      [N,s,p] = values[0:3]      t = values[3:]      answer = 0      for note in t:          if note < 2:              if note >= p:                  answer += 1          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:              answer += 1          elif note % 3 == 0:              n = note / 3              if n >= p:                  answer += 1              elif s > 0 and n + 1 >= p:                  answer += 1                  s -= 1          elif note % 3 == 2:              n = (note - 2) / 3              if n + 1 >= p:                  answer += 1              elif s > 0 and n + 2 >= p:                  answer += 1                  s -= 1      print 'Case #{0}: {1}'.format(i+1, answer)  <CODESPLIT> 27
  import sys  import math    def is_fair(n):      n = str(n)      for i in range(long(len(n) / 2)):          if n[i] != n[len(n) - i - 1]:              return False      return True    def is_square_and_fair(n):      if not is_fair(n): return False      root = math.sqrt(n)      if root != math.floor(root): return False      if not is_fair(long(root)): return False      return True    def process():      a, b = sys.stdin.readline().split()      a = long(a)      b = long(b)            count = 0      for i in range(a, b + 1):          if is_square_and_fair(i): count = count + 1        return count    def main():        count = int(sys.stdin.readline())      for index in range(count):          result = process()          print "Case #%d: %s" % (index + 1, result)    if __name__ == '__main__':      main()  <CODESPLIT> 28
import sys      def calculate_max_score(scores_sum):      if scores_sum % 3 == 1:          max_score = (scores_sum + 2) / 3          return (max_score, max_score)      if scores_sum % 3 == 2:          max_score = (scores_sum + 1) / 3          return (max_score, max_score + 1)      max_score = scores_sum / 3      if max_score == 0:          return (0, 0)      return (max_score, max_score + 1)    def find_max_dancers(s, p, *scores_sums):      dancers_count = 0      for scores_sum in scores_sums:          (normal_max, surprise_max) = calculate_max_score(scores_sum)          if normal_max >= p:              dancers_count = dancers_count + 1              continue          if surprise_max >= p and s > 0:              s = s - 1              dancers_count = dancers_count + 1              continue      return dancers_count    def main():        case_count = int(sys.stdin.readline())        for case_index in range(1, case_count + 1):          line = sys.stdin.readline().strip().split(' ')          s = int(line[1])          p = int(line[2])          scores_sums = [int(scores_sum) for scores_sum in line[3:]]          print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums))    if __name__ == '__main__':      main() <CODESPLIT> 28
import sys  import Queue    def ken(ken_blocks, naomi_block):      """      Since ken do not know Naomi's blocks weights      Best strategy will be spent the smallest block to beat Naomi      """        for block in ken_blocks:          if block > naomi_block:              ken_blocks = ken_blocks[:]              ken_blocks.remove(block)              return True, ken_blocks        ken_blocks = ken_blocks[1:]      return False, ken_blocks    def naomi(naomi_blocks):      naomi_block = naomi_blocks[0]      naomi_blocks = naomi_blocks[1:]      return naomi_block, naomi_blocks    def play(naomi_blocks, ken_blocks):      naomi_points = 0      ken_points = 0        naomi_blocks.sort()      ken_blocks.sort()        while naomi_blocks and ken_blocks:          naomi_block, naomi_blocks = naomi(naomi_blocks)          ken_wins, ken_blocks = ken(ken_blocks, naomi_block)          if ken_wins:              ken_points += 1          else:              naomi_points += 1        return naomi_points    def naomi2(naomi_blocks, ken_blocks):      target = ken_blocks[0]      for block in naomi_blocks:          if block > target:              naomi_blocks = naomi_blocks[:]              naomi_blocks.remove(block)              return ken_blocks[-1] + 0.0000001, naomi_blocks      return naomi_blocks[0], naomi_blocks[1:]    def cheat(naomi_blocks, ken_blocks):      naomi_points = 0      ken_points = 0        naomi_blocks.sort()      ken_blocks.sort()        while naomi_blocks and ken_blocks:          naomi_block, naomi_blocks = naomi2(naomi_blocks, ken_blocks)          ken_wins, ken_blocks = ken(ken_blocks, naomi_block)          if ken_wins:              ken_points += 1          else:              naomi_points += 1      return naomi_points    def main():      cases = int(sys.stdin.readline())        for case in range(cases):          N = int(sys.stdin.readline())          naomi_blocks = map(float, sys.stdin.readline().split())          ken_blocks = map(float, sys.stdin.readline().split())          assert len(naomi_blocks) is N          assert len(ken_blocks) is N            normal_war = play(naomi_blocks, ken_blocks)          cheat_war = cheat(naomi_blocks, ken_blocks)          print 'Case #%d: %d %d' % (case + 1, cheat_war, normal_war)    if __name__ == '__main__':      main()  <CODESPLIT> 28
  import sys    def process():      height, width = sys.stdin.readline().split()      width = int(width)      height = int(height)        lawn = [[0 for c in range(width)] for r in range(height)]      mark = [[0 for c in range(width)] for r in range(height)]      settings = []        for r in range(height):          row = sys.stdin.readline().split()          for c in range(width):              h = int(row[c])              lawn[r][c] = h              if h not in settings: settings.append(h)        settings = sorted(settings)        for i in range(len(settings)):          h = settings[i]          h_next = 0          if i < len(settings) - 1:              h_next = settings[i + 1]            # check row          for r in range(height):              count = 0              for c in range(width):                  if lawn[r][c] == h: count = count + 1              if count == width:                  for c in range(width): mark[r][c] = h            # check col          for c in range(width):              count = 0              for r in range(height):                  if lawn[r][c] == h: count = count + 1              if count == height:                  for r in range(height): mark[r][c] = h            # anything left?          for c in range(width):              for r in range(height):                  if lawn[r][c] == h:                      if mark[r][c] != h: return "NO"                      lawn[r][c] = h_next        return "YES"                def main():        count = int(sys.stdin.readline())      for index in range(count):          result = process()          print "Case #%d: %s" % (index + 1, result)    if __name__ == '__main__':      main()  <CODESPLIT> 28
import sys  import Queue      def click(C, F, X):      states = Queue.PriorityQueue()        # (time, rate, is_done)      states.put((0.0, 2.0, False))      while not states.empty():          time, rate, is_done = states.get()            # done          if is_done:              return time            # two ways to move forward          # 1. wait          states.put((              time + X / rate,              rate,              True          ))            # 2. wait for a farm          states.put((              time + C / rate,              rate + F,              False          ))        return None    def main():      cases = int(sys.stdin.readline())        for case in range(cases):          C, F, X = map(float, sys.stdin.readline().split())          print 'Case #%d: %.7f' % (case + 1, click(C, F, X))    if __name__ == '__main__':      main()  <CODESPLIT> 28
import sys      def main():      cases = int(sys.stdin.readline())        for case in range(cases):          row1 = int(sys.stdin.readline())          arrangement1 = [              map(int, sys.stdin.readline().split())              for _ in range(4)          ]          chosen1 = set(arrangement1[row1 - 1])            row2 = int(sys.stdin.readline())          arrangement2 = [              map(int, sys.stdin.readline().split())              for _ in range(4)          ]          chosen2 = set(arrangement2[row2 - 1])            chosen = chosen1 & chosen2            if not chosen:              print 'Case #%d: Volunteer cheated!' % (case + 1)          elif len(chosen) != 1:              print 'Case #%d: Bad magician!' % (case + 1)          else:              print 'Case #%d: %d' % (case + 1, chosen.pop())    if __name__ == '__main__':      main()  <CODESPLIT> 28
import sys    cipher = dict()    def learn(encrypted_text, clear_text):      for encrypted_letter, clear_letter in zip(encrypted_text, clear_text):          if encrypted_letter in cipher:              assert cipher[encrypted_letter] == clear_letter          cipher[encrypted_letter] = clear_letter    def test():      alphabet = 'abcdefghijklmnopqrstuvwxyz '      for letter in alphabet:          if letter not in cipher.keys():              print 'Googlerese letter %s does not have corresponding English letter.' % letter          if letter not in cipher.values():              print 'English letter %s not found in cipher dictionary values.' % letter      if len(cipher.keys()) != len(alphabet):          print 'Size of cipher dictionary and alphabet mismatch.'    def decrypt(text):      decrypted_text = ''      for letter in text:          assert letter in cipher          decrypted_text += cipher[letter]      return decrypted_text    def main():      learn(' yeqz', ' aozq')      learn('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand')      learn('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities')      learn('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')      test()        case_count = int(sys.stdin.readline())        for case_index in range(1, case_count + 1):          print 'Case #%i: %s' % (case_index, decrypt(sys.stdin.readline().strip()))    if __name__ == '__main__':      main() <CODESPLIT> 28
  import sys    def process():      empty = 0      board = [['.', '.', '.', '.'] for i in range(4)]      for r in range(4):          row = sys.stdin.readline()          for c in range(4):              board[r][c] = row[c]              if row[c] == '.': empty = empty + 1      sys.stdin.readline()        # print board        # check rows      for r in range(4):          x = 0          o = 0          for c in range(4):              if board[r][c] == 'X':                  x = x + 1              if board[r][c] == 'O':                  o = o + 1              if board[r][c] == 'T':                  x = x + 1                  o = o + 1          if x == 4: return "X won"          if o == 4: return "O won"        for c in range(4):          x = 0          o = 0          for r in range(4):              if board[r][c] == 'X':                  x = x + 1              if board[r][c] == 'O':                  o = o + 1              if board[r][c] == 'T':                  x = x + 1                  o = o + 1          if x == 4: return "X won"          if o == 4: return "O won"        x = 0      o = 0      for c in range(4):          r = c          if board[r][c] == 'X':              x = x + 1          if board[r][c] == 'O':              o = o + 1          if board[r][c] == 'T':              x = x + 1              o = o + 1        if x == 4: return "X won"      if o == 4: return "O won"        x = 0      o = 0      for c in range(4):          r = 3 - c          if board[r][c] == 'X':              x = x + 1          if board[r][c] == 'O':              o = o + 1          if board[r][c] == 'T':              x = x + 1              o = o + 1        if x == 4: return "X won"      if o == 4: return "O won"        if empty == 0: return "Draw"        return "Game has not completed"                def main():        count = int(sys.stdin.readline())      for index in range(count):          result = process()          print "Case #%d: %s" % (index + 1, result)    if __name__ == '__main__':      main()  <CODESPLIT> 28
import sys  import random    NEIGHBOURS = [      (-1, -1), (-1, 0), (-1, 1),      ( 0, -1),          ( 0, 1),      ( 1, -1), ( 1, 0), ( 1, 1),  ]    MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]    def valid(size, location, changes):      y, x = location      for y1, x1 in changes:          y1 += y          x1 += x          if y1 < 0 or y1 >= size[0]:              continue          if x1 < 0 or x1 >= size[1]:              continue          yield (y1, x1)    def click(size, grid, location):      y, x = location      if grid[y][x] is 0:          return None        grid = [row[:] for row in grid]      grid[y][x] = 0        for y, x in valid(size, location, NEIGHBOURS):          if grid[y][x]:              grid[y][x] = False        return grid    def sweep(R, C, M):      # create initial grid      grid = [[True] * C for _ in range(R)]      size = (R, C)        if M + 1 == R * C:          grid[0][0] = False          return grid, (0, 0)        # start by click top left      states = []      for y in range(R):          for x in range(C):              location = (y, x)              states.append((click(size, grid, location), location))        while states:          grid, location = states.pop(0)            mines_count = sum([sum(row) for row in grid])          if mines_count == M:              return grid, location            if mines_count < M:              continue            for new_location in valid(size, location, NEIGHBOURS):              new_grid = click(size, grid, new_location)              if new_grid:                  states.insert(0, (new_grid, new_location))        return None    def validate(size, grid, location):        result = [row[:] for row in grid]        y, x = location      result[y][x] = sum([          grid[y1][x1]          for y1, x1 in valid(size, (y, x), NEIGHBOURS)      ])      assert result[y][x] == 0        seen = set([location])      locations = set([location])        while locations:          location = locations.pop()          for y, x in valid(size, location, NEIGHBOURS):              assert grid[y][x] is not True              result[y][x] = sum([                  grid[y1][x1]                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)              ])              if result[y][x] == 0 and (y, x) not in seen:                  locations.add((y, x))                  seen.add((y, x))        for row in result:          for col in row:              assert col is not False      #print result        for y, row in enumerate(result):          output = ''          for x, col in enumerate(row):              if col is True:                  output += '*'              else:                  output += str(col)          print output      def process(case, R, C, M):      result = sweep(R, C, M)        print 'Case #%d:' % (case + 1)      #print R, C, M      if not result:          #print R, C, M          print 'Impossible'          return        grid, location = result      for y, row in enumerate(grid):          output = ''          for x, col in enumerate(row):              if (y, x) == location:                  output += 'c'              elif col:                  output += '*'              #elif col is 0:              #    output += '0'              else:                  output += '.'          print output        #validate((R, C), grid, location)      def main():      #for R in range(1, 6):      #    for C in range(1, 6):      #        for M in range(R * C):      #            process(0, R, C, M)      #return      #for M in range(1, 25):      #    process(M - 1, 5, 5, M)      #return      cases = int(sys.stdin.readline())        for case in range(cases):          R, C, M = map(int, sys.stdin.readline().split())          process(case, R, C, M)        return      for case in range(100):          R = random.randrange(51) + 1          C = random.randrange(51) + 1          M = random.randrange(R * C - 1) + 1          process(case * 100000 + M - 1, R, C, M)      if __name__ == '__main__':      main()  <CODESPLIT> 28
import sys    def find_recycled_pairs(A, B):      count = 0      l = len(str(A))      for i in range(A, B + 1):          variants = []          for d in range(1, l):              fixed = str(i)[:d]              moving = str(i)[-(l - d):]              j = int(moving + fixed)              if j != i and len(str(i)) == len(str(j)) and j in range(A, B + 1) and j not in variants:                  variants.append(j)                  #print '%s -> %s' % (fixed + moving, moving + fixed)                  count = count + 1      return count / 2      def find_recycled_pairs_efficient(A, B):      count = 0      sa = str(A)      sb = str(B)      l = len(sa)      for fixed in range(1, l):          moving = l - fixed          x = int(sa[:fixed])          y = int(sb[:fixed])          m = int(sa[-fixed:])          n = int(sb[-fixed:])          j = int(sa[:moving])          k = int(sb[:moving])          print '%i fixed: x = %i, m = %i, n = %i, y = %i, j = %i, k = %i' % (fixed, x, m, n, y, j, k)            if int(str(y) + str(k)) >= B:              k1 = int(sb[-moving:])              print 'k1 - j = %i - %i' % (k1, j)              if k1 > j:                  count = count + (k1 - j)          if int(str(x) + str(j)) <= A:              j1 = int(sa[-moving:])              print 'k - j1 = %i - %i' % (k, j1)              if k > j1:                  count = count + (k - j1)            if len(str(k)) >= len(str(x)):              count = count + (y - x) * (k - j)          else:              count = count + (y - x - 1) * (k - j + 1)            if x < m:              count = count - (m - x - 1)          if y > n:              count = count - (y - n - 1)        return count / 2    def main():        case_count = int(sys.stdin.readline())        for case_index in range(1, case_count + 1):          (A, B) = sys.stdin.readline().strip().split(' ')          A = int(A)          B = int(B)          assert len(str(A)) == len(str(B))          print 'Case #%i: %s' % (case_index, find_recycled_pairs(A, B))    if __name__ == '__main__':      main() <CODESPLIT> 28
def check(a,b):      c = 0      n = 1      for i in range(1,4):          if i**2 >= a and i**2 <=b:              c += 1      if 44944 >= a and 44944 <= b:          c += 1      while n < 10:          p1 = int('1'+'1'*n)**2          if p1 >= a and p1 <=b:              c += 1          n += 1          if 484 >= a and 484 <= b:          c += 1        n = 1      while True:          p2 = int('1'+'0'*n+'1')**2          p3 = int('2'+'0'*n+'2')**2          if p2 >= a and p2 <= b:              c += 1          else:              break          if p3 >= a and p3 <= b:              c += 1          else:              continue          n += 1        n = 1      while True:          t = False          for m in range(2,5):              p4 = int('1'*m+'0'*n+'1'*m)**2              if p4 >= a and p4 <= b:                  c += 1              else:                  t = True                  break          if t:              break                        n += 1      return c                    dat = raw_input().split()  n = int(dat.pop(0))  data = [int(e) for e in dat]    for i in range(0, n*2, 2):      a, b = data[i], data[i+1]      print 'Case #%i: '%(i/2+1) + str(check(a,b))           <CODESPLIT> 29
f = open('cj2.in','r')  out = open('out1.txt','w')  inp = [[int(n) for n in s.split()] for s in f.readlines()]    def score_partition(score):      poss = []      if score == 0:          return [[0,0,0]]      if score == 1:          return [[0,0,1]]      if score % 3 == 0:          poss.append([score/3,score/3,score/3])          poss.append([score/3-1,score/3,score/3+1])      if score % 3 == 1:          poss.append([score/3, score/3,score/3+1])          poss.append([score/3-1,score/3+1,score/3+1])      if score % 3 == 2:          poss.append([score/3,score/3+1,score/3+1])          poss.append([score/3,score/3,score/3+2])        return poss      s = 0  c = 1  for e in inp[1:len(inp)]:      count = 0      surprises = e[1]      s = 0      p = e[2]      for i in e[3:len(e)]:          scores = score_partition(i)          for j in scores:               if max(j) >= p:                  if max(j)-min(j) == 2:                      if s < surprises:                          s +=1                          count +=1                          break                  else:                      count += 1                      break                        out.write('Case #'+str(c)+': '+str(count)+'\n')      c += 1    out.close()  f.close()                                                  <CODESPLIT> 29
def war(n, k):      k.sort()      score = 0      for x in n:          for i  in xrange(len(k)):              if k[i] > x:                  score += 1                  k.pop(i)                  break      return len(n) - score                      def deceit(n, k):      n.sort()      k.sort()      score = 0      for y in k:          for i in xrange(len(n)):              if n[i] > y:                  score +=1                  n.pop(i)                  break      return score          f = open('Dsmall.in', 'r')  g = open('outputD.txt', 'w')    data = [[float(e) for e in line.strip("\n").split(' ')] for line in f]  T = int(data.pop(0)[0])  c = 1  for i in xrange(0, T*3, 3):      N = data[i+1]      K = data[i+2]        w = war(N, list(K))      d = deceit(list(N), list(K))      g.write('Case #%i: %i %i\n' %(c, d, w))      c += 1    f.close()  g.close()    <CODESPLIT> 29
  def check(grid, n, m):      for i in range(n):          for j in range(m):              if neighbor(grid,i,j,n,m):                  return False      return True    def neighbor(grid,i,j,n,m):      u = not i      d = not (n-i-1)      l = not j      r = not (m-j-1)      if n == 1:          return False      if m == 1:          return False      if i > 0:          for k in range(i,-1,-1):              if grid[k][j] > grid[i][j]:                  u = 1                    if i < n-1:          for k in range(i,n):              if grid[k][j] > grid[i][j]:                  d = 1                if j > 0:          for k in range(j,-1,-1):              if grid[i][k] > grid[i][j]:                  l = 1                if j < m-1:          for k in range(j,m):              if grid[i][k] > grid[i][j]:                  r = 1      return (u*d*l*r)              dat = raw_input().split()  c = int(dat.pop(0))  data = [int(e) for e in dat]  index = 0  t = 0  while t < c:      n = data[index]      m = data[index+1]      index += 2      grid = []      for i in range(n):          grid.append(data[index:index+m])          index += m      if check(grid, n, m):          print 'Case #%i: YES'%(t+1)      else:          print 'Case #%i: NO'%(t+1)      t += 1  <CODESPLIT> 29
f = open('Bsmall.in', 'r')  ##f = open('test.txt', 'r')  g = open('outputB.txt', 'w')    data = [[float(e) for e in line.strip("\n").split(' ')] for line in f]  T = int(data.pop(0)[0])    for i, case in enumerate(data):      C, F, X = case[0], case[1], case[2]      n = 1      t = X/2      t_next = X/(2 + F) + C/2      metric = (t_next < t)      while metric:          n += 1          t = t_next          t_next = t_next - X/(2 + F*(n-1)) + C/(2 + F*(n-1)) + X/(2 + F*n)          metric = (t_next < t)      g.write('Case #%i: %f\n' %(i+1, t))  f.close()  g.close()  <CODESPLIT> 29
f = open('A.in', 'r')  g = open('outputA.txt', 'w')  data = [[int(e) for e in line.strip("\n").split(' ')] for line in f]  T = data[0][0]  c = 0  for i in xrange(1, T*10 + 1, 10):      c += 1      choice1 = data[i][0]      choice2 = data[i+5][0]      grid1, grid2 = [], []      for j in xrange(1,5):          grid1.append(data[i+j])        for j in xrange(6, 10):          grid2.append(data[i+j])        s1 = set(grid1[choice1-1])      s2 = set(grid2[choice2-1])        s = s1 & s2      if len(s) == 1:          g.write("Case #%i: %i\n" %(c, s.pop()))      elif not s:          g.write("Case #%i: Volunteer cheated!\n" %(c))      else:          g.write("Case #%i: Bad magician!\n" %(c))    f.close()  g.close()        <CODESPLIT> 29
mapping = {'y':'a','n':'b','f':'c','i':'d','c':'e','w':'f','l':'g','b':'h','k':'i','u':'j','o':'k','m':'l','x':'m','s':'n','e':'o','v':'p','p':'r','d':'s','r':'t','j':'u','g':'v','t':'w','h':'x','a':'y','q':'z','z':'q',' ':' ','\n':'\n'}    f = open('cj.in','r')  out = open('out.txt','w')  inp = [line for line in f]    i = 1  for G in inp[1:len(inp)]:      string = ''      for e in G:          string+=mapping[e]      out.write('Case #'+str(i)+': '+string)      i+=1    f.close()  out.close()  <CODESPLIT> 29
  def checkRow(d, t):      g = 0      for row in d:          a = list(row)          a.sort()          a = ''.join(a)          if 'TXXX' in a or 'XXXX' in a:              print 'Case #%i: X won' %(t/4+1)              return 1          if 'OOOT' in a or 'OOOO' in a:              print 'Case #%i: O won' %(t/4+1)              return 1          if '.' in a:              g = 10      return g    def checkCol(d, t):      for j in range(4):          col = []          for row in d:              col.append(row[j])          a = list(col)          a.sort()          a = ''.join(a)          if 'TXXX' in a or 'XXXX' in a:              print 'Case #%i: X won' %(t/4+1)              return 1          if 'OOOT' in a or 'OOOO' in a:              print 'Case #%i: O won' %(t/4+1)              return 1      return 0    def checkDiag(d1, d2, t):      a = list(d1)      b = list(d2)      a.sort()      b.sort()      a = ''.join(a)      b = ''.join(b)        if 'TXXX' in a or 'XXXX' in a:          print 'Case #%i: X won' %(t/4+1)          return 1      if 'OOOT' in a or 'OOOO' in a:          print 'Case #%i: O won' %(t/4+1)          return 1        if 'TXXX' in b or 'XXXX' in b:          print 'Case #%i: X won' %(t/4+1)          return 1      if 'OOOT' in b or 'OOOO' in b:          print 'Case #%i: O won' %(t/4+1)          return 1      return 0    dat = raw_input()    data = dat.split()  c = int(data.pop(0))    for t in range(0, 4*c, 4):      a = checkRow(data[t:t+4],t)      if a == 1:          continue      b = checkCol(data[t:t+4],t)      if b:          continue      d1 = data[t][0]+data[t+1][1]+data[t+2][2]+data[t+3][3]      d2 = data[t][3]+data[t+1][2]+data[t+2][1]+data[t+3][0]      c = checkDiag(d1, d2,t)      if c:          continue      if (a+b+c) == 0:          print 'Case #%i: Draw' %(t/4+1)      if a == 10:          print 'Case #%i: Game has not completed' %(t/4+1)     <CODESPLIT> 29
def make_string(R, C, M):      grid = [['.' for j in xrange(C)] for i in xrange(R)]      grid[-1][-1] = 'c'      t = M      for i in xrange(R):          for j in xrange(C):              if M:                  if forbidden(R, C, t, i, j):                      continue                  grid[i][j] = '*'                  M -= 1              else:                  break      s = ''      if M:          return 'Impossible'      for r in grid:          s += ''.join(r)+'\n'      return s[:-1]    def forbidden(R, C, M, i, j):      a = M / C      b = M % C      if (R*C - M == 1):          return False        if i >= (R-2) and j >= (C-2):          return True        if i >= (R-2) and b:          if b % 2:              return True          if j < b/2:              return False          else:              return True      return False              f = open('Csmall.in', 'r')  ##f = open('test.txt', 'r')  g = open('outputC.txt', 'w')    data = [[int(e) for e in line.strip("\n").split(' ')] for line in f]  T = int(data.pop(0)[0])  for i, case in enumerate(data):      R, C, M = case[0], case[1], case[2]      num_cells = R*C      if (R-1) == 0 or (C-1) == 0:          s = make_string(R, C, M)          g.write('Case #%i:\n%s\n' %(i+1,s))          continue      else:          s = make_string(R, C, M)          g.write('Case #%i:\n%s\n' %(i+1, s))              f.close()  g.close()  <CODESPLIT> 29
import math    f = open('csmall.in','r')  out = open('out3.txt','w')  inp = [[int(n) for n in s.split()] for s in f.readlines()]  count = 1    for e in inp[1:len(inp)]:      interval = xrange(e[0],e[1]+1)      exp = xrange(1, int(math.log(interval[-1],10))+1)      skip = []      pairs = []      for i in interval:          if str(i)[::-1] == str(i):              continue          for j in exp:              val = int(str(i%10**j)+str(i/10**j))              if val in skip:                  continue              elif val >= interval[0] and val <= interval[-1] and not val == i:                  skip.append(i)      out.write('Case #'+str(count)+': '+str(len(skip))+'\n')      count += 1    f.close()  out.close()  <CODESPLIT> 29
#!/usr/bin/env python  import math  import sys      def is_palindrome(a):      return str(a) == ''.join(reversed(str(a)))      def solve_problem(min_num, max_num):      count = 0      for i in xrange(min_num, max_num + 1):          if is_palindrome(i):              sqrt = math.sqrt(i)              if int(sqrt) == sqrt and is_palindrome(int(sqrt)):                  count += 1      return count      if __name__ == '__main__':      num_of_cases = int(sys.stdin.readline())      for i in xrange(1, num_of_cases + 1):          min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))          print 'Case #{0}: {1}'.format(i, solve_problem(min_num, max_num))  <CODESPLIT> 30
"""  Google Code Jam 2012 Problem B  Usage:      python problem_b.py < input.txt > output.txt  """  import itertools  import sys      def calc_possible(n):      combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores      return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)      def calc_surprising(n):      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))      return results[0] if results else None      def calc_normal(n):      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))      return results[0] if results else None      def solve_problem():      number_of_cases = int(sys.stdin.readline())        for i in xrange(1, number_of_cases + 1):            case = sys.stdin.readline().strip()          result = 0          num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)          num_of_googlers = int(num_of_googlers)          num_of_surprising = int(num_of_surprising)          desired_score = int(desired_score)          scores = map(int, scores.split())            possible_scores = []            for k in xrange(num_of_googlers):                normal = calc_normal(scores[k])              surprising = calc_surprising(scores[k])                possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))            possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))          result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))            sys.stdout.write('Case #{0}: {1}\n'.format(i, result))      if __name__ == '__main__':      solve_problem()  <CODESPLIT> 30
"""  Google Code Jam 2014 Qualification Problem D  Usage:      python d.py < input.txt > output.txt  """  import sys      def memoized(func):      cache = {}      def wrapped(*args):          if not args in cache:              cache[args] = func(*args)          return cache[args]      return wrapped      @memoized  def play_dwar(naomi_blocks, ken_blocks):      if not naomi_blocks:          return 0        max_score = 0        for naomi_choice in naomi_blocks:          naomi_remaining = tuple(b for b in naomi_blocks if b != naomi_choice)            ken_better = tuple(b for b in ken_blocks if b > naomi_choice)          ken_worse = tuple(b for b in ken_blocks if b < naomi_choice)            if ken_better and not ken_worse:              ken_choice = max(ken_better)              ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)              score = 0 + play_dwar(naomi_remaining, ken_remaining)          else:              ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))              score = 1 + play_dwar(naomi_remaining, ken_remaining)            max_score = max(max_score, score)        return max_score      @memoized  def play_war(naomi_blocks, ken_blocks):      if not naomi_blocks:          return 0        max_score = 0        for naomi_choice in naomi_blocks:          naomi_remaining = tuple(b for b in naomi_blocks if b != naomi_choice)            ken_better = tuple(b for b in ken_blocks if b > naomi_choice)            if ken_better:              ken_choice = min(ken_better)              ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)              score = 0 + play_war(naomi_remaining, ken_remaining)          else:              ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))              score = 1 + play_war(naomi_remaining, ken_remaining)            max_score = max(max_score, score)        return max_score      def solve_problem(naomi_blocks, ken_blocks):      return play_dwar(naomi_blocks, ken_blocks), play_war(naomi_blocks, ken_blocks)      if __name__ == "__main__":      num_of_cases = int(sys.stdin.readline().strip())      for i in xrange(1, num_of_cases + 1):            num_of_blocks = int(sys.stdin.readline().strip())            naomi_blocks = tuple(map(float, sys.stdin.readline().strip().split()))          ken_blocks = tuple(map(float, sys.stdin.readline().strip().split()))            print "Case #{0}: {1} {2}".format(i, *solve_problem(naomi_blocks, ken_blocks))  <CODESPLIT> 30
#!/usr/bin/env python  import sys      def solve_problem(lawn, size_x, size_y):      for i in xrange(size_x):          for k in xrange(size_y):              elem = lawn[i][k]              if max(lawn[i]) > elem and max([lawn[j][k] for j in xrange(size_x)]) > elem:                  return 'NO'        return 'YES'    def read_lawn(stdin, size_x, size_y):      lawn = []      for i in xrange(size_x):          line = map(int, sys.stdin.readline().strip().split(' '))          lawn.append(line)      return lawn      if __name__ == '__main__':      num_of_cases = int(sys.stdin.readline())      for i in xrange(1, num_of_cases + 1):          size_x, size_y = map(int, sys.stdin.readline().strip().split(' '))          lawn = read_lawn(sys.stdin, size_x, size_y)          print 'Case #{0}: {1}'.format(i, solve_problem(lawn, size_x, size_y))  <CODESPLIT> 30
"""  Google Code Jam 2014 Qualification Problem B  Usage:      python b.py < input.txt > output.txt  """  import sys      def solve_problem(farm_cost, farm_rate, target):      rate = 2.0      farms = 0.0        while (farms + target / rate) > (farms + farm_cost / rate + target / (rate + farm_rate)):          farms = farms + farm_cost / rate          rate = rate + farm_rate        return farms + target / rate      if __name__ == "__main__":      num_of_cases = int(sys.stdin.readline().strip())      for i in xrange(1, num_of_cases + 1):          farm_cost, farm_rate, target = map(float, sys.stdin.readline().strip().split())          print "Case #{0}: {1:9.7f}".format(i, solve_problem(farm_cost, farm_rate, target))  <CODESPLIT> 30
"""  Google Code Jam 2014 Qualification Problem A  Usage:      python a.py < input.txt > output.txt  """  import sys      def solve_problem(first, first_rows, second, second_rows):      intersection = set(first_rows[first - 1]) & set(second_rows[second - 1])        if not intersection:          return "Volunteer cheated!"      elif len(intersection) > 1:          return "Bad magician!"      else:          return intersection.pop()        if __name__ == "__main__":      num_of_cases = int(sys.stdin.readline().strip())        for i in xrange(1, num_of_cases + 1):          first_answer = int(sys.stdin.readline().strip())          first_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]            second_answer = int(sys.stdin.readline().strip())          second_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]            print "Case #{0}: {1}".format(i, solve_problem(first_answer, first_arrangement, second_answer, second_arrangement))  <CODESPLIT> 30
"""  Google Code Jam 2012 Problem A  Usage:      python problem_a.py < input.txt > output.txt  """  import sys    hints = {      'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',      'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',      'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up',  }    mapping = {'q': 'z', 'z': 'q'}    for k, v in hints.items():      for from_char, to_char in zip(k, v):          mapping[from_char] = to_char    def solve_problem():      number_of_cases = int(sys.stdin.readline())      for i in xrange(1, number_of_cases + 1):          case = sys.stdin.readline().strip()          translated = ''.join(map(lambda c: mapping.get(c, c), case))          sys.stdout.write('Case #{0}: {1}\n'.format(i, translated))    if __name__ == '__main__':      solve_problem()  <CODESPLIT> 30
#!/usr/bin/env python  import sys  import itertools      WINNING = (      set(['X']),      set(['O']),      set(['X', 'T']),      set(['O', 'T']),  )      def solve_problem(matrix):      game_completed = True        lines_combo = (matrix[i] for i in xrange(4))      rows_combo = ((matrix[k][i] for k in xrange(4)) for i in xrange(4))      diagonals = ((matrix[i][i] for i in xrange(4)),                   (matrix[i][3 - i] for i in xrange(4)))        for combo in itertools.chain(lines_combo, rows_combo, diagonals):          combo_set = set(combo)          if combo_set in WINNING:              if 'X' in combo_set:                  return 'X won'              if 'O' in combo_set:                  return 'O won'          if '.' in combo_set:              game_completed = False        # we have no winner, check game status        if game_completed:          return 'Draw'      else:          return 'Game has not completed'        return 0    def read_matrix(stdin):      matrix = [[], [], [], []]      for i in xrange(4):          line = stdin.readline().strip()          for k in line:              matrix[i].append(k)      return matrix      if __name__ == '__main__':      num_of_cases = int(sys.stdin.readline())      for i in xrange(1, num_of_cases + 1):          matrix = read_matrix(sys.stdin)          print 'Case #{0}: {1}'.format(i, solve_problem(matrix))          sys.stdin.readline() # separator  <CODESPLIT> 30
"""  Google Code Jam 2014 Qualification Problem C  Usage:      python c.py < input.txt > output.txt  """  import copy  import itertools  import sys      def iter_neighbors(x, y, cells):      columns = len(cells[0])      rows = len(cells)        if y > 0:          if x > 0:              yield x - 1, y - 1          yield x, y - 1            if x + 1 < columns:              yield x + 1, y - 1        if x > 0:          yield x - 1, y        if x + 1 < columns:          yield x + 1, y        if y + 1 < rows:          if x > 0:              yield x - 1, y + 1            yield x, y + 1            if x + 1 < columns:              yield x + 1, y + 1      def try_to_click(x, y, cells, remaining):      if remaining == 0:          return cells        recent = []        opened = 0        for n_x, n_y in iter_neighbors(x, y, cells):          if cells[n_y][n_x] == "?":              cells[n_y][n_x] = "."              opened += 1              recent.append((n_x, n_y))        if opened == remaining:          return cells        if opened > remaining:          return []        for n_x, n_y in recent:          solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)          if solution:              return solution        return []      def solve_problem(rows, columns, mines):        for x in xrange(columns):          for y in xrange(rows):              cells = [["?" for i in xrange(columns)] for j in xrange(rows)]              cells[y][x] = "c"              solution = try_to_click(x, y, cells, rows * columns - mines - 1)                if solution:                  return "\n".join(["".join(row) for row in solution]).replace("?", "*")        return "Impossible"      if __name__ == "__main__":      num_of_cases = int(sys.stdin.readline().strip())      for i in xrange(1, num_of_cases + 1):            rows, columns, mines = map(int, sys.stdin.readline().strip().split())            print "Case #{0}:\n{1}".format(i, solve_problem(rows, columns, mines))  <CODESPLIT> 30
"""  Google Code Jam 2012 Problem C  Usage:      python problem_c.py < input.txt > output.txt  """  import itertools  import sys      def is_recycled(n, m, _cache={}, _cache_sorted={}, _cache_length={}):      if not n in _cache:          _cache[n] = str(n)        if not m in _cache:          _cache[m] = str(m)        str_n = _cache[n]      str_m = _cache[m]        if not n in _cache_sorted:          _cache_sorted[n] = sorted(str_n)        if not m in _cache_sorted:          _cache_sorted[m] = sorted(str_m)        if _cache_sorted[n] != _cache_sorted[m]:          return False        if not n in _cache_length:          _cache_length[n] = len(str_n)        for i in xrange(_cache_length[n] + 1):          if str_m == str_n[i:] + str_n[:i]:              return True        return False      def solve_problem():      number_of_cases = int(sys.stdin.readline())        for i in xrange(1, number_of_cases + 1):          case = sys.stdin.readline().strip()          A, B = map(int, case.split())          result = sum(itertools.imap(lambda (n, m): is_recycled(n, m),                                      itertools.combinations(xrange(A, B + 1), 2)))            sys.stdout.write('Case #{0}: {1}\n'.format(i, result))    if __name__ == '__main__':      solve_problem()  <CODESPLIT> 30
#!/usr/bin/env python  import sys    from itertools import count    def palindromes():      # it's not straightforward to get the numbers in order...      for digits in count(1):          for n in xrange(10**(digits-1), 10**digits):              n = str(n)              yield int(n + n[-2::-1])          for n in xrange(10**(digits-1), 10**digits):              n = str(n)              yield int(n + n[::-1])    def is_palindrome(n):      n = str(n)      return n == n[::-1]    def solve(A, B):      # Loop through palindromic numbers and check that their squares are palindromes.      count = 0      for n in palindromes():          square = n**2          if square > B:              break          if square >= A and is_palindrome(square):              count += 1      return count    if __name__ == '__main__':      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:          T = int(fin.readline())          for case in xrange(1, T+1):                A, B = map(int,fin.readline().split())              soln = solve(A, B)                print >> fout, "Case #{0}: {1}".format(case, soln)  <CODESPLIT> 31
#!/usr/local/bin/python3  import sys  from math import ceil    def solve(n, s, p, scores):      count = 0      for t in scores:          if ceil(t/3) >= p:              # This one must have a best score, even if it wasn't surprising.              count += 1          elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:              # This one could be surprising              count += 1              s -= 1      return count    if __name__ == '__main__':      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:          T = int(fin.readline())          for case in range(1, T+1):              line = map(int, fin.readline().split())              n, s, p, *scores = line              result = solve(n, s, p, scores)              print("Case #{0}: {1}".format(case, result), file=fout)  <CODESPLIT> 31
#!/usr/bin/env python    import sys    def war(N, ns, ks):      """Return Naomi's score in regular War        Strategy: Naomi and Ken both play their smallest possible block. When Ken      runs out of winning blocks, Naomi's score is the number of remaining blocks.        Ken's strategy is to select the smallest block which will beat Naomi's      choice, or if there is none, then his smallest block.      """      i = 0   # position through naomi's blocks      j = 0   # position through ken's blocks        # Play each of Naomi's blocks:      while i < N:          # Invariant: i <= j          # Find a block for Ken to play          while j < N and ks[j] < ns[i]:              j += 1            # If Ken is out of playable blocks, game is over.          if j == N:              break            # Move on to the next block for each player          i += 1          j += 1        return N - i    def deceit(N, ns, ks):      """Return Naomi's score in Deceitful War        Strategy: Naomi selects the smallest block with size > min(ks), and sets      Told_N > max(ks). Ken will choose to play min(ks), and lose the round.      If all of Naomi's blocks are smaller than all of Ken's, she cannot win any      more rounds, and her score is the number of blocks used (which is also equal      to N - the number of remaining blocks).        This happens to be the same strategy as regular war, with ks and ns swapped,      and the final score subtracted from N. (At least, I'm pretty sure it'll work).      """      return N - war(N, ks, ns)      def solve(N, ns, ks):      ns.sort()      ks.sort()      return "{} {}".format(deceit(N, ns, ks), war(N, ns, ks))    if __name__ == '__main__':      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout      with fin, fout:          T = int(fin.readline())          for case in xrange(1, T+1):              n = int(fin.readline())              ns = map(float, fin.readline().split())              ks = map(float, fin.readline().split())              soln = solve(n, ns, ks)              print >> fout, "Case #{0}: {1}".format(case, soln)    <CODESPLIT> 31
#!/usr/bin/env python  import sys    def solve(N, M, grid):      possible = [[False for _ in xrange(M)] for _ in xrange(N)]      for i in xrange(N):          m = max(grid[i])          for j in xrange(M):              possible[i][j] = possible[i][j] or grid[i][j] == m        for j in xrange(M):          m = max(grid[_][j] for _ in xrange(N))          for i in xrange(N):              possible[i][j] = possible[i][j] or grid[i][j] == m        if all(all(row) for row in possible):          return "YES"      else:          return "NO"    if __name__ == '__main__':      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:          T = int(fin.readline())          for case in xrange(1, T+1):              print "Case #{0}:".format(case)                N, M = map(int, fin.readline().split())              grid = [map(int, fin.readline().split()) for _ in xrange(N)]                soln = solve(N, M, grid)              print soln              print >> fout, "Case #{0}: {1}".format(case, soln)  <CODESPLIT> 31
#!/usr/bin/env python    import sys    def solve(c, f, x):      time = 0      cps = 2.0      while True:          time_to_farm = c / cps          time_to_end = x / cps          buy_a_farm = (time_to_farm + x / (cps + f)) < time_to_end          #print time_to_farm, time_to_end, (time_to_farm + x / (cps + f)), buy_a_farm          if buy_a_farm:              time += time_to_farm              cps += f          else:              time += time_to_end              return time    if __name__ == '__main__':      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout      with fin, fout:          T = int(fin.readline())          for case in xrange(1, T+1):              c, f, x = map(float, fin.readline().split())              soln = solve(c, f, x)              print >> fout, "Case #{0}: {1:.7f}".format(case, soln)    <CODESPLIT> 31
#!/usr/bin/env python    import sys    def read_row(fin, n):      rows = [set(map(int, fin.readline().strip().split())) for i in xrange(4)]      return rows[n-1]    def solve(rowa, rowb):      both = rowa & rowb      if len(both) == 1:          return list(both)[0]      elif len(both) > 1:          return "Bad magician!"      elif not both:          return "Volunteer cheated!"    if __name__ == '__main__':      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout      with fin, fout:          T = int(fin.readline())          for case in xrange(1, T+1):              n = int(fin.readline())              rowa = read_row(fin, n)              n = int(fin.readline())              rowb = read_row(fin, n)              soln = solve(rowa, rowb)              print >> fout, "Case #{0}: {1}".format(case, soln)    <CODESPLIT> 31
import sys    from string import translate, maketrans    code = maketrans("y qee"                   "ejp mysljylc kd kxveddknmc re jsicpdrysi"                   "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"                   "de kr kd eoya kw aej tysr re ujdr lkgc jv"                   "z",                   "a zoo"                   "our language is impossible to understand"                   "there are twenty six factorial possibilities"                   "so it is okay if you want to just give up"                   "q")    if __name__ == '__main__':      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:          T = int(fin.readline())          for case in xrange(1, T+1):              line = fin.readline().strip('\n')              decrypted = translate(line, code)              print >> fout, "Case #{0}: {1}".format(case, decrypted) <CODESPLIT> 31
#!/usr/bin/env python  import sys    def fours(grid):      for i in xrange(4):          yield list(grid[i]) # row i          yield [grid[x][i] for x in xrange(4)] # column i      yield [grid[x][x] for x in xrange(4)] # major diagonal      yield [grid[x][3-x] for x in xrange(4)] # minor diagonal    def solve(grid):      for x in fours(grid):          if set(x) in ({'X', 'T'}, {'X'}):              return "X won"          elif set(x) in ({'O', 'T'}, {'O'}):              return "O won"      if any('.' in x for x in grid):          return "Game has not completed"      else:          return "Draw"    if __name__ == '__main__':      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:          T = int(fin.readline())          for case in xrange(1, T+1):                grid = [fin.readline().strip() for _ in xrange(4)]              assert fin.readline().strip() == ''                soln = solve(grid)              print >> fout, "Case #{0}: {1}".format(case, soln)  <CODESPLIT> 31
#!/usr/bin/env python    import sys    IMPOSSIBLE = []    def transpose(grid):      return map(list, zip(*grid))    def find_grid(R, C, M):      """Return a grid of a solution, if one exists, otherwise []        Observations:      * WLOG, C <= R (otherwise, take the transpose of a solution)      * Trivial cases are:        - M = 0 or  M = RC - 1        - C = 1        - (R, C) = (2, 2)        - (R, C, M) = (3, 3, 2)        - (C, M) = (2, 1)      * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1      * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable      """      # Take care of simple cases      if M == 0:          #print "zero ", R, C, M          grid = [['.' for c in xrange(C)] for r in xrange(R)]          grid[0][0] = 'c'          return grid      elif M == R * C - 1:          #print "full ", R, C, M          grid = [['*' for c in xrange(C)] for r in xrange(R)]          grid[0][0] = 'c'          return grid      elif C > R:          #print "trans", R, C, M          return transpose(find_grid(C, R, M))      elif C == 1:          #print "C=1  ", R, C, M          return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]      elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):          #print "impos", R, C, M          return IMPOSSIBLE        assert 2 <= C <= R >= 3, "R={} C={} M={}".format(R, C, M)        if M >= C:          #print "M>=C ", R, C, M          s = find_grid(R-1, C, M-C)          return s and s + [['*' for c in xrange(C)]]      elif M <= R-2 and C >= 3:          #print "M+1<R", R, C, M          grid = [['.' for c in xrange(C)] for r in xrange(R)]          grid[0][0] = 'c'          for i in xrange(M):              grid[R-i-1][C-1] = '*'          return grid      elif M + 1 == R == C >= 4:          #print "M+1=R", R, C, M          grid = [['.' for c in xrange(C)] for r in xrange(R)]          grid[0][0] = 'c'          grid[R-1][C-2] = '*'          for i in xrange(M-1):              grid[R-i-1][C-1] = '*'          return grid        assert False, "R={} C={} M={}".format(R, C, M)    def check_soln(grid, R, C, M):      """checking, because debugging..."""      error = "R={} C={} M={}".format(R, C, M)      assert sum(row.count('*') for row in grid) == M, error      assert sum(row.count('c') for row in grid) == 1, error      assert len(grid) == R, error      assert all(len(row) == C for row in grid), error      _ = [i for i, row in enumerate(grid) if 'c' in row][0]      click = (_, [i for i, c in enumerate(grid[_]) if c == 'c'][0])        def neighbours(r, c):          ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]          ns.remove((r, c))          return ns        cpy = map(list, grid)      def fill(cpy, pos):          cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if grid[i][j] == '*'))          if cpy[pos[0]][pos[1]] == '0':              for i, j in neighbours(*pos):                  if cpy[i][j] == '.':                      fill(cpy, (i, j))      fill(cpy, click)      assert sum(row.count('.') for row in cpy) == 0, error    def solve(R, C, M):      soln = find_grid(R, C, M)      if soln == IMPOSSIBLE:          return "Impossible"      else:          check_soln(soln, R, C, M)          return '\n'.join(''.join(row) for row in soln)    if __name__ == '__main__':      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout      with fin, fout:          T = int(fin.readline())          for case in xrange(1, T+1):              r, c, m = map(int, fin.readline().split())              soln = solve(r, c, m)              print >> fout, "Case #{0}:\n{1}".format(case, soln)    <CODESPLIT> 31
import sys    def solve(a, b):      count = 0      for n in xrange(a, b):          s = str(n)          for i in xrange(len(s)):              m = int(s[i:] + s[:i])              if n < m <= b:                  count += 1      return count    if __name__ == '__main__':      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:          T = int(fin.readline())          for case in xrange(1, T+1):              a, b = map(int, fin.readline().split())              print >> fout, "Case #{0}: {1}".format(case, solve(a, b))  <CODESPLIT> 31
#! /usr/bin/python    T = input()    for n in range(1, T+1):        A, B = raw_input().split()      A, B = int(A), int(B)        j = 0      for i in range(A, B+1):          s = str(i)          m = int(i**.5)          if s[-1] in ["1", "4", "5", "6", "9"] and \                  (s == "".join(reversed(s))) and \                  m**2 == i:              s = str(m)              if s == "".join(reversed(s)):                  j += 1          print "Case #%d: %d" % (n, j)  <CODESPLIT> 32
import fileinput    T=0 #no. of Test cases  for line in fileinput.input():      if fileinput.isfirstline():          T=int(line)          print "no. of test cases:", T          continue            nums=[int(x) for x in line.split()]      N=nums[0] #no. of googlers      S=nums[1] #no. of surprising triplets      p=nums[2] #max value      #print "N S p:", N, S, p            del nums[:3]      count=0      for num in nums:          quo=num//3          rem=num%3          #print "num, quo, rem", num, quo, rem          if quo >= p:              count += 1              continue          elif quo+1 == p and rem > 0:              count += 1              continue          elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:              count += 1              S -= 1              continue          elif quo+2 >= p and rem == 2 and S > 0:              count += 1              S -= 1            print "Case #%(k)i: %(count)i" % {"k":fileinput.lineno()-1,"count":count}  <CODESPLIT> 32
#! /usr/bin/python3    T = int(input())    for n in range(1, T+1):      blocks = int(input())      naomi = [ int(float(a)*(10**5)) for a in input().split() ]      ken = [ int(float(a)*(10**5)) for a in input().split() ]        naomi.sort()      ken.sort()      dcwar = blocks      war = 0      i = 0      j = 0      while i<blocks and j<blocks:          if ken[i] > naomi[j]:              dcwar -= 1          else:              i += 1          j += 1      i = 0      j = 0      while i<blocks and j<blocks:          if ken[i] < naomi[j]:              war += 1          else:              j += 1          i += 1        print("Case #%d: %d %d" % (n, dcwar, war))              <CODESPLIT> 32
#! /usr/bin/python    T=input()    for i in range(1, T+1):      N, M = raw_input().split()      N, M = int(N), int(M)      matrix = []      for j in range(N):          row = raw_input().split()          assert len(row) == M          row = [int(x) for x in row]          matrix.append(row)      rmax = [max(x) for x in matrix]      matrix_t = [list(x) for x in zip(*matrix)]      cmax = [max(x) for x in matrix_t]      feasible = True      for r, k in zip(matrix, range(N)):          for c, l in zip(r, range(M)):              if c == rmax[k]:                  continue              elif c == cmax[l]:                  continue              else:                  break          else:              continue          break      else:          print "Case #%d: %s" % (i, "YES")          continue      print "Case #%d: %s" % (i, "NO")  <CODESPLIT> 32
#! /usr/bin/python3    T = int(input())    for x in range(1, T+1):      (C, F, X) = [float(y) for y in input().split()]      totalsecs = 0      cur_speed = 2      while True:          cur_time = X/cur_speed          new_speed = cur_speed + F          new_time = C/cur_speed + X/new_speed          if new_time < cur_time:              totalsecs += C/cur_speed              cur_speed = new_speed          else:              totalsecs += cur_time              break            print("Case #%d: %.7f" % (x, totalsecs))  <CODESPLIT> 32
#! /usr/bin/python3  ncases = int(input())    for n in range(1, ncases+1):      row = int(input())      for m in range(1, 5):          if m == row:              r1list = [int(x) for x in input().split()]              assert len(r1list) == 4          else:              tmp = input()      row = int(input())      for m in range(1,5):          if m == row:              r2list = [int(x) for x in input().split()]              assert len(r1list) == 4          else:              tmp = input()      nset = set(r1list) & set(r2list)      if len(nset) == 1:          print("Case #%d:" % n, nset.pop())      elif len(nset) > 1:          print("Case #%d:" % n, "Bad magician!")      else:          print("Case #%d:" % n, "Volunteer cheated!")  <CODESPLIT> 32
import fileinput    str1="""ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jv"""    strlist=str1.split()    str2="""our language is impossible to understand  there are twenty six factorial possibilities  so it is okay if you want to just give up"""    strlist2=str2.split()    mapLang={"y":"a","e":"o","q":"z"}  for x,y in zip(strlist,strlist2):      for xi,yj in zip(x,y):          if xi not in mapLang:              mapLang[xi]=yj                alphabet= ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']  for letter in  alphabet:      if letter not in mapLang.keys():          for lv in alphabet:              if lv not in mapLang.values():                  mapLang[letter]=lv                  break        #print "dict size is:", len(mapLang)  #print mapLang  ncases=0  sp=" "  for txt in fileinput.input():      if fileinput.isfirstline():          ncases=int(txt)          continue      txtList=txt.split()      outList=[]      for word in txtList:          outword=""          for letter in word:              outword += mapLang[letter]          outList.append(outword)      outstr=sp.join(outList)      print "Case #%(k)i: %(str)s" % {"k":fileinput.lineno()-1,"str":outstr}  <CODESPLIT> 32
#! /usr/bin/python  import re    T=input()  for i in range(1, T+1):      game = []      res = ""      unfinished = False      for j in range(4):          game.append(raw_input())      diag1=""      diag2=""      for (j, line) in zip(range(4), game):          if re.match("(X|T){4}|(O|T){4}", line):              res = line[0] if line[0] != 'T' else line[1]              break          else:              if "." in line:                  unfinished = True              diag1 += line[j]              diag2 += line[3-j]      if not res:          game = ["".join(x) for x in zip(*game)]          game.append(diag1)          game.append(diag2)          for line in game:              grp = re.match("(X|T){4}|(O|T){4}", line)              if grp:                  res = line[0] if line[0] != 'T' else line[1]                  break        if res:          print "Case #%d: %s won" % (i, res)      elif unfinished:          print "Case #%d: Game has not completed" % i      else:          print "Case #%d: Draw" % i      raw_input() #empty line after each test case  <CODESPLIT> 32
#! /usr/bin/python3    T = int(input())    for n in range(1, T+1):      print("Case #%d:" % n)      (R, C, M) = (int(x) for x in input().split())      dots = R*C - M      if M == 0:          print("\n".join(["c"+(C-1)*"."] + (R-1)*[C*"."]))      elif dots == 0:          print("Impossible")      elif R == 1:          assert C - M > 0          print("c"+(C-M-1)*"."+M*"*")      elif C == 1:          assert R - M > 0          print("c\n"+(R-M-1)*".\n"+M*"*\n", end='')      elif dots == 1:          print("\n".join(["c"+ (C-1)*"*"] + (R-1)*[C*"*"]))      elif dots > 3:          if (dots == 5) or (dots == 7):              print("Impossible")              continue          if (R == 2) or (C == 2):              if dots%2 != 0 :                  print("Impossible")                  continue              elif R == 2:                  l = int(dots/2)                  print("c"+(l-1)*"."+(C-l)*"*")                  print(l*"."+(C-l)*"*")                  continue              elif C == 2:                  l = int(dots/2)                  print("c.")                  print((l-1)*"..\n", end='')                  print(int(M/2)*"**\n", end='')                  continue          (lines, extra) = divmod(dots, C)          temp = []          if (lines >= 2) and (extra != 1):              temp.append("c"+(C-1)*".")              temp.extend((lines-1)*[C*"."])              temp.append(extra*"."+(C-extra)*"*")              temp.extend((R-lines-1)*[C*"*"])              print("\n".join(temp))              continue          elif (lines > 2) and (extra == 1):              temp.append("c"+(C-1)*".")              temp.extend((lines-2)*[C*"."])              temp.append((C-1)*"."+"*")              temp.append(".."+ (C-2)*"*")              temp.extend((R-lines-1)*[C*"*"])              print("\n".join(temp))              continue          elif (lines == 2) and (extra == 1):              temp.append("c"+(C-2)*"."+"*")              temp.append((C-1)*"."+"*")              temp.append(3*"."+(C-3)*"*")              temp.extend((R-3)*[C*"*"])              print("\n".join(temp))              continue          elif lines < 2:              (l, rem) = divmod(dots, 2)              if rem == 1:                  l -= 1                  rem += 2              temp.append("c"+(l-1)*"."+(C-l)*"*")              temp.append(l*"."+(C-l)*"*")              temp.append(rem*"."+(C-rem)*"*")              temp.extend( (R-3)*[ C*"*" ])              print("\n".join(temp))              continue      else:          print("Impossible")    <CODESPLIT> 32
#!/usr/bin/env python    import fileinput    def checkIndex(index,num,numB):  	n=int(str(num)[index:]+str(num)[:index])  	if n > num and n <= numB:  		#print "pair",num, n  		return n  	else: return False      for line in fileinput.input():  	if fileinput.isfirstline():  		T=int(line) # no. of test cases  		continue  	numStrs=line.split()  	numSize=len(numStrs[0])  	numA=int(numStrs[0])  	numB=int(numStrs[1])  	count=0  	for num in xrange(numA, numB+1):  		pairs=set()  		for i in range(numSize):  			n=checkIndex(i,num, numB)  			if n:  				pairs.add(n)  		count +=len(pairs)  				  	print "Case #%(k)i: %(count)i" % {"k":fileinput.lineno()-1,"count":count}  	 <CODESPLIT> 32
import math    #wont help, runs out of memory for 10^100  # palindromeCache = {} #ideally this is precalculated    # def isPalindrome(S):  	# s = str(S) #so I dont need to make sure its a string  	# if s in palindromeCache:  		# return palindromeCache[s]  		  	# palindromeCache[s] = True  	# for i in range(len(s)//2):  		# if not s[i] == s[-1 - i]:  			# palindromeCache[s] = False  			# break  	# return palindromeCache[s]  	  def isPalindrome(S):  	s = str(S) #so I dont need to make sure its a string  	for i in range(len(s)//2):  		if not s[i] == s[-1 - i]:  			return False  	return True    def FairAndSquare(infile="C-small-attempt0.in", outfile="C-small-attempt0.out"):  	inF = open(infile, 'r')  	outF = open(outfile, 'w')  	  	for t in range(1, int(inF.readline().strip()) + 1):  		temp = inF.readline().strip().split()  		A = long(temp[0])  		B = long(temp[1])  		count = long(0)  		  		i = long(math.ceil(math.sqrt(A)))  		m = long(math.floor(math.sqrt(B)))  		while i <= m:  			if isPalindrome(i):  				if isPalindrome(i**2):  					count += 1  			i += 1  					  		outF.write("Case #" + str(t) + ": " + str(count) + "\n")  	  	#closing files  	inF.close()  	outF.close()  	  	#so I dont need to cat the file after  	f = open(outfile, 'r')  	print f.read()  	f.close()  	  	  if __name__ == "__main__":      FairAndSquare() <CODESPLIT> 33
data_dict = {}  init = False      def partB(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt",\                outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt"):            #Reading input      linesA = []      for line in open(infile, 'r'):          linesA.append(line.strip())        outA = []                #Parsing Input      T = int(linesA[0])      for i in range(1, 1 + T):          caseA = linesA[i].split()          N = int(caseA[0])          S = int(caseA[1])          P = int(caseA[2])                    #these will be exclusive          over_norm = 0          over_supr = 0                    #Calculating answer          for t in [int(conv) for conv in caseA[3:3+N]]:              if data_dict[t][0] >= P:                  over_norm += 1              elif data_dict[t][1] >= P:                  over_supr += 1                    outA.append(over_norm + min(over_supr, S))                                                  #Writing Output      out = open(outfile, 'w')      print "\nOUTPUT"      for i in range(1, 1 + T):          if i != 1:              out.write("\n")          print "Case #" + str(i) + ": " +str(outA[i-1])          out.write("Case #" + str(i) + ": " +str(outA[i-1]))      out.close()    def dict_helper(total, depth=0, lowest=10):      pass    #Brute forcing this because my girlfriend is in my bed right now waiting for me  #Its also running fast enough that it doesnt seem worth being clever  def build_dict():      for i in range(31):          fullA = []          maxN = 0          maxS = 0          print str(i) + ": "          for a1 in range(0,11):              for a2 in range(0,11):                  for a3 in range(0,11):                      if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):                          fullA.append((a1,a2,a3))                                                    print "\t", fullA[-1],                          if max(a1,a2,a3)-min(a1,a2,a3) == 2:                              print "*"                              maxS = max(maxN, max(a1,a2,a3))                          else:                              print                              maxN = max(maxN, max(a1,a2,a3))          data_dict[i]=[maxN, maxS]      init = True        if __name__ == "__main__":      build_dict()      partB()  <CODESPLIT> 33
__author__ = 'Jeffrey'    # inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-sample.in"  inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-small-attempt0.in"  # inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-large.in"    outFileName = inFileName[: -2] + "out"      def parseInput(f):      T = int(f.readline())      L = []        for i in range(T):          f.readline()          L.append(([float(j) for j in f.readline().split()], [float(j) for j in f.readline().split()]))          L[-1][0].sort()          L[-1][1].sort()        return T, L      def calculateScores(naomi, ken):      return [calcDeceit(naomi, ken), calcHonest(naomi, ken)]    def calcDeceit(naomi, ken):      wins = 0      while len(naomi) > 0:          if naomi[-1] > ken[-1]:              naomi = naomi[ : -1]              ken = ken[ : -1]              wins += 1          else:              naomi = naomi[1: ]              ken = ken[ : -1]      return wins    def calcHonest(naomi, ken):      wins = 0      while len(naomi) > 0:          n = naomi.pop(0)          k = ken[0]          for i in range(len(ken)):              kTemp = ken[i]              if kTemp > n:                  k = ken.pop(i)                  break          else:              ken.pop(0)              wins += 1      return wins        def playGame(T, L):      for i in range(T):          result = calculateScores(L[i][0], L[i][1])          yield "Case #{}: {} {}".format(i + 1, result[0], result[1])      if __name__ == "__main__":      iF = open(inFileName, 'r')      T, L = parseInput(iF)      iF.close()        print(T)      for l in L:          print()          for k in l:              print(k)        oF = open(outFileName, "wb")      for out in playGame(T, L):          print(out)          # print(bytes(out, 'utf-8'), file=oF)          oF.write(bytes(out + "\n", 'utf-8'))      oF.close()  <CODESPLIT> 33
from array import array    def Lawnmower(infile="B-small-attempt0.in", outfile="B-small-attempt0.out"):  	inF = open(infile, 'r')  	outF = open(outfile, 'w')  	  	for t in range(1, int(inF.readline().strip()) + 1):  		#read grid size  		temp = inF.readline().strip().split()  		N = int(temp[0])  		M = int(temp[1])  		L = []  		  		for i in range(N):  			L.append(inF.readline().strip().split()) #using an array should speed up the lookups  			for j in range(M):  				L[i][j] = int(L[i][j])  		  		for y in range(N):  			for x in range(M):  				# check horizontal  				for i in range(M):  					if L[y][i] > L[y][x]:  						break  				else:  					continue  				  				# check vertical  				for i in range(N):  					if L[i][x] > L[y][x]:  						break  				else:  					continue  				break  			else:  				continue  			break  		else:  			#good  			outF.write("Case #" + str(t) + ": YES\n")  			continue  		#bad  		outF.write("Case #" + str(t) + ": NO\n")  	  	#closing files  	inF.close()  	outF.close()  	  	#so I dont need to cat the file after  	f = open(outfile, 'r')  	print f.read()  	f.close()  	  	  if __name__ == "__main__":      Lawnmower() <CODESPLIT> 33
__author__ = 'Jeffrey'    inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\B-small-attempt0.in"  outFileName = inFileName[ : -2] + "out"      def parseInput(f):      T = int(f.readline())      L = []        for i in range(T):          L.append([float(i) for i in f.readline().split()])        return T, L      def calculateWinTime(C, F, X):      R = 2.0 # rate of cookie profit (cookies/s)      totalTime = 0.0      while (X / R >= C/R + X/(R + F)):          totalTime += C / R          R += F      return totalTime + X / R      def playGame(T,L):      for i in range(T):          result = calculateWinTime(L[i][0], L[i][1], L[i][2])          yield "Case #" + str(i + 1) + ": " + "{:0.7f}".format(result)      if __name__=="__main__":      iF = open(inFileName, 'r')      T, L = parseInput(iF)      iF.close()        print(T)      print(L)        oF = open(outFileName, "wb")      for out in playGame(T, L):          print(out)          # print(bytes(out, 'utf-8'), file=oF)          oF.write(bytes(out + "\n",'utf-8'))      oF.close()  <CODESPLIT> 33
__author__ = 'Jeffrey'    inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\A-small-attempt0.in"  outFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\A-small-attempt0.out"      def parseInput(f):      T = int(f.readline())      L = []        for i in range(T):          picks = []          cards = []          for j in range(2):              picks.append( int(f.readline()))              tempL = []              for k in range(4):                  tempL.append( [int(j) for j in f.readline().split()])              cards.append(tempL)          L.append((picks, cards))        return T, L      def performTrick(picks, cards):      matchFound = False      matchedCard = None      for card in cards[0][picks[0] - 1]:          possibleMatch = card in cards[1][picks[1] - 1]          if possibleMatch and matchFound:              return "Bad magician!"          elif possibleMatch:              matchFound = True              matchedCard = card      if matchFound:          return matchedCard      else:          return "Volunteer cheated!"      def playGame(T,L):      for i in range(T):          result = performTrick(L[i][0], L[i][1])          yield "Case #" + str(i + 1) + ": " + str(result)      if __name__=="__main__":      iF = open(inFileName, 'r')      T, L = parseInput(iF)      iF.close()        oF = open(outFileName, "wb")      for out in playGame(T, L):          # print(out)          # print(bytes(out, 'utf-8'), file=oF)          oF.write(bytes(out + "\n",'utf-8'))      oF.close()  <CODESPLIT> 33
from string import maketrans    f = "abcdefghijklmnopqrstuvwxyz"  o = "ynficwlbkuomxsevzpdrjgthaq"            def partAfile(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/input.txt",\                outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/output.txt"):      tempF = open(infile, 'r')      tempA = []      for line in tempF:          tempA.append(line.strip())                N = int(tempA[0])            out = open(outfile, 'w')      for i in range(1, 1+N):          if i != 1:              out.write("\n")          print "Case #" + str(i) + ": " +tempA[i].translate(maketrans(o,f))          out.write("Case #" + str(i) + ": " +tempA[i].translate(maketrans(o,f)))                  if __name__ == "__main__":      partAfile()  <CODESPLIT> 33
def checkRow(r):  	c = r[0];  	  	# making sure it isnt an empty line  	if (c == '.'):  		return (False, None)  		  	for i in range(1,4):  		if not (r[i] == c or r[i] == 'T'):  			return (False, None)  	  	# if it got this far it must be right  	return (True, c)    def checkCol(L, col):  	c = L[0][col];  	  	# making sure it isnt an empty line  	if (c == '.'):  		return (False, None)  		  	for i in range(1,4):  		if not (L[i][col] == c or L[i][col] == 'T'):  			return (False, None)  	  	# if it got this far it must be right  	return (True, c)  	  def checkDiag(L):  	c = L[0][0];  	  	for i in range(1,4):  		if not (L[i][i] == c or L[i][i] == 'T'):  			break  	else:  		if (c != '.'):  			# if it got this far it must be right  			return (True, c)  	  	#first diag failed  	c = L[0][3];  	  	# making sure it isnt an empty line  	if (c == '.'):  		return (False, None)  		  	for i in range(1,4):  		if not (L[i][3-i] == c or L[i][3-i] == 'T'):  			break  	else:  		# if it got this far it must be right  		return (True, c)  		  	return (False, None)  		  def checkComplete(L):  	for i in range(4):  		if '.' in L[i]:  			return False  	return True    def TicTacToeTomek(infile="A-small-attempt0.in", outfile="A-small-attempt0.out"):  	f = open(infile, 'r')  	out = open(outfile, 'w')  	  	# get the number of tests  	n = int(f.readline().strip())  	  	for t in range(1, n + 1):  		L = []  		# loading game  		for i in range(4):  			L.append(f.readline().strip());  		  		# checking game state  		for i in range(4):  			#checking row  			result = checkRow(L[i])  			if result[0]:  				out.write("Case #" + str(t) + ": " + result[1] + " won\n")  				break  			#checking column  			result = checkCol(L,i)  			if result[0]:  				out.write("Case #" + str(t) + ": " + result[1] + " won\n")  				break  		else:  			#checking column  			result = checkDiag(L)  			if result[0]:  				out.write("Case #" + str(t) + ": " + result[1] + " won\n")  			else:  				if checkComplete(L):  					out.write("Case #" + str(t) + ": Draw\n")  				else:  					out.write("Case #" + str(t) + ": Game has not completed\n")  				  		f.readline() #skipping empty line  	  	#closing files  	f.close()  	out.close()  	  	#so I dont need to cat the file after  	f = open(outfile, 'r')  	print f.read()  	f.close()  	  	  if __name__ == "__main__":      TicTacToeTomek() <CODESPLIT> 33
__author__ = 'Jeffrey'    # inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-sample.in"  inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-small-attempt0.in"  # inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-large.in"    outFileName = inFileName[: -2] + "out"      def parseInput(f):      T = int(f.readline())      L = []        for i in range(T):          L.append([int(i) for i in f.readline().split()])        return T, L      def calculateOneClick(R, C, M):      size = R * C      if R == 1 or C == 1 and M < size:          return generateWinBoardBaseCase(R, C, M)      elif size - M == 1:          return generateWinBoardBaseCase(R, C, M)      elif size - M >= 4:          return generateWinBoard(R, C, M)      return "Impossible"    def generateWinBoard(R,C,M):      emptySpace = R * C - M - 4      out = "c"      if C > 1:          out += "."          for i in range(2,C):              if emptySpace > 0:                  out += "."                  emptySpace -= 1              else:                  out += "*"                  # out += '\n'      if R > 1:          out += '\n'          out += "."          if C > 1:              out += "."          for i in range(2,C):              if emptySpace > 0:                  out += "."                  emptySpace -= 1              else:                  out += "*"      for r in range(2,R):          out += '\n'          for c in range(C):              if emptySpace > 0:                  out += "."                  emptySpace -= 1              else:                  out += "*"      return out    def generateWinBoardBaseCase(R,C,M):      emptySpace = R * C - M - 1      out = "c"      if C > 1:          for c in range(1,C):              if emptySpace > 0:                  out += "."                  emptySpace -= 1              else:                  out += "*"      for r in range(1,R):          out += '\n'          for c in range(C):              if emptySpace > 0:                  out += "."                  emptySpace -= 1              else:                  out += "*"      return out      def playGame(T, L):      for i in range(T):          result = calculateOneClick(L[i][0], L[i][1], L[i][2])          yield "Case #" + str(i + 1) + ":\n" + str(result)      if __name__ == "__main__":      iF = open(inFileName, 'r')      T, L = parseInput(iF)      iF.close()        print(T)      print(L)        oF = open(outFileName, "wb")      for out in playGame(T, L):          print(out)          # print(bytes(out, 'utf-8'), file=oF)          oF.write(bytes(out + "\n", 'utf-8'))      oF.close()  <CODESPLIT> 33
#!/usr/bin/env python    def partCa(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/C-small-attempt0.in",\                outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/output.txt"):            #if not init:          #build_dict()            #Reading input      linesA = []      for line in open(infile, 'r'):          linesA.append(line.strip())        outA = []                #Parsing Input      T = int(linesA[0])      for i in range(1, 1 + T):          caseA = linesA[i].split()          A = int(caseA[0])          B = int(caseA[1])                              outA.append(0)          #Calculating answer          for i in range(A,B):              for j in range(i + 1, B + 1):                  #testing pair (i, j)                  outA[-1] += int(isRecycled(i, j))            #Writing Output      out = open(outfile, 'w')      print "\nOUTPUT"      for i in range(1, 1 + T):          if i != 1:              out.write("\n")          print "Case #" + str(i) + ": " +str(outA[i-1])          out.write("Case #" + str(i) + ": " +str(outA[i-1]))      out.close()        def isRecycled(n,m):      '''      Takes 2 integers and tells you if they are recycled      '''      a = str(n)      b = str(m)      if len(a) == len(b):          for i in range(len(a)):              if (a[i:] + a[:i]) == b:                  return True                return False        if __name__ == "__main__":      partCa()  <CODESPLIT> 33
import math    fin = open('C-small-attempt0.in', 'r')  fout = open('ass3.out', 'w')    T = int(fin.readline())    def perfsq(n):      sq = int(math.sqrt(n))      if n == sq * sq:          return sq      return 0    def palindrome(n):      s = str(n)      return (s == s[::-1])    def getpal(n):      if n == 1:          for i in range(10):              yield i      else:          n2 = n / 2          for x in xrange(10 ** (n2 - 1), 10 ** n2):              s = str(x)              if n % 2:                  for i in range(10):                      ns = s + str(i) + s[::-1]                      yield int(ns)              else:                  ns = s + s[::-1]                  yield int(ns)    for i in range(T):      A, B = map(int, fin.readline().split())        ret = 0      for j in range(len(str(A)), len(str(B)) + 1):          for x in getpal(j):              if x < A:                  continue              if x > B:                  break              sq = perfsq(x)              if sq and palindrome(sq):                  ret += 1      fout.write('Case #%i: %i\n' % (i + 1, ret))  <CODESPLIT> 34
input_file = 'B-small-attempt1.in'  output_file = 'b.out'      def solvecase(inp):  	data = [int(n) for n in inp.split()]  	N, S, p = data[0:3]  	if p == 0:  		return N  	t = data[3:]  	ret = 0  	for br in t:  		d, r = br / 3, br % 3  		if br == 0 or p - d > 2:  			continue  		if (d >= p) or (r and (d + 1) >= p):  			ret += 1  		elif S and (d + max(r, 1)) >= p:  			ret += 1  			S -= 1  	return ret    lines = open(input_file, 'r').readlines()  out = open(output_file, 'w')    for i, l in enumerate(lines[1:]):  	sout = 'Case #%i: %i' % (i + 1, solvecase(l))  	print sout  	out.write(sout + '\n')    out.close()  <CODESPLIT> 34
    INPUT = 'D-small-attempt3.in'  OUTPUT = 'D-small-attempt3.out'      def solve(N, naomis, kens):      naomis.sort()      kens.sort()        def play_war(naomis, kens):          score = 0          for game_round in range(N):              nweight = naomis.pop(0)              if nweight > kens[-1]:                  kweight = kens.pop(0)              else:                  for i, weight in enumerate(kens):                      if weight > nweight:                          kweight = kens.pop(i)                          break              if nweight > kweight:                  score += 1          return score        def play_deceitful_war(naomis, kens):          score = 0          crap = 0          for i, weight in enumerate(naomis):              if weight < kens[i]:                  crap += 1            for game_round in range(N):              if crap:                  ntold = kens[-1] - 0.0000001                  crap -= 1              else:                  ntold = naomis[-1]              nweight = naomis.pop(0)                if ntold > kens[-1]:                  kweight = kens.pop(0)              else:                  for i, weight in enumerate(kens):                      if weight > ntold:                          kweight = kens.pop(i)                          break              if nweight > kweight:                  score += 1          return score         return play_deceitful_war(naomis[:], kens[:]), play_war(naomis[:], kens[:])      if __name__ == '__main__':      inp = open(INPUT)      out = open(OUTPUT, 'w')            T = int(inp.readline())        for case in range(T):          N = int(inp.readline())          naomis = map(float, inp.readline().split())          kens = map(float, inp.readline().split())          sol = solve(N, naomis, kens)          out.write('Case #%i: %i %i\n' % (case + 1, sol[0], sol[1])) <CODESPLIT> 34
fin = open('B-small-attempt0.in', 'r')  fout = open('ass2.out', 'w')      T = int(fin.readline())    def check(lawn, r, c):      h, v = True, True      for i in range(len(lawn[0])):          if i == c:              continue          if lawn[r][i] > lawn[r][c]:              h = False              break      for i in range(len(lawn)):          if i == r:              continue          if lawn[i][c] > lawn[r][c]:              v = False      return (h or v)    for i in range(T):      N, M = map(int, fin.readline().split())      lawn = []      for j in range(N):          lawn.append( map(int, fin.readline().split()) )        n = i + 1      ret = True      for j in range(len(lawn)):          if not ret: break          for k in range(len(lawn[0])):              if not check(lawn, j, k):                  ret = False                  fout.write('Case #%i: NO\n' % n)                  break      if ret:          fout.write('Case #%i: YES\n' % n) <CODESPLIT> 34
    INPUT = 'B-small-attempt1.in'  OUTPUT = 'B-small-attempt1.out'      def solve(C, F, X):        cps = 2.0      farm_time = 0.0      time = X / cps            while True:          farm_time += C / cps          cps += F          ntime = farm_time + X / cps          if ntime < time:              time = ntime          else:              break      return time      if __name__ == '__main__':      inp = open(INPUT)      out = open(OUTPUT, 'w')            T = int(inp.readline())        for case in range(T):          sol = solve(*map(float, inp.readline().split()))          out.write('Case #%i: %.7f\n' % (case + 1, sol)) <CODESPLIT> 34
    INPUT = 'A-small-attempt0.in'  OUTPUT = 'A-small-attempt0.out'      def solve(answer1, arr1, answer2, arr2):      ret = None        for card in arr1[answer1 - 1]:          if card in arr2[answer2 - 1]:              if ret is not None:                  return 'Bad magician!'              else:                  ret = card      if ret is None:          return 'Volunteer cheated!'      return ret    if __name__ == '__main__':      inp = open(INPUT)      out = open(OUTPUT, 'w')            T = int(inp.readline())        def read_answer_and_arr():          answer = int(inp.readline())          arr = []          for i in range(4):              arr.append( map(int, inp.readline().split()) )          return answer, arr        for case in range(T):          answer1, arr1 = read_answer_and_arr()          answer2, arr2 = read_answer_and_arr()            out.write('Case #%i: %s\n' % \                          (case + 1, solve(answer1, arr1, answer2, arr2)))  <CODESPLIT> 34
  input_file = 'A-small-attempt0.in'  output_file = 'a_out'    googlerese = ''.join([  	'ejp mysljylc kd kxveddknmc re jsicpdrysi',  	'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',  	'de kr kd eoya kw aej tysr re ujdr lkgc jv',  	'y qee', 'z'  ])    english = ''.join([  	'our language is impossible to understand',  	'there are twenty six factorial possibilities',  	'so it is okay if you want to just give up',  	'a zoo', 'q'  ])    alphabet = {}    for g, e in zip(googlerese, english):  	alphabet[g] = e    lines = open(input_file, 'r').readlines()  out = open(output_file, 'w')    for i, l in enumerate(lines[1:]):  	trans = 'Case #%i: %s' % (  		i + 1,   		''.join([alphabet[c] for c in l if c in alphabet]))  	print trans  	out.write(trans + '\n')    out.close()    	  	    <CODESPLIT> 34
  fin = open('A-small-attempt0.in', 'r')  fout = open('ass1.out', 'w')    N = int(fin.readline())    for i in range(N):      field = []      for j in range(4):          field.append(fin.readline())      fin.readline()        for j in range(4):          field.append([field[ln][j] for ln in range(4)])      field.append([field[x][x] for x in range(4)])      field.append([field[x][3 - x] for x in range(4)])              hasdot = False      winner = None      for ln in field:          if '.' in ln:              hasdot = True              continue          if 'X' in ln and not ('O' in ln):              winner = 'X'              break          if 'O' in ln and not ('X' in ln):              winner = 'O'              break      n = i + 1      if not (winner or hasdot):          fout.write('Case #%i: Draw\n' % n)      elif not winner and hasdot:          fout.write('Case #%i: Game has not completed\n' % n)      else:          fout.write('Case #%i: %s won\n' % (n, winner)) <CODESPLIT> 34
    INPUT = 'C-small-attempt0.in'  OUTPUT = 'C-small-attempt0.out'      def solve(R, C, M):      grid = [[0 for c in range(C)] for r in range(R)]        def get_cell(cell_r, cell_c):          if not(0 <= cell_r < R):              return None          if not(0 <= cell_c < C):              return None          return grid[cell_r][cell_c]        def for_each_neighbour(cell_r, cell_c, func):          ret = []          coords = (              (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),              (cell_r, cell_c - 1), (cell_r, cell_c + 1),              (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)          )          for nb in coords:              if get_cell(nb[0], nb[1]) is not None:                  ret.append(func(nb[0], nb[1]))          return ret        def mark_dirty(cell_r, cell_c):          if grid[cell_r][cell_c] != '*':              grid[cell_r][cell_c] += 1            def unmark_dirty(cell_r, cell_c):          if grid[cell_r][cell_c] != '*':              grid[cell_r][cell_c] -= 1        def check_empty_neighbours(cell_r, cell_c):          return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))        def click():          for i, row in enumerate(grid):              for j, cell in enumerate(row):                  if cell != '*':                      if cell == 0 or ((R * C - M) == 1):                          grid[i][j] = 'c'                          return        def place_mine():          for i, row in enumerate(grid):              for j, cell in enumerate(row):                  if cell == '*':                      continue                  prevstate = grid[i][j]                  grid[i][j] = '*'                  for_each_neighbour(i, j, mark_dirty)                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):                      grid[i][j] = prevstate                      for_each_neighbour(i, j, unmark_dirty)                  else:                      return True          return False        for m in range(M):          if not place_mine():              return 'Impossible\n'        click()        ret = ''      for row in grid:          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\n'        return ret      if __name__ == '__main__':      inp = open(INPUT)      out = open(OUTPUT, 'w')            T = int(inp.readline())        for case in range(T):          sol = solve(*map(int, inp.readline().split()))          out.write('Case #%i:\n%s' % (case + 1, sol)) <CODESPLIT> 34
input_file = 'C-small-attempt4.in'  #input_file = 'c_sample.in'  output_file = 'c.out'      def solvecase(inp):  	A, B = [int(n) for n in inp.split()]  	  	def shift(s):  		return s[-1] + s[:-1]  	  	ret = 0  	for n in range(A, B + 1):  		sn = str(n)  		sm = sn  		rep = []  		for i in range(len(sn) - 1):  			sm = shift(sm)  			if not (sm in rep) and (B >= int(sm) > n):  				ret += 1  				rep.append(sm)  	return ret      lines = open(input_file, 'r').readlines()  out = open(output_file, 'w')    for i, l in enumerate(lines[1:]):  	sout = 'Case #%i: %i' % (i + 1, solvecase(l))  	print sout  	out.write(sout + '\n')    out.close()  <CODESPLIT> 34
"""Usage:      X.py < X.in > X.out  """    # http://code.activestate.com/recipes/577821-integer-square-root-function/  def isqrt(x):      "returns int(floor(sqrt(x))) using only integer math"      assert x >= 0, 'Undefined %r' % locals()      n = int(x)      if n == 0:          return 0      a, b = divmod(n.bit_length(), 2)      x = 2**(a+b)      while True:          y = (x + n//x)//2          if y >= x:              return x          x = y    def setup(infile):      #C = {}      return locals()    def reader(testcase, infile, **ignore):      #N = int(infile.next())      P = map(int, infile.next().split())      #I = map(int, infile.next().split())      #T = infile.next().split()      #S = [infile.next().strip() for i in range(N)]      return locals()    def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):      #import collections as co      #import functools as ft      #import itertools as it      #import operator as op      #import math as ma      #import re      #import numpy as np      #import scipy as sp      #import networkx as nx        low = isqrt(P[0])      high = isqrt(P[1])+1        def is_pal(n):          n = str(n)          for i in range(len(n)/2+1):              if n[i]!=n[len(n)-1-i]:                  return False          return True        res = 0      for i in range(low, high+1):          if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):              res += 1        return 'Case #%s: %s\n' % (testcase, res)    if __name__ == '__main__':      import sys      T = int(sys.stdin.next())      common = setup(sys.stdin)      for t in xrange(1, T+1):          sys.stdout.write(solver(**reader(t, **common)))  <CODESPLIT> 35
"""Usage:      X.py < X.in > X.out  """    import sys      class Solver(object):      cache = {}        def __init__(self, infile, testcase):          self.testcase = testcase          self.P = P = map(int, infile.next().split())        def init_cache(self):          if 'main' in self.cache:              return          #self.cache['main'] = res        def solve(self):            N, S, p = self.P[:3]          G = sorted(self.P[3:], reverse=True)            r = 0          s = 0          for g in G:              if g >= 3 * p - 2 and g >= p:                  r += 1              elif g >= 3 * p - 4 and g >= p:                  if s == S:                      break                  r += 1                  s += 1            return r      def main():      T = int(sys.stdin.next())      for t in xrange(T):          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))      if __name__ == '__main__':      main()  <CODESPLIT> 35
"""Usage:      pypy X.py < X-size.in > X-size.out  or sometimes      python X.py < X-size.in > X-size.out  """    def setup(infile):      #C = {}      return locals()    def reader(testcase, infile, C=None, **ignore):      N = int(infile.next())      P = map(float, infile.next().split())      I = map(float, infile.next().split())      #T = infile.next().split()      #S = [infile.next().strip() for i in range(N)]      return locals()    def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):      #import collections as co      #import functools32 as ft      #import itertools as it      #import operator as op      #import math as ma      #import re      #import numpypy as np      #import scipy as sp      #import networkx as nx        N = sorted(P)      K = sorted(I)        W = 0      ik = 0      for n in N:          while ik < len(K) and K[ik] < n:              ik += 1              W += 1          ik += 1        D = 0      i = 0      for k in K:          while i < len(N) and N[i] < k:              i += 1          i += 1          if i <= len(N):              D += 1        return 'Case #%s: %s %s\n' % (testcase, D, W)    if __name__ == '__main__':      import sys      T = int(sys.stdin.next())      common = setup(sys.stdin)      for t in xrange(1, T+1):          sys.stdout.write(solver(**reader(t, **common)))  <CODESPLIT> 35
"""Usage:      X.py < X.in > X.out  """    def setup(infile):      #C = {}      return locals()    def reader(testcase, infile, **ignore):      #N = int(infile.next())      P = map(int, infile.next().split())      #I = map(int, infile.next().split())      #T = infile.next().split()      S = [map(int, infile.next().split()) for i in range(P[0])]      return locals()    def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):      #import collections as co      #import functools as ft      #import itertools as it      #import operator as op      #import math as ma      #import re      import numpypy as np      #import scipy as sp      #import networkx as nx            S = np.array(S)      done = np.zeros(P, dtype=int)      for row in range(P[0]):          m = S[row].max()          done[row][S[row]==m] = 1        for col in range(P[1]):          m = S[:,col].max()          done[:,col][S[:,col]==m] = 1        res = 'YES' if done.sum() == P[0]*P[1] else 'NO'      return 'Case #%s: %s\n' % (testcase, res)    if __name__ == '__main__':      import sys      T = int(sys.stdin.next())      common = setup(sys.stdin)      for t in xrange(1, T+1):          sys.stdout.write(solver(**reader(t, **common)))  <CODESPLIT> 35
"""Usage:      pypy X.py < X-size.in > X-size.out  or sometimes      python X.py < X-size.in > X-size.out  """    def setup(infile):      #C = {}      return locals()    def reader(testcase, infile, C=None, **ignore):      #N = int(infile.next())      #P = map(int, infile.next().split())      I = map(float, infile.next().split())      #T = infile.next().split()      #S = [infile.next().strip() for i in range(N)]      return locals()    def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):      #import collections as co      #import functools32 as ft      #import itertools as it      #import operator as op      #import math as ma      #import re      #import numpypy as np      #import scipy as sp      #import networkx as nx        C, F, X = I      n = [0]      r = 2.        res = X / r      while True:          n.append(n[-1] + C / r)          r += F          nres = n[-1] + X / r          if nres >= res:              break          res = nres        return 'Case #%s: %s\n' % (testcase, res)    if __name__ == '__main__':      import sys      T = int(sys.stdin.next())      common = setup(sys.stdin)      for t in xrange(1, T+1):          sys.stdout.write(solver(**reader(t, **common)))  <CODESPLIT> 35
"""Usage:      pypy X.py < X-size.in > X-size.out  or sometimes      python X.py < X-size.in > X-size.out  """    def setup(infile):      #C = {}      return locals()    def reader(testcase, infile, C=None, **ignore):      N = int(infile.next())      #P = int(infile.next())      #P = map(int, infile.next().split())      I = [map(int, infile.next().split()) for i in range(4)]      T = int(infile.next())      #T = infile.next().split()      S = [map(int, infile.next().split()) for i in range(4)]      return locals()    def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):      #import collections as co      #import functools32 as ft      #import itertools as it      #import operator as op      #import math as ma      #import re      #import numpypy as np      #import scipy as sp      #import networkx as nx        res = set(I[N-1]) & set(S[T-1])      if len(res) == 1:          res = res.pop()      elif len(res) > 1:          res = 'Bad magician!'      else:          res = 'Volunteer cheated!'      return 'Case #%s: %s\n' % (testcase, res)    if __name__ == '__main__':      import sys      T = int(sys.stdin.next())      common = setup(sys.stdin)      for t in xrange(1, T+1):          sys.stdout.write(solver(**reader(t, **common)))  <CODESPLIT> 35
"""Usage:      X.py < X.in > X.out  """    import sys    ins = """ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jvqz  """    outs = """our language is impossible to understand  there are twenty six factorial possibilities  so it is okay if you want to just give upzq  """    class Solver(object):      cache = {}        def __init__(self, infile, testcase):          self.testcase = testcase          self.S = S = infile.next().strip()            self.init_cache()        def init_cache(self):          if 'main' in self.cache:              return          t = {}          for i in xrange(len(ins)):              t[ins[i]] = outs[i]          print t          self.cache['main'] = t        def solve(self):            S = self.S                      return ''.join(self.cache['main'][c] for c in list(S))      def main():      T = int(sys.stdin.next())      for t in xrange(T):          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))      if __name__ == '__main__':      main()  <CODESPLIT> 35
"""Usage:      X.py < X.in > X.out  """    def setup(infile):      #C = {}      return locals()    def reader(testcase, infile, **ignore):      #N = int(infile.next())      #P = map(int, infile.next().split())      #I = map(int, infile.next().split())      #T = infile.next().split()      S = [infile.next().strip() for i in range(5)]      return locals()    def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):      #import collections as co      #import functools as ft      import itertools as it      #import operator as op      #import math as ma      #import re      #import numpy as np      #import scipy as sp      #import networkx as nx            not_draw = False      for line in S[:4]:          not_win = set()          if '.' in line:              not_draw = True              continue          if 'O' in line:              not_win.add('X')          if 'X' in line:              not_win.add('O')          if len(not_win) == 1:              return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')        ST = []      for j in range(4):          ST.append(''.join(S[i][j] for i in range(4)))      for line in ST:          not_win = set()          if '.' in line:              continue          if 'O' in line:              not_win.add('X')          if 'X' in line:              not_win.add('O')          if len(not_win) == 1:              return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')        line = ''.join(S[i][i] for i in range(4))      not_win = set()      if '.' not in line:             if 'O' in line:              not_win.add('X')          if 'X' in line:              not_win.add('O')          if len(not_win) == 1:              return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')        line = ''.join(S[i][3-i] for i in range(4))      not_win = set()      if '.' not in line:          if 'O' in line:              not_win.add('X')          if 'X' in line:              not_win.add('O')          if len(not_win) == 1:              return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')        if not_draw:          return 'Case #%s: %s\n' % (testcase, 'Game has not completed')      else:          return 'Case #%s: %s\n' % (testcase, 'Draw')    if __name__ == '__main__':      import sys      T = int(sys.stdin.next())      common = setup(sys.stdin)      for t in xrange(1, T+1):          sys.stdout.write(solver(**reader(t, **common)))  <CODESPLIT> 35
"""Usage:      pypy X.py < X-size.in > X-size.out  or sometimes      python X.py < X-size.in > X-size.out  """    def setup(infile):      #C = {}      return locals()    def reader(testcase, infile, C=None, **ignore):      #N = int(infile.next())      P = map(int, infile.next().split())      #I = map(int, infile.next().split())      #T = infile.next().split()      #S = [infile.next().strip() for i in range(N)]      return locals()    def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):      #import collections as co      #import functools32 as ft      #import itertools as it      #import operator as op      #import math as ma      #import re      import numpy as np      #import scipy as sp      #import networkx as nx        R, C, M = P      #print '--', R, C, M      MM = M        F = np.array([['.'] * C] * R)      while M > 0:          # reduce if possible          if R >= C and M >= C and R > 2:              M -= C              R -= 1              F[R] = '*'          elif C > R  and M >= R and C > 2:              M -= R              C -= 1              F[:, C] = '*'          # solve simple          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):              if M < C - 1:                  R -= 1                  F[R, C - M:C] = '*'              elif M < R - 1:                  C -= 1                  F[R - M:R, C] = '*'              elif M == C - 1:                  R -= 1                  F[R, C - M + 1:C] = '*'                  F[R - 1, C - 1] = '*'              else:                  C -= 1                  F[R - M + 1:R, C] = '*'                  F[R - 1, C - 1] = '*'              M = 0          #special cases          elif M == R * C - 1:              F[:, :] = '*'              M = 0          else:              #print F              #print R, C, M              return 'Case #%s:\n%s\n' % (testcase, 'Impossible')        F[0, 0] = 'c'      assert (F == '*').sum() == MM      return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))    if __name__ == '__main__':      import sys      T = int(sys.stdin.next())      common = setup(sys.stdin)      for t in xrange(1, T+1):          sys.stdout.write(solver(**reader(t, **common)))  <CODESPLIT> 35
"""Usage:      X.py < X.in > X.out  """    import sys      class Solver(object):      cache = {}        def __init__(self, infile, testcase):          self.testcase = testcase          #self.N = N = int(infile.next())          #self.P = P = map(int, infile.next().split())          self.I = I = map(int, infile.next().split())          #self.T = T = infile.next().split()          #self.S = S = [infile.next().strip() for i in range(N)]            #self.init_cache()        def init_cache(self):          if 'main' in self.cache:              return          #self.cache['main'] = res        def solve(self):          #import collections as co          #import functools as ft          #import itertools as it          #import operator as op          #import math as ma          #import re          #import numpy as np          #import scipy as sp            #N = self.N          #N, M = self.P          I = self.I          #T = self.T          #S = self.S          l = len(str(I[0]))            r = 0          for i in xrange(I[0], I[1]):              ii = str(i)              rr = set()              for j in xrange(1, l):                  if  i < int(ii[j:]+ii[:j]) <= I[1]:                      rr.add(ii[j:]+ii[:j])              r += len(rr)            return r      def main():      T = int(sys.stdin.next())      for t in xrange(T):          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))      if __name__ == '__main__':      main()  <CODESPLIT> 35
def IsPal(n):      S = str(n);      return S == S[::-1];      def Gen():      LIM = 10**14;      N = 10**7;      LIST = [];      for i in range(1, N):          if IsPal(i):              if IsPal(i*i):                  LIST.append(i);      return LIST    PP = Gen();  #print 'Generated'    T = int(raw_input());  for q in range(1,T+1):      [A,B] = map(int, raw_input().split());          ANS = 0;      for i in range(len(PP)):          if B >= PP[i]**2 >= A:              ANS += 1;            print "Case #%d: %d" %(q, ANS);  <CODESPLIT> 36
T = int(raw_input());  for i in range(T):     Data = map(int, raw_input().split());     N = Data.pop(0);     S = Data.pop(0);     p = Data.pop(0);          Good = 0;     for score in Data:        if score >= 3*p-2:           Good += 1;        else:           if (S > 0) and (score >= 3*p-4) and (score >= p):              S -= 1;              Good += 1;       print "Case #%d:" % (i+1),;     print Good;         <CODESPLIT> 36
def PlayDevious(list1, list2):      Ret = 0;      i = 0;      j = 0;      while (i < len(list1)):          if list1[i] > list2[j]:              j += 1;          i += 1;      return j;    def PlayWar(list1, list2):      j = 0;      Score = 0;      for entry in list1:          winner = False;          while (not winner):              if j != len(list2):                  if list2[j] > entry:                      winner = True;                  j += 1;              else:                  Score += 1;                  winner = True;        return Score;    def PlayWar2(list1, list2):      L1 = [];        L2 = [];        Score = 0;        for i in range(len(list1)):          L1.append(list1[i]);        L2.append(list2[i]);      L1.reverse();        Score = 0;      for play in L1:          index =  0;          for i in range(1, len(L2)):              if L2[i] > play > L2[i-1]:                  index = i;            if play > L2[index]:              Score += 1;          L2.pop(index);      return Score                 T = int(raw_input());  for q in range(T):      N = int(raw_input());      Nlist = map(float, raw_input().split());      Klist = map(float, raw_input().split());        Nlist.sort();      Klist.sort();            print "Case #%d:" % (q+1),      print PlayDevious(Nlist, Klist), PlayWar(Nlist, Klist)#, PlayWar2(Nlist, Klist);  <CODESPLIT> 36
T = int(raw_input());  for q in range(T):      [H,W] = map(int, raw_input().split());      Lawn = [];      MRow = [0]*H;      MCol = [0]*W;      for i in range(H):          Lawn.append( map(int, raw_input().split()) );          MRow[i] = max(Lawn[-1]);          for j in range(W):              MCol[j] = max(MCol[j], Lawn[-1][j]);        Valid = True;      for i in range(H):          for j in range(W):              if Lawn[i][j] not in [MRow[i], MCol[j]]:                  Valid = False;                  break;              if Valid:          print "Case #%d: YES" %(q+1);      else:          print "Case #%d: NO" %(q+1);          <CODESPLIT> 36
T = int(raw_input());  for q in range(T):      [C,F,X] = map(float, raw_input().split());        # Default rate is 2 cookies / s;      # Farm costs C      #   produces F      # Target is X;        Time = 0.;      Rate = 2.;      Fin = False;      while (not Fin):          t0 = X/Rate;          t1 = C/Rate + X/(Rate+F);            if t0 <= t1:              Time += t0;              Fin = True;          else:              Time += C/Rate;              Rate += F;        print "Case #%d:" % (q+1),;      print "%.7f" % Time;                  <CODESPLIT> 36
T = int(raw_input());  for q in range(T):      R1 = int(raw_input());      Data1 = [];      for i in range(4):          Data1.append( map(int, raw_input().split()) );                R2 = int(raw_input());      Data2 = [];      for i in range(4):          Data2.append( map(int, raw_input().split()) );        Ans = [];      for entry in Data1[R1-1]:          if entry in Data2[R2-1]:              Ans.append(entry);        print "Case #%d:" % (q+1),;        if len(Ans) == 0:          print "Volunteer cheated!";      if len(Ans) == 1:          print Ans[0];      if len(Ans) > 1:          print "Bad magician!"            <CODESPLIT> 36
RAW = ['ejp mysljylc kd kxveddknmc re jsicpdrysi',         'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',         'de kr kd eoya kw aej tysr re ujdr lkgc jv']  ENG = ['our language is impossible to understand',         'there are twenty six factorial possibilities',         'so it is okay if you want to just give up'];    New = [32]*128;  Left = [];  for c in range(97, 123):     Left += [chr(c)];    for i in range(3):     for j in range(len(RAW[i])):         x = ord(RAW[i][j]);         if (New[x] == 32) and (x != 32):            Left.remove(RAW[i][j]);         New[x] = ord(ENG[i][j]);    New[ord('q')] = ord('z');  New[ord('z')] = ord('q');      T = int(raw_input());  for i in range(T):     print "Case #%d:" % (i+1),;     S_in = raw_input();     S_out = '';     for c in S_in:        S_out += chr(New[ord(c)])     print S_out         <CODESPLIT> 36
def Winner( M ):      for i in range(4):          # Check rows          nX = 0;     nO = 0;               for j in range(4):              if M[i][j] == 'X':                  nX += 1;              if M[i][j] == 'O':                  nO += 1;              if M[i][j] == 'T':                  nX += 1;                  nO += 1;          if nX == 4:              return 'X';          if nO == 4:              return 'O';                for j in range(4):          # Check columns          nX = 0;     nO = 0;               for i in range(4):              if M[i][j] == 'X':                  nX += 1;              if M[i][j] == 'O':                  nO += 1;              if M[i][j] == 'T':                  nX += 1;                  nO += 1;          if nX == 4:              return 'X';          if nO == 4:              return 'O';        if (M[0][0] in ['X','T']) and (M[1][1] in ['X','T']) and (M[2][2] in ['X','T']) and (M[3][3] in ['X','T']):          return 'X';      if (M[0][3] in ['X','T']) and (M[1][2] in ['X','T']) and (M[2][1] in ['X','T']) and (M[3][0] in ['X','T']):          return 'X';      if (M[0][0] in ['O','T']) and (M[1][1] in ['O','T']) and (M[2][2] in ['O','T']) and (M[3][3] in ['O','T']):          return 'O';                 if (M[0][3] in ['O','T']) and (M[1][2] in ['O','T']) and (M[2][1] in ['O','T']) and (M[3][0] in ['O','T']):          return 'O';        return 'D';                  T = int(raw_input());  for q in range(T):      if q != 0:          raw_input();      Map = [];      Dot = False;      for i in range(4):          Map.append( raw_input() );          if '.' in Map[-1]:              Dot = True;        ANS = Winner(Map);  #    print ANS      if ANS == 'X':          print "Case #%d: X won" %(q+1)      if ANS == 'O':          print "Case #%d: O won" %(q+1)      if ANS == 'D':          if Dot:              print "Case #%d: Game has not completed" %(q+1)          else:              print "Case #%d: Draw " % (q+1)    <CODESPLIT> 36
def Trivial(R,C,char):  #    print      for i in range(R):          Ans = '';          for j in range(C):              if (i==j==0):                  Ans += 'c';              else:                  Ans += char;          print Ans;      def Draw1(R,C,Blank):  #    print      Ans = "c";      for i in range(Blank-1):          Ans += '.';      for i in range(R*C-Blank):          Ans += '*';      if (R == 1):          print Ans;                  return;      if (C == 1):          for i in range(len(Ans)):              print Ans[i];    def Draw2(R,C,Blank):      if (Blank%2 != 0) or (Blank == 2):          print "Impossible";          return;      Row1 = '.'*(Blank/2) + '*'*(Mine/2);      Row0 = 'c' + Row1[1:];      if R==2:          print Row0;          print Row1;      else:          for i in range(len(Row0)):              print Row0[i]+Row1[i];      return;      def Generate(R, C, Blank):      TODO = Blank;      Spaces = [0]*R;      if TODO <= 2*C:          if TODO%2 == 0:              Spaces[0] = TODO/2;              Spaces[1] = TODO-Spaces[0];          else:              if (TODO == 7):                  Spaces[0] = 3;                  Spaces[1] = 2;                  Spaces[2] = 2;              else:                  Spaces[0] = (TODO-3)/2;                  Spaces[1] = (TODO-3)/2;                  Spaces[2] = 3;      else:          row = 0;          if (TODO >= 2*C+2):              Spaces[0] = C;              Spaces[1] = C;              TODO -= 2*C;              row = 2;                        while TODO > C+1:              if (TODO == 2*C+1) and (C != 3):                  Spaces[row] = C-1;                  Spaces[row+1] = C-1;                  Spaces[row+2] = 3;                  TODO = 0;              else:                  Spaces[row] = C;                  TODO -= C;                  row += 1;          if (TODO == C+1):              Spaces[row] += C-1;              Spaces[row+1] = 2;              TODO = 0;          Spaces[row] += TODO;        for r in range(R):          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);          if r == 0:              Ans = 'c'+Ans[1:];          print Ans;      def Solve(R, C, M):      Blank = R*C-M;      if Blank == 0:          print "Impossible";          return;        if (Blank == 1):          Trivial(R,C,'*');          return      if (Blank == R*C):          Trivial(R,C,'.');          return        if (R == 1) or (C == 1):            Draw1(R,C,Blank);            return        if (R-2)*(C-2) == 0:          Draw2(R,C,Blank);          return        if Blank in [2,3,5,7]:          print "Impossible";          return;            if (R >= 3) and (C >= 3):          Generate(R, C, Blank);        return;      T = int(raw_input());  for q in range(T):      [Row,Col,Mine] = map(int, raw_input().split());        Blanks = Row*Col - Mine;            print "Case #%d:" % (q+1)  #    print str(Row)+'x'+str(Col)+' with '+str(Mine)+' mines ('+str(Blanks)+' gaps)'      Solve(Row, Col, Mine);                  <CODESPLIT> 36
T = int(raw_input());  for case in range(T):     [A,B] = map(int, raw_input().split());       Big = 10**(len(str(A))-1);     Ans = 0;       for i in range(A,B+1):        j = (i/10)+Big*(i%10);        while (j != i):           if i < j <= B:              Ans += 1;           j = (j/10)+Big*(j%10);       print "Case #%d:" % (case+1),;     print Ans;         <CODESPLIT> 36
  def ispal(num):      num = str(num)      if num == num[::-1]:          return True      else:          return False    def test(bot, top):      count = []      for i in range(bot,top+1):          if not ((int(i**0.5)**2) == i):              continue          if ispal(i) and ispal(int(i**0.5)):              count.append(i)      return len(count)    case = 1  for line in open('C-small-attempt2.in', 'Ur'):      if ' ' in line:          a,b = line.split()          res = test(int(a),int(b))          print("Case #{0}: {1}".format(case, res))          case += 1      <CODESPLIT> 37
#data = [ [int(a) for a in i.split(" ")] for i in open("small.data","rU").read().split("\n")]  data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]  count = 0  for line in data[1:]:  	count += 1  	supps = line[1]  	score = line[2]  	maxes = 0  	nonsuptot = (score*3)-2  	suptot = (score*3)-4  	if suptot < 0:  		suptot = 1  	for i in range(3,(len(line))):  		if line[i] >= nonsuptot:  			maxes += 1  			continue  		if (line[i] >= suptot) and (supps > 0):  			maxes += 1  			supps -= 1  	if score == 0:  		maxes = line[0]  	print ("Case #"+str(count)+":", maxes)  		  			          <CODESPLIT> 37
#!/usr/bin/python      def normal(ken, nao):      total = 0      k = ken[:]      for i in nao[::-1]:          if i > ken[-1]:              k = k[1:]          else:              for e in range(len(k)):                  if k[e] > i:                      del k[e]                      total += 1                      break      return total    def deceit(ken, nao):      k = ken[:]      n = nao[:]      while(len(n) > 0 and len(n) > 0 and (n[0] < k[0] or n[-1] < k[-1])):              n = n[1:]              k = k[:-1]      return len(n)      # total = 0      # for i in k[::-1]:      #     if n[-1] < i:      #         n = n[1:]      #     else:      #         for e in range(len(n)):      #             if n[e] > i:      #                 del n[e]      #                 total += 1      #                 break      # return total                  def main():      # filename = "D-small-attempt0.in"      filename = "D-small-attempt1.in"      # filename = "D-large.in"      # filename = "sample.in"        inp = open(filename, "rU")        n = int(inp.readline().strip())        for case in range(1, n + 1):          count = int(inp.readline().strip())          nao = sorted(map(float, inp.readline().strip().split()))          ken = sorted(map(float, inp.readline().strip().split()))            war = count - normal(ken, nao)          dwar = normal(nao, ken)            print("Case #{}: {} {}".format(case, dwar, war))          # print(count)          # print(nao)          # print(ken)          # print(list(map((lambda x: x[0] > x[1]), zip(nao,ken))))          # print()    main() <CODESPLIT> 37
  def check(grid):      if len(grid) <= 1 or len(grid[0]) <= 1:          return True      for r in range(len(grid)-1):          for c in range(len(grid[r])-1):              e1 = grid[r][c]              e2 = grid[r][c+1]              e3 = grid[r+1][c]              e4 = grid[r+1][c+1]              if (e1 > e2 and e4 > e2) or (e1 > e3 and e4 > e3):                  return False              if (e2 > e1 and e3 > e1) or (e2 > e4 and e3 > e4):                  return False      return True    def removeG(grid):      for i in range(len(grid)):          if len(set(grid[i])) == 1 and grid[i][0] == 1 :              del grid[i]              return True      return False    infile = open('B-small-attempt5.in', 'Ur')  #infile = open('test3.in', 'Ur')    tests = int(infile.readline().strip())    for t in range(tests):      grid = []      h, w = [int(x) for x in infile.readline().strip().split()]      for i in range(h):          row =[int(x) for x in infile.readline().strip().split()]          grid.append(row)        pass1 = check(grid)      print("------")      for r in grid:          print(" ".join([str(x) for x in r]))      while len(grid) >= 3:          if not removeG(grid):              break        pass2 = check(grid)      grid = [x for x in zip(*grid[::-1])]      while len(grid) >= 3:          if not removeG(grid):              break      print("------")      for r in grid:          print(" ".join([str(x) for x in r]))      pass3 = check(grid)      #   if len(grid) >= 3:  #       grid = [row for row in grid if len(set(row)) != 1]  #   print("------")  #   for r in grid:  #       print(" ".join([str(x) for x in r]))        if pass1 and pass2 and pass3:          res = 'YES'      else:          res = 'NO'        print("Case #{0}: {1}".format(t+1,res))      <CODESPLIT> 37
#!/usr/bin/python    #!/usr/bin/python    filename = "B-small-attempt0.in"  # filename = "sample.in"    inp = open(filename, "rU")    n = int(inp.readline().strip())    for case in range(1, n + 1):      cost, freq, goal = map(float, inp.readline().strip().split(" "))      fac = 0.0      time = 0.0      test = lambda x: (goal/(2+(freq * (x + 1)))) + (cost /(2+(freq * x)))      test2 = lambda x: (goal/(2+(freq * x)))      while(test2(fac) > test(fac)):          # print(time)          time += cost/(2 + (freq *  fac))          fac += 1      time += goal/(2+(freq*fac))      print("Case #{}: {}".format(case, time))  <CODESPLIT> 37
#!/usr/bin/python    filename = "A-small-attempt0.in"    inp = open(filename, "rU")    n = int(inp.readline().strip())    for case in range(1, n+1):      gr = lambda x: [list(map(int, inp.readline().strip().split(" "))) for p in range(4)][x-1]      ans1 = int(inp.readline().strip())      row1 = set(gr(ans1))      ans2 = int(inp.readline().strip())      row2 = set(gr(ans2))      sect = row1 & row2      if len(sect) <= 0:          print("Case #{}: Volunteer cheated!".format(case))      elif len(sect) == 1:          print("Case #{}: {}".format(case, sect.pop()))      elif len(sect) > 1:          print("Case #{}: Bad magician!".format(case))      else:          print("ERROR")  <CODESPLIT> 37
mapp = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm','q':'z','z':'q'}  input = open("A-small-attempt0.in", "rU").readlines()  counter = 0  for a in input[1:]:  	counter += 1  	outline = a.replace("\n",'')  	outline2 = []  	for i in outline:  		outline2.append(mapp[i])  	print ("Case #"+str(counter)+":",''.join(outline2))    <CODESPLIT> 37
    infile = open('A-small-attempt0.in', 'Ur').read()[1:].split('\n\n')    case = 1  for test in infile:      test = test.replace('\n','')      sets = []      if not test:          break        r = 0      for i in range(4):          sets.append(test[i::4])          sets.append(test[r:r+4])          r = r+4      sets.append(test[0] + test[5] + test[10] + test[15])      sets.append(test[3] + test[6] + test[9] + test[12])        sets = [set(x) for x in sets]      winner = ''      for i in sets:          if i.issubset({'X', 'T'}):              winner = 'X'              break          if i.issubset({'O', 'T'}):              winner = 'O'              break        if winner:          print("Case #{0}: {1} won".format(case, winner))      else:          if '.' in test:              print("Case #{0}: Game has not completed".format(case))          else:              print("Case #{0}: Draw".format(case))      case += 1    <CODESPLIT> 37
#!/usr/bin/python  from copy import copy, deepcopy    def check_bounds(state, coord):      if coord[0] < 0 or coord[1] < 0:          return False      elif coord[0] > (len(state) - 1):          return False      elif coord[1] > (len(state[coord[0]]) - 1):          return False      else:          return True    def clear(state, coord):      for r in range(-1,2):          for c in range(-1,2):              row = coord[0] + r              col = coord[1] + c              if check_bounds(state, (row, col)):                  state[row][col] = 0    def count(state):      return sum([sum(x) for x in state])    def state_print(state):      print("c" + "".join(["*"  if x else "." for x in state[0][1:]]))      for line in state[1:]:          print("".join(["*"  if x else "." for x in line]))    def solve(state, mines):      prev_state = deepcopy(state)      for row in range(len(state)):          for col in range(len(state[row])):              new_state = deepcopy(state)              clear(new_state, (row, col))              c = count(new_state)              # print(c)              # state_print(state)              if(c < mines):                  state = prev_state              elif( c == mines):                  state_print(new_state)                  return True              else:                  if col == len(state[row]) -2:                      prev_state = deepcopy(state)                  state = new_state      print("Impossible")      return False          def main():      filename = "C-small-attempt0.in"      # filename = "C-large.in"      # filename = "sample.in"          inp = open(filename, "rU")        n = int(inp.readline().strip())        for case in range(1, n + 1):          R, C, M = map(int, inp.readline().strip().split(" "))          state = [[1 for x in range(C)] for y in range(R)]          print("Case #{}:".format(case))          solve(state, M)      # state = [[1 for x in range(7)] for y in range(4)]      # solve(state, 13)    main() <CODESPLIT> 37
data = [ [int(a) for a in i.split(" ")] for i in open("C-small-attempt0.in","rU").read()[:-1].split("\n")]    def recycle(number, mini, maxi):  	number2 = str(number)  	count = 0  	for i in range(len(number2)):  		number2 = number2[-1:] + number2[:-1]  		numtemp = int(number2)  		if (number == numtemp) or (number > numtemp):  			continue  		if ((numtemp <= maxi) and (numtemp > mini)):  			#print (number,numtemp)  			numlist.append((number,numtemp))  			count += 1  	return count  # total = 0  # for i in range(1111,2222):  # 	total += (recycle(i,1111,2222))  # 	print (len(set(numlist)))        count = 0  for line in data[1:]:  	count += 1  	total = 0  	numlist = []  	for a in range(line[0],(line[1])):  		total += recycle(a,line[0], line[1])  	print ("Case #"+str(count)+":", len(set(numlist))) <CODESPLIT> 37
from math import sqrt    def isqrt(num):      return int(sqrt(num))    def is_square(num):      return isqrt(num)**2 == num    def is_palindrome(num):      return str(num) == "".join(reversed(str(num)))    def is_fair_and_square(num):      return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))    def solve(A,B):      count = 0      for i in range(A,B+1):          if is_fair_and_square(i):              count += 1      return count    if __name__ == "__main__":      T = int(raw_input())      for i in range(1, T+1):          A,B = [int(x) for x in raw_input().split()]          print "Case #%d: %d" % (i, solve(A,B))            <CODESPLIT> 38
def max_of_triplets(n):      a = n//3      if (n % 3) == 0:          if a == 0 : return (0,0)          return (a, a+1)      if (n % 3) == 1:          return (a+1, a+1)      if a == 9: return (10, 10)      return (a+1, a+2)    def solve(scores, S, p):      t = 0      for s in scores:          a,b = max_of_triplets(s)          if a >= p:              t += 1          elif b >= p and S > 0:              t += 1              S -= 1      return t    if __name__ == "__main__":      T = int(raw_input())      for i in range(1, T+1):          nums = map(int, raw_input().strip().split())          N = nums[0]          S = nums[1]          p = nums[2]          scores = nums[3:]          if len(scores) != N:              #sanity check              print "WTF", i          print "Case #%d: %d" % (i, solve(scores, S, p))        <CODESPLIT> 38
def solve(naomi, ken):      N = list(sorted(naomi))      K = list(sorted(ken))      pd = 0      while len(N) > 0:          if N[0] > K[0]:              pd += 1              N.pop(0)              K.pop(0)          else:              N.pop(0)              K.pop(-1)      pn = 0      N = list(sorted(naomi))      K = list(sorted(ken))      while len(N) > 0:          n = N.pop(0)          if n < K[0]:              K.pop(0)          else:              found = None              for i,k in enumerate(K):                  if k > n:                      found = i                      break              if found is not None:                  K.pop(found)              else:                  K.pop(0)                  pn += 1      return pd,pn    if __name__=="__main__":      T = int(raw_input())      for i in range(1,T+1):          raw_input()          naomi = map(float, raw_input().split())          ken = map(float, raw_input().split())          x,y = solve(naomi,ken)          print "Case #%d: %d %d" %(i,x,y)  <CODESPLIT> 38
def solve(grid, M, N):      row_max = {}      column_max = {}      for i in range(M):          row_max[i] = max(grid[i])      for i in range(N):          column_max[i] = max([grid[j][i] for j in range(M)])      for i in range(M):          for j in range(N):              v = grid[i][j]              if v < row_max[i] and v < column_max[j]:                  return "NO"      return "YES"    if __name__ == "__main__":      T = int(raw_input())      for i in range(1,T+1):          M,N = [int(x) for x in raw_input().split()]          grid = [[int(x) for x in raw_input().split()] for j in range(M)]          print "Case #%d: %s" % (i, solve(grid, M,N))  <CODESPLIT> 38
def time_to_get(target, num_factories, factory_cost, factory_increase):      rate = 2.0      t = 0      for i in range(num_factories):          t += factory_cost/rate          rate += factory_increase      return t + target/rate        def solve(C,F,X):      min_sol = None      num_fact = 0      while True:          t = time_to_get(X, num_fact, C, F)          if min_sol is None or t < min_sol:              min_sol = t              num_fact += 1          else:              return min_sol    if __name__ == "__main__":      T = int(raw_input())      for i in range(1, T+1):          C,F,X = map(float, raw_input().split())          print "Case #%d: %.07f" % (i, solve(C,F,X))  <CODESPLIT> 38
def solve(c1, g1, c2, g2):      row_1 = g1[c1-1]      row_2 = g2[c2-1]      inter = set(row_1) & set(row_2)      if len(inter) == 0:          return "Volunteer cheated!"      if len(inter) > 1:          return "Bad magician!"      return str(inter.pop())    if __name__ == "__main__":      T = int(raw_input())      for i in range(1,T+1):          c1 = int(raw_input())          g1 = []          for j in range(4):              g1.append(map(int, raw_input().split()))          c2 = int(raw_input())          g2 = []          for j in range(4):              g2.append(map(int, raw_input().split()))          print "Case #%d: %s" % (i, solve(c1,g1,c2,g2))                   <CODESPLIT> 38
mapping = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's',             'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u',             'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n',             'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a',             'x': 'm', 'z': 'q', 'q': 'z'}    def translate(s):      return "".join(map(lambda a: mapping[a], s))    if __name__ == "__main__":      T = int(raw_input())      for i in range(1, T+1):          s = translate(raw_input().strip())          print "Case #%d: %s" %(i, s)              <CODESPLIT> 38
def line_status(line):      s = set(line)      if '.' in s:          return 'I'      if len(s) == 1 or (len(s) == 2 and 'T' in s):          player = s.pop()          while player == "T":              player = s.pop()          return player      return 'D'    def grid_status(grid):      lines = grid      columns = []      for i in range(4):          columns.append([])          for j in range(4):              columns[-1].append(grid[j][i])      lines.extend(columns)      lines.append([grid[i][i] for i in range(4)])      lines.append([grid[i][3-i] for i in range(4)])      incomplete = False      for l in lines:          s = line_status(l)          if s == 'I':              incomplete = True          elif s in ('X', 'O'):              return s + " won"      if incomplete:          return "Game has not completed"      return "Draw"    if __name__ == "__main__":      T = int(raw_input())      for i in range(1, T+1):          grid = [raw_input() for j in range(4)]          if i < T:              raw_input()          print "Case #%d: %s" % (i, grid_status(grid))        <CODESPLIT> 38
import sys    def all_grids(R,C,M, lp=0,placed=0):      rem = R*C-lp      if M-placed >= rem:          if M-placed > rem:              return None                    res = set()          for i in range(lp, R*C):              res.add(i)          return [res]                if placed == M:          return [set()]        res = []      for i in range(lp, R*C):          sub_sol = all_grids(R,C,M,i+1, placed+1)          if sub_sol is None:              continue                        for s in sub_sol:              s.add(i)              res.append(s)      return res    def adj(R,C,i):            res = []      left_edge = i % C == 0      top_edge = i // C == 0      right_edge = (i+1) % C == 0      bottom_edge = i // C == R-1            if not left_edge:          res.append(i-1)          if not top_edge:              res.append(i-1-C)          if not bottom_edge:              res.append(i+C-1)                    if not right_edge:          res.append(i+1)          if not top_edge:              res.append(i+1-C)          if not bottom_edge:              res.append(i+1+C)                    if not bottom_edge:          res.append(i+C)      if not top_edge:          res.append(i-C)      return res                              def solution(R,C,g):      M = R*C      res = []      num_zeroes = 0      for i in range(M):          if i in g:              res.append('x')              continue          x = 0          for a in adj(R,C,i):              if a in g:                  x += 1          if x == 0:              num_zeroes += 1          res.append(x)                for i in range(M):          if i in g:              continue          r = res[i]          if r == 0 and num_zeroes == 1:              continue          connected = False          for a in adj(R,C,i):              if res[a] == 0:                  connected = True                  break          if not connected:              return None            return res.index(0)    def transcribe(R,C, g, sol):      res = []      for i in range(R):          r = []          for j in range(C):              x = i*C+j              if x in g:                  r.append('*')              elif x == sol:                  r.append('c')              else:                  r.append('.')          res.append(r)      return res    def printed_sol(transcript):      if transcript is None:          return "Impossible"      else:          return "\n".join("".join(row) for row in transcript)    def solve(R,C,M):      if M == R*C-1:          g = []          for i in range(R*C-1):              g.append(i)          return transcribe(R,C, g, R*C-1)            for g in all_grids(R,C,M):          sol = solution(R,C,g)          if sol is None:              continue          return transcribe(R,C, g, sol)      return None                      def output_grid(R,C,g):      for i in range(R):          for j in range(C):              if i*C+j not in g:                  sys.stdout.write(".")              else:                  sys.stdout.write("*")          sys.stdout.write("\n")    if __name__ == "__main__":      T = int(raw_input())      for i in range(1,T+1):          R,C,M = map(int, raw_input().split())          print "Case #%d:" % i          print printed_sol(solve(R,C,M))  <CODESPLIT> 38
def num_rotations(n, A, B):      # I'm sure there's a better way to do this      # but this works fast enough so who cares      s = str(n)      a = set()      for i in range(len(s)):          rotated = s[i:] + s[:i]          r = int(rotated)          if rotated[0] != '0' and A <= r <= B:              a.add(rotated)      return len(a) -1    def solve(A,B):      t  = 0      for i in range(A, B+1):          t += num_rotations(i, A, B)      if t % 2 != 0:          print "WTF", A, B, t      return t//2    if __name__ == "__main__":      T = int(raw_input())      for i in range(1, T+1):          A,B = map(int, raw_input().strip().split())          print "Case #%d: %d" % (i, solve(A,B))  <CODESPLIT> 38
import sys, itertools    def get_generators_up_to_length_n(n):      generators = []      for ii in range(1, n + 1):          generators += get_generators_length_n(ii)      return generators            def get_generators_length_n(length):      if length % 2 == 0: return get_even_generators_length_n(length)      else: return get_odd_generators_length_n(length)    def get_odd_generators_length_n(length):      if length == 1: return [1, 2, 3]      else:           n = length / 2          generators = []          for ii in range(min(n, 4)):              for comb in itertools.combinations(range(1, n), ii):                  first_half = ["1"] + ["0"] * (n-1)                  for jj in comb:                      first_half[jj] = "1"                  second_half = list(first_half)                  second_half.reverse()                  palin = first_half + ["0"] + second_half                  generators.append(int("".join([elem for elem in palin])))                  palin[n] = "1"                  generators.append(int("".join([elem for elem in palin])))                  if ii <= 1:                      palin[n] = "2"                      generators.append(int("".join([elem for elem in palin])))          generators.append(int("".join([elem for elem in (["2"] + ["0"] * (n - 1) + ["0"] + ["0"] * (n - 1) + ["2"])])))          generators.append(int("".join([elem for elem in (["2"] + ["0"] * (n - 1) + ["1"] + ["0"] * (n - 1) + ["2"])])))          generators.sort()          return generators    def get_even_generators_length_n(length):      if length == 2: return [11, 22]      n = length / 2      generators = []      for ii in range(min(n, 4)):          for comb in itertools.combinations(range(1, n), ii):              first_half = ["1"] + ["0"] * (n-1)              for jj in comb:                  first_half[jj] = "1"              second_half = list(first_half)              second_half.reverse()              palin = first_half + second_half              generators.append(int("".join([elem for elem in palin])))      generators.append(int("".join([elem for elem in (["2"] + ["0"] * (length - 2) + ["2"])])))      generators.sort()      return generators    def is_palin(num):      string = str(num)      length = len(string)      ii = 0      while ii < length/2:          if string[ii] != string[-(1+ii)]:              return False          ii += 1      return True    def gen_fair_and_squares(upper_limit):      fair_and_squares = []      for ii in range(1, upper_limit + 1):          if (is_palin(ii) and is_palin(ii*ii)):              fair_and_squares.append(ii)      return fair_and_squares    f = open(sys.argv[1])  T = int(f.readline())  gens = get_generators_up_to_length_n(60)  squares = map(lambda x: x*x, gens)    for t in range(T):      A, B = map(int, f.readline().strip().split())      total = 0      for elem in squares:          assert(is_palin(elem))          if elem >= A and elem <= B: total += 1          if elem > B:              break        print "Case #%d:" % (t + 1), total  <CODESPLIT> 39
import sys    f = open(sys.argv[1])  T = int(f.readline())  for t in range(T):      temp = map(int, f.readline().split())      N = temp[0]      S = temp[1]      p = temp[2]      scores = temp[3:]      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))      if (p<=1):          surprising_scores = 0      else:          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))      num_scores = non_surprising_scores + min(surprising_scores, S)         print "Case #%d:" % (t + 1), num_scores  <CODESPLIT> 39
import sys    f = open(sys.argv[1])  T = int(f.readline())  for test in range(T):      N = int(f.readline())      naomi_blocks = map(float, f.readline().strip().split(" "))      ken_blocks = map(float, f.readline().strip().split(" "))      naomi_blocks.sort()      ken_blocks.sort()      naomi_clone = list(naomi_blocks)      ken_clone = list(ken_blocks)        naomi_standard_score = 0      while naomi_blocks != []:          naomi_new_val = naomi_blocks.pop()          if naomi_new_val > ken_blocks[-1]:              naomi_standard_score += 1              ken_blocks.pop(0)          else:              ii = 0              while ken_blocks[ii] < naomi_new_val:                  ii += 1              ken_blocks.pop(ii)        assert(ken_blocks == [])        naomi_blocks = naomi_clone      ken_blocks = ken_clone      naomi_blocks.sort(reverse=True)      ken_blocks.sort(reverse=True)      deceiving_strat_score = 0      while naomi_blocks != []:          naomi_new_val = naomi_blocks.pop()          if naomi_new_val > ken_blocks[-1]:              ken_blocks.pop()              deceiving_strat_score += 1        print "Case #%d: " % (test + 1), deceiving_strat_score, naomi_standard_score        <CODESPLIT> 39
import sys    f = open(sys.argv[1])  T = int(f.readline())  for t in range(T):      N, M = map(int, f.readline().strip().split())      grass_lengths = []      for nn in range(N):          grass_lengths.append(map(int, f.readline().strip().split())) # Read in all grass heights        x_max = [0] * M      y_max = [0] * N      for xx in range(M):          for yy in range(N):              height = grass_lengths[yy][xx]              x_max[xx] = max(x_max[xx], height)  # Update the max required height for column x              y_max[yy] = max(y_max[yy], height)  # Update the max required height for row y        impossible = False      for xx in range(M):          for yy in range(N):              height = grass_lengths[yy][xx]              if (x_max[xx] > height and y_max[yy] > height): # Can we cut this row down to this level?                  impossible = True        print "Case #%d:" % (t + 1), "NO" if impossible else "YES"  <CODESPLIT> 39
import sys  from decimal import *    f = open(sys.argv[1])  T = int(f.readline())  for test in range(T):      data = f.readline().split()      C = Decimal(data[0])      F = Decimal(data[1])      X = Decimal(data[2])      curr_rate = Decimal(2)      best_time = Decimal(10**100)      curr_time = Decimal(0)      while curr_time < best_time:          poss_finish_time = curr_time + X / curr_rate          if poss_finish_time < best_time:              best_time = poss_finish_time            curr_time += C / curr_rate          curr_rate += F        print "Case #%d: %.7f" % (test + 1, best_time)  <CODESPLIT> 39
import sys    f = open(sys.argv[1])  T = int(f.readline())  for test in range(T):      first_row_index = int(f.readline())      first_row = []      for ii in range(4):          if (ii + 1) == first_row_index:              first_row = f.readline().strip().split()          else:              f.readline()      second_row_index = int(f.readline())      second_row = []      for ii in range(4):          if (ii + 1) == second_row_index:              second_row = f.readline().strip().split()          else:              f.readline()      combined = [val for val in first_row if val in second_row]        print "Case #%d:" % (test + 1), "Bad magician!" if len(combined) > 1 else "Volunteer cheated!" if len(combined) == 0 else combined[0]      <CODESPLIT> 39
import sys    def translate(letter):      input =  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']      output = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']      index = input.index(letter)      return output[index]    f = open(sys.argv[1])  T = int(f.readline())  for t in range(T):      string = []      A = f.readline().split()      for elem in A:          for ii in range(len(elem)):              string.append(translate(elem[ii]))          string.append(' ')                 print "Case #%d:" % (t + 1), ''.join(elem for elem in string)  <CODESPLIT> 39
import sys    def hasWon(game, player):      for ii in range(4):          success = True          for jj in range(4): # Has the player won in row ii              if game[4*ii + jj] != player and game[4*ii + jj] != "T":                  success = False          if success: return True          success = True          for jj in range(4): # Has the player won in column ii              if game[4*jj + ii] != player and game[4*jj + ii] != "T":                  success = False          if success: return True            success = True      for ii in range(4):          if game[ii*5] != player and game[ii*5] != "T":              success = False      if success: return True      success = True      for ii in range(4):          if game[3+ii*3] != player and game[3+ii*3] != "T":              success = False      if success: return True      return False    def gameOver(game):      ret_val = True      for ii in range(16):          if game[ii] == ".":              ret_val = False      return ret_val    f = open(sys.argv[1])  T = int(f.readline())  for t in range(T):      game = []      for ii in range(4):          for elem in f.readline().strip():              game.append(elem)        if hasWon(game, "O"):          print "Case #%d:" % (t + 1), "O won"      elif hasWon(game, "X"):          print "Case #%d:" % (t + 1), "X won"      elif gameOver(game):          print "Case #%d:" % (t + 1), "Draw"      else:          print "Case #%d:" % (t + 1), "Game has not completed"        f.readline()  <CODESPLIT> 39
import sys    f = open(sys.argv[1])  T = int(f.readline())  for test in range(T):      R, C, M = map(int, f.readline().strip().split())      Rorig = R      Corig = C      impossible = False      grid = [['.' for i in range(C)] for j in range(R)]      #print grid        curr_coord = [0,0]      while M > 0 and not impossible:          #print curr_coord, M, grid          if (C > R): # more columns - fill one in              num_mines_in_column = R              if M < R:                  num_mines_in_column = min(R - 2, M)              if num_mines_in_column <= 0:                  impossible = True                  break              for ii in range(num_mines_in_column):                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'              C -= 1              curr_coord[1] += 1              M -= num_mines_in_column          else:              num_mines_in_row = C              if M < C:                  num_mines_in_row = min(C - 2, M)              if num_mines_in_row <= 0:                  impossible = True                  break              for ii in range(num_mines_in_row):                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'              R -= 1              curr_coord[0] += 1              M -= num_mines_in_row        #print grid      print "Case #%d:" % (test + 1)      if impossible:          print "Impossible"      else:          for ii in range(Rorig):              for jj in range(Corig):                  if grid[ii][jj] == '.':                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':                          grid[ii][jj] = 'dirty'                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':                          grid[ii][jj] = 'dirty'                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':                          grid[ii][jj] = 'dirty'          #print grid            for ii in range(Rorig):              for jj in range(Corig):                  if grid[ii][jj] == 'dirty':                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':                          grid[ii][jj] = '.'                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':                          grid[ii][jj] = '.'                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':                          grid[ii][jj] = '.'                      else:                          if ii != Rorig - 1 or jj != Corig - 1:                              impossible = True          #print grid            if impossible:              print "Impossible"          else:              grid[Rorig-1][Corig-1] = 'c'                for ii in range(Rorig):                  print " ".join([val for val in grid[ii]])      <CODESPLIT> 39
import sys    def recycle(num):      x = str(num)      recycles = []      for ii in range(1, len(x)):          recycles.append(x[ii:] + x[:ii])          return recycles    f = open(sys.argv[1])  T = int(f.readline())  for t in range(T):      A, B = map(int, f.readline().split())      total = 0      debugs = []      for ii in range(A,B):          recycles_ii = recycle(ii)          recycles_ii = (filter(lambda x: int(x) > ii and int(x) <= B, recycles_ii))          total += len(recycles_ii)          for elem in recycles_ii:              debugs.append((ii, int(elem)))         print "Case #%d:" % (t + 1), len(set(debugs))  <CODESPLIT> 39
import sys  #sys.stdin = open("c_example.in")    n_cases = input()    def to_ints(s):      return map(int, s.split())    def is_palindrome(n):      s = str(n)      return s == s[::-1]    for case in xrange(1, n_cases + 1):      a, b = to_ints(raw_input())        nums = range(int(b ** .5) + 2)      palins = filter(is_palindrome, nums)      squares = [x**2 for x in palins]      palin_squares = filter(is_palindrome, squares)      range_squares = [x for x in palin_squares if a <= x <= b]        print "Case #%d: %s" % (case, len(range_squares))  <CODESPLIT> 40
n_cases = input()    for case in xrange(1, n_cases + 1):      ins = map(int, raw_input().strip().split())      n = ins[0]      s = ins[1]      p = ins[2]      t = ins[3:]        out = 0      for x in t:          if (x + 2) / 3 >= p:              out += 1          elif s and x > p and p - ((x - p) / 2) <= 2:              out += 1              s -= 1                    print "Case #%d: %s" % (case, out)  <CODESPLIT> 40
import sys  if len(sys.argv) == 1:      sys.stdin = open("D.in")  else:      sys.stdin = open(sys.argv[1])    def to_floats(s):      return map(float, s.split())    def get_floats():      return to_floats(raw_input())    n_cases = input()    # Ken strategy: pick smallest block larger than  #     claimed one, else use smallest block    def cheat(our_blocks, opp_blocks):      # Cheat strategy: eliminate opponents      # largest blocks with our smallest, until all our      # blocks are larger than corresponding      n_blocks = len(our_blocks)      burned = 0      while any(our_blocks[x+burned] < opp_blocks[x] for x in xrange(0, n_blocks - burned)):          burned += 1      return n_blocks - burned    def fair(our_blocks, opp_blocks):      # Our strategy: use blocks smallest to largest      score = 0      opp_left, opp_right = 0, len(opp_blocks)-1      for our in our_blocks:          for n, opp in enumerate(opp_blocks):              if opp > our:                  opp_blocks.pop(n)                  break          else:              score += 1              opp_blocks.pop(0)      return score    for case in xrange(1, n_cases + 1):      n_blocks, = get_floats()      our_blocks = sorted(get_floats())      opp_blocks = sorted(get_floats())        deceitful_score = cheat(our_blocks, opp_blocks)      fair_score = fair(our_blocks, opp_blocks)        print "Case #%d: %d %d" % (case, deceitful_score, fair_score)  <CODESPLIT> 40
import sys  #sys.stdin = open("b_example.in")    n_cases = input()    def to_ints(s):      return map(int, s.split())    for case in xrange(1, n_cases + 1):      ydim, xdim = to_ints(raw_input())      heights = [to_ints(raw_input()) for _ in xrange(ydim)]        ymaxes = [max(row) for row in heights]      xmaxes = [max(col) for col in zip(*heights)]        #print ymaxes, xmaxes        poss = True        for y in range(ydim):          for x in range(xdim):              height = heights[y][x]              if not (height == xmaxes[x] or height == ymaxes[y]):                  poss = False          print "Case #%d: %s" % (case, 'YES' if poss else 'NO')  <CODESPLIT> 40
import sys  if len(sys.argv) == 1:      sys.stdin = open("B.in")  else:      sys.stdin = open(sys.argv[1])    def to_floats(s):      return map(float, s.split())    def get_floats():      return to_floats(raw_input())    n_cases = input()    for case in xrange(1, n_cases + 1):      farm_cost, farm_increase, goal = get_floats()        best_time = float('inf')      time = 0.0      rate = 2.0      while time < best_time:          best_time = min(best_time, time + goal / rate)          time += farm_cost / rate          rate += farm_increase        print "Case #%d: %.7f" % (case, best_time)  <CODESPLIT> 40
import sys  if len(sys.argv) == 1:      sys.stdin = open("A.in")  else:      sys.stdin = open(sys.argv[1])    def to_ints(s):      return map(int, s.split())    def get_ints():      return to_ints(raw_input())    n_cases = input()    for case in xrange(1, n_cases + 1):      a_row, = get_ints()      a_layout = [get_ints() for _ in range(4)]      b_row, = get_ints()      b_layout = [get_ints() for _ in range(4)]        poss = set(a_layout[a_row - 1])      poss.intersection_update(b_layout[b_row - 1])        result = 'Bad magician!'        if len(poss) == 0:          result = 'Volunteer cheated!'      elif len(poss) == 1:          result = poss.pop()        print "Case #%d: %s" % (case, result)  <CODESPLIT> 40
mapping = {'y':'a', 'e':'o', 'q':'z', 'z':'q'}    for src, dst in [("ejp mysljylc kd kxveddknmc re jsicpdrysi", "our language is impossible to understand"),      ("rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd","there are twenty six factorial possibilities"),      ("de kr kd eoya kw aej tysr re ujdr lkgc jv","so it is okay if you want to just give up")]:      for a, b in zip(src,dst):          mapping[a] = b    n_cases = input()      for case in xrange(1, n_cases + 1):      string = raw_input()        out = ''.join(mapping.get(c, c) for c in string)                    print "Case #%d: %s" % (case, out)  <CODESPLIT> 40
import sys  #sys.stdin = open("a_example.in")    n_cases = input()    def xwin(s):      return all(c in 'XT' for c in s)    def owin(s):      return all(c in 'OT' for c in s)    for case in xrange(1, n_cases + 1):      board = [raw_input().strip() for _ in xrange(4)]      raw_input()        board_t = zip(*board)        #print board, board_t        x_win = False      o_win = False      full = not any('.' in line for line in board)        diag_nw = [board[x][x] for x in range(4)]      diag_ne = [board[x][3-x] for x in range(4)]        #print diag_nw, diag_ne        if xwin(diag_nw) or xwin(diag_ne):          x_win = True      if owin(diag_nw) or owin(diag_ne):          o_win = True        for line, line_t in zip(board, board_t):          if xwin(line) or xwin(line_t):              x_win = True          if owin(line) or owin(line_t):              o_win = True        out = 'Game has not completed'      if x_win:          out = 'X won'      elif o_win:          out = 'O won'      elif full:          out = 'Draw'        print "Case #%d: %s" % (case, out)  <CODESPLIT> 40
import sys  if len(sys.argv) == 1:      sys.stdin = open("C.in")  else:      sys.stdin = open(sys.argv[1])    def to_ints(s):      return map(int, s.split())    def get_ints():      return to_ints(raw_input())    sys.setrecursionlimit(4000)    def fill(rows, cols, mines):      seen = set()      visited = set()        # we are trying to carve through a mountain       # and leave 'mine' squares unseen      def search(numbered, zeros, min_numbered):          left = (rows * cols - mines) - len(numbered)          #print left, numbered,  min_numbered, zeros          if left == 0:              raise StopIteration((numbered, zeros))          if left < 0:              return          for n in xrange(min_numbered, len(numbered)):              number = numbered[n]              if number in zeros:                  continue              row, col = number              neigh = []              if row > 0:                  if col > 0: neigh.append((row - 1, col - 1))                  neigh.append((row - 1, col))                  if col < cols - 1: neigh.append((row - 1, col + 1))              if col > 0: neigh.append((row, col - 1))              if col < cols - 1: neigh.append((row, col + 1))              if row < rows - 1:                  if col > 0: neigh.append((row + 1, col - 1))                  neigh.append((row + 1, col))                  if col < cols - 1: neigh.append((row + 1, col + 1))              # BUG: we might try to walk to a diagonal, oh well              neigh = list(set(neigh) - set(numbered))              zeros.add(number)              search(numbered + neigh, zeros, n + 1)              zeros.remove(number)        try:          for row in xrange(rows):              for col in xrange(cols):                  search([(row, col)], set(), 0)      except StopIteration, e:          numbered, zeros = e.message          board = {}          for row, col in numbered + list(zeros):              board[row, col] = '.'          if zeros:              board[zeros.pop()] = 'c'          else: # case where first click is on a number              board[0, 0] = 'c'          out = ''          for row in xrange(rows):              for col in xrange(cols):                  out += board.get((row, col), '*')              out += '\n'          return out.strip()      return 'Impossible'    n_cases = input()  for case in xrange(1, n_cases + 1):      rows, cols, mines = get_ints()        result = fill(rows, cols, mines)        print "Case #%d:" % case      print result  <CODESPLIT> 40
n_cases = input()    for case in xrange(1, n_cases + 1):      a, b = map(int, raw_input().split())        out = 0      e = 10 ** (len(str(a)) - 1)      for n in xrange(a, b):          s = str(n)          m = n          while True:              m = (m / 10) + (m % 10 * e)              if n < m <= b:                  out += 1              if m == n:                  break        print "Case #%d: %s" % (case, out)  <CODESPLIT> 40
# In general 1[10]*1 square is always a palindrome and some subset of [12][012]*[12] is also good but it's just  # too much hassle to figure that out. Also needs a more complex generator for ranges. 55p is hard...      LIMIT = 10    def check_palindrome(number):      rev = 0      runner = number      while runner > 0:          rev = rev * 10 + (runner % 10)          runner /= 10      if rev == number:          return True      else:          return False    def list_to_number(number_list):      l = len(number_list)      res = 0; rres = 0      multi = 1      for i in xrange(1, l + 1):          res += number_list[l - i] * multi          rres += number_list[i - 1] * multi          multi *= 10      return (res, rres)    def gen_one_side(side_length):      state = [0 for _ in xrange(side_length)]      done = False        while not done:          if state[-1] != 0:              yield state          state[-1] += 1          curr = side_length - 1          while state[curr] == LIMIT:              if curr == 0:                  done = True                  break              state[curr] = 0              curr -= 1              state[curr] += 1    def gen_odd_palindrome(side_length):      if side_length == 0:          for i in xrange(1, 10):              yield i      else:          multi = 10**side_length          for one_side in gen_one_side(side_length):              number, rnumber = list_to_number(one_side)              for i in xrange(LIMIT):                  yield number + i * multi + rnumber * multi * 10    def gen_even_palindrome(side_length):      multi = 10**side_length      for one_side in gen_one_side(side_length):          number, rnumber = list_to_number(one_side)          yield number + rnumber * multi      def gen_palindrome():      l = 1        while True:          if l % 2 == 1:              for odd_pal in gen_odd_palindrome((l - 1) / 2):                  yield odd_pal          else:              for even_pal in gen_even_palindrome(l / 2):                  yield even_pal          l += 1      cache = []  upper = 10**14  for pal in gen_palindrome():      pal2 = pal**2      if pal2 > upper:          break      if check_palindrome(pal2):          cache.append(pal2)    cl = len(cache)  T = int(raw_input().strip())  for i in xrange(T):      low_ind = 0      high_ind = cl - 1      A, B = map(int, raw_input().strip().split(' '))        # The cache is small for 10**14      while cache[low_ind] < A:          low_ind += 1      while cache[high_ind] > B:          high_ind -= 1          if low_ind <= high_ind:          print "Case #%s: %s" % (i + 1, high_ind - low_ind + 1)      else:          print "Case #%s: 0" % (i + 1)  <CODESPLIT> 41
from sys import argv    surprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]  regular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]    f = open(argv[1], 'r')  T = int(f.readline().strip('\n'))  for i in range(T):  	both = 0  	surp_only = 0  	line = f.readline().strip('\n').split(' ')  	N = int(line[0]) # What for?  	S = int(line[1])  	p = int(line[2])  	ts = map(int, line[3:])  	for t in ts:  		if reduce(max, map(max, regular[t])) >= p:  			both += 1  		elif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:  			surp_only += 1    	print "Case #%s: %s" % (i + 1, both + min(surp_only, S)) <CODESPLIT> 41
T = int(raw_input().strip())    for i in xrange(T):  	N = int(raw_input().strip())  	naomi = sorted(map(float, raw_input().strip().split(' ')))  	# print "naomi: %s"  % naomi  	ken = sorted(map(float, raw_input().strip().split(' ')))  	# print "ken: %s" % ken    	war_score = N  	np = 0  	kp = 0  	while np < N and kp < N:  		while kp < N and naomi[np] >= ken[kp]:  			kp += 1  		if kp < N:  			kp += 1  			np += 1  			war_score -= 1    	d_war_score = N  	best = None  	for start_from in xrange(N):  		j = 0  		good = True  		while start_from + j < N:  			if ken[j] >= naomi[start_from + j]:  				good = False  				break  			j += 1  		if good:  			best = N - start_from  			break  	if best is not None:  		d_war_score = best  	else:  		d_war_score = 0    	print "Case #%s: %s %s" % (i + 1, d_war_score, war_score)  <CODESPLIT> 41
YES = 0  NO = 1    messages = [      "YES",      "NO"  ]    # def check_height(lawn, N, M, height, was, levels):  #     for x, y in levels[height]:  #         if x not in was['row'] and y not in was['col']:  #             # Try the row  #             good_row = True  #             for i in xrange(M):  #                 if lawn[x][i] > height:  #                     good_row = False  #                     break  #             if good_row:  #                 was['row'].add(x)  #                 continue  #             good_col = True  #             for i in xrange(N):  #                 if lawn[i][y] > height:  #                     good_col = False  #                     break  #             if good_col:  #                 was['col'].add(y)  #                 continue  #             # There is no good cut for this field  #             return False  #     return True    # def check_lawn(lawn, N, M):  #     heights_dict = {i: False for i in xrange(1,101)}  #     for i in xrange(N):  #         for j in xrange(M):  #             heights_dict[lawn[i][j]] = True    #     heights = [key for key in sorted(heights_dict.keys()) if heights_dict[key]]  #     if len(heights) == 1:  #         return YES  #     levels = {height: [] for height in heights}    #     for i in xrange(N):  #         for j in xrange(M):  #             levels[lawn[i][j]].append((i, j))    #     was = {  #         "row": set()  #         "col": set()  #     }    #     for i, height in enumerate(heights[:-1]):  #         if not check_height(lawn, N, M, height, was, levels):  #             return NO    #     return YES    def check_lawn(lawn, N, M):      row_maxs = [0 for _ in xrange(N)]      col_maxs = [0 for _ in xrange(M)]        for i in xrange(N):          cmax = -1          for j in xrange(M):              if lawn[i][j] > cmax:                  cmax = lawn[i][j]          row_maxs[i] = cmax        for j in xrange(M):          cmax = -1          for i in xrange(N):              if lawn[i][j] > cmax:                  cmax = lawn[i][j]          col_maxs[j] = cmax        for i in xrange(N):          for j in xrange(M):              if row_maxs[i] > lawn[i][j] and col_maxs[j] > lawn[i][j]:                  return NO        return YES      T = int(raw_input().strip())  for i in xrange(T):      N, M = map(int, raw_input().strip().split(' '))      lawn = [[] for j in xrange(N)]      for j in xrange(N):          lawn[j] = map(int, raw_input().strip().split(' '))      print "Case #%s: %s" % (i + 1, messages[check_lawn(lawn, N, M)])  <CODESPLIT> 41
T = int(raw_input().strip())    for i in xrange(T):  	C, F, X = map(float, raw_input().strip().split(' '))  	best = X / 2.0  	c_sum = 0  	factories = 1  	n_sum = c_sum + C / (2.0 + (factories - 1) * F)  	while n_sum + X / (2.0 + factories * F) < best:  		best = n_sum + X / (2.0 + factories * F)  		c_sum = n_sum  		factories += 1  		n_sum = c_sum + C / (2.0 + (factories - 1) * F)    	print "Case #%s: %s" % (i + 1, best)  <CODESPLIT> 41
T = int(raw_input().strip())    for j in xrange(T):  	row_num1 = int(raw_input().strip())  	for i in xrange(4):  		if i + 1 == row_num1:  			row1 = set(map(int, raw_input().strip().split(' ')))  		else:  			raw_input()  	row_num2 = int(raw_input().strip())  	for i in xrange(4):  		if i + 1 == row_num2:  			row2 = set(map(int, raw_input().strip().split(' ')))  		else:  			raw_input()  	common = row1 & row2  	lc = len(common)  	if lc == 1:  		stuff = list(common)[0]  	elif lc > 1:  		stuff = "Bad magician!"  	else:  		stuff = "Volunteer cheated!"    	print "Case #%s: %s" % (j + 1, stuff)  <CODESPLIT> 41
from sys import argv    mapping = { "a": "y", "c": "e", "b": "h", "e": "o", "d": "s", "g": "v", "f": "c", "i": "d", "h": "x", "k": "i", "j": "u", "m": "l", "l": "g", "o": "k", "n": "b", "p": "r", "s": "n", "r": "t", "u": "j", "t": "w", "w": "f", "v": "p", "y": "a", "x": "m", "q": "z", "z": "q"}    def translator(s):  	ret = []  	for c in s:  		if ord(c) > 96 and ord(c) < 123:  			ret.append(mapping[c])  		else:  			ret.append(c)    	return ''.join(ret)    f = open(argv[1], 'r')  T = int(f.readline().strip('\n'))  for i in range(T):  	line = f.readline().strip('\n')  	print "Case #%s: %s" % (i + 1, translator(line)) <CODESPLIT> 41
X_WON = 0  O_WON = 1  DRAW = 2  NEITHER = 3    messages = [      "X won",      "O won",      "Draw",      "Game has not completed"  ]      def check_win(state):      if state['X'] == 4 or state['X'] == 3 and state['T'] == 1:          return X_WON      elif state['O'] == 4 or state['O'] == 3 and state['T'] == 1:          return O_WON      else:          return -1    def check_state(table):        # Check rows      for i in xrange(4):          state = {'T': 0, 'X': 0, 'O': 0, '.': 0}          for j in xrange(4):              state[table[i][j]] += 1          res = check_win(state)          if res != -1:              return res        # Check cols      for i in xrange(4):          state = {'T': 0, 'X': 0, 'O': 0, '.': 0}          for j in xrange(4):              state[table[j][i]] += 1          res = check_win(state)          if res != -1:              return res        # Check diags      # Normal      state = {'T': 0, 'X': 0, 'O': 0, '.': 0}      for i in xrange(4):          state[table[i][i]] +=  1      res = check_win(state)      if res != -1:          return res        # Cross      state = {'T': 0, 'X': 0, 'O': 0, '.': 0}      for i in xrange(4):          state[table[i][3 - i]] +=  1      res = check_win(state)      if res != -1:          return res        # Check not full      for i in xrange(4):          for j in xrange(4):              if table[i][j] == '.':                  return NEITHER        # It's a draw      return DRAW    T = int(raw_input().strip())  for i in xrange(T):      table = [[] for _ in xrange(4)]      for j in xrange(4):          table[j] = list(raw_input().strip())      # print "table: %s" % table      if i != T - 1:          raw_input()      print "Case #%s: %s" % (i + 1, messages[check_state(table)]) <CODESPLIT> 41
T = int(raw_input().strip())  misses = set()    for i in xrange(T):  	R, C, M = map(int, raw_input().strip().split(' '))  	F = R * C - M  	# print "F: %s, R: %s, C: %s, M: %s" % (F, R, C, M)  	impossible = False  	if F == 1:  		matrix = ["c" + "*" * (C - 1)]  		for _ in xrange(R - 1):  			matrix.append("*" * C)  	elif R == 1:  		matrix = ["c" + "." * (F - 1) + "*" * (C - F)]  	elif C == 1:  		matrix = ["c"]  		for _ in xrange(F - 1):  			matrix.append(".")  		for _ in xrange(R - F):  			matrix.append("*")  	elif R == 2:  		if F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):  			matrix = [  				"c" + "." * (F / 2 - 1) + "*" * (C - F / 2),	  				"." * (F / 2) + "*" * (C - F / 2)  			]  		else:  			matrix = []  			impossible = True  	else:  		stack = []  		matrix = []  		for j in xrange(C, 1, -1):  			if F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:  				stack.append([j, j])    		while stack:  			# print "stack: %s" % stack  			elems = stack.pop()  			se = sum(elems)  			if se == F:  				for count in elems:  					matrix.append("." * count + "*" * (C - count))  				for _ in xrange(R - len(elems)):  					matrix.append("*" * C)  				matrix[0] = "c" + matrix[0][1:]  				break  			elif len(elems) < R:  				for j in xrange(elems[-1], 1, -1):  					if F - se - j >= 0 and (R - len(elems)) * j >= F - se:  						stack.append(elems[::] + [j])    		if matrix == []:  			impossible =True    	print "Case #%s:" % (i + 1)  	if impossible:  		print "Impossible"  	else:  		for row in matrix:  			print row  <CODESPLIT> 41
from sys import argv  from math import floor, log10    def grab2(x):  	if x < 2:  		return 0  	return x * (x - 1) / 2    def solve(low, high):  	was = [0 for i in range(low, high + 1)]  	total = 0    	for i in xrange(low, high + 1):  		if was[i - low] == 0:  			was[i - low] = 1  			variations = set([i])  			  			if global_variations[i] != []:  				for j in global_variations[i]:  					if j >= low and j <= high:  						was[j - low] = 1  						variations.add(j)  			else:  				curr = i  				clen = int(floor(log10(i)))  				pow10 = pow(10, clen)  				cgvariations = set(list(variations))  				for i in range(clen):  					pre = curr % 10  					curr = pow10 * pre + (curr - (curr % 10)) / 10  					if pre != 0 and curr not in variations and curr >= low and curr <= high:  						variations.add(curr)  						was[curr - low] = 1  					if pre != 0 and curr < ma and curr not in cgvariations:  						cgvariations.add(curr)    				for cg in cgvariations:  					global_variations[cg] = list(cgvariations)    			total += grab2(len(variations))      	return total    f = open(argv[1], 'r')  T = int(f.readline().strip('\n'))  mi = 2000000  ma = 1  ab = []  for i in range(T):  	ab.append(map(int, f.readline().strip('\n').split(' ')))  	if ab[-1][1] > ma:  		ma = ab[-1][1]    global_variations = [[] for i in range(ma + 2)]    i = 1  for x in ab:  	print "Case #%s: %s" % (i, solve(x[0],x[1]))  	i += 1 <CODESPLIT> 41
#!/usr/bin/python    import sys  import math  import copy    f = open(sys.argv[1],'r')    num = int(f.readline())    def pal(x):      l = list(str(x))      l2 = copy.copy(l)      l2.reverse()      return l == l2    for i in range(num):      count = 0      line = f.readline()      a,b = line.split()      a = int(a)      b = int(b)      ma = int(math.sqrt(a))      mb = int(math.sqrt(b))+1      #print a,b      for j in range(ma,mb+1):          q = j*j          if q < a or q > b:              continue          #print i*i          if pal(j) and pal(q):              #print i,q              count += 1      print 'Case #{}:'.format(i+1), count  <CODESPLIT> 42
#!/usr/bin/python    import sys  import re  import math    f = open(sys.argv[1],'r')    num = int(f.readline())    for i in range(num):      res = [int(x) for x in f.readline().split()]      nrg, nrsup, score = res[0:3]      del res[0:3]      #print nrg, nrsup, score, res      nrpass = 0      nrsuppass = 0      for x in res:          if score > 1:              if x >= 3*score-2:                  nrpass += 1              elif x >= 3*score-4:                  nrsuppass += 1          elif score == 1:              if x > 0:                  nrpass += 1          else:              nrpass +=1      print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)  <CODESPLIT> 42
#!/usr/bin/python    import sys  import re  import math  import string    f = open(sys.argv[1],'r')    num = int(f.readline())    for i in range(num):      f.readline()      na = [float(x) for x in f.readline().split()]      ke = [float(x) for x in f.readline().split()]      na.sort()      ke.sort()      dw = 0      index = 0      for x in ke:          while index < len(na) and na[index] <= x:              index += 1          if index == len(na):              break          dw += 1          index += 1      w = 0      index = 0      na.reverse()      ke.reverse()      for x in na:          if ke[index] > x:              index += 1          else:              w += 1      print 'Case #{}: {} {}'.format(i+1, dw, w)  <CODESPLIT> 42
#!/usr/bin/python    import sys  import math  import copy  import operator    f = open(sys.argv[1],'r')    num = int(f.readline())    for i in range(num):      l = f.readline()      n,m = l.split()      n = int(n)      m = int(m)      lawn = []      seen = []      for j in range(n):          l = f.readline()          lawn.append([int(x) for x in l.split()])          seen.append([False]*m)      #print lawn      l = []      for j in range(n):          for k in range(m):              l.append((lawn[j][k], (j,k)))      l.sort(key=operator.itemgetter(0))      #print l      ok = True      for x in l:          if seen[x[1][0]][x[1][1]]:              continue          row = True          for j in range(n):              if not (seen[j][x[1][1]] or lawn[j][x[1][1]] <= lawn[x[1][0]][x[1][1]]):                  row = False                  break          if(row):              for j in range(n):                  seen[j][x[1][1]] = True              continue          col = True          for j in range(m):              if not (seen[x[1][0]][j] or lawn[x[1][0]][j] <= lawn[x[1][0]][x[1][1]]):                  col = False                  break          if(col):              for j in range(m):                  seen[x[1][0]][j] = True              continue          ok = False          break      if ok:          print 'Case #{}: YES'.format(i+1)      else:          print 'Case #{}: NO'.format(i+1)  <CODESPLIT> 42
#!/usr/bin/python    import sys  import re  import math  import string    f = open(sys.argv[1],'r')    num = int(f.readline())    for i in range(num):      c, e, x = [float(x) for x in f.readline().split()]      n = int((x*e-2*c)/(c*e))      if n < 0:          n = 0      t = 0      for j in range(n):          t += c/(2+j*e)      t += x/(2+n*e)      print 'Case #{}: {}'.format(i+1, t)  <CODESPLIT> 42
#!/usr/bin/python    import sys  import re  import math  import string    f = open(sys.argv[1],'r')    num = int(f.readline())    for i in range(num):      q1 = int(f.readline())      for j in range(4):          if j+1 == q1:              line1 = f.readline()          else:              f.readline()      q2 = int(f.readline())      for j in range(4):          if j+1 == q2:              line2 = f.readline()          else:              f.readline()      line1 = [int(x) for x in line1.split()]      line2 = [int(x) for x in line2.split()]      count = 0      for x in line1:          if x in line2:              count += 1              y = x      if count == 0:          print 'Case #{}: Volunteer cheated!'.format(i+1)      elif count == 1:          print 'Case #{}: {}'.format(i+1, y)      else:          print 'Case #{}: Bad magician!'.format(i+1)  <CODESPLIT> 42
#!/usr/bin/python    import sys  import re  import math  import string    f = open(sys.argv[1],'r')    num = int(f.readline())    for i in range(num):      s = f.readline().strip()      t = s.translate(string.maketrans("yeqjpmslckdxvnribtahwfougz",          "aozurlngeismpbtdhwyxfckjvq"))      #print 'Case #{}:'.format(i+1), s      print 'Case #{}:'.format(i+1), t  <CODESPLIT> 42
#!/usr/bin/python    import sys  import re  import math  import string    f = open(sys.argv[1],'r')    num = int(f.readline())    def check(x, mat):      for i in range(4):          row = True          col = True          for j in range(4):              if not (mat[i][j] == x or mat[i][j] == 'T'):                  row = False              if not (mat[j][i] == x or mat[j][i] == 'T'):                  col = False          if row or col:              return True      diag1 = True      diag2 = True      for i in range(4):          if not (mat[i][i] == x or mat[i][i] == 'T'):              diag1 = False          if not (mat[3-i][i] == x or mat[3-i][i] == 'T'):              diag2 = False      if diag1 or diag2:          return True      return False    def fin(mat):      for i in range(4):          for j in range(4):              if mat[i][j] == '.':                  return False      return True    for i in range(num):      mat = []      for j in range(4):          mat.append(list(f.readline().strip()))      f.readline()      #print mat      #print check('X', mat), check('O', mat)      if check('X', mat):          print 'Case #{}: X won'.format(i+1)      elif check('O', mat):          print 'Case #{}: O won'.format(i+1)      elif fin(mat):          print 'Case #{}: Draw'.format(i+1)      else:          print 'Case #{}: Game has not completed'.format(i+1)  <CODESPLIT> 42
#!/usr/bin/python    import sys  import re  import math  import string    f = open(sys.argv[1],'r')    num = int(f.readline())    def count(z, r, c):      return len(z_and_nei(z,r,c))    def nei(z, r, c):      s = z_and_nei(z, r, c)      s -= set(z)      return s    def z_and_nei(z, r, c):      s = set()      for x in z:          s.add(x)          s.add((x[0]-1,x[1]-1))          s.add((x[0]-1,x[1]))          s.add((x[0]-1,x[1]+1))          s.add((x[0],x[1]-1))          s.add((x[0],x[1]+1))          s.add((x[0]+1,x[1]-1))          s.add((x[0]+1,x[1]))          s.add((x[0]+1,x[1]+1))      o = set()      for x in s:          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:              o.add(x)      s-=o      return s    def find_config(z, r, c, t):      if count(z,r,c) == t:          return z      if count(z,r,c) > t:          return []      n = nei(z,r,c)      for x in n:          z.append(x)          if find_config(z,r,c,t) != []:              return z          z.pop()      return []    for i in range(num):      print 'Case #{}:'.format(i+1)      r, c, m = [int(x) for x in f.readline().split()]      if r*c-m == 1:          print 'c' + '*'*(c-1)          for i in range(r-1):              print '*'*c      else:          z = find_config([(0,0)], c, r, c*r-m)          if z == []:              print "Impossible"          else:              s = z_and_nei(z, c, r)              for j in range(r):                  for k in range(c):                      if j == 0 and k == 0:                          print 'c',                      elif (k,j) in s:                          print '.',                      else:                          print '*',                  print      <CODESPLIT> 42
#!/usr/bin/python    import sys  import re  import math    def permute(x, d):      perm = []      for i in range(1,d):          n = x / 10**i          r = x % 10**i          #print 'p', i, n, r          if r >= 10**(i-1):              perm.append(r * 10**(d-i) + n)      perm = list(set(perm))      while x in perm:          perm.remove(x)      return perm    f = open(sys.argv[1],'r')    num = int(f.readline())    for i in range(num):      n1, n2 = [int(x) for x in f.readline().split()]      d = int(math.floor(math.log10(n1))) + 1      rec = 0      for j in range(n1,n2+1):          p = permute(j, d)          #print j,p          rec += sum([1 for x in p if x >= n1 and x <= n2])          #print rec      print 'Case #{}:'.format(i+1), rec/2  <CODESPLIT> 42
import math    def isPalindrome(n) :      return str(n) == str(n)[::-1]    def findPalindrome(n) :      if n % 2 == 0 : return [start*(10**(n/2)) + int(str(start)[::-1]) for start in range(10**(n/2-1),10**(n/2))]      if n == 1 : return range(1,10)      return [start*(10**(n/2)) + int(str(start)[:-1][::-1]) for start in range(10**(n/2),10**((n+1)/2))]    def findPalindromeInRange(a, b) :      num = range(len(str(a)), len(str(b)) + 1)      allPalindrome = []      for n in num : allPalindrome += findPalindrome(n)      return filter(lambda x : a <= x <= b, allPalindrome)    f = open('C-small-attempt0.in', 'r')  g = open('output', 'w')    T = int(f.readline()[:-1])    for case in range(T) :      A, B = map(int, f.readline()[:-1].split())      a = int(math.ceil(A**0.5))      b = int(B**0.5)      res = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(a, b)))      outString = 'Case #' + str(case+1) + ': ' + str(res) + '\n'      print outString[:-1]      g.write(outString)    f.close()  g.close()  <CODESPLIT> 43
fin = open('B-small-attempt0.in', 'r')  fout = open('B-output.txt', 'w')    cases = int(fin.readline()[:-1])    for case in range(cases) :      line = map(int, fin.readline()[:-1].split(' '))      N, S, p = line[:3]      T = line[3:]      okLimit = p + 2*max(p-1,0)      okIfSLimit = p + 2*max(p-2,0)      ok = len(filter(lambda x : x >= okLimit, T))      okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))      res = ok + min(okIfS, S)      # print 'Case #' + str(case+1) + ': ' + str(res)      fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')        fin.close()  fout.close()  <CODESPLIT> 43
f = open('input.in')  g = open('output', 'w')    T = int(f.readline()[:-1])    for case in xrange(T) :      N = int(f.readline()[:-1])      Naomi = sorted(map(float, f.readline()[:-1].split()))      Ken = sorted(map(float, f.readline()[:-1].split()))      Ken2 = Ken[:]      War, DWar = 0, 0      for n in Naomi :          if n > max(Ken) :              Ken.pop(0)              War += 1          else :              for i, k in enumerate(Ken) :                  if k > n : break              Ken.pop(i)      Ken = Ken2      for n in Naomi :          if n < min(Ken) :              Ken.pop(-1)          else :              Ken.pop(0)              DWar += 1      output = 'Case #' + str(case + 1) + ': ' + str(DWar) + ' ' + str(War)      g.write(output + '\n')      print output    f.close()  g.close()  <CODESPLIT> 43
f = open('B-small-attempt0.in', 'r')  g = open('output', 'w')    T = int(f.readline()[:-1])    for case in range(T) :      A = []      N, M = map(int, f.readline()[:-1].split())      for i in range(N) : A.append(map(int, f.readline()[:-1].split()))      for line in A : print line      maxPerRow = map(max, A)      maxPerColumn = map(max, zip(*A))      res = all(A[i][j] in (maxPerRow[i], maxPerColumn[j]) for i in range(N) for j in range(M))      outString = 'Case #' + str(case+1) + ': ' + ('YES' if res else 'NO') + '\n'      print outString[:-1]      g.write(outString)    f.close()  g.close()  <CODESPLIT> 43
f = open('input.in')  g = open('output', 'w')    T = int(f.readline()[:-1])    def tot(n) :      if n == 0 : return X / 2      else :          s = 0          for i in range(0, n) : s += C / (2 + i*F)          return s + X / (2 + n*F)    for case in xrange(T) :      C, F, X = map(float, f.readline()[:-1].split())      N =  int(X/C) + 1      s, e = 0, N      if tot(0) >= tot(1) :           while True :              m = (s+e)/2              if tot(m) <= tot(m-1) and tot(m) <= tot(m+1) : break              elif tot(m-1) <= tot(m) <= tot(m+1) : e = m              elif tot(m-1) >= tot(m) >= tot(m+1) : s = m              else : 1/0      else : m = 0      output = 'Case #' + str(case + 1) + ': ' + str(tot(m))      g.write(output + '\n')      print output    f.close()  g.close()  <CODESPLIT> 43
f = open('input.in')  g = open('output', 'w')    T = int(f.readline()[:-1])    for case in xrange(T) :      a1 = int(f.readline()[:-1])      M1 = [map(int, f.readline()[:-1].split()) for i in range(4)]      a2 = int(f.readline()[:-1])      M2 = [map(int, f.readline()[:-1].split()) for i in range(4)]      r1 = M1[a1-1]      r2 = M2[a2-1]      res = set(r1).intersection(set(r2))      if len(res) == 1 : res = res.pop()      elif len(res) == 0 : res = 'Volunteer cheated!'      else : res = 'Bad magician!'      output = 'Case #' + str(case + 1) + ': ' + str(res)      g.write(output + '\n')      print output    f.close()  g.close()  <CODESPLIT> 43
fin = open('A-small-attempt0.in', 'r')  fout = open('A-output.txt', 'w')    translation = {'y': 'a', 'e': 'o', 'q': 'z'}    knownresults = {      'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',      'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',      'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up'      }    for key in knownresults :      for letter in range(len(key)) :          translation[key[letter]] = knownresults[key][letter]    missingkey = [i for i in translation.values() if i not in translation.keys()][0]  missingvalue = [i for i in translation.keys() if i not in translation.values()][0]    translation[missingkey] = missingvalue    cases = int(fin.readline()[:-1])    for case in range(cases) :      line = fin.readline()[:-1]      res = [translation[line[i]] for i in range(len(line))]      res = ''.join(res)      fout.write('Case #' + str(case+1) + ': ' + res + '\n')        fin.close()  fout.close()  <CODESPLIT> 43
def detectResults() :      for sym in ('X', 'O') :          for line in board :              if all(elem in (sym, 'T') for elem in line) :                  return sym + ' won'          for column in range(4) :              if all(board[i][column] in (sym, 'T') for i in range(4)) :                  return sym + ' won'          if all(board[i][i] in (sym, 'T') for i in range(4)) or all(board[3-i][i] in (sym, 'T') for i in range(4)) :              return sym + ' won'      for sym in ('X', 'O') :          for line in board :              if all(elem in (sym, 'T', '.') for elem in line) :                  return 'Game has not completed'          for column in range(4) :              if all(board[i][column] in (sym, 'T', '.') for i in range(4)) :                  return 'Game has not completed'          if all(board[i][i] in (sym, 'T', '.') for i in range(4)) or all(board[3-i][i] in (sym, 'T', '.') for i in range(4)) :              return 'Game has not completed'      return 'Draw'    f = open('A-small-attempt0.in', 'r')  g = open('output', 'w')    T = int(f.readline()[:-1])    for case in range(T) :      board = []      for i in range(4) : board.append([i for i in f.readline()[:-1]])      outString = 'Case #' + str(case+1) + ': ' + detectResults() + '\n'      print outString[:-1]      g.write(outString)      useless = f.readline()[:-1]    f.close()  g.close()  <CODESPLIT> 43
f = open('input.in')  g = open('output', 'w')    T = int(f.readline()[:-1])    for case in xrange(T) :      R, C, M = map(int, f.readline()[:-1].split())      FREE = R*C - M      if FREE == 0 : res = '\nImpossible'      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\nImpossible'      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\nImpossible'      else :          MAP = [['.' for c in range(C)] for r in range(R)]          MAP[0][0] = 'c'          if R == 1 :              for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'          elif C == 1 :              for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'          elif R == 2 :              for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'              if FREE == 1 : MAP[1][0] = '*'          elif C == 2 :              for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'              if FREE == 1 : MAP[0][1] = '*'          else :              com = M / C              for i in range(R-1, max(R-com-1, 2), -1) :                  MAP[i] = ['*' for j in range(C)]                  M -= C              I = max([i for i, j in enumerate(MAP) if j[0] == '.'])              if I == 2 :                  com = M / 3                  if com == 0 : i = C                  for i in range(C-1, C-com-1, -1) :                      MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'                      M -= 3                  if M >= 1 : MAP[2][i-1] = '*'                  if M >= 2 :                      if i != 1 : MAP[2][i-2] = '*'                      else : MAP[1][0] = '*'              else :                  for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'                  if i == 1 :                      MAP[I][i] = '.'                      MAP[I-1][C-1] = '*'          res = '\n' + '\n'.join([''.join(i) for i in MAP])      output = 'Case #' + str(case + 1) + ': ' + str(res)      g.write(output + '\n')      print output    f.close()  g.close()  <CODESPLIT> 43
fin = open('C-small-attempt0.in', 'r')  fout = open('C-output.txt', 'w')    cases = int(fin.readline()[:-1])    for case in range(cases) :      A, B = map(int, fin.readline()[:-1].split(' '))      digits = len(str(A))      couples = set()      for n in range(A,B+1) :          for t in range(1,digits) :              m = [str(n)[(i+t)%digits] for i in range(digits)]              m = int(''.join(m))              if A <= n < m <= B :                  couples.add(str([n,m]))      res = len(couples)      print 'Case #' + str(case+1) + ': ' + str(res)      fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')        fin.close()  fout.close()  <CODESPLIT> 43
import itertools, sys, os  from itertools import *  import time, heapq    def pal(s):      for i in xrange(len(s)/2):          if s[i] != s[-i-1]:              return False      return True    def pal2(x, s):      return pal(s) and pal(str(x*x))    def E(k):      return 10**k      def CREATE_DATABASE(MAX):      def init():          yield 1          yield 2          yield 3          yield 11          yield 22          for i in xrange(1, MAX):              yield 1*E(2*i) + 1              yield 1*E(2*i+1) + 1              #yield 1*E(2*i + 1) + 1              #yield 1*E(2*i) + 1 + 2*E(i)              yield 2*E(2*i) + 2              yield 2*E(2*i) + 2 + 1*E(i)              yield 2*E(2*i+1) + 2                                  heap = list(sorted(set(init())))      for i in heap:          print i      heapq.heapify(heap)      RES = []      try:          MAX_X = E(MAX)          print "MAX_X", MAX_X          while True:              x = heapq.heappop(heap)              #print x              RES.append(x)              if x == 3:                  continue              if x > MAX_X:                  break              s = str(x)              j = len(s) / 2              shift = 1 if len(s) == 2*j else 0              for i in xrange(j+1, MAX):                  n = E(2*i-shift) + 1 + E(i-j) * x                  if pal2(n,str(n)):                      #print ("{:^%i} => {:^%i}" % (2*MAX, 2*MAX)).format(x, n)                      heapq.heappush(heap, n)                        except KeyboardInterrupt:          print "stopped while x is", x      with open("c.database", 'w') as f:          for i in sorted(RES + heap):              f.write("%i\n"%i)    def READ_DATABASE():      with open("c.database", 'r') as f:          return sorted(map(lambda x: int(x.strip())**2, f))  DB = READ_DATABASE()    from bisect import bisect_left, bisect_right  def CASE(IN):      def rstr(): return IN.readline().strip()      def rint(): return int(rstr())      def rints(): return map(int, rstr().split())      def nrints(N): return [rints() for i in xrange(N)]      A, B = rints()      i = bisect_left(DB, A)       j = bisect_right(DB, B)      return j-i    def RUN(IN, OUT):      t = int(IN.readline().strip())      for i in xrange(1,t+1):          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))    if __name__ == "__main__":      # CREATE_DATABASE(52)      import sys      RUN(sys.stdin, sys.stdout)  <CODESPLIT> 44
#!/usr/bin/env python      import cPickle    D1 = {} # no suprize  D2 = {} # surprize  for i in xrange(0, 31):      D1[i] = D2[i] = -1    def precompute():      for a in xrange(0, 11):          for b in xrange(a, min(a+3,11)):              for c in xrange(b, min(a+3,11)):                  t = a+b+c                  assert a <= b <= c <= a+2 and c <= 11                  if c < a+2:                      D1[t] = max(D1[t], c)                  else: # that is, c == a+2, we have a suprize                      D2[t] = max(D2[t], c)    #    for k in D1:  #        print k, D2[k] - D1[k]    precompute()  #import cPickle  #with open("prec","wb") as f:  #    cPickle.dump((D1, D2), f )  #print D1, D2    def case(S, P, ts):      res_n = 0      res_s = 0      for t in ts:          if D1[t] >= P:              res_n+=1          elif D2[t]>=P:              res_s+=1      return (res_n + min(res_s, S))      def solve(fin, fout):      T = int(fin.readline())      for t in xrange(T):          nums = map(int, fin.readline().strip().split(" "))          N, S, P = nums[:3]          ts = nums[3:]          assert len(ts) == N              fout.write("Case #%i: %i\n" % (t+1, case(S,P,ts)) )      return True    if __name__ == "__main__":      import sys      with open(sys.argv[1],'r') as fin:          with open(sys.argv[2], 'w') as fout:              solve(fin, fout)  <CODESPLIT> 44
def CASE(IN):      def rstr(): return IN.readline().strip()      def rint(): return int(rstr())      def rfs(): return map(float, rstr().split())      N = rint()      A = sorted(rfs())      B = sorted(rfs())      dwar = solve(N, A, B)      war = N - solve(N, B, A)      return "%i %i" % (dwar, war)      def solve(N, A, B):      i, j = 0, 0      while True:          while j < N and A[j] < B[i]:              j += 1          if j == N:              return i          i += 1          j += 1      def RUN(IN, OUT):      t = int(IN.readline().strip())      for i in xrange(1,t+1):          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))    if __name__ == "__main__":      import sys      RUN(sys.stdin, sys.stdout)  <CODESPLIT> 44
from itertools import izip    def CASE(IN):      def rstr(): return IN.readline().strip()      def rint(): return int(rstr())      def rints(): return map(int, rstr().split())      def nrints(N): return [rints() for i in xrange(N)]      N, M = rints()      A = nrints(N)      R = [max(row) for row in A]      C = [max(col) for col in izip(*A)]      for i, r in enumerate(R):          for j, c in enumerate(C):              if A[i][j] != min(r,c):                  return "NO"      return "YES"    def RUN(IN, OUT):      t = int(IN.readline().strip())      for i in xrange(1,t+1):          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))    if __name__ == "__main__":      import sys      RUN(sys.stdin, sys.stdout)  <CODESPLIT> 44
def CASE(IN):      def rstr(): return IN.readline().strip()      def rint(): return int(rstr())      def rints(): return map(int, rstr().split())      def rfs(): return map(float, rstr().split())      c, f, x = rfs()      b = 2.0      if x <= c:          return x/b      t = 0      while True:          # we can buy a farm now, should we?          tf = x/(b+f) + c/b          tn = x/b          if tn <= tf:              return t + tn          t += c/b          b += f      def RUN(IN, OUT):      t = int(IN.readline().strip())      for i in xrange(1,t+1):          OUT.write("Case #%i: %.7f\n" % (i, CASE(IN)))    if __name__ == "__main__":      import sys      RUN(sys.stdin, sys.stdout)  <CODESPLIT> 44
def CASE(IN):      def rstr(): return IN.readline().strip()      def rint(): return int(rstr())      def rints(): return map(int, rstr().split())      def rr():          x = rint()          m = [rints() for i in xrange(4)]          return set(m[x-1])      s = rr().intersection(rr())      if not s:          return "Volunteer cheated!"      if len(s) == 1:          return s.pop()      return "Bad magician!"      def RUN(IN, OUT):      t = int(IN.readline().strip())      for i in xrange(1,t+1):          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))    if __name__ == "__main__":      import sys      RUN(sys.stdin, sys.stdout)  <CODESPLIT> 44
#!/usr/bin/env python    IN = """  ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jv"""  OUT ="""  Case #1: our language is impossible to understand  Case #2: there are twenty six factorial possibilities  Case #3: so it is okay if you want to just give up"""    ins = IN.strip().split("\n")  outs = OUT.strip().split("\n")  assert len(ins) == len(outs) == 3    D = {}  D['a'] = 'y'  D['o'] = 'e'  D['z'] = 'q'    for case, s in enumerate(ins):      out = outs[case][9:] # skip "Case #?: "      assert len(out) == len(s)      for i, o in enumerate(out):          if o == ' ': continue          D[s[i]] = o    if len(D) == 25:      chars = map(chr, xrange(97, 123))      key = set(chars).difference( set(D.keys()) ).pop()      value = set(chars).difference( set(D.values()) ).pop()      D[key] = value  assert len(D) == 26  D[' '] = ' '      def solve(fin, fout):      T = int(fin.readline())      for t in xrange(T):          fout.write("Case #%i: " % (t+1) )          for c in fin.readline().strip():              fout.write(D[c])          fout.write('\n')      return True    if __name__ == "__main__":      import sys      with open(sys.argv[1],'r') as fin:          with open(sys.argv[2], 'w') as fout:              solve(fin, fout)  <CODESPLIT> 44
def test_win(M, c):      N = len(M)      def yielder():          for row in M:              yield row, 'row'          for i in xrange(N):              yield [row[i] for row in M], 'col'          yield [M[i][i] for i in xrange(N)], 'd1'          yield [M[i][N-i-1] for i in xrange(N)], 'd2'      for lst, typ in yielder():          if all(l == c or l == 'T' for l in lst):              #print "won at %s %s" % (lst, typ)              return True      return False    def CASE(IN):      def rstr(): return IN.readline().strip()      def rint(): return int(rstr())      def rints(): return map(int, rstr().split())      M = [rstr() for i in xrange(4)]      rstr()      #print M      if test_win(M, 'X'):          return 'X won'      if test_win(M, 'O'):          return 'O won'      if any('.' in row for row in M):          return 'Game has not completed'      return 'Draw'    def RUN(IN, OUT):      t = int(IN.readline().strip())      for i in xrange(1,t+1):          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))    if __name__ == "__main__":      import sys      RUN(sys.stdin, sys.stdout)  <CODESPLIT> 44
def get_a(r, c, f='.'):      A = []      for i in xrange(r):          A.append([f] * c)      return A      def apply(A, r, c, B):      for i, b in enumerate(B):          for j, v in enumerate(b):              A[r + i][c + j] = v      def draw(A):      if A is None:          return '\nImpossible'      res = ['']      for a in A:          res.append(''.join(a))      return '\n'.join(res)      def trans(A):      if not A:          return None      B = get_a(len(A[0]), len(A))      for i, a in enumerate(A):          for j, v in enumerate(a):              B[j][i] = v      return B      def check(A, m, r, c):      if A is None:          return True      cnts = {'c': 0, '*': 0, '.': 0}      #print draw(A)      #print        assert len(A) == r      for i in xrange(r):          assert len(A[i]) == c          for j in xrange(c):              cnts[A[i][j]] += 1      #print m, r, c, "=>", cnts      assert cnts['*'] == m      assert cnts['c'] == 1      assert cnts['.'] == r * c - m - 1      def CASE(IN):      def rstr():          return IN.readline().strip()        def rint():          return int(rstr())        def rints():          return map(int, rstr().split())      r, c, m = rints()      A = solve(m, r, c)      if A:          A[-1][-1] = 'c'      check(A, m, r, c)      return draw(A)      def solve(m, r, c):      if r > c:          return trans(solve(m, c, r))      assert r <= c      assert m != r * c      e = r * c - m      # we click always in the right bottom corner      if e == 1:          A = get_a(r, c, '*')          return A      if r == 1:          A = get_a(1, c, '.')          for i in xrange(m):              A[0][i] = '*'          return A      if r == 2:          if e == 2 or e % 2 == 1:              return None          A = get_a(2, c, '.')          assert m % 2 == 0          for i in xrange(m / 2):              A[0][i] = A[1][i] = '*'          return A      assert r >= 3      A = get_a(r, c, '*')      if e in (2, 3, 5, 7):          return None      E = [c] * (e / c) + ([e % c] if e % c else [])      if sum(E) < e:          E.append(e % c)          assert sum(E) == e      if len(E) == 1:          E = [e / 2] * 2          if sum(E) < e:              e.append(1)      if E[0] != E[1]:          s = sum(E[:2])          E[0] = E[1] = s / 2          if sum(E[:2]) != s:              assert len(E) == 2              E.append(1)      if E[-1] == 1:          if len(E) > 3:              E[-2] -= 1              E[-1] += 1          else:              E[0] -= 1              E[1] -= 1              E[2] += 2      for i in xrange(len(E)):          for j in xrange(E[i]):              A[-i - 1][-j - 1] = '.'      return A      def RUN(IN, OUT):      t = int(IN.readline().strip())      for i in xrange(1, t + 1):          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))    if __name__ == "__main__":      import sys      RUN(sys.stdin, sys.stdout)  <CODESPLIT> 44
#!/usr/bin/env python  import cPickle, time  F = {}  # to compute F:  def f(x, _x, _min, _max):      if x < 10:           #raise StopIteration          return set()      l = len(str(x)) -1      k = 10**l      res = set()      res.add(_x)      for i in xrange(l):          x = (x % 10) * k + x/10          if _min <= x <= _max and _x < x:              res.add(x)      res.remove(_x)      if res:          #print _x, "=>", res          F[_x] = sorted(res)      return res    def compute_F(B):      for i in xrange(0, B+1):          f(i,i, 0, B+1)      with open("picle",'wb') as _file:          cPickle.dump( F, _file)    #print "start", time.time()  #compute_F(2000000)  #print "end  ", time.time()      t_start = time.time()  print "loading..."  with open("picle",'rb') as _file:      F = cPickle.load(_file)  print "done in %.2fs" % (time.time() - t_start)  print "loaded F with %i keys" % len(F)    def case(A, B):      print "XXXXXXXXX ", A, B      res = 0      res2 = 0      for i in xrange(A, B):          l = F.get(i, [])          #l = sorted(f(i,i,A,B))          #res += len(l)          #l1 = sorted(F.get(i,[]))          #if l != l1:          #    print i, l, l1            for x in l:             if x <= B:                 res += 1      return res    def solve(fin, fout):      T = int(fin.readline())      for t in xrange(T):          A, B = map(int, fin.readline().strip().split(" "))          assert A <= B          fout.write("Case #%i: %i\n" % (t+1, case(A,B)) )      return True    if __name__ == "__main__":      import sys      with open(sys.argv[1],'r') as fin:          with open(sys.argv[2], 'w') as fout:              solve(fin, fout)  <CODESPLIT> 44
import math    def ss(t, amap, bmap):      s = 0      for m in amap:          if len(m) == 1 and t == m.keys()[0]:              s += m[t]              for b in bmap:                  if t in b:                      b[t] -= 1                      if b[t] == 0:                          b.pop(t)              m.clear()      return s                 def solve(case, in_lines):      out = 'Case #%d: '%case         rn, cn = [int(x) for x in in_lines[0].split()]      mtx = []      for i in xrange(rn):          mtx.append([int(x) for x in in_lines[i+1].split()])      rmap = [{} for x in xrange(rn)]      cmap = [{} for x in xrange(cn)]      td = {}            for i in xrange(rn):          for j in range(cn):              k = mtx[i][j]              if k in rmap[i]:                  rmap[i][k] += 1              else:                  rmap[i][k] = 1              if k in cmap[j]:                  cmap[j][k] += 1              else:                  cmap[j][k] = 1              if k in td:                  td[k] += 1              else:                  td[k] = 1                        while len(td):          k = min(td.keys())          sb = ss(k, rmap, cmap)          sb += ss(k, cmap, rmap)          if sb == 0:              break;          td[k] -= sb          if td[k] == 0:              td.pop(k)        return out + ('YES' if sb else 'NO')      def main(raw):      lines = raw.split('\n')      n = int(lines[0])      ln = 1      outs = []      for case in xrange(1, n+1):          buff = []          cl = int(lines[ln].split()[0]) + ln + 1          while ln < cl and lines[ln]:              buff.append(lines[ln])              ln += 1          s = solve(case, buff)          print s          outs.append(s)      return '\n'.join(outs)      pass    if __name__ == '__main__':      test_input = """4  4 3  2 5 2  1 1 1  2 4 2  2 3 2  3 3  2 1 2  1 1 1  2 1 2  5 5  2 2 2 2 2  2 1 1 1 2  2 1 2 1 2  2 1 1 1 2  2 2 2 2 2  1 3  1 2 1"""      force_no_file = False      in_file_name = '' if force_no_file else 'B-large.in'      base_path = 'G:/workspace/py/codejam2013/RQ/'      if in_file_name:          with open(base_path + in_file_name) as f:              raw = f.read()      else:          raw = test_input      out = main(raw)      if in_file_name:          with open(base_path + in_file_name + '.out', 'w') as f:              f.write(out)      pass <CODESPLIT> 45
#! /usr/bin/env python  #coding=utf-8    def solve(icase, case_input):      case_output = 'Case #%i: '%icase            result = 0      raw = [int(x) for x in case_input[0].split()]      ts = raw[3:]      ct = raw[1]      n = raw[2]      cc = 0      for i in ts:          if i > 3*n-3:              result += 1          elif i > max(3*n-5, 0):              cc += 1      result += min(cc, ct)        case_output += '%d'%result            return case_output      def main():      global use_test_data      global test_data      global input_file      global output_file            if use_test_data:          data = [x.strip() for x in test_data.split('\n')]      else:          data = [x.strip() for x in input_file.readlines()]            T = int(data[0])      iLine = 1      caseLineNum = 1      for icase in range(1, T + 1):          input = []          for i in range(caseLineNum):              input.append(data[iLine])              iLine += 1          rslt = solve(icase, input)          print rslt          if not use_test_data:              print >> output_file, rslt            if not use_test_data:          input_file.close()          output_file.close()              if __name__ == '__main__':      test_data = """4  3 1 5 15 13 11  3 0 8 23 22 21  2 1 1 8 0  6 2 8 29 20 8 18 18 21  """      use_test_data = False            test_file = 'B-small-attempt0.in'      if not use_test_data and '' != test_file:          input_file = open(test_file)          output_file = open(test_file + '.out', 'w')            main() <CODESPLIT> 45
import os  import bisect    class Solver(object):      def __init__(self):          pass            def solve(self, inputs):          nn = [float(x) for x in inputs[1].split()]          nn.sort()          kk = [float(x) for x in inputs[2].split()]          kk.sort()          dw = self.dwar(nn[:], kk[:])          w = self.war(nn[:], kk[:])          return '%d %d'%(dw, w)          pass            def dwar(self, nn, kk):          turn = len(nn)          cnt = 0          for i in range(turn):              i = i              if nn[-1] < kk[-1]:                  nn.pop(0)                  kk.pop(-1)              elif nn[0] < kk[0]:                  nn.pop(0)                  kk.pop(-1)              else:                  cnt += 1                  nn.pop(0)                  kk.pop(0)          return cnt            def war(self, nn, kk):          turn = len(nn)          cnt = 0          for i in range(turn):              i = i              j = bisect.bisect_left(kk, nn[0])              if j == len(kk):                  cnt += 1                  kk.pop(0)              else:                  kk.pop(j)              nn.pop(0)          return cnt            def feed(self, inputs):          lines = [x.strip() for x in inputs]          outputs = []          test_case_n = int(lines[0])          cur = 1          for i in range(test_case_n):              i = i              case_line_cnt = 3              case_inputs = lines[cur:cur+case_line_cnt]              cur += case_line_cnt              outputs.append(self.solve(case_inputs))          return outputs    if __name__ == '__main__':      iname = 'D-small-attempt0.in'  #     iname = 'foo'      sample_in = '''  4  1  0.5  0.6  2  0.7 0.2  0.8 0.3  3  0.5 0.1 0.9  0.6 0.4 0.3  9  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458      '''      sample_out = '''  Case #1: 0 0  Case #2: 1 0  Case #3: 2 1  Case #4: 8 4      '''      if os.path.exists(iname):          with open(iname) as f:              inputs = f.readlines()      else:          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]      solver = Solver()      outputs = solver.feed(inputs)      fail_flag = False      if os.path.exists(iname):          with open(iname+'.out', 'w') as f:              for i, v in enumerate(outputs):                  print >> f, 'Case #%d: %s'%(i+1, str(v))      else:          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])          for i, v in enumerate(outputs):              t = 'Case #%d: %s'%(i+1, str(v))              if t not in ans:                  print '!!! Wrong:', t                  fail_flag = True      print '===================================================='      for i, v in enumerate(outputs):          print 'Case #%d: %s'%(i+1, str(v))      print '===================================================='      print 'done' if not fail_flag else 'fail'      pass <CODESPLIT> 45
import math    def ss(t, amap, bmap):      s = 0      for m in amap:          if len(m) == 1 and t == m.keys()[0]:              s += m[t]              for b in bmap:                  if t in b:                      b[t] -= 1                      if b[t] == 0:                          b.pop(t)              m.clear()      return s                 def solve(case, in_lines):      out = 'Case #%d: '%case         rn, cn = [int(x) for x in in_lines[0].split()]      mtx = []      for i in xrange(rn):          mtx.append([int(x) for x in in_lines[i+1].split()])      rmap = [{} for x in xrange(rn)]      cmap = [{} for x in xrange(cn)]      td = {}            for i in xrange(rn):          for j in range(cn):              k = mtx[i][j]              if k in rmap[i]:                  rmap[i][k] += 1              else:                  rmap[i][k] = 1              if k in cmap[j]:                  cmap[j][k] += 1              else:                  cmap[j][k] = 1              if k in td:                  td[k] += 1              else:                  td[k] = 1                        while len(td):          k = min(td.keys())          sb = ss(k, rmap, cmap)          sb += ss(k, cmap, rmap)          if sb == 0:              break;          td[k] -= sb          if td[k] == 0:              td.pop(k)        return out + ('YES' if sb else 'NO')      def main(raw):      lines = raw.split('\n')      n = int(lines[0])      ln = 1      outs = []      for case in xrange(1, n+1):          buff = []          cl = int(lines[ln].split()[0]) + ln + 1          while ln < cl and lines[ln]:              buff.append(lines[ln])              ln += 1          s = solve(case, buff)          print s          outs.append(s)      return '\n'.join(outs)      pass    if __name__ == '__main__':      test_input = """4  4 3  2 5 2  1 1 1  2 4 2  2 3 2  3 3  2 1 2  1 1 1  2 1 2  5 5  2 2 2 2 2  2 1 1 1 2  2 1 2 1 2  2 1 1 1 2  2 2 2 2 2  1 3  1 2 1"""      force_no_file = False      in_file_name = '' if force_no_file else 'B-small-attempt0.in'      base_path = 'G:/workspace/py/codejam2013/RQ/'      if in_file_name:          with open(base_path + in_file_name) as f:              raw = f.read()      else:          raw = test_input      out = main(raw)      if in_file_name:          with open(base_path + in_file_name + '.out', 'w') as f:              f.write(out)      pass <CODESPLIT> 45
import os  import math    class Solver(object):      def __init__(self):          pass            def solve(self, inputs):          c, f, x = [float(t) for t in inputs[0].split()]          if x <= c:              return '%.7f'%(x/2)          ii = int(math.ceil((f*x-2*c)/(f*c)-1))          if ii <= 0:              return '%.7f'%(x/2)          t = 0          for i in range(ii):              t += c/(2+i*f)          t += x/(2+ii*f)          return '%.7f'%t          pass            def feed(self, inputs):          lines = [x.strip() for x in inputs]          outputs = []          test_case_n = int(lines[0])          cur = 1          for i in range(test_case_n):              i = i              case_line_cnt = 1              case_inputs = lines[cur:cur+case_line_cnt]              cur += case_line_cnt              outputs.append(self.solve(case_inputs))          return outputs    if __name__ == '__main__':      iname = 'B-small-attempt0.in'  #     iname = 'foo'      sample_in = '''      4  30.0 1.0 2.0  30.0 2.0 100.0  30.50000 3.14159 1999.19990  500.0 4.0 2000.0      '''      sample_out = '''  Case #1: 1.0000000  Case #2: 39.1666667  Case #3: 63.9680013  Case #4: 526.1904762      '''      if os.path.exists(iname):          with open(iname) as f:              inputs = f.readlines()      else:          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]      solver = Solver()      outputs = solver.feed(inputs)      fail_flag = False      if os.path.exists(iname):          with open(iname+'.out', 'w') as f:              for i, v in enumerate(outputs):                  print >> f, 'Case #%d: %s'%(i+1, str(v))      else:          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])          for i, v in enumerate(outputs):              t = 'Case #%d: %s'%(i+1, str(v))              if t not in ans:                  print '!!! Wrong:', t                  fail_flag = True      print '===================================================='      for i, v in enumerate(outputs):          print 'Case #%d: %s'%(i+1, str(v))      print '===================================================='      print 'done' if not fail_flag else 'fail'      pass <CODESPLIT> 45
import os    class Solver(object):      def __init__(self):          pass            def solve(self, inputs):          r1 = int(inputs[0])          cs1 = set([int(x) for x in inputs[r1].split()])          r2 = int(inputs[5])          cs2 = set([int(x) for x in inputs[5+r2].split()])          r = cs1.intersection(cs2)          cnt = len(r)          if 1 == cnt:              return max(r)          elif 0 == cnt:              return 'Volunteer cheated!'          else:              return 'Bad magician!'          pass            def feed(self, inputs):          lines = [x.strip() for x in inputs]          outputs = []          test_case_n = int(lines[0])          cur = 1          for i in range(test_case_n):              i = i              case_line_cnt = 10              case_inputs = lines[cur:cur+case_line_cnt]              cur += case_line_cnt              outputs.append(self.solve(case_inputs))          return outputs    if __name__ == '__main__':      iname = 'A-small-attempt0.in'  #     iname = 'foo'      sample_in = '''      3  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  3  1 2 5 4  3 11 6 15  9 10 7 12  13 14 8 16  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  3  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16      '''      sample_out = '''   Case #1: 7  Case #2: Bad magician!  Case #3: Volunteer cheated!      '''      if os.path.exists(iname):          with open(iname) as f:              inputs = f.readlines()      else:          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]      solver = Solver()      outputs = solver.feed(inputs)      fail_flag = False      if os.path.exists(iname):          with open(iname+'.out', 'w') as f:              for i, v in enumerate(outputs):                  print >> f, 'Case #%d: %s'%(i+1, str(v))      else:          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])          for i, v in enumerate(outputs):              t = 'Case #%d: %s'%(i+1, str(v))              if t not in ans:                  print '!!! Wrong:', t                  fail_flag = True      print '===================================================='      for i, v in enumerate(outputs):          print 'Case #%d: %s'%(i+1, str(v))      print '===================================================='      print 'done' if not fail_flag else 'fail'      pass <CODESPLIT> 45
#! /usr/bin/env python  #coding=utf-8    def solve(icase, case_input):      case_output = 'Case #%i: '%icase            result = ""      for c in case_input[0]:          if c in map:              result += map[c]          else:              result += c        case_output += '%s'%result            return case_output      def getmap():      inputs = ["ejp mysljylc kd kxveddknmc re jsicpdrysi",                "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",                "de kr kd eoya kw aej tysr re ujdr lkgc jv"]      outputs = ["our language is impossible to understand",                 "there are twenty six factorial possibilities",                 "so it is okay if you want to just give up"]      map = {}      for case in xrange(3):          for i, c in enumerate(inputs[case]):              map[c] = outputs[case][i]            map['q'] = 'z'      map['z'] = 'q'            print map      print len(map)      for c in "abcdefghijklmnopqrstuvwxyz":          if c not in map:              print c      return map      def main():      global use_test_data      global test_data      global input_file      global output_file            if use_test_data:          data = [x.strip() for x in test_data.split('\n')]      else:          data = [x.strip() for x in input_file.readlines()]            T = int(data[0])      iLine = 1      caseLineNum = 1      for icase in range(1, T + 1):          input = []          for i in range(caseLineNum):              input.append(data[iLine])              iLine += 1          rslt = solve(icase, input)          print rslt          if not use_test_data:              print >> output_file, rslt            if not use_test_data:          input_file.close()          output_file.close()              if __name__ == '__main__':      test_data = """3  ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jv      """      use_test_data = False            map = getmap()            test_file = 'A-small-attempt2.in'      if not use_test_data and '' != test_file:          input_file = open(test_file)          output_file = open(test_file + '.out', 'w')            main() <CODESPLIT> 45
import math    mm = [0xf, 0xf0, 0xf00, 0xf000, 0x8888, 0x4444, 0x2222, 0x1111, 0x8421, 0x1248]    def solve(case, in_lines):      out = 'Case #%d: '%case      s = ''.join(in_lines)      x = 0      o = 0      nc = False      for i in xrange(16):          m = 1 << i          c = s[i]          if c == 'X':              x |= m          elif c == 'O':              o |= m          elif c == 'T':              x |= m              o |= m          else:              nc = True      r = ''      for m in mm:          if m & x == m:              r = 'X won'              break          if m & o == m:              r = 'O won'              break      if not r:          if nc:              r = 'Game has not completed'          else:              r = 'Draw'            return out + r      def main(raw):      lines = raw.split('\n')      n = int(lines[0])      ln = 0      outs = []      for case in xrange(1, n+1):          buff = []          ln += 1          while ln < len(lines) and lines[ln]:              buff.append(lines[ln])              ln += 1          s = solve(case, buff)          print s          outs.append(s)      return '\n'.join(outs)      pass    if __name__ == '__main__':      test_input = """6  XXXT  ....  OO..  ....    XOXT  XXOO  OXOX  XXOO    XOX.  OX..  ....  ....    OOXX  OXXX  OX.T  O..O    XXXO  ..O.  .O..  T...    OXXX  XO..  ..O.  ...O"""      force_no_file = False      in_file_name = '' if force_no_file else 'A-small-attempt0.in'      base_path = 'G:/workspace/py/codejam2013/RQ/'      if in_file_name:          with open(base_path + in_file_name) as f:              raw = f.read()      else:          raw = test_input      out = main(raw)      if in_file_name:          with open(base_path + in_file_name + '.out', 'w') as f:              f.write(out)      pass <CODESPLIT> 45
import os    class Solver(object):      def __init__(self):          pass            def solve(self, inputs):          R, C, M = [int(x) for x in inputs[0].split()]          mp = []          for r in range(R):              mp.append(['.']*C)          mp[0][0] = 'c'          outputs = []          if M == 0:              for row in mp:                  outputs.append(''.join(row))              return outputs          rr, cc, rm = R, C, M          while rm >= min(rr, cc):              if rr <= cc:                  for r in range(rr):                      mp[r][cc-1] = '*'                  cc -= 1                  rm -= rr              else:                  for c in range(cc):                      mp[rr-1][c] = '*'                  rr -= 1                  rm -= cc                    if rm == 0:              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:                  return ['Impossible']          else:              if min(rr, cc) - rm >= 2:                  if rr <= cc:                      for r in range(rr-rm, rr):                          mp[r][cc-1] = '*'                  else:                      for c in range(cc-rm, cc):                          mp[rr-1][c] = '*'              else:                  if min(rr, cc) >= 4:                      if rr <= cc:                          for r in range(2, rr):                              mp[r][cc-1] = '*'                          mp[rr-1][cc-2] = '*'                      else:                          for c in range(2, cc):                              mp[rr-1][c] = '*'                          mp[rr-2][cc-1]='*'                  elif min(rr,cc) == 3:                      if max(rr, cc) == 3:                          return ['Impossible']                      else:                          if rr <= cc:                              mp[2][cc-1] = '*'                              mp[2][cc-2] = '*'                          else:                              mp[rr-1][2] = '*'                              mp[rr-2][2] = '*'                  else:                      return ['Impossible']                                for row in mp:              outputs.append(''.join(row))          return outputs          pass            def feed(self, inputs):          lines = [x.strip() for x in inputs]          outputs = []          test_case_n = int(lines[0])          cur = 1          for i in range(test_case_n):              i = i              case_line_cnt = 1              case_inputs = lines[cur:cur+case_line_cnt]              cur += case_line_cnt              R, C, M = [int(x) for x in case_inputs[0].split()]              rslt = self.solve(case_inputs)              if self.verify(rslt, R, C, M):                  outputs.append(rslt)              else:                  raise 'Failed'          return outputs            def verify(self, outputs, RR, CC, MCNT):          if 'Impossible' == outputs[0]:              return True          rr = len(outputs)          cc = len(outputs[0])          if RR != rr or CC != cc:              return False          bd = []          mask = []          for i in range(rr):              mask.append([1]*cc)              bd.append([0]*cc)              for j in range(cc):                  if outputs[i][j] == '*':                      bd[i][j] = 9                  elif outputs[i][j] == 'c':                      start = (i, j)          for r in range(rr):              for c in range(cc):                  if bd[r][c] == 9:                      for i in [r-1,r,r+1]:                          for j in [c-1,c,c+1]:                              if 0 <= i < rr and 0 <= j < cc:                                  if bd[i][j] != 9:                                      bd[i][j] += 1  #         for i, row in enumerate(bd):  #             print i, row            nlist = [start]          while len(nlist):              i, j = nlist.pop(0)              if mask[i][j] != 0:                  mask[i][j] = 0                  if bd[i][j] == 9:                      raise '!!! BOMB'                  elif bd[i][j] == 0:                      for ii in [i-1,i,i+1]:                          for jj in [j-1,j,j+1]:                              if 0<=ii<rr and 0<=jj<cc:                                  if ii != i or jj != j:                                      nlist.append((ii,jj))          mcnt = 0          for r in range(rr):  #             print mask[r]              for c in range(cc):                  if mask[r][c] == 1:                      mcnt += 1                  if mask[r][c] == 1 and bd[r][c] != 9:                      return False                  if mask[r][c] != 1 and bd[r][c] == 9:                      return False          return (mcnt == MCNT)                      if __name__ == '__main__':      iname = 'C-small-attempt0.in'  #     iname = 'foo'      sample_in = '''  7  5 5 23  3 1 1  2 2 1  4 7 3  10 10 82  3 4 0  2 2 3      '''      sample_out = '''  Case #1: 1.0000000  Case #2: 39.1666667  Case #3: 63.9680013  Case #4: 526.1904762      '''      if os.path.exists(iname):          with open(iname) as f:              inputs = f.readlines()      else:          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]      solver = Solver()      outputs = solver.feed(inputs)      fail_flag = False      if os.path.exists(iname):          with open(iname+'.out', 'w') as f:              for i, v in enumerate(outputs):                  print >> f, 'Case #%d:'%(i+1)                  print >> f, '\n'.join(v)      print '===================================================='      for i, v in enumerate(outputs):          print 'Case #%d:'%(i+1)          print '\n'.join(v)      print '===================================================='      print 'done' if not fail_flag else 'fail'      pass <CODESPLIT> 45
#! /usr/bin/env python  #coding=utf-8    def solve(icase, case_input):      case_output = 'Case #%i: '%icase            result = 0      raw = case_input[0].split()      n = len(raw[0])      a = int(raw[0])      b = int(raw[1])            for i in xrange(a, b):          rslt = set()          for t in xrange(1, n):              tt = 10**t              tn = 10**(n-t)              ia, ib = divmod(i, tt)              ii = ib*tn + ia              if ii > i and ii <= b:                  rslt.add(ii)          result += len(rslt)                  case_output += '%d'%result            return case_output      def main():      global use_test_data      global test_data      global input_file      global output_file            if use_test_data:          data = [x.strip() for x in test_data.split('\n')]      else:          data = [x.strip() for x in input_file.readlines()]            T = int(data[0])      iLine = 1      caseLineNum = 1      for icase in range(1, T + 1):          input = []          for i in range(caseLineNum):              input.append(data[iLine])              iLine += 1          rslt = solve(icase, input)          print rslt          if not use_test_data:              print >> output_file, rslt            if not use_test_data:          input_file.close()          output_file.close()              if __name__ == '__main__':      test_data = """5  1 9  10 40  100 500  1111 2222  1000000 2000000  """      use_test_data = False            test_file = 'C-small-attempt0.in'      if not use_test_data and '' != test_file:          input_file = open(test_file)          output_file = open(test_file + '.out', 'w')            main() <CODESPLIT> 45
#!/usr/bin/env python  # -*- coding:utf-8 -*-  #  # Problem C. Fair and Square  # https://code.google.com/codejam/contest/2270488/dashboard#s=p2  #    import sys  import math      def ispalindrome(n):      return str(n) == str(n)[::-1]      def solve(A, B):      solution = []      for n in range(int(math.sqrt(A)), int(math.sqrt(B))+1):          if ispalindrome(n):              m = n ** 2              if ispalindrome(m) and A <= m <= B:                  solution.append(n)      return len(solution)      def main(IN, OUT):      T = int(IN.readline())      for index in range(T):          A, B = map(int, IN.readline().split())          OUT.write('Case #%d: %s\n' % (index + 1, solve(A, B)))      def makesample(T=100, ABmax=1000):      import random      print T      for index in range(T):          A = random.randint(1, ABmax)          B = random.randint(A, ABmax)          print A, B      if __name__ == '__main__':      if '-makesample' in sys.argv[1:]:          makesample()      else:          main(sys.stdin, sys.stdout)    <CODESPLIT> 46
#!/usr/bin/env python  # -*- coding:utf-8 -*-  #  # Problem B. Dancing With the Googlers  # http://code.google.com/codejam/contest/1460488/dashboard#s=p1  #    import sys  import string    #   # t  3   (t/3, t/3, t/3)  # t  3  +1   (t//3 + 1, t//3, t//3)  # t  3  +2   (t//3 + 1, t//3 + 1, t//3)    # surprising   # t  3   (t/3 + 1, t/3, t/3 - 1)  # t  3  +1   (t//3 + 1, t//3 + 1, t//3 - 1)  # t  3  +2   (t//3 + 2, t//3, t//3)      def solve(S, p, tlist):  	#  p   	above = 0  	# surprising   	consider = 0    	for t in tlist:  		avg = t / 3  		mod = t % 3    		if mod == 0:  			# t  3   (t/3, t/3, t/3)  			if avg >= p:  				above += 1  			elif avg + 1 >= p and t > 0:  				# surprising  (t/3 + 1, t/3, t/3 - 1)  				consider += 1    		elif mod == 1:  			# t  3  +1  (t//3+1, t//3, t//3)  			if avg + 1 >= p:  				above += 1  			# surprising  (t//3 + 1, t//3 + 1, t//3 - 1)  			# +1 NOP    		elif mod == 2:  			# t  3  +2  (t//3+1, t//3+1, t//3)  			if avg + 1 >= p:  				above += 1  			elif avg + 2 >= p:  				# surprising  (t//3 + 2, t//3, t//3)  				consider += 1    	return above + min(S, consider)      def main(IN, OUT):  	N = int(IN.readline())  	for index in range(N):  		data = map(int, IN.readline().strip().split())  		(N, S, p), tlist = data[:3], data[3:]  		OUT.write('Case #%d: %d\n' % (index + 1, solve(S, p, tlist)))      if __name__ == '__main__':  	main(sys.stdin, sys.stdout)    <CODESPLIT> 46
#!/usr/bin/env python  # -*- coding:utf-8 -*-  #  # Problem D. Deceitful War  # https://code.google.com/codejam/contest/2974486/dashboard#s=p3  #    import sys      def solve1(naomi, ken):      # Deceitful War      win = 0      while naomi:          chosenK = max(ken)          chosenN = min(filter(lambda mass: mass > chosenK, naomi) or naomi)          if chosenN > chosenK:              win += 1          naomi.remove(chosenN)          ken.remove(chosenK)      return win      def solve2(naomi, ken):      # War      win = 0      while naomi:          chosenN = min(naomi)          chosenK = min(filter(lambda mass: mass > chosenN, ken) or ken)          if chosenN > chosenK:              win += 1          naomi.remove(chosenN)          ken.remove(chosenK)      return win      def main(IN, OUT):      T = int(IN.readline())      for index in range(T):          N = int(IN.readline())          naomi = map(float, IN.readline().split())          ken = map(float, IN.readline().split())          OUT.write('Case #%d: %d %d\n' % (index + 1, solve1(naomi[:], ken[:]), solve2(naomi[:], ken[:])))      def makesample(maxN=1000, T=50):      import random      print T      for index in range(T):          N = random.randint(1, maxN)          print N          print ' '.join(map(str, (random.random() for n in range(N))))          print ' '.join(map(str, (random.random() for n in range(N))))      if __name__ == '__main__':      if '-makesample' in sys.argv[1:]:          makesample()      else:          main(sys.stdin, sys.stdout)    <CODESPLIT> 46
#!/usr/bin/env python  # -*- coding:utf-8 -*-  #  # Problem B. Lawnmower  # https://code.google.com/codejam/contest/2270488/dashboard#s=p1  #    import sys      def solve(board):      vboard = []      for m in range(len(board[0])):          vboard.append([board[n][m] for n in range(len(board))])        for n in range(len(board)):          for m in range(len(board[n])):              h = board[n][m]              if h < max(board[n]) and h < max(vboard[m]):                  return 'NO'      return 'YES'      def main(IN, OUT):      T = int(IN.readline())      for index in range(T):          N, M = map(int, IN.readline().split())          field = [map(int, IN.readline().split()) for n in range(N)]          OUT.write('Case #%d: %s\n' % (index + 1, solve(field)))      def makesample(NMmax=100, amax=100, T=100):      import random      print T      for index in range(T):          N = random.randint(1, NMmax)          M = random.randint(1, NMmax)          print N, M          for n in range(N):              print ' '.join(str(random.randint(1, amax)) for m in range(M))      if __name__ == '__main__':      if '-makesample' in sys.argv[1:]:          makesample()      else:          main(sys.stdin, sys.stdout)    <CODESPLIT> 46
#!/usr/bin/env python  # -*- coding:utf-8 -*-  #  # Problem B. Cookie Clicker Alpha  # https://code.google.com/codejam/contest/2974486/dashboard#s=p1  #    import sys  import itertools      def solve(C, F, X):      def needtime(cookies, farm):          speed = 2.0 + F * farm          return cookies / speed        farm = 0      pasttime = 0      while True:          complete = needtime(X, farm)          nextfarm = needtime(C, farm)          nextchallenge = needtime(X, farm + 1)          if complete <= nextfarm + nextchallenge:              return pasttime + complete          pasttime += nextfarm          farm += 1      def main(IN, OUT):      T = int(IN.readline())      for index in range(T):          C, F, X = map(float, IN.readline().split())          OUT.write('Case #%d: %.7f\n' % (index + 1, solve(C, F, X)))      def makesample(maxC=500, maxF=4, maxX=2000, T=100):      import random      print T      for index in range(T):          print ' '.join('{0}'.format(random.randint(10000, maxvalue * 10000) / 10000.0)                         for maxvalue in (maxC, maxF, maxX))      if __name__ == '__main__':      if '-makesample' in sys.argv[1:]:          makesample()      else:          main(sys.stdin, sys.stdout)    <CODESPLIT> 46
#!/usr/bin/env python  # -*- coding:utf-8 -*-  #  # Problem *.   # https://code.google.com/codejam/contest/***  #    import sys      def solve(arrange):      board, row = arrange[0]      before = board[row - 1]      board, row = arrange[1]      after = board[row - 1]      dup = set(before) & set(after)      if len(dup) == 1:          return dup.pop()      elif len(dup) >= 2:          return 'Bad magician!'      else:          return 'Volunteer cheated!'      def main(IN, OUT):      T = int(IN.readline())      for index in range(T):          arrange = []          for n in range(2):              row = int(IN.readline())              board = []              for line in range(4):                  board.append(map(int, IN.readline().split()))              arrange.append((board, row))          OUT.write('Case #%d: %s\n' % (index + 1, solve(arrange)))      def makesample(T=100):      import random      print T      for index in range(T):          for n in range(2):              print random.randint(1, 4)              board = list(range(1, 16+1))              random.shuffle(board)              while board:                  print ' '.join(map(str, board[:4]))                  board = board[4:]      if __name__ == '__main__':      if '-makesample' in sys.argv[1:]:          makesample()      else:          main(sys.stdin, sys.stdout)    <CODESPLIT> 46
#!/usr/bin/env python  # -*- coding:utf-8 -*-  #  # Problem A. Speaking in Tongues  # http://code.google.com/codejam/contest/1460488/dashboard#s=p0  #    import sys  import string    INPUT = '''ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jv'''  OUTPUT = '''our language is impossible to understand  there are twenty six factorial possibilities  so it is okay if you want to just give up'''      class Table(dict):  	TARGET = string.ascii_lowercase    	def translate(self, msg):  		return ''.join((self[c] if c in self.TARGET else c) for c in msg)    	@classmethod  	def maketable(cls, src, dst):  		table = cls()  		left = set(cls.TARGET)  		for s, d in zip(src, dst):  			if s in table:  				if table[s] != d:  					raise Exception('BAD MAPPING "%s" => "%s"/"%s"' % (s, table[s], d))  			elif s in cls.TARGET:  				table[s] = d  				left.remove(s)  		if left:  			if len(left) != 2:  				raise Exception('left letter incorrect')  			l1, l2 = left  			table[l1] = l2  			table[l2] = l1  		return table      def main():  	table = Table.maketable(INPUT, OUTPUT)  	N = int(sys.stdin.readline())  	for index in range(N):  		line = sys.stdin.readline().strip()  		print 'Case #%d:' % (index + 1), table.translate(line)      if __name__ == '__main__':  	main()    <CODESPLIT> 46
#!/usr/bin/env python  # -*- coding:utf-8 -*-  #  # Problem A. Tic-Tac-Toe-Tomek  # https://code.google.com/codejam/contest/2270488/dashboard#s=p0  #    import sys  import string      def solve(board):      rows = [board[n:][:4] for n in range(0, len(board), 4)]      cols = [''.join(board[step+n*4] for n in range(4)) for step in range(4)]      corners = [''.join(board[n] for n in range(0, len(board), 5)),                 ''.join(board[n] for n in range(3, len(board)-1, 3))]      lines = rows + cols + corners        for line in lines:          if line.replace('T', 'X') == 'XXXX':              return 'X won'          if line.replace('T', 'O') == 'OOOO':              return 'O won'      return 'Game has not completed' if '.' in board else 'Draw'      def main(IN, OUT):      T = int(IN.readline())      for index in range(T):          board = ''.join([IN.readline().strip() for row in range(4)])          OUT.write('Case #%d: %s\n' % (index + 1, solve(board)))          # empty line          IN.readline()      def makesample(T=1000):      import random      print T      for index in range(T):          board = []          for row in range(4):              board.append(''.join(random.choice('XO.') for col in range(4)))          tcol = random.randint(0, 3)          trow = random.randint(0, 3)          board[trow] = board[trow][:tcol] + 'T' + board[trow][tcol+1:]          print '\n'.join(board)          print      if __name__ == '__main__':      if '-makesample' in sys.argv[1:]:          makesample()      else:          main(sys.stdin, sys.stdout)    <CODESPLIT> 46
#!/usr/bin/env python  # -*- coding:utf-8 -*-  #  # Problem C. Minesweeper Master  # https://code.google.com/codejam/contest/2974486/dashboard#s=p2  #    import sys      def check(R, C, M, _board):      # deepcopy      board = [line[:] for line in _board]        pos = [(0, 0)]      while pos:          row, col = pos.pop()          # neighbor cell list          neighbor = []          for r in (-1, 0, 1):              r += row              for c in (-1, 0, 1):                  c += col                  if r >= 0 and r < R and c >= 0 and c < C:                      neighbor.append((r, c))          # count bomb          count = len([1 for r, c in neighbor if board[r][c] == '*'])          board[row][col] = str(count)          # push next cell          if count == 0:              for r, c in neighbor:                  if board[r][c] == '.':                      pos.append((r, c))        flat = ''.join(''.join(line) for line in board)      result = not flat.count('.')      if not result and False: # for DEBUG          print '-' * 20          print R, C, M          print '\n'.join(''.join(line) for line in _board)          print '-' * 20      assert flat.count('*') == M      return result      def solve(R, C, M):      # initialize      board = [['.'] * C for row in range(R)]      board[0][0] = 'c'      row = R      col = C      mine = M        # phase 1: right edge, bottom edge      while mine:          if 0 < row <= col and mine >= row:              for r in range(row):                  board[row - r - 1][col - 1] = '*'              mine -= row              col -= 1          elif 0 < col <= row and mine >= col:              for c in range(col):                  board[row - 1][col - c - 1] = '*'              mine -= col              row -= 1          else:              break        # phase 2:      if mine:          #print '\n'.join(''.join(line) for line in board)          #print 'left', mine          while mine and row > 2:              for r in range(min(mine, row - 2)):                  board[row - r - 1][col - 1] = '*'                  mine -= 1              col -= 1          while mine and col > 2:              for c in range(min(mine, col - 2)):                  board[row - 1][col - c - 1] = '*'                  mine -= 1              row -= 1        # phase 3      if mine:          # col == row == 2          if mine:              board[1][1] = '*'              mine -= 1          if mine:              board[1][0] = '*'              mine -= 1          if mine:              board[0][1] = '*'              mine -= 1        assert mine == 0      return '\n'.join(''.join(line) for line in board) if check(R, C, M, board) else 'Impossible'      def main(IN, OUT):      T = int(IN.readline())      for index in range(T):          R, C, M = map(int, IN.readline().split())          OUT.write('Case #%d:\n%s\n' % (index + 1, solve(R, C, M)))      def makesample(maxSize=5, T=230):      import random      print T      for index in range(T):          R = random.randint(1, maxSize)          C = random.randint(1, maxSize)          print R, C, random.randint(0, R * C - 1)      def makesample():      pattern = []      for R in range(1, 5+1):          for C in range(1, 5+1):              for M in range(R * C):                  pattern.append((R, C, M))      print len(pattern)      for R, C, M in pattern:          print R, C, M      if __name__ == '__main__':      if '-makesample' in sys.argv[1:]:          makesample()      else:          main(sys.stdin, sys.stdout)    <CODESPLIT> 46
#!/usr/bin/env python  # -*- coding:utf-8 -*-  #  # Problem C. Recycled Numbers  # http://code.google.com/codejam/contest/1460488/dashboard#s=p2  #    import sys  import string      def solve(A, B):  	# Given integers A and B with the same number of digits  	# AB  	top = str(B)[0]    	count = 0  	for n in xrange(A, B):		# n=B (n < m <= B )  		digit = str(n)  		found = set()  		for index in range(1, len(digit)):  			if digit[index] < digit[0]:  				# m  n   n < m   				continue  			if digit[index] > top:  				# m  B   m <= B   				continue    			m = int(digit[index:] + digit[:index])  			if n < m and m <= B and m not in found:  				found.add(m)		# distinct ()  				count += 1  				#print n, m  	return count      def main(IN, OUT):  	N = int(IN.readline())  	for index in range(N):  		A, B = map(int, IN.readline().strip().split())  		OUT.write('Case #%d: %d\n' % (index + 1, solve(A, B)))      def makesample(ABmax=2000000, T=50):  	import random  	print T  	for index in range(T):  		A = random.randint(1, ABmax)  		B = random.randint(A, ABmax)  		print A, B      if __name__ == '__main__':  	if '-makesample' in sys.argv[1:]:  		makesample()  	else:  		main(sys.stdin, sys.stdout)    <CODESPLIT> 46
# -*- coding: utf-8 -*-    N_MAX = 10 ** 7  # for First large dataset      def is_palindrome(n):      s = str(n)      for i in xrange(len(s) / 2):          if s[i] != s[-1 - i]:              return False      return True    palindromes = [x for x in xrange(N_MAX) if is_palindrome(x)]  palindrome_squares = [x ** 2 for x in palindromes]  fair_and_square_palindromes = filter(is_palindrome, palindrome_squares)      T = int(raw_input())  for test_case_id in xrange(1, T + 1):      A, B = map(int, raw_input().split())      answer = len([x for x in fair_and_square_palindromes if A <= x <= B])      print 'Case #{}: {}'.format(test_case_id, answer)  <CODESPLIT> 47
# -*- coding: utf-8 -*-    import itertools    poss = dict([(i, {}) for i in xrange(0, 30 + 1)])  for a, b, c in itertools.product(range(10 + 1), repeat=3):      if a <= b <= c and c - a <= 2:          n = a + b + c          if c - a == 2:              poss[n]['s'] = tuple(sorted((a, b, c)))          else:              poss[n]['n'] = tuple(sorted((a, b, c)))      T = int(raw_input())  for case in xrange(1, T + 1):      div = map(int, raw_input().split())      N, S, p = div[:3]      t = div[3:]        ans = 0      t.sort(reverse=True)      for i in xrange(len(t)):          na, nb, nc = poss[t[i]]['n']          sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))          if p <= nc:              ans += 1          elif 0 < S and p <= sc:              ans += 1              S -= 1        print 'Case #%d: %d' % (case, ans)    <CODESPLIT> 47
# -*- coding: utf-8 -*-    import bisect    T = int(raw_input())  for test_case in xrange(1, T + 1):      N = int(raw_input())      W1 = sorted(map(float, raw_input().split()))      W2 = sorted(map(float, raw_input().split()))        y = 0      c1 = c2 = 0      while c1 < N and c2 < N:          if W2[c2] < W1[c1]:              y += 1              c1 += 1              c2 += 1          while c1 < N and c2 < N and W1[c1] < W2[c2]:              c1 += 1        z = N      c1 = c2 = 0      while c1 < N and c2 < N:          if W1[c1] < W2[c2]:              z -= 1              c1 += 1              c2 += 1          while c1 < N and c2 < N and W2[c2] < W1[c1]:              c2 += 1        print 'Case #{}: {} {}'.format(test_case, y, z)  <CODESPLIT> 47
# -*- coding: utf-8 -*-    T = int(raw_input())  for test_case_id in xrange(1, T + 1):      N, M = map(int, raw_input().split())      A = []      for i in xrange(N):          A.append(map(int, raw_input().split()))        heights = reduce(lambda a, b: a | b, (set(row) for row in A))      for y in xrange(N):          for x in xrange(M):              if (                  any(A[y][j] > A[y][x] for j in xrange(M)) and                  any(A[i][x] > A[y][x] for i in xrange(N))              ):                  # Found a region surrounded by higher regions.                  print 'Case #{}: NO'.format(test_case_id)                  break          else:              continue          break      else:          print 'Case #{}: YES'.format(test_case_id)  <CODESPLIT> 47
# -*- coding: utf-8 -*-    T = int(raw_input())  for test_case in xrange(1, T + 1):      C, F, X = map(float, raw_input().split())      answer = X / 2      i = 0      last_tc = 0      while True:          tc = last_tc + C / (2 + (i * F))          if answer < tc:              break          answer = min(tc + X / (2 + (i + 1) * F), answer)            i += 1          last_tc = tc      print 'Case #{}: {:.7f}'.format(test_case, answer)  <CODESPLIT> 47
# -*- coding: utf-8 -*-    T = int(raw_input())  for test_case in xrange(1, T + 1):      N1 = int(raw_input())      for i in xrange(4):          if i + 1 == N1:              R1 = map(int, raw_input().split(' '))          else:              raw_input()      N2 = int(raw_input())      for i in xrange(4):          if i + 1 == N2:              R2 = map(int, raw_input().split(' '))          else:              raw_input()      assert 1 <= N1 <= 4      assert 1 <= N2 <= 4      assert len(R1) == len(R2) == 4        num = set(R1) & set(R2)      if len(num) == 1:          answer = num.pop()      elif 1 < len(num):          answer = 'Bad magician!'      else:          answer = 'Volunteer cheated!'      print 'Case #{}: {}'.format(test_case, answer)  <CODESPLIT> 47
# -*- coding: utf-8 -*-    import string      str_to = '''  ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jv  '''.replace(' ', '').replace('\n', '')    str_from = '''  our language is impossible to understand  there are twenty six factorial possibilities  so it is okay if you want to just give up  '''.replace(' ', '').replace('\n', '')    conv = {}  for i, c in enumerate(str_from):      assert c not in conv or conv[c] == str_to[i]      conv[c] = str_to[i]  conv['z'] = 'q'  conv['q'] = 'z'    assert len(set(conv.keys())) == 26  assert len(set(conv.values())) == 26  mat = ['', '']  for k, v in conv.items():      mat[0] += v      mat[1] += k    T = int(raw_input())  for case in xrange(1, T + 1):      line = raw_input()      ans = string.translate(line, string.maketrans(*mat))      print 'Case #%d: %s' % (case, ans)    <CODESPLIT> 47
# -*- coding: utf-8 -*-    T = int(raw_input())  for test_case_id in xrange(1, T + 1):      cells = []      for i in xrange(4):          cells.append(raw_input())      raw_input()        R = range(4)      for c in 'XO':          if (              any(all(cells[i][j] in (c, 'T') for j in R) for i in R) or              any(all(cells[i][j] in (c, 'T') for i in R) for j in R) or              all(cells[i][i] in (c, 'T') for i in R) or              all(cells[i][3 - i] in (c, 'T') for i in R)          ):              print 'Case #{}: {} won'.format(test_case_id, c)              break      else:          if '.' in ''.join(cells):              print 'Case #{}: Game has not completed'.format(test_case_id)          else:              print 'Case #{}: Draw'.format(test_case_id)  <CODESPLIT> 47
# -*- coding: utf-8 -*-    T = int(raw_input())  for test_case in xrange(1, T + 1):      R, C, M = map(int, raw_input().split())      N = R * C      B = N - M        W, H = (C, R) if R <= C else (R, C)        if H == 1:          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]      elif M == N - 1:          answer = [['*'] * W for r in xrange(H)]          answer[0][0] = 'c'      elif B < 4 or B in (5, 7):          answer = None      elif H == 2:          if M % 2 == 0:              bw = B / 2              answer = [                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),                  ['.'] * bw + ['*'] * (W - bw),              ]          else:              answer = None      else:          answer = [['*'] * W for y in xrange(H)]          answer[0][0] = 'c'          answer[0][1] = answer[1][0] = answer[1][1] = '.'          left = B - 4          if 2 <= left:              answer[0][2] = answer[1][2] = '.'              left -= 2          if 2 <= left:              answer[2][0] = answer[2][1] = '.'              left -= 2            x = y = 3          while (x < W or y < H) and 2 <= left:              if x < W and 2 <= left:                  answer[0][x] = answer[1][x] = '.'                  left -= 2                  x += 1              if y < H and 2 <= left:                  answer[y][0] = answer[y][1] = '.'                  left -= 2                  y += 1            y = 2          while 0 < left and y < H:              x = 2              while 0 < left and x < W:                  answer[y][x] = '.'                  left -= 1                  x += 1              y += 1        if answer is None:          answer = 'Impossible'      else:          if W == R:              answer = map(list, zip(*answer))          assert len(answer) == R          assert len(answer[0]) == C          assert sum(row.count('*') for row in answer) == M  #        # DEBUG  #        h = len(answer)  #        w = len(answer[0])  #        for y in xrange(h):  #            for x in xrange(w):  #                if answer[y][x] in '.c':  #                    count = 0  #                    for dy in (-1, 0, 1):  #                        for dx in (-1, 0, 1):  #                            if (  #                                0 <= x + dx < w and  #                                0 <= y + dy < h and  #                                answer[y + dy][x + dx] == '*'  #                            ):  #                                count += 1  #                    answer[y][x] = str(count)          answer = '\n'.join([''.join(row) for row in answer])      print 'Case #{}:\n{}'.format(test_case, answer)  <CODESPLIT> 47
# -*- coding: utf-8 -*-      def rotate(x, w):      x = str(x)      return int(x[-w:] + x[:-w])      T = int(raw_input())  for case in xrange(1, T + 1):      A, B = map(int, raw_input().split())        l = len(str(A))      assert l == len(str(B))        s = []      for n in xrange(A, B + 1):          for w in xrange(1, len(str(n))):              m = int(rotate(n, w))              if n < m <= B:                  s.append((n, m))        print 'Case #%d: %d' % (case, len(set(s)))    <CODESPLIT> 47
#!/usr/bin/env python  import sys  import numpy as np    def isPalindrome(n):      cn=str(n)      return (cn==cn[::-1])    #Precomputed  palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]      #def genPalindromes(nPlaces):  #    assert nPlaces>0  #  #    if nPlaces==1:  #        for i in (1,2,3): yield i  #    elif nPlaces%2==0:  #        for i in xrange(nPlaces/2):                                            def Solve(a,b):      num=0      for p in palinSqrt:          if a<= p**2 <=b: num+=1      return num        def parse(infile):      a,b=map(int, infile.readline().split() )      return a,b        class GCJ_Parser( object ):      def __init__(self,fname):          self.infile=open(fname,'r')          self.NumCases=int(self.infile.readline().strip() )          self.caseNum=0        def __iter__(self): return self        def next(self):          if self.caseNum==self.NumCases: raise StopIteration          self.caseNum += 1          args=parse(self.infile)          return self.caseNum , args      def runmain():      myCases=GCJ_Parser(sys.argv[1])      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')        for iCase, args in myCases:          answer=Solve(*args)            print 'Case #'+str(iCase)+':',answer          print >> outfile, 'Case #'+str(iCase)+':',answer          ########library functions  class Categorizer(dict):      def __init__(self,thelist,transform,trunc=2):          dict.__init__(self)          self.transform=transform          self.AddList(thelist)          self.trunc=trunc      def AddList(self,thelist):          for item in thelist: self.Add( item )      def Add(self,object):          cat=self.transform( object )          if type(cat) is float:              cat=round(cat,trunc)          if self.has_key(cat):              self[cat].append( object )          else:              self[cat]=[object]      def PrintRanking(self,n=None):          if n is None: n=len(self)          items=self.items()          items.sort(key=lambda x:-len(x[1]))          total=0          for i in items: total+=len(i[1])          maxkey=max( len(str(key)) for key in self.iterkeys() )          maxval=max( len(str(len(val))) for val in self.itervalues() )          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"          for key,count in items[0:n]:              print formatter.format(key,len(count),                                     ("%.2f"%(len(count)*100.0/total))+'%')      def Combine(self,newdict):          newkeys=newdict.keys()          for key in newkeys:             if not type(newdict[key])==int:                raise TypeError('passed object is not a counter')          for key in newkeys:             if not self.has_key(key): self[key]=[]             self[key] += newdict[key]      def Avg(self):          avg=0.0          ntot=0          for key in self.keys():              ntot+=len(self[key])              avg+=len(self[key])*key          return avg/(1.0*ntot)      def StdDev(self):          avg=self.Avg()          ntot=0          stddev=0.0          for key in self.iterkeys():              ntot+=len(self[key])              stddev += len(self[key]) * ( (key-avg)**2)          return stddev/(1.0*ntot)      def Median(self):          tot=0          for value in self.itervalues(): tot+=len(value)          keys=self.keys()          keys.sort()          nCount=0          for key in keys:             nCount += len(self[key])             if nCount>tot/2: return key      def Mode(self):          return max(self.iteritems(), key=lambda x: len(x[1]))[0]          class Counter(dict):      def __init__(self,thelist,transform=None,trunc=2):          dict.__init__(self)          self.transform=transform          self.trunc=trunc          self.AddList(thelist)      def AddList(self,thelist):          if self.transform is not None:              for item in thelist: self.Add( self.transform(item) )          else:              for item in thelist: self.Add( item )                  def Add(self,object):          if type(object) is float:              object=round(object,self.trunc)          if self.has_key(object):              self[object]+=1          else:              self[object]=1      def PrintRanking(self,n=None):          if n is None: n=len(self)          items=self.items()          items.sort(key=lambda x:-x[1])          total=0          for i in items: total+=i[1]          maxkey=max( len(str(key)) for key in self.iterkeys() )          maxval=max( len(str(val)) for val in self.itervalues() )          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"          for key,count in items[0:n]:              print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')      def Combine(self,newdict):          newkeys=newdict.keys()          for key in newkeys:             if not type(newdict[key])==int:                raise TypeError('passed object is not a counter')          for key in newkeys:             if not self.has_key(key): self[key]=0             self[key] += newdict[key]      def Avg(self):          avg=0.0          ntot=0          for key in self.keys():              ntot+=self[key]              avg+=self[key]*key          return avg/(1.0*ntot)      def StdDev(self):          avg=self.Avg()          ntot=0          stddev=0.0          for key in self.iterkeys():              ntot+=self[key]              stddev += self[key] * ( (key-avg)**2)          return stddev/(1.0*ntot)      def Median(self):   	total=sum(self.values())          keys=self.keys()          keys.sort()          nCount=0          for key in keys:             nCount += self[key]             if nCount>total/2: return key      def Mode(self):          return max(self.iteritems(), key=lambda x: x[1])[0]      def gen_primes():      """ Generate an infinite sequence of prime numbers.      from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python      """      D = {}        q = 2          while True:          if q not in D:              yield q                      D[q * q] = [q]          else:              for p in D[q]:                  D.setdefault(p + q, []).append(p)              del D[q]            q += 1        if __name__=='__main__':      runmain()  <CODESPLIT> 48
#!/usr/bin/env python  import sys  import numpy as np    infile=open(sys.argv[1],'r')    NumCases=int(infile.readline())    for iCase in xrange(NumCases):      line=[ int(i) for i in infile.readline().split() ]        n=line.pop(0)      s=line.pop(0)      p=line.pop(0)        scores=line      assert(len(scores))==n        imax=0      isurprise=0        for score in scores:          if score<p: continue          if score<3*p-4:              pass          elif 3*p-2>score>=3*p-4:              isurprise+=1          else:              imax+=1        print 'Case #'+str(iCase+1)+':',imax+min(isurprise,s)    <CODESPLIT> 48
#!/usr/bin/env python  import sys,os  import numpy as np      def Solve(N,n,k):      n.sort(reverse=True)      k.sort(reverse=True)      nDW=0      i_n,i_k=0,0      while i_n<N and i_k<N:          if n[i_n]>k[i_k]:              nDW+=1              i_n+=1              i_k+=1          else:              i_k+=1        nW=0      i_n,i_k=0,0      while i_n<N and i_k<N:          if n[i_n]<k[i_k]:              nW+=1              i_n+=1              i_k+=1          else:              i_n+=1        nW=N-nW      return '%d %d'%(nDW,nW)        def parse(infile):      N=int(infile.readline().strip())      n=map(float, infile.readline().split() )      k=map(float, infile.readline().split() )      return N,n,k        class GCJ_Parser( object ):      def __init__(self,fname):          self.infile=open(fname,'r')          self.NumCases=int(self.infile.readline().strip() )          self.caseNum=0        def __iter__(self): return self        def next(self):          if self.caseNum==self.NumCases: raise StopIteration          self.caseNum += 1          args=parse(self.infile)          return self.caseNum , args      def runmain():      myCases=GCJ_Parser(sys.argv[1])        #Open output file, but don't overwrite old ones (for comparison)      outname=sys.argv[1].rstrip('.in')+'.out'      if os.path.isfile(outname):          oldout=outname+'.old'          ii=0          while os.path.isfile(oldout):              ii+=1              oldout=outname+'.old'+str(ii)          os.rename(outname,oldout)          print 'Rename: %s -> %s'%(outname,oldout)            outfile=open(outname,'w')        for iCase, args in myCases:          answer=Solve(*args)            print 'Case #'+str(iCase)+':',answer          print >> outfile, 'Case #'+str(iCase)+':',answer          if __name__=='__main__':      runmain()  <CODESPLIT> 48
#!/usr/bin/env python  import sys  import numpy as np      def Solve(n,m,heights):      #print heights      for i,j in ( (i,j) for i in xrange(n) for j in xrange(m) ):          if (heights[i,:]<= heights[i,j]).all(): continue            if (heights[:,j]>heights[i,j]).any(): return "NO"          return 'YES'        def parse(infile):      n,m=map(int, infile.readline().split() )      heights=np.zeros( (n,m) )      for i in xrange(n):          heights[i,:]=np.array( map(int, infile.readline().split() ) )      return n,m,heights        class GCJ_Parser( object ):      def __init__(self,fname):          self.infile=open(fname,'r')          self.NumCases=int(self.infile.readline().strip() )          self.caseNum=0        def __iter__(self): return self        def next(self):          if self.caseNum==self.NumCases: raise StopIteration          self.caseNum += 1          args=parse(self.infile)          return self.caseNum , args      def runmain():      myCases=GCJ_Parser(sys.argv[1])      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')        for iCase, args in myCases:          answer=Solve(*args)            print 'Case #'+str(iCase)+':',answer          print >> outfile, 'Case #'+str(iCase)+':',answer          ########library functions  class Categorizer(dict):      def __init__(self,thelist,transform,trunc=2):          dict.__init__(self)          self.transform=transform          self.AddList(thelist)          self.trunc=trunc      def AddList(self,thelist):          for item in thelist: self.Add( item )      def Add(self,object):          cat=self.transform( object )          if type(cat) is float:              cat=round(cat,trunc)          if self.has_key(cat):              self[cat].append( object )          else:              self[cat]=[object]      def PrintRanking(self,n=None):          if n is None: n=len(self)          items=self.items()          items.sort(key=lambda x:-len(x[1]))          total=0          for i in items: total+=len(i[1])          maxkey=max( len(str(key)) for key in self.iterkeys() )          maxval=max( len(str(len(val))) for val in self.itervalues() )          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"          for key,count in items[0:n]:              print formatter.format(key,len(count),                                     ("%.2f"%(len(count)*100.0/total))+'%')      def Combine(self,newdict):          newkeys=newdict.keys()          for key in newkeys:             if not type(newdict[key])==int:                raise TypeError('passed object is not a counter')          for key in newkeys:             if not self.has_key(key): self[key]=[]             self[key] += newdict[key]      def Avg(self):          avg=0.0          ntot=0          for key in self.keys():              ntot+=len(self[key])              avg+=len(self[key])*key          return avg/(1.0*ntot)      def StdDev(self):          avg=self.Avg()          ntot=0          stddev=0.0          for key in self.iterkeys():              ntot+=len(self[key])              stddev += len(self[key]) * ( (key-avg)**2)          return stddev/(1.0*ntot)      def Median(self):          tot=0          for value in self.itervalues(): tot+=len(value)          keys=self.keys()          keys.sort()          nCount=0          for key in keys:             nCount += len(self[key])             if nCount>tot/2: return key      def Mode(self):          return max(self.iteritems(), key=lambda x: len(x[1]))[0]          class Counter(dict):      def __init__(self,thelist,transform=None,trunc=2):          dict.__init__(self)          self.transform=transform          self.trunc=trunc          self.AddList(thelist)      def AddList(self,thelist):          if self.transform is not None:              for item in thelist: self.Add( self.transform(item) )          else:              for item in thelist: self.Add( item )                  def Add(self,object):          if type(object) is float:              object=round(object,self.trunc)          if self.has_key(object):              self[object]+=1          else:              self[object]=1      def PrintRanking(self,n=None):          if n is None: n=len(self)          items=self.items()          items.sort(key=lambda x:-x[1])          total=0          for i in items: total+=i[1]          maxkey=max( len(str(key)) for key in self.iterkeys() )          maxval=max( len(str(val)) for val in self.itervalues() )          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"          for key,count in items[0:n]:              print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')      def Combine(self,newdict):          newkeys=newdict.keys()          for key in newkeys:             if not type(newdict[key])==int:                raise TypeError('passed object is not a counter')          for key in newkeys:             if not self.has_key(key): self[key]=0             self[key] += newdict[key]      def Avg(self):          avg=0.0          ntot=0          for key in self.keys():              ntot+=self[key]              avg+=self[key]*key          return avg/(1.0*ntot)      def StdDev(self):          avg=self.Avg()          ntot=0          stddev=0.0          for key in self.iterkeys():              ntot+=self[key]              stddev += self[key] * ( (key-avg)**2)          return stddev/(1.0*ntot)      def Median(self):   	total=sum(self.values())          keys=self.keys()          keys.sort()          nCount=0          for key in keys:             nCount += self[key]             if nCount>total/2: return key      def Mode(self):          return max(self.iteritems(), key=lambda x: x[1])[0]      def gen_primes():      """ Generate an infinite sequence of prime numbers.      from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python      """      D = {}        q = 2          while True:          if q not in D:              yield q                      D[q * q] = [q]          else:              for p in D[q]:                  D.setdefault(p + q, []).append(p)              del D[q]            q += 1        if __name__=='__main__':      runmain()  <CODESPLIT> 48
#!/usr/bin/env python  import sys,os  import numpy as np    BIG_NUM=100000  def Solve(C,F,X):      best_time=float('inf')      for n in xrange(0,BIG_NUM):          if n==0:              farm_time=0          else:              farm_time += C/(2+(n-1)*F)          if best_time<=farm_time: break          cookie_time=X/(2+n*F)            if farm_time+cookie_time<best_time:              best_time=farm_time+cookie_time        return '%.9f'%best_time        def parse(infile):      C,F,X=map(float, infile.readline().split() )      return C,F,X        class GCJ_Parser( object ):      def __init__(self,fname):          self.infile=open(fname,'r')          self.NumCases=int(self.infile.readline().strip() )          self.caseNum=0        def __iter__(self): return self        def next(self):          if self.caseNum==self.NumCases: raise StopIteration          self.caseNum += 1          args=parse(self.infile)          return self.caseNum , args      def runmain():      myCases=GCJ_Parser(sys.argv[1])        #Open output file, but don't overwrite old ones (for comparison)      outname=sys.argv[1].rstrip('.in')+'.out'      if os.path.isfile(outname):          oldout=outname+'.old'          ii=0          while os.path.isfile(oldout):              ii+=1              oldout=outname+'.old'+str(ii)          os.rename(outname,oldout)          print 'Rename: %s -> %s'%(outname,oldout)            outfile=open(outname,'w')        for iCase, args in myCases:          answer=Solve(*args)            print 'Case #'+str(iCase)+':',answer          print >> outfile, 'Case #'+str(iCase)+':',answer          if __name__=='__main__':      runmain()  <CODESPLIT> 48
#!/usr/bin/env python  import sys,os  import numpy as np      def Solve(F1,r1,F2,r2):      s1=set(F1[r1-1])      s2=set(F2[r2-1])      sx=s1.intersection(s2)      if len(sx)>1:          return "Bad magician!"      elif len(sx)==0:          return "Volunteer cheated!"      else:          return sx.__iter__().next()        def parse(infile):      r1=int(infile.readline().strip())      F1=[]      for i in xrange(4):          F1.append( map(int, infile.readline().split() ))      r2=int(infile.readline().strip())      F2=[]      for i in xrange(4):          F2.append( map(int, infile.readline().split() ))      return F1,r1,F2,r2        class GCJ_Parser( object ):      def __init__(self,fname):          self.infile=open(fname,'r')          self.NumCases=int(self.infile.readline().strip() )          self.caseNum=0        def __iter__(self): return self        def next(self):          if self.caseNum==self.NumCases: raise StopIteration          self.caseNum += 1          args=parse(self.infile)          return self.caseNum , args      def runmain():      myCases=GCJ_Parser(sys.argv[1])        #Open output file, but don't overwrite old ones (for comparison)      outname=sys.argv[1].rstrip('.in')+'.out'      if os.path.isfile(outname):          oldout=outname+'.old'          ii=0          while os.path.isfile(oldout):              ii+=1              oldout=outname+'.old'+str(ii)          os.rename(outname,oldout)          print 'Rename: %s -> %s'%(outname,oldout)            outfile=open(outname,'w')        for iCase, args in myCases:          answer=Solve(*args)            print 'Case #'+str(iCase)+':',answer          print >> outfile, 'Case #'+str(iCase)+':',answer          if __name__=='__main__':      runmain()  <CODESPLIT> 48
#!/usr/bin/env python  import sys  import numpy as np    infile=open(sys.argv[1],'r')    NumCases=int(infile.readline())    myinput="""ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jv"""    myoutput=\  """our language is impossible to understand  there are twenty six factorial possibilities  so it is okay if you want to just give up"""    mapping={}  mapping['q']='z'  mapping['z']='q'      for char,mapto in zip(myinput,myoutput):      if mapping.has_key(char):          assert mapping[char]==mapto      else:          mapping[char]=mapto    #allchar=set('abcdefghijklmnopqrstuvwxyz')  #print allchar-set( mapping.keys() )  #print allchar-set(mapping.values() )        for iCase in xrange(NumCases):      thestring=infile.readline().strip()        newstring=''      for char in thestring: newstring+=mapping[char]          print 'Case #'+str(iCase+1)+': '+newstring    <CODESPLIT> 48
#!/usr/bin/env python  import sys  import numpy as np      def Solve(lines):      hasEmpty=False        rows=[ lines[0][i]+lines[1][i]+lines[2][i]+lines[3][i]              for i in xrange(4) ]        diags=[ lines[0][0]+lines[1][1]+lines[2][2]+lines[3][3] ,              lines[0][3]+lines[1][2]+lines[2][1]+lines[3][0] ]          for il in lines + rows + diags:          if il.replace('T','X')=='XXXX': return "X won"          elif il.replace('T','O')=='OOOO': return "O won"          elif il.find('.')>=0: hasEmpty=True              if hasEmpty: return "Game has not completed"      else: return "Draw"        def parse(infile):      lines=[]      for i in xrange(4):          lines.append(infile.readline().strip())      infile.readline()      return (lines,)        class GCJ_Parser( object ):      def __init__(self,fname):          self.infile=open(fname,'r')          self.NumCases=int(self.infile.readline().strip() )          self.caseNum=0        def __iter__(self): return self        def next(self):          if self.caseNum==self.NumCases: raise StopIteration          self.caseNum += 1          args=parse(self.infile)          return self.caseNum , args      def runmain():      myCases=GCJ_Parser(sys.argv[1])      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')        for iCase, args in myCases:          answer=Solve(*args)            print 'Case #'+str(iCase)+':',answer          print >> outfile, 'Case #'+str(iCase)+':',answer          ########library functions  class Categorizer(dict):      def __init__(self,thelist,transform,trunc=2):          dict.__init__(self)          self.transform=transform          self.AddList(thelist)          self.trunc=trunc      def AddList(self,thelist):          for item in thelist: self.Add( item )      def Add(self,object):          cat=self.transform( object )          if type(cat) is float:              cat=round(cat,trunc)          if self.has_key(cat):              self[cat].append( object )          else:              self[cat]=[object]      def PrintRanking(self,n=None):          if n is None: n=len(self)          items=self.items()          items.sort(key=lambda x:-len(x[1]))          total=0          for i in items: total+=len(i[1])          maxkey=max( len(str(key)) for key in self.iterkeys() )          maxval=max( len(str(len(val))) for val in self.itervalues() )          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"          for key,count in items[0:n]:              print formatter.format(key,len(count),                                     ("%.2f"%(len(count)*100.0/total))+'%')      def Combine(self,newdict):          newkeys=newdict.keys()          for key in newkeys:             if not type(newdict[key])==int:                raise TypeError('passed object is not a counter')          for key in newkeys:             if not self.has_key(key): self[key]=[]             self[key] += newdict[key]      def Avg(self):          avg=0.0          ntot=0          for key in self.keys():              ntot+=len(self[key])              avg+=len(self[key])*key          return avg/(1.0*ntot)      def StdDev(self):          avg=self.Avg()          ntot=0          stddev=0.0          for key in self.iterkeys():              ntot+=len(self[key])              stddev += len(self[key]) * ( (key-avg)**2)          return stddev/(1.0*ntot)      def Median(self):          tot=0          for value in self.itervalues(): tot+=len(value)          keys=self.keys()          keys.sort()          nCount=0          for key in keys:             nCount += len(self[key])             if nCount>tot/2: return key      def Mode(self):          return max(self.iteritems(), key=lambda x: len(x[1]))[0]          class Counter(dict):      def __init__(self,thelist,transform=None,trunc=2):          dict.__init__(self)          self.transform=transform          self.trunc=trunc          self.AddList(thelist)      def AddList(self,thelist):          if self.transform is not None:              for item in thelist: self.Add( self.transform(item) )          else:              for item in thelist: self.Add( item )                  def Add(self,object):          if type(object) is float:              object=round(object,self.trunc)          if self.has_key(object):              self[object]+=1          else:              self[object]=1      def PrintRanking(self,n=None):          if n is None: n=len(self)          items=self.items()          items.sort(key=lambda x:-x[1])          total=0          for i in items: total+=i[1]          maxkey=max( len(str(key)) for key in self.iterkeys() )          maxval=max( len(str(val)) for val in self.itervalues() )          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"          for key,count in items[0:n]:              print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')      def Combine(self,newdict):          newkeys=newdict.keys()          for key in newkeys:             if not type(newdict[key])==int:                raise TypeError('passed object is not a counter')          for key in newkeys:             if not self.has_key(key): self[key]=0             self[key] += newdict[key]      def Avg(self):          avg=0.0          ntot=0          for key in self.keys():              ntot+=self[key]              avg+=self[key]*key          return avg/(1.0*ntot)      def StdDev(self):          avg=self.Avg()          ntot=0          stddev=0.0          for key in self.iterkeys():              ntot+=self[key]              stddev += self[key] * ( (key-avg)**2)          return stddev/(1.0*ntot)      def Median(self):   	total=sum(self.values())          keys=self.keys()          keys.sort()          nCount=0          for key in keys:             nCount += self[key]             if nCount>total/2: return key      def Mode(self):          return max(self.iteritems(), key=lambda x: x[1])[0]      def gen_primes():      """ Generate an infinite sequence of prime numbers.      from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python      """      D = {}        q = 2          while True:          if q not in D:              yield q                      D[q * q] = [q]          else:              for p in D[q]:                  D.setdefault(p + q, []).append(p)              del D[q]            q += 1        if __name__=='__main__':      runmain()  <CODESPLIT> 48
#!/usr/bin/env python  import sys,os  import numpy as np  import Queue    #guaranteed that R,C>=3, and F is not 1,2,3,5,7  def Fill(outmat,R,C,F):      nF=F      #first square      outmat[:2,:2]='.'      nF-=4      if nF==0: return        #next two      outmat[2,:2]='.'      nF-=2      if nF==0: return            #nearly there...      outmat[:2,2]='.'      nF-=2      if nF==0: return        #Fill by 2 across columns      for iC in xrange(3,C):          if nF==1:              outmat[2,2]='.'              return          outmat[:2,iC]='.'          nF-=2          if nF==0: return                #Fill by 2 across rows      for iR in xrange(3,R):          if nF==1:              outmat[2,2]='.'              return          outmat[iR,:2]='.'          nF-=2          if nF==0: return        #Now fill singly 3rd row/column      for iR,iC in ( (iR,iC) for iR in xrange(2,R)                     for iC in xrange(2,C)):          outmat[iR,iC]='.'          nF-=1          if nF==0: return              def Solve(R,C,M):      F=R*C-M      if F==0: return '\nImpossible'      if (R>1 and C>1 and F in (2,3)):          return '\nImpossible'        outmat=np.zeros( (R,C), dtype='S1')      outmat[:,:]='*'        if R==1:          for i in xrange(F):              outmat[0][i]='.'            elif C==1:          for i in xrange(F):              outmat[i][0]='.'        elif F>1:          if F in (2,3,5,7): return "\nImpossible"          elif (R==2 or C==2) and F%2 != 0:              return "\nImpossible"          elif R==2:              outmat[:,:F/2]='.'          elif C==2:              outmat[:F/2,:]='.'          else: Fill(outmat,R,C,F)                outmat[0,0]='c'      outmatlines=[ ''.join(x) for x in outmat ]      #print outmatlines      answer='\n'+'\n'.join(outmatlines)        Verify(answer,F)        return answer    disp=[ (dx,dy) for dx in (-1,0,1)      for dy in (1,0,-1) if (dx !=0 or dy!=0) ]    def Verify(answer,F):      lines=[list(x) for x in answer.split('\n')]      if len(lines[0])==0: lines.pop(0)      R,C=len(lines),len(lines[0])      assert lines[0][0]=='c'      assert answer.count('.')+1==F      q=Queue.Queue()      q.put( (0,0) )        def adjToMine(x,y):          for dx,dy in disp:              if 0<=x+dx<R and 0<=y+dy<C:                  if lines[x+dx][y+dy]=='*': return True          return False                          while not q.empty():          x,y=q.get()          for dx,dy in disp:              if 0<=x+dx<R and 0<=y+dy<C:                  if lines[x+dx][y+dy]=='c': continue                  lines[x+dx][y+dy]='c'                  if not adjToMine(x+dx,y+dy):                      q.put( (x+dx,y+dy) )        clicked='\n'.join([ ''.join(x) for x in lines])      if clicked.find('.')>=0:          print '\n','*'*20,"\nERROR, input:"          print answer          print 'OUTPUT:'          print clicked              def parse(infile):      R,C,M=map(int, infile.readline().split() )      return R,C,M        class GCJ_Parser( object ):      def __init__(self,fname):          self.infile=open(fname,'r')          self.NumCases=int(self.infile.readline().strip() )          self.caseNum=0        def __iter__(self): return self        def next(self):          if self.caseNum==self.NumCases: raise StopIteration          self.caseNum += 1          args=parse(self.infile)          return self.caseNum , args      def runmain():      myCases=GCJ_Parser(sys.argv[1])        #Open output file, but don't overwrite old ones (for comparison)      outname=sys.argv[1].rstrip('.in')+'.out'      if os.path.isfile(outname):          oldout=outname+'.old'          ii=0          while os.path.isfile(oldout):              ii+=1              oldout=outname+'.old'+str(ii)          os.rename(outname,oldout)          print 'Rename: %s -> %s'%(outname,oldout)            outfile=open(outname,'w')        for iCase, args in myCases:          answer=Solve(*args)            print 'Case #'+str(iCase)+':',answer          print >> outfile, 'Case #'+str(iCase)+':',answer          if __name__=='__main__':      runmain()  <CODESPLIT> 48
#!/usr/bin/env python  import sys  import numpy as np    infile=open(sys.argv[1],'r')    NumCases=int(infile.readline())    for iCase in xrange(NumCases):        a,b=[int(i) for i in infile.readline().split()]      #for iCase in xrange(1):  #    a,b=[int(i) for i in sys.argv[1:]]      a_digits=[int(i) for i in str(a) ]      b_digits=[int(i) for i in str(b) ]        ld=len(a_digits)    #    print a_digits,b_digits        result=0  #    lowers={}        for iNum in xrange(a,b+1):          mystr=str(iNum)          myset=set()          for i in xrange(1,ld):              mystr=mystr[1:]+mystr[0]              iii=int(mystr)              if iii>iNum and iii<=b and iii not in myset:                  result+=1                  #print iNum,iii                  #if lowers.has_key(iii):                  #    lowers[iii].append(iNum)                  #else: lowers[iii]=[iNum]                myset.add(iii)                              #    for k,v in lowers.iteritems(): print k,':',v      print 'Case #'+str(iCase+1)+':',result    <CODESPLIT> 48
import sys  import bisect    def is_palindrome(n):      s = str(n)      return s == s[::-1]     palindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]  all_palindromes = palindromes[1] + palindromes[2]  limit = [100]    palindromic_squares = []  psqtop = 0  psqix = 0    stdin = sys.stdin  for c in xrange(int(stdin.readline())):      a,b = map(int, stdin.readline().split())        while psqtop < b:          while psqix >= len(all_palindromes):              ps = []              pp = 10 ** (len(palindromes)-1) + 1              for i in range(1,10):                  for p in palindromes[-2]:                      ps.append(i * pp + 10 * p)               palindromes.append(ps)              all_palindromes.extend(ps)            sq = all_palindromes[psqix] * all_palindromes[psqix]          if is_palindrome(sq):              palindromic_squares.append(sq)          psqix  += 1          psqtop = sq        aix = bisect.bisect_left(palindromic_squares, a)      bix = bisect.bisect_right(palindromic_squares, b)        print "Case #%i: %i" % (c+1, bix-aix)   <CODESPLIT> 49
from sys import stdin    T = int(stdin.readline())  for i in xrange(1,T+1):  	ns = map(int, stdin.readline().split())  	N,S,p = ns[0:3]  	  	h = 0  	z = 0    	for n in ns[3:]:  		if n <= 1:  			if n >= p: h += 1	  		elif (n+2) // 3 >= p:  			h += 1  		elif (n+4) // 3 >= p:  			z += 1    	print "Case #%d: %d" % (i, h + min(S,z))      <CODESPLIT> 49
import sys    f = open(sys.argv[1])  count = int(f.readline())    for i in xrange(0, count):      n = int(f.readline())      naomis = sorted(map(float, f.readline().split()))      kens = sorted(map(float, f.readline().split()))      assert len(naomis) == n and len(kens) == n        naomis_w = set(naomis)      kens_w = set(kens)      naomi_war_wins = 0      while naomis_w:          nao = max(naomis_w)          try:              ken = min(w for w in kens_w if w > nao)          except ValueError:              ken = min(kens_w)              naomi_war_wins += 1          naomis_w.remove(nao)          kens_w.remove(ken)        naomi_deceit_wins = 0      naomis_w = set(naomis)      kens_w = set(kens)      while naomis_w:          ken = min(kens_w)          try:              nao = min(w for w in naomis_w if w > ken)              naomi_deceit_wins += 1          except ValueError:              nao = min(naomis_w)          naomis_w.remove(nao)          kens_w.remove(ken)        print "Case #%s: %s %s" % (i+1, naomi_deceit_wins, naomi_war_wins)  <CODESPLIT> 49
import sys    stdin = sys.stdin  for c in xrange(int(stdin.readline())):      n,m = map(int, stdin.readline().split())      rows = [map(int, stdin.readline().split()) for i in xrange(n)]      cols = [[row[i] for row in rows] for i in xrange(m)]        rowmaxs = [max(x) for x in rows]      colmaxs = [max(x) for x in cols]        verdict = "YES"      for i in xrange(n):          for k in xrange(m):              if min(rowmaxs[i], colmaxs[k]) > rows[i][k]:                  verdict = "NO"                  break            if verdict == "NO": break        print "Case #%i: %s" % (c+1, verdict)  <CODESPLIT> 49
import sys    lines = [line.strip() for line in open(sys.argv[1])]  count = int(lines[0])    for i in xrange(count):      farm_cost,farm_production,target = map(float, lines[i+1].split())      seconds = 0      production = 2      best = float("inf")      while True:          best = min(best, seconds + target / production)          seconds += farm_cost / production          if seconds >= best: break          production += farm_production        print "Case #%s: %.7f" % (i+1, best)  <CODESPLIT> 49
import sys      lines = [map(int, line.strip().split(" ")) for line in open(sys.argv[1]).readlines()]  [count] = lines[0]  assert count * 10 + 1 == len(lines)    for i in xrange(count):      base = i*10      [n1] = lines[base+1]      [n2] = lines[base+6]      row1 = set(lines[base+1+n1])      row2 = set(lines[base+6+n2])      common = row1.intersection(row2)      print "Case #%s:" % (i+1),      if len(common) == 1:          print list(common)[0]      elif not common:          print "Volunteer cheated!"      else:          print "Bad magician!"  <CODESPLIT> 49
import sys    googlerese = """  y qee  ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jv  z  """    plain = """  a zoo  our language is impossible to understand  there are twenty six factorial possibilities  so it is okay if you want to just give up  q  """    gtos = {}  stog = {}    for s,g in zip(plain, googlerese):  	gtos[g] = s  	stog[s] = g    #for c in "abcdefghijklmnopqrstuvwxyz":  #	print c, stog.get(c, None), gtos.get(c,None)    f = sys.stdin    t = int(f.readline())    for i in xrange(0,t):  	line = f.readline().strip()  	print "Case #%d: %s" % (i+1, "".join([gtos.get(c,c) for c in line]))    <CODESPLIT> 49
import sys    stdin = sys.stdin  ixs = range(4)  for i in xrange(int(stdin.readline())):      print "Case #%i: " % (i+1),      rows = [stdin.readline()[:4] for i in ixs]        cols = [[row[i] for row in rows] for i in ixs]      diags = [          [rows[i][i] for i in ixs],          [rows[i][3-i] for i in ixs]      ]      notdone = False      for row in rows + cols + diags:          x = None          for t in row:              if t == '.':                  notdone = True                  break              elif t == 'T':                  continue              elif x is not None and x != t:                  break              else:                  x = t          else:              print x, "won"              break      else:          if notdone: print "Game has not completed"          else:       print "Draw"        stdin.readline()  <CODESPLIT> 49
import sys    lines = [line.strip() for line in open(sys.argv[1])]  count = int(lines[0])    for i in xrange(count):      R,C,M = map(int, lines[i+1].split())      print "Case #%s:" % (i+1)        w = max(R,C)      h = min(R,C)      X = R*C - M      assert X > 0        if X == 1:          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]      elif h == 1:          rows = ['c' + '.' * (X-1) + '*' * M]      elif X == 4:              rows = [                  'c.' + '*' * (w-2),                  '..' + '*' * (w-2),              ] + ['*' * w] * (h-2)      elif h == 2:          if X%2 == 1 or X == 2:              rows = None          else:              rows = [                  'c' + '.' * (X/2-1) + '*' * (M/2),                  '.' + '.' * (X/2-1) + '*' * (M/2)              ]      elif X <= 5 or X == 7:          rows = None        elif X%2 == 0 and X <= w*2:          r = X/2          rows = [              'c' + '.' * (r - 1) + '*' * (w-r),                    '.' * r       + '*' * (w-r),          ] + ['*' * w] * (h-2)        elif X <= w*3 and (X % 3) != 1:          n = (X+1) / 3          t = X - 2*n          rows = [              'c' + '.' * (n-1) + '*' * (w-n),                    '.' * n     + '*' * (w-n),                    '.' * t     + '*' * (w-t)          ] + ['*' * w] * (h-3)      else:          n = X / w          t = X % w          if t == 1:              rows = (                      ['c' + (w-1) * '.']                  +   ['.' * w] * (n-2)                  +   ['.' * (w-1) + '*']                  +   ['..' + '*' * (w-2)]                  +   ['*' * w] * (h - n - 1)              )          else:              k = 1 if t == 0 else 0              rows = (                      ['c' + (w-1) * '.']                  +   ['.' * w] * (n-1)                  +   ['.' * t + '*' * (w-t)] * (1 - k)                  +   ['*' * w] * (h - n - 1 + k)              )        if rows:          if R > C:              rows = ["".join(row[i] for row in rows) for i in xrange(R)]            for row in rows:              print row            assert len(rows) == R          assert len(rows[0]) == C          assert sum(1 for row in rows for col in row if col == '*') == M        else:          print "Impossible"    <CODESPLIT> 49
from sys import stdin  import math    pots = [int(10**k) for k in xrange(0,16)]    T = int(stdin.readline())    for i in xrange(1,T+1):  	a,b = map(int, stdin.readline().split())  	t = 0  	m = len(str(a))    	pp = int(10**m)    	for n in xrange(a,b):  		ss = []  		q = 1  		p = pp  		for j in xrange(1,m):  			q *= 10  			p /= 10  			r = (n % p) * q + (n /p)  			if n < r and r <= b and not r in ss:   				ss.append(r)  				t += 1      	print "Case #%d: %d" % (i,t)    <CODESPLIT> 49
#  # Google Code Jam 2013  # Round 0: C. Fair and Square  # submission by EnTerr  #    '''  Limits    Small dataset       1 <= T <= 100, 1 <= A <= B <= 1000.  First large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.  Second large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.    Sample  *** Input   3  1 4  10 120  100 1000   	  *** Output   Case #1: 2  Case #2: 0  Case #3: 2      '''    #import psyco  #psyco.full()    import sys  from time import clock    inf = open(sys.argv[1])  def input(): return inf.readline().strip()    # "cheat" from http://www.worldofnumbers.com/allsquar.htm  # "Exhaustive list of Palindromic Squares up to length 31"  # roots of palindromic squares  pal_sqr_roots = '''1   2   3   11   22   26   101   111   121   202   212   264   307   836   1001   1111   2002   2285   2636   10001   10101   10201   11011   11111   11211   20002   20102   22865   24846   30693   100001   101101   110011   111111   200002   798644   1000001   1001001   1002001   1010101   1011101   1012101   1042151   1100011   1101011   1102011   1109111   1110111   1111111   1270869   2000002   2001002   2012748   2294675   3069307   10000001   10011001   10100101   10111101   11000011   11011011   11100111   11111111   11129361   12028229   12866669   20000002   30001253   64030648   100000001   100010001   100020001   100101001   100111001   100121001   101000101   101010101   101020101   101101101   101111101   110000011   110010011   110020011   110091011   110101011   110111011   111000111   111010111   111091111   111101111   111111111   200000002   200010002   306930693   1000000001   1000110001   1001001001   1001111001   1010000101   1010110101   1011001101   1011111101   1100000011   1100110011   1101001011   1101111011   1110000111   1110110111   1111001111   2000000002   2062386218   2481623254   10000000001   10000100001   10000200001   10001010001   10001110001   10001210001   10010001001   10010101001   10010201001   10011011001   10011111001   10100000101   10100100101   10100200101   10101010101   10101110101   10106064399   10109901101   10110001101   10110101101   10110911101   10111011101   10111111101   10207355549   11000000011   11000100011   11000200011   11000910011   11001010011   11001110011   11010001011   11010101011   11010911011   11011011011   11011111011   11100000111   11100100111   11100910111   11101010111   11101110111   11110001111   11110101111   13579355059   20000000002   20000100002   22865150135   30101273647   30693069307   83163115486   100000000001   100001100001   100010010001   100011110001   100100001001   100101101001   100110011001   100111111001   101000000101   101001100101   101010010101   101011110101   101100001101   101101101101   101110011101   101116809851   110000000011   110001100011   110010010011   110011110011   110100001011   110101101011   110110011011   111000000111   111001100111   111010010111   111100001111   111283619361   112247658961   128817084669   200000000002   1000000000001   1000001000001   1000002000001   1000010100001   1000011100001   1000012100001   1000100010001   1000101010001   1000102010001   1000110110001   1000111110001   1001000001001   1001001001001   1001002001001   1001010101001   1001011101001   1001100011001   1001101011001   1001110111001   1001111111001   1010000000101   1010001000101   1010002000101   1010010100101   1010011100101   1010099010101   1010100010101   1010101010101   1010109110101   1010110110101   1010111110101   1011000001101   1011001001101   1011010101101   1011011101101   1011099011101   1011100011101   1011101011101   1100000000011   1100001000011   1100002000011   1100009100011   1100010100011   1100011100011   1100100010011   1100101010011   1100110110011   1100111110011   1101000001011   1101001001011   1101009101011   1101010101011   1101011101011   1101100011011   1101101011011   1110000000111   1110001000111   1110009100111   1110010100111   1110011100111   1110100010111   1110101010111   1111000001111   1111001001111   1349465117841   2000000000002   2000001000002   2149099165358   2634812417864   3069306930693   6360832925898   10000000000001   10000011000001   10000100100001   10000111100001   10001000010001   10001011010001   10001100110001   10001111110001   10010000001001   10010011001001   10010100101001   10010111101001   10011000011001   10011011011001   10011100111001   10100000000101   10100011000101   10100100100101   10100111100101   10101000010101   10101011010101   10101100110101   10110000001101   10110011001101   10110100101101   10111000011101   11000000000011   11000011000011   11000100100011   11000111100011   11001000010011   11001011010011   11001100110011   11010000001011   11010011001011   11010100101011   11011000011011   11100000000111   11100011000111   11100100100111   11101000010111   11110000001111   20000000000002   30395080190573   69800670077028   98275825201587   100000000000001   100000010000001   100000020000001   100000101000001   100000111000001   100000121000001   100001000100001   100001010100001   100001020100001   100001101100001   100001111100001   100010000010001   100010010010001   100010020010001   100010101010001   100010111010001   100011000110001   100011010110001   100011101110001   100011111110001   100100000001001   100100010001001   100100020001001   100100101001001   100100111001001   100101000101001   100101010101001   100101101101001   100101111101001   100109990011001   100110000011001   100110010011001   100110091011001   100110101011001   100110111011001   100110990111001   100111000111001   100111010111001   101000000000101   101000010000101   101000020000101   101000101000101   101000111000101   101000990100101   101001000100101   101001010100101   101001091100101   101001101100101   101001111100101   101010000010101   101010010010101   101010101010101   101010111010101   101010990110101   101011000110101   101011010110101   101100000001101   101100010001101   101100101001101   101100111001101   101101000101101   101101010101101   101110000011101   101110010011101   110000000000011   110000010000011   110000020000011   110000091000011   110000101000011   110000111000011   110001000100011   110001010100011   110001101100011   110001111100011   110010000010011   110010010010011   110010091010011   110010101010011   110010111010011   110011000110011   110011010110011   110100000001011   110100010001011   110100101001011   110100111001011   110101000101011   110101010101011   110110000011011   110110010011011   111000000000111   111000010000111   111000091000111   111000101000111   111000111000111   111001000100111   111001010100111   111010000010111   111010010010111   111100000001111   111100010001111   129610990752569   200000000000002   200000010000002   210786628549538   314155324482867   1000000000000000   1000000110000000   1000001001000000   1000001111000000   1000010000100000   1000010110100000   1000011001100000   1000011111100000   1000100000010000   1000100110010000   1000101001010000   1000101111010000   1000110000110000   1000110110110000   1000111001110000   1001000000001000   1001000110001000   1001001001001000   1001001111001000   1001010000101000   1001010110101000   1001011001101000   1001100000011000   1001100110011000   1001101001011000   1001110000111000   1010000000000100   1010000110000100   1010001001000100   1010001111000100   1010010000100100   1010010110100100   1010011001100100   1010100000010100   1010100110010100   1010101001010100   1010110000110100   1011000000001100   1011000110001100   1011001001001100   1011010000101100   1011100000011100   1100000000000010   1100000110000010   1100001001000010   1100001111000010   1100010000100010   1100010110100010   1100011001100010   1100100000010010   1100100110010010   1100101001010010   1100110000110010   1101000000001010   1101000110001010   1101001001001010   1101010000101010   1101100000011010   1110000000000110   1110000110000110   1110001001000110   1110010000100110   1110100000010110   1111000000001110   2000000000000000   2201019508986470   2564053868197730   3066446727654240   3107974295870660   3138199296186060'''  pal_sqr_roots = map(int, pal_sqr_roots.split())    # see also http://web.archive.org/web/20020614225321/http://www.geocities.com/williamrexmarshall/math/palsq.html  # http://www.worldofnumbers.com/square.htm  # http://mathforum.org/library/drmath/view/51510.html      def is_palindrome(n):      return str(n)[::-1] == str(n)    palindromic_roots = [x for x in pal_sqr_roots if is_palindrome(x)]    fair_and_square = [x*x for x in palindromic_roots]      def get_num_fair_and_square(a, b):      return len([x for x in fair_and_square if a <= x <= b])    for caseNo in range(1, int(input())+1):      #tm = clock()      a,b = map(int, input().split())      print 'Case #%d:' % caseNo, get_num_fair_and_square(a, b)      #print >>sys.stderr, caseNo, clock() - tm    <CODESPLIT> 50
#  # Google Code Jam 2012  # Round 0: B. Dancing With the Googlers  # submission by EnTerr  #    '''  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]  At least S of the ti values will be between 2 and 28, inclusive.    Small dataset 1 = N = 3.  Large dataset 1 = N = 100.    Sample Input   4  3 1 5 15 13 11  3 0 8 23 22 21  2 1 1 8 0  6 2 8 29 20 8 18 18 21    Output   Case #1: 3  Case #2: 2  Case #3: 1  Case #4: 3  '''    #import psyco  #psyco.full()    import sys  from time import clock    inf = open(sys.argv[1])  def input(): return inf.readline().strip()    def maxBestDancers(N, S, p, *Ti):      cnt = 0      for score in Ti:          mx = (score + 2) // 3          if mx >= p:              cnt += 1          elif mx >= p-1 > 0 and S>0:              S -= 1              cnt += 1      return cnt    for caseNo in range(1, int(input())+1):      #tm = clock()      print 'Case #%d:' % caseNo,      lst = map(int, input().split())      print maxBestDancers(*lst)      #print >>sys.stderr, caseNo, clock() - tm    <CODESPLIT> 50
#  # Google Code Jam 2014  # Roaund 0: D. Deceitful War  # submission by EnTerr  #    '''  Input  The first line of the input gives the number of test cases, T. T test cases follow.   Each test case starts with a line containing a single integer N, the number of blocks   each player has. Next follows a line containing N space-separated real numbers:   the masses of Naomi's blocks, in kg. Finally there will be a line containing N   space-separated real numbers: the masses of Ken's blocks, in kg.    Output  For each test case, output one line containing "Case #x: y z", where   x is the test case number (starting from 1),   y is the number of points Naomi will score if she plays Deceitful War optimally, and   z is the number of points Naomi will score if she plays War optimally.    Limits  1 <= T <= 50.  All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.    Small dataset  1 <= N <= 10.    Large dataset  1 <= N <= 1000.    ---Input   4  1  0.5  0.6  2  0.7 0.2  0.8 0.3  3  0.5 0.1 0.9  0.6 0.4 0.3  9  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458    ---Output   Case #1: 0 0  Case #2: 1 0  Case #3: 2 1  Case #4: 8 4      '''    import sys  from time import clock    f = open(sys.argv[1])  def input(): return f.readline().strip();        def deceitfulWar(Naomi, Ken):      Naomi = Naomi[:]      Ken = Ken[:]      pts = 0      while Naomi and Ken and Naomi[-1] > Ken[0]:          #Naomi's max is bigger than Ken's min          #lie to force him to throw out the min          #fore-"trump" with smallest bigger card          kn = Ken.pop(0)          for i in range(len(Naomi)):              if Naomi[i] > kn:                  #since Naomi[-1] > kn, we'll get here                  Naomi.pop(i)                  break          pts += 1                return pts    def war(Naomi, Ken):      Naomi = Naomi[:]      Ken = Ken[:]      pts = 0      while Naomi and Ken:          #naomi plays her smallest          nm = Naomi.pop(0)          if nm > Ken[-1]:              #if Ken cannot beat, he plays his smallest              Ken.pop(0)              pts += 1          else:              #if he can beat, he finds the smallest above nm              for i in range(len(Ken)):                  if Ken[i] > nm:                      #since Ken[-1] > nm, we'll get here                      Ken.pop(i)                      break                return pts    #clk = clock()    for caseNo in xrange(1, int(input())+1):      #print >>sys.stderr, caseNo      _ = input()      Naomi = sorted(map(float, input().split()))      Ken = sorted(map(float, input().split()))      print 'Case #%d:' % caseNo, deceitfulWar(Naomi, Ken), war(Naomi, Ken)        #print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )      <CODESPLIT> 50
#  # Google Code Jam 2013  # Round 0: B. Lawnmower  # submission by EnTerr  #    '''  Limits    1 <= T <= 100.    Small dataset   1 <= N, M <= 10. 1 <= a[i,j] <= 2.  Large dataset   1 <= N, M <= 100. 1 <= a[i,j] <= 100.    Sample    *** Input   3  3 3  2 1 2  1 1 1  2 1 2  5 5  2 2 2 2 2  2 1 1 1 2  2 1 2 1 2  2 1 1 1 2  2 2 2 2 2  1 3  1 2 1    *** Output   Case #1: YES  Case #2: NO  Case #3: YES    '''    #import psyco  #psyco.full()    import sys  from time import clock    inf = open(sys.argv[1])  def input(): return inf.readline().strip()      def check_lawn(board):      n = len(board)      m = len(board[0])      hmax = map(max, board)      vmax = map(max, zip(*board))      for i in range(n):          for j in range(m):              if board[i][j] < min(hmax[i], vmax[j]):                  return 'NO'      return 'YES'    for caseNo in range(1, int(input())+1):      #tm = clock()      n,m = map(int, input().split())      board = [map(int, input().split()) for _ in range(n)]      print 'Case #%d:' % caseNo, check_lawn(board)      #print >>sys.stderr, caseNo, clock() - tm    <CODESPLIT> 50
#  # Google Code Jam 2014  # Roaund 0: B. Cookie Clicker Alpha  # submission by EnTerr  #    '''  Input  The first line of the input gives the number of test cases, T. T lines follow.   Each line contains three space-separated real-valued numbers: C, F and X.    Output  For each test case, output one line containing "Case #x: y", where x is   the test case number (starting from 1) and y is the minimum number of seconds   it takes before you can have X delicious cookies.    We recommend outputting y to 7 decimal places, but it is not required.   y will be considered correct if it is close enough to the correct number:   within an absolute or relative error of 10^-6.     Limits  1 <= T <= 100.    Small dataset  1 <= C <= 500.  1 <= F <= 4.  1 <= X <= 2000.    Large dataset  1 <= C <= 10000.  1 <= F <= 100.  1 <= X <= 100000.      ---Input    4  30.0 1.0 2.0  30.0 2.0 100.0  30.50000 3.14159 1999.19990  500.0 4.0 2000.0    ---Output   Case #1: 1.0000000  Case #2: 39.1666667  Case #3: 63.9680013  Case #4: 526.1904762    '''        import sys  from time import clock      f = open(sys.argv[1])  def input(): return f.readline().strip();    def bestTime(C, F, X):      #C= cost of cookie farm, ck      #F= farm production, ck/sec      #X= goal, ck      v = 2   #speed of production, cookies/sec      t = 0   #total time of production, sec      while True:          tX = X / v          #time to reach goal at current speed          tC = C / v          #time to buy farm          tXc = X / (v + F)   #time to reach goal after adding farm          if tX <= tC + tXc:              #no more farms              break          #we are buying farm          t += tC          v += F      #finishing at current speed      t += tX      return t    #clk = clock()    for caseNo in xrange(1, int(input())+1):      C, F, X = map(float, input().split())      #print >>sys.stderr, caseNo      print 'Case #%d: %.7f' % (caseNo, bestTime(C, F, X))        #print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )      <CODESPLIT> 50
#  # Google Code Jam 2014  # Roaund 0: A. Magic Trick  # submission by EnTerr  #    '''  ---Input   3  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  3  1 2 5 4  3 11 6 15  9 10 7 12  13 14 8 16  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  3  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16    ---Output   Case #1: 7  Case #2: Bad magician!  Case #3: Volunteer cheated!  '''        import sys  from time import clock      f = open(sys.argv[1])  def input(): return f.readline().strip();               #clk = clock()    for caseNo in xrange(1, int(input())+1):      #first time      row_no = int(input())      for i in 1,2,3,4:          row = input()          if i == row_no:              nums = set(row.split())                    #second time      row_no = int(input())      for i in 1,2,3,4:          row = input()          if i == row_no:              nums &= set(row.split())    #    print >>sys.stderr, caseNo      if not nums:          res = 'Volunteer cheated!'      elif len(nums) > 1:          res = 'Bad magician!'              else:          res = nums.pop()      print 'Case #%d:' % caseNo, res        #print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )    <CODESPLIT> 50
#  # Google Code Jam 2012  # Round 0: A. Speaking in Tongues  # submission by EnTerr  #    '''  Limits: 1 = T = 30. G contains at most 100 characters.  None of the text is guaranteed to be valid English.  Sample    Input  3  ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jv    Output  Case #1: our language is impossible to understand  Case #2: there are twenty six factorial possibilities  Case #3: so it is okay if you want to just give up  '''    #import psyco  #psyco.full()    import sys  #from time import clock    inf = open(sys.argv[1])  def input(): return inf.readline().strip()    knownPairs = [      ('zq', 'qz'),      ('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'),      ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'),      ('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')  ]    xlat = [chr(0) for ch in range(256)]  for crypt, plain in knownPairs:      for a,b in zip(crypt, plain):          xlat[ord(a)] = b  for i in range(26):      xlat[ord('A')+i] = chr(ord(xlat[ord('a')+i]) - ord('a') + ord('A'))  xlat = ''.join(xlat)    for caseNo in range(1, int(input())+1):      #print >>sys.stderr, caseNo      print 'Case #%d:' % caseNo, input().translate(xlat)      <CODESPLIT> 50
#  # Google Code Jam 2013  # Round 0: A. Tic-Tac-Toe-Tomek  # submission by EnTerr  #    '''  Limits  The game board provided will represent a valid state that was reached  through play of the game Tic-Tac-Toe-Tomek as described above.    Small dataset   1 = T = 10.  Large dataset   1 = T = 1000.    *** Sample Input   6  XXXT  ....  OO..  ....    XOXT  XXOO  OXOX  XXOO    XOX.  OX..  ....  ....    OOXX  OXXX  OX.T  O..O    XXXO  ..O.  .O..  T...    OXXX  XO..  ..O.  ...O    ***Output   Case #1: X won  Case #2: Draw  Case #3: Game has not completed  Case #4: O won  Case #5: O won  Case #6: O won    '''    #import psyco  #psyco.full()    import sys  from time import clock    inf = open(sys.argv[1])  def input(): return inf.readline().strip()    import re    # compile "just in case" not to rely on `re` caching  # check horizontal or vertical or diagonal type1 or diag. type2  x_ptrn = re.compile('X{4}|X(.{4}X){3}|X(.{3}X){3}|X(.{5}X){3}')  o_ptrn = re.compile('O{4}|O(.{4}O){3}|O(.{3}O){3}|O(.{5}O){3}')      def check_game_status(board):      if x_ptrn.search(board.replace('T','X')):          return 'X won'      elif o_ptrn.search(board.replace('T','O')):          return 'O won'      elif '.' not in board:          return 'Draw'      else:          return 'Game has not completed'    for caseNo in range(1, int(input())+1):      #tm = clock()      board = '|'.join(input() for _ in range(4))      input() # skip empty line      print 'Case #%d:' % caseNo, check_game_status(board)      #print >>sys.stderr, caseNo, clock() - tm    <CODESPLIT> 50
#  # Google Code Jam 2014  # Roaund 0: C. Minesweeper Master  # submission by EnTerr  #    '''  Input  The first line of the input gives the number of test cases, T. T lines follow.   Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).    Output  For each test case, output a line containing "Case #x:", where x is the test case number.   On the following R lines, output the board configuration with C characters per line,   using '.' to represent an empty cell, '*' to represent a cell that contains a mine,   and 'c' to represent the clicked cell. If there is no possible configuration,   then instead of the grid, output a line with "Impossible" instead.   If there are multiple possible configurations, output any one of them.    Limits  0 <= M < R * C.    Small dataset  1 <= T <= 230.  1 <= R, C <= 5.    Large dataset  1 <= T <= 140.  1 <= R, C <= 50.    Sample  ---Input   5  5 5 23  3 1 1  2 2 1  4 7 3  10 10 82    ---Output   Case #1:  Impossible  Case #2:  c  .  *  Case #3:  Impossible  Case #4:  ......*  .c....*  .......  ..*....  Case #5:  **********  **********  **********  ****....**  ***.....**  ***.c...**  ***....***  **********  **********  **********      '''    import sys  from time import clock    f = open(sys.argv[1])  def input(): return f.readline().strip();    from itertools import product, combinations  def genBoards(R, C, M):      #extra empty/boundary row added at the end (also reached as the one before [0])      #each row has extra empty/boundary element at the end      for mines in combinations( product(range(R), range(C)), M):          board = [ ['.'] * C + [''] for _ in range(R) ]          for row, col in mines:              board[row][col] = '*'          yield board + [[''] * (C+1)]      pass    def oneClickSolution(R, C, M):      for bd in genBoards(R, C, M):          #count number of mines          minTile = 10          for r in range(R):              for c in range(C):                  if bd[r][c] == '.':                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))                      bd[r][c] = `n`                      if n <= minTile:                          minTile = n                          minR, minC = r, c          if minTile < 10:              #use flood from a 0 square, does it reach all 0-s?              queue = [ (minR, minC) ]              nOpen = 0              while queue:                  r,c = queue.pop()                  if bd[r][c] == '0':                      for i in -1,0,1:                          for j in -1,0,1:                              if i or j: # we don't add the one we popped back                                  queue.append( (r+i, c+j) )                  if bd[r][c] not in '.*':                      bd[r][c] = '.'                      nOpen += 1              if M + nOpen == R*C:                  bd[minR][minC] = 'c'                  return '\n'.join( ''.join(row[:-1]) for row in bd[:-1] )        return 'Impossible'      clk = clock()    for caseNo in xrange(1, int(input())+1):      R, C, M = map(int, input().split())      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'      print 'Case #%d:' % caseNo        print oneClickSolution(R, C, M)        print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )    <CODESPLIT> 50
#  # Google Code Jam 2012  # Round 0: C. Recycled Numbers  # submission by EnTerr  #    '''  Limits: 1 <= T <= 50. A and B have the same number of digits.  Small dataset: 1 <= A <= B <= 1000.  Large dataset: 1 <= A <= B <= 2000000    Input   4  1 9  10 40  100 500  1111 2222   	  Output   Case #1: 0  Case #2: 3  Case #3: 156  Case #4: 287    '''    import psyco  psyco.full()    import sys  from time import clock    inf = open(sys.argv[1])  def input(): return inf.readline().strip()    def numRecycled(A,B):      ln = len(str(A))      rot = 10**(ln-1)      cnt = 0      for i in range(A,B+1):          res = set()          j = i          for _ in range(ln-1):              a,b = divmod(j, 10)              j = rot*b + a              if i < j <= B:                  res.add(j)          cnt += len(res)      return cnt    for caseNo in range(1, int(input())+1):      #print >>sys.stderr, caseNo      #tm = clock()      print 'Case #%d:' % caseNo,      A,B = map(int, input().split())      print numRecycled(A,B)      #print A, B, clock() - tm    <CODESPLIT> 50
def checkpalin(s):      k = len(s)//2      for i in range(k):          if s[i]!= s[-1-i]:              return False      return True    goods = [1,2,3]    for i in range(1000):      for j in ['']+list(range(10)):          test = str(i)+str(j)+(str(i)[::-1])          if checkpalin(str(int(test)**2)):              goods.append(int(test))  goods = list(set(goods))  goods.sort()    T = int(input())    for case in range(1,T+1):      A,B = [int(x) for x in input().split()]      ans = 0      for n in goods:          if A <= n*n <= B:              ans += 1      print("Case #",case,": ",ans,sep='')  <CODESPLIT> 51
T=int(input())  for t in range(T):    l = [int(x) for x in input().split()]    n,huh,p = l[:3]    ss = l[3:]    nice, maybe = 0,0    for s in ss:      if s>= p+2*max(p-1,0):        nice += 1      elif s>= p+2*max(p-2,0):        maybe += 1    y = nice + min(maybe,huh)    print('Case #',t+1,': ',y,sep = '')      <CODESPLIT> 51
def findmin(l,y):      for (i,x) in enumerate(l):          if x>y:              return i      return None    T = int(input())  for case in range(1,T+1):      N = int(input())      Ns = [float(x) for x in input().split()]      Ks = [float(x) for x in input().split()]        Ns.sort()      Ks.sort()      bad = 0        Ns1 = Ns[:]      Ks1 = Ks[:]      while Ns1:          y = Ks1.pop()          if Ns1[-1]>y:              i = findmin(Ns1,y)              Ns1[i:i+1]=[]              bad += 1          else:              Ns1[:1] = []        good = 0      Ns2 = Ns[:]      Ks2 = Ks[:]      for x in Ns2:          if Ks2[-1]>x:              i = findmin(Ks2,x)              Ks2[i:i+1]=[]          else:              Ks2[:1]=[]              good += 1        print("Case #",case,": ",bad,' ',good,sep = '')  <CODESPLIT> 51
T = int(input().strip())    for case in range(1,T+1):      N,M = [int(x) for x in input().strip().split()]      lawn = []      for r in range(N):          lawn.append([int(x) for x in input().strip().split()])      rmax = [max(row) for row in lawn]      cmax = [max(lawn[r][c] for r in range(N)) for c in range(M)]      ans = all(lawn[r][c] == min(rmax[r],cmax[c]) for r in range(N) for c in range(M))      ans = "YES" if ans else "NO"      print("Case #",case,": ",ans,sep = '')  <CODESPLIT> 51
from decimal import Decimal    T = int(input())  for case in range(1,T+1):      C,F,X = (Decimal(x) for x in input().split())            ans = X/2      time,rate = 0,2      while True:          if time >= ans:              break          ans = min(ans,(X/rate)+time)          time,rate = time+(C/rate),rate+F      print("Case #",case,": ",ans,sep = '')  <CODESPLIT> 51
T = int(input())  for case in range(1,T+1):      row1 = int(input())      for i in range(1,5):          l = input()          if i==row1:              first = set(int(x) for x in l.split())      row2 = int(input())      for i in range(1,5):          l = input()          if i==row2:              second = set(int(x) for x in l.split())      poss = first & second      if len(poss) ==0:          ans = 'Volunteer cheated!'      elif len(poss) >1:          ans = 'Bad magician!'      else:          ans = min(poss)      print("Case #",case,": ",ans,sep = '')  <CODESPLIT> 51
sub = {}  sub['y']='a'  sub['e']='o'  sub['q']='z'  sub[' ']=' '  sub['z'] = 'q'    pairs = [('ejp mysljylc kd kxveddknmc re jsicpdrysi','our language is impossible to understand'), ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd','there are twenty six factorial possibilities'), ('de kr kd eoya kw aej tysr re ujdr lkgc jv','so it is okay if you want to just give up')]    for (j,(a,b)) in enumerate(pairs):    for i in range(len(a)):      sub[a[i]] = b[i]      #print(a[i],b[i])    #print(''.join(sorted(sub.keys())))  #print(''.join(sorted(sub.values())))    T=int(input())  for i in range(T):    s = input().strip()    new = ''.join([sub[c] for c in s])    print('Case #',i+1,': ',new,sep = '')      <CODESPLIT> 51
T = int(input().strip())    def check(s,ans):      #print(s,ans)      if '.' in s:          return ans if ans < 2 else 3      if 'O' not in s:          return 0      if 'X' not in s:          return 1      return ans    for case in range(1,T+1):      ans = 2      answers = ["X won", "O won", "Draw", "Game has not completed"]      board = [0]*4      for r in range(4):          board[r] = input().strip()      input()      for row in board:          ans = check(row,ans)      for c in range(4):          col = ''.join(board[r][c] for r in range(4))          ans = check(col,ans)      diag = ''.join(board[r][r] for r in range(4))      ans = check(diag,ans)      diag = ''.join(board[r][3-r] for r in range(4))      ans = check(diag,ans)      print("Case #",case,": ",answers[ans],sep = '')  <CODESPLIT> 51
T = int(input())    def solve(R,C,M):      # print('solving',R,C,M)      if R>C:          flipboard = solve(C,R,M)          if flipboard:              return [[flipboard[j][i] for j in range(C)] for i in range(R)]          else:              return      if M==0:          board = [['.']*C for i in range(R)]          board[-1][-1] = 'c'          return board      if R == 1:          board = ['*' if i<M else '.' for i in range(R*C)]          board[-1] = 'c'          return [board]      if R == 2:          if R*C==M+1:              board = [['*']*C for i in range(R)]              board[-1][-1] = 'c'              return board          if (M%2) or (M+2)==(R*C):              return          board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]          board[-1][-1] = 'c'          return board      if M>=R:          subboard = solve(R,C-1,M-R)          if subboard:              return [['*']+r for r in subboard]          return      if (R,C,M) == (3,3,2):          return      k = min(M,C-2)      board = [['*']*k+['.']*(C-k)]      for i in range(M-k):          board.append(['*']+['.']*(C-1))      while len(board)<R:          board.append(['.']*(C))      board[-1][-1] = 'c'      return board                           for case in range(1,T+1):      print("Case #",case,": ",sep='')      R,C,M = (int(x) for x in input().split())      ans = solve(R,C,M)      if ans:          for r in ans:              print(''.join(r))      else:          print('Impossible')      # for M in range(36):  #     ans = solve(6,6,M)  #     if ans:  #         for r in ans:  #             print(''.join(r))  #     else:  #         print('Impossible')  <CODESPLIT> 51
T=int(input())  for t in range(T):      a,b = [int(x) for x in input().split()]      count = 0      l = [0 for i in range(a,b+1)]      for n in range(a,b):          if l[n-a]:              continue          l[n-a]=1          ms = set()          s = str(n)          for i in range(len(s)):              m = int(s[i:]+s[:i])              if n<m<=b:                  l[m-a]=1                  ms.add(m)          case = len(ms)          count+= (case*(case+1))//2      print('Case #',t+1,': ',count,sep = '')  <CODESPLIT> 51
import sys    def is_sym( number ):  	num_str = str( number )  	num_len = len( num_str )  	half_len = int( num_len / 2 )  	end = num_str[-half_len:]  	rev_end = end[::-1]  	start = num_str[:half_len]  	equal = rev_end == start   	return equal    f = open( 'palindromes.out' )    numbers = [ int(x) for x in f.read().split() ]    numCases = input()  for case in range( 1, numCases + 1 ):  	min, max = [ int(x) for x in raw_input().split() ]  	count = 0  	for number in numbers:  		if min <= number and max >= number:  			count += 1    	print 'Case #' + str( case ) + ': ' + str( count )  <CODESPLIT> 52
def build_table():  	table = []  	for i in range( 0, 31 ):  		table.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )    	return table      def get_max_score( i ):  	return max( 0, min( 10, ( i + 2 ) / 3 ) )    def get_max_surprise_score( i ):  	return min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )    def get_max( x, scores, score_needed, num_surprises ):  	scores = sorted( scores, reverse=True )  	numPass = 0  	i = 0;  	while ( i < len(scores) ):  		if ( x[scores[i]][0] >= score_needed ):  			numPass += 1  		else:  			break  		i += 1    	while ( i < len(scores) and num_surprises > 0 ):  		if ( x[scores[i]][1] >= score_needed ):  			numPass += 1  			num_surprises -= 1  			  		i += 1    	return numPass    x = build_table()    num_cases = input()    for i in range( 1, num_cases + 1 ):  	line = raw_input().split()  	num_surprises = int(line[1])  	score_needed = int(line[2])  	scores_raw = line[3:]    	scores = [ int(y) for y in scores_raw ]    	print 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )  <CODESPLIT> 52
import sys  from bisect import bisect_left    numCases = input()  for case in range( 1, numCases + 1 ):    N = input()    Naomis = list( [float(x) for x in raw_input().split() ] )    Kens = list( [float(x) for x in raw_input().split() ] )    Naomis = sorted( Naomis )    Kens = sorted( Kens )      # sim optimal    NaomisOptimal = Naomis[:]    KensOptimal = Kens[:]      KenScore = 0    for i in xrange( 0, N ):      Naomi = NaomisOptimal.pop()      x = bisect_left( KensOptimal, Naomi )      if x < len( KensOptimal ):        KenScore += 1        del KensOptimal[ x ]      else:        del KensOptimal[ 0 ]      NScore = 0    for i in xrange( 0, N ):      Naomi = Naomis[0]      del Naomis[0]      x = bisect_left( Kens, Naomi )      if x == 0:        Kens.pop()      else:        NScore += 1        del Kens[ 0 ]        output = str( NScore ) + ' ' + str( N - KenScore )        print 'Case #' + str( case ) + ': ' + str( output )  <CODESPLIT> 52
import sys    numCases = input()  for case in range( 1, numCases + 1 ):  	sizeX, sizeY = raw_input().split()  	sizeX = int(sizeX)  	sizeY = int(sizeY)  	board = {}  	rowMax = {}  	colMax = {}  	  	for row in range( 0, sizeX ):  		row_raw = raw_input()  		board[ row ] = {}  		col = 0  		for value in row_raw.split():  			board[ row ][ col ] = int(value)  			colMax[ col ] = max( colMax.get(col, 0 ), board[row][col] )  			col += 1    		rowMax[row] = max( board[row].values() )  	  	possible = True  	result = 'YES'  	for row in range( 0, sizeX ):  		for col in range( 0, sizeY ):  			if board[ row ][ col ] != colMax[ col ] and board[ row ][ col ] != rowMax[ row ]:  				possible = False  				break  		if not possible:  			result = 'NO'  			break    	print 'Case #' + str( case ) + ': ' + result   <CODESPLIT> 52
import sys    numCases = input()  for case in range( 1, numCases + 1 ):    C, F, X = raw_input().split()    C = float(C)    F = float(F)    X = float(X)    time = 0.0    rate = 2.0        while ( True ):      timeToFinish = X / rate      timeToFarm   = C / rate      farmPayoffTime = C / F        if timeToFinish < ( timeToFarm + farmPayoffTime ):        time += timeToFinish        break      else:        time += timeToFarm        rate += F        output = '{0:0.15f}'.format( time )      print 'Case #' + str( case ) + ': ' + str( output )  <CODESPLIT> 52
import sys    numCases = input()  for case in range( 1, numCases + 1 ):    row1 = input()    grid1 = []    for i in range( 0, 4 ):      grid1.append( raw_input().split() )      cards = grid1[ row1 - 1 ]      row2 = input()    grid2 = []    for i in range( 0, 4 ):      grid2.append( raw_input().split() )      bad = True            cards2 = grid2[ row2 - 1 ]      numPossibleAnswers = 0    for card in cards:      for card2 in cards2:        if ( card == card2 ):          if numPossibleAnswers == 0:            output = card          numPossibleAnswers += 1          break      if numPossibleAnswers == 0:      output = "Volunteer cheated!"    elif numPossibleAnswers > 1:      output = "Bad magician!"      print 'Case #' + str( case ) + ': ' + str( output )  <CODESPLIT> 52
import sys    translation = { 'a' : 'y', 'b' : 'h', 'c' : 'e', 'd' : 's', 'e' : 'o', 'f' : 'c', 'g' : 'v', 'h' : 'x',  'i' : 'd', 'j' : 'u', 'k' : 'i', 'l' : 'g', 'm' : 'l', 'n' : 'b', 'o' : 'k', 'p' : 'r', 'q' : 'z', 'r' : 't',   's' : 'n', 't' : 'w', 'u' : 'j', 'v' : 'p', 'w' : 'f', 'x' : 'm', 'y' : 'a', 'z' : 'q', ' ' : ' ' }    #words = 'ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv'    numCases = input()  for case in range( 1, numCases + 1 ):  	words = raw_input()  	output = ''  	  	for letter in words:  		output = output + translation[letter]    	print 'Case #' + str( case ) + ': ' + output  <CODESPLIT> 52
import sys    def get_winner( row ):  	if row.count( 'X' ) + row.count( 'T' )  == size:  		return 'X won'  	if row.count( 'O' ) + row.count( 'T' )  == size:  		return 'O won'  	return 'Draw'  	    numCases = input()  for case in range( 1, numCases + 1 ):  	size = 4  	board = {}  	full = True  	winner = 'Draw'  	  	for row in range( 0, size ):  		row_raw = raw_input()  		board[row] = row_raw  		if '.' in row_raw:  			full = False    		if winner == 'Draw':  			winner = get_winner( row_raw )  	  	raw_input()    	if winner == 'Draw':  		for col in range( 0, size ):  			row_new = ''  			for row in range( 0, size ):  				row_new += board[row][col]  			winner = get_winner( row_new )  			if winner != 'Draw':  				break    	if winner == 'Draw':  		row_new = ''  		for z in range( 0, size ):  			row_new += board[z][z]  		winner = get_winner( row_new )  		if winner == 'Draw':  			row_new = ''  			for z in range( 0, size ):  				row_new += board[z][size - z - 1]  			winner = get_winner( row_new )  		    	if winner == 'Draw' and not full:  		winner = 'Game has not completed'    	print 'Case #' + str( case ) + ': ' + winner  <CODESPLIT> 52
import sys    def DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines ):    x = []    numSpaces = 0    numMines = 0      gridRows = max( R-2, 0 )    gridCols = max( C-2, 0 )      for r in xrange( 0, R ):      x.append( [] )      for c in xrange( 0, C ):        x[ r ].append( '.' )        numSpaces += 1      if gridMines > 0:      for r in xrange( 0, gridRows ):        if numMines >= gridMines:          break;        for c in xrange( 0, gridCols ):          x[ r ][ c ] = '*'          numMines += 1          numSpaces -= 1          if numMines >= gridMines:            break;      for r in xrange( 0, R ):      if sideMines <= 0:        break      for c in xrange( gridCols, C ):        x[ r ][ c ] = '*'        numMines += 1        numSpaces -= 1        sideMines -= 1        if sideMines <= 0:          break      for c in xrange( 0, C ):      if bottomMines <= 0:        break      for r in xrange( gridRows, R ):        x[ r ][ c ] = '*'        numMines += 1        numSpaces -= 1        bottomMines -= 1        if bottomMines <= 0:          break          x[ R - 1][ C - 1 ] = 'c'        if numMines != M and ( R * C ) - M != 1:      print "ERROR!!!!!!!!!!!!!!!!!!!!!!!!"      print ( R * C ) - M        o = ""      if Flip:      for c in xrange( 0, C ):        for r in xrange( 0, R ):           o += x[ r ][ c ]        o += '\n'    else:      for r in xrange( 0, R ):        for c in xrange( 0, C ):           o += x[ r ][ c ]        o += '\n'      return o[:-1] #strip the extra newline          numCases = input()  for case in xrange( 1, numCases + 1 ):    R, C, M = [int(x) for x in raw_input().split()]      Output = None      Flip = C > R    if Flip:      temp = R      R = C      C = temp      NonMines = ( R * C ) - M    # Special cases first    if ( NonMines == 0 ):      Output = "Impossible"    elif ( C == 1 ):      gridMines = 0      extraMines = M - gridMines      Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )    elif ( NonMines == 2 or  NonMines == 3 ):      Output = "Impossible"    else:      maxGridCols = max( 0, C - 2 )      maxGridRows = max( 0, R - 2 )      gridMines = min( M, maxGridCols * maxGridRows )      extraMines = M - gridMines      extraPairs = ( extraMines + 1 ) / 2      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )      safeExtraPairs = extraPairsSide + extraPairsBottom      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )      blockingPairs = blockingPairsSide + blockingPairsBottom      totalPairs = safeExtraPairs + blockingPairs              if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):        extraMines += 1        gridMines -= 1        if ( NonMines == 1 ):        if extraMines % 2 != 0:          extraMines += 1        blockingPairsSide += 1        blockingPairsBottom += 1            if extraMines % 2 == 0:        sideMines = 2 * ( extraPairsSide + blockingPairsSide )        bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )        Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )      else:        Output = "Impossible"      output = "\n" + Output    print 'Case #' + str( case ) + ': ' + str( output )  <CODESPLIT> 52
import time    def get_num_recycled( number_s, limit ):    num_digits = len(number_s)    num_s = number_s + number_s    num = int(number_s)    r_nums = []    for i in range( 1, num_digits ):      r_num_s = num_s[i:num_digits+i]      r_num = int(r_num_s)      if ( r_num > num and r_num <= limit ):        r_nums.append( r_num )      return len(set(r_nums))      num_cases = input()  for i in range( 1, num_cases + 1 ):    start, limit = raw_input().split()    num_recycled = 0    #start_t = time.clock()    for num in range( int(start), int(limit) + 1 ):       num_recycled += get_num_recycled( str(num), int(limit) )    #end_t = time.clock()    #print start_t, end_t, end_t - start_t    print 'Case #' + str(i) + ': ' + str( num_recycled )  <CODESPLIT> 52
#include<stdio.h>  #include<stdlib.h>  #include<string.h>  char str[1005];  long long a,b;  int palin()  {      int N=strlen(str);      int i,j;      for(i=0,j=N-1;;i++,j--)      {          if(i>j) break;          if(str[i]!=str[j]) return 0;      }      return 1;  }  int pow2palin()  {      long long num;      int N=strlen(str);      sscanf(str,"%I64d",&num);      num=num*num;      if(num>b || num<a) return 0;      else      {          sprintf(str,"%d",num);          if(palin()) return 1;          else return 0;      }  }  main()  {      freopen("C-small-attempt0.in","r",stdin);  	freopen("outX.txt","w",stdout);        int n;      scanf("%d",&n);      int i,j,k;      int countt;      for(i=0;i<n;i++)      {          scanf("%I64d %I64d",&a,&b);          countt=0;          for(j=1;j<=9;j++)          {              sprintf(str,"%d",j*j);              if(j*j>=a && j*j<=b)              {                  if(palin()) countt++;              }          }          for(j=1;j<=9;j++)          {              sprintf(str,"%d",j);              str[1]=j-1+'1';              str[2]='\0';              if(pow2palin()) countt++;                sprintf(str,"%d",j);              str[2]=j-1+'1';              str[3]='\0';              for(k=0;k<=9;k++)              {                  str[1]=k-0+'0';                  if(pow2palin()) countt++;              }          }          for(j=10;j<=99;j++)          {              sprintf(str,"%d",j);              str[2]=str[1];              str[3]=str[0];              str[4]='\0';              if(pow2palin()) countt++;                sprintf(str,"%d",j);              str[3]=str[1];              str[4]=str[0];              str[5]='\0';              for(k=0;k<=9;k++)              {                  str[2]=k-0+'0';                  if(pow2palin()) countt++;              }          }          for(j=100;j<=999;j++)          {              sprintf(str,"%d",j);              str[3]=str[2];              str[4]=str[1];              str[5]=str[0];              str[6]='\0';              if(pow2palin()) countt++;                sprintf(str,"%d",j);              str[4]=str[2];              str[5]=str[1];              str[6]=str[0];              str[7]='\0';              for(k=0;k<=9;k++)              {                  str[3]=k-0+'0';                  if(pow2palin()) countt++;              }          }            printf("Case #%d: %d\n",i+1,countt);      }      scanf(" ");  }  <CODESPLIT> 53
def readFile(file):      name = file[:file.index('.')]      ##print(name)      f = open(file)      fout = open(name+'.out','w')      cases = int(f.readline().strip())      for i in range(cases):          case = f.readline().strip().split()          n = int(case[0])          s = int(case[1])          p = int(case[2])          scores = [int(x) for x in case[3:]]          result = execute(i,n,s,p,scores)          print(result)          fout.write(result)    def execute(index,n,s,p,scores):      print(index,n,s,p,scores)      count=0      tempS = s      triplets = []        for j in range(n):          mean = int(scores[j]/3)          remainder = scores[j]%3            triplet = [mean for x in range(3)]            c = 0          while remainder > 0 :              triplet[c] = triplet[c]+1              remainder-=1              c+=1            triplets.append(triplet)        ##add suprising      for t in triplets:          if t[0] >= p:              count+=1              continue          elif (tempS > 0 and (p-t[0]) == 1 and t[0] == t[1] and t[1] > 0):              #surprise case              t[0]=t[0]+1              t[1]=t[1]-1              count+=1              tempS-=1              continue        print(tempS)      print(triplets)            return ''.join(['Case #',str(index+1),': ',str(count),'\n'])                if __name__ == "__main__":      readFile('B-small-attempt1.in')  <CODESPLIT> 53
#include<stdio.h>  #include<stdlib.h>  #include<string.h>  #include<algorithm>  using namespace std;  #define INF 1000000000  double a[1005],b[1005];  bool chk[1005];  main()  {   	freopen("D-small-attempt0.in","r",stdin);  	freopen("xxx.out","w",stdout);  	int t;  	scanf("%d",&t);  	int i,j,st,ed;  	int n;  	int win1,win2;  	int tcase=1;  	while(t--)  	{  		memset(chk,0,sizeof chk);  		  		scanf("%d",&n);  		for(i=0;i<n;i++) scanf("%lf",&a[i]);  		for(i=0;i<n;i++) scanf("%lf",&b[i]);  		  		sort(a,a+n);  		sort(b,b+n);  		  		/*for(i=0;i<n;i++) printf("%.3lf ",a[i]);  		printf("\n");  		for(i=0;i<n;i++) printf("%.3lf ",b[i]);  		printf("\n");*/  		  		win2=n;  		for(i=n-1;i>=0;i--)  		{  			for(j=0;j<n;j++)  			{  				if(b[j]>a[i] && chk[j]==0)  				{   					chk[j]=1;  					win2--;   					break;   				}  			}  			if(j==n)  			{  				for(j=0;j<n;j++)   				{  					if(chk[j]==0){ chk[j]=1; break; }  				}  			}  		}  		  		st=0;  		ed=n-1;  		win1=n;  		for(i=0;i<n;i++)  		{  			if(a[i] < b[st]){ win1--; ed--; }  			else st++;  		}  		printf("Case #%d: %d %d\n",tcase++,win1,win2);  	}  }    <CODESPLIT> 53
def readFile(file):      name = file[:file.index('.')]      ##print(name)      f = open(file)      fout = open(name+'.out','w')      cases = int(f.readline().strip())      for case in range(cases):          n,m = [int(x) for x in f.readline().split()]          lawn = []          for i in range(n):              row = [int(x) for x in f.readline().split()]              lawn.append(row)          result = execute(case,lawn,n,m)          print(result)          fout.write(result)    def execute(index,lawn,n,m):      print(index,lawn)        result = ''      for i in range(n):          for j in range(m):              h = lawn[i][j]              row = True              column = True              #check row              for x in range(m):                  if h < lawn[i][x]:                      row = False              #check column              for x in range(n):                  if h < lawn[x][j]:                      column = False                if not(row or column):                  result = "NO"                  break          if result:              break        if not result:          result = "YES"            return ''.join(['Case #',str(index+1),': ',str(result),'\n'])      if __name__ == "__main__":      readFile('B-small-attempt0.in')  <CODESPLIT> 53
#include<stdio.h>  #include<stdlib.h>  #include<string.h>  #include<algorithm>  using namespace std;  #define INF 1000000000    main()  {   	freopen("B-small-attempt0.in","r",stdin);  	freopen("xxx.out","w",stdout);  	int t;  	double c,f,x;  	int i;  	int tcase=1;  	  	scanf("%d",&t);  	while(t--)  	{  		scanf("%lf %lf %lf",&c,&f,&x);  		double ans=x/2.0;  		  		for(i=1;;i++)  		{  			if(ans - x/(2+(i-1)*f) + c/(2+(i-1)*f) + x/(2+i*f) > ans) break;  			else ans = ans - x/(2+(i-1)*f) + c/(2+(i-1)*f) + x/(2+i*f);  		}  		printf("Case #%d: ",tcase++);  		printf("%.7lf\n",ans);  	}  }    <CODESPLIT> 53
#include<stdio.h>  #include<stdlib.h>  #include<string.h>  #include<algorithm>  using namespace std;  #define INF 1000000000  int a[5][5];  bool chk[20];  main()  {   	freopen("A-small-attempt0.in","r",stdin);  	freopen("xxx.out","w",stdout);  	int t;  	int r1,r2;  	int cnt=0;  	int jum;  	scanf("%d",&t);  	int tcase=1;  	int i,j;  	while(t--)  	{  		cnt=0;  		memset(chk,0,sizeof chk);  		scanf("%d",&r1);  		for(i=0;i<4;i++)  		{  			for(j=0;j<4;j++)  			{  				scanf("%d",&a[i][j]);  				if(i+1 == r1) chk[a[i][j]]=1;  			}  		}  		scanf("%d",&r2);  		for(i=0;i<4;i++)  		{  			for(j=0;j<4;j++)  			{  				scanf("%d",&a[i][j]);  				if(i+1 == r2)   				{  					if(chk[a[i][j]]){ cnt++; jum=a[i][j]; }  				}  			}  		}  		printf("Case #%d: ",tcase++);  		if(cnt==1) printf("%d\n",jum);  		else if(cnt>1) printf("Bad magician!\n");  		else printf("Volunteer cheated!\n");  	}  }    <CODESPLIT> 53
m = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'q': 'z', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm', 'z': 'q'}    def readFile(file):      name = file[:file.index('.')]      ##print(name)      f = open(file)      fout = open(name+'.out','w')      cases = int(f.readline().strip())      for i in range(cases):          text = f.readline().strip()          result = execute(i,text)          print(result)          fout.write(result)    def execute(index,text):      print(index,text)      t = ''            for c in text :          t += m[c]                  return ''.join(['Case #',str(index+1),': ',str(t),'\n'])              if __name__ == "__main__":      readFile('A-small-attempt0.in')  <CODESPLIT> 53
def readFile(file):      name = file[:file.index('.')]      ##print(name)      f = open(file)      fout = open(name+'.out','w')      cases = int(f.readline().strip())      for case in range(cases):          board = []          for i in range(4):              l = list(f.readline().strip())              board.append(l)          f.readline()                        result = execute(case,board)          print(result)          fout.write(result)    def execute(index,board):      print(index,board)        #fixed      k = 4      g = replaceTO(board)      h = replaceTX(board)        print(g)      print(h)        o = False      x = False      space = False      for i in range(k):          for j in range(k):              c = g[i][j]              if c != '.':                  #check right                                  if checkright(g,i,j,k):                      if c == "O" :                          o = True                      elif c == "X" :                          x = True                                                                #check down                  if checkdown(g,i,j,k):                      if c == "O" :                          o = True                      elif c == "X" :                          x = True                    #check downright                  if checkdownright(g,i,j,k):                      if c == "O" :                          o = True                      elif c == "X" :                          x = True                    #check downleft                  if checkdownleft(g,i,j,k):                      if c == "O" :                          o = True                      elif c == "X" :                          x = True              else:                  space = True        for i in range(k):          for j in range(k):              c = h[i][j]              if c != '.':                  #check right                                  if checkright(h,i,j,k):                      if c == "O" :                          o = True                      elif c == "X" :                          x = True                                        #check down                  if checkdown(h,i,j,k):                      if c == "O" :                          o = True                      elif c == "X" :                          x = True                    #check downright                  if checkdownright(h,i,j,k):                      if c == "O" :                          o = True                      elif c == "X" :                          x = True                    #check downleft                  if checkdownleft(h,i,j,k):                      if c == "O" :                          o = True                      elif c == "X" :                          x = True              else:                  space = True        result = ''      if o and x:          result = "Both"      elif o and not x:          result = "O won"      elif not o and x:          result = "X won"      else:          if space :              result = "Game has not completed"          else:              result = "Draw"            return ''.join(['Case #',str(index+1),': ',str(result),'\n'])    def replaceTO(b):      t=[]      for r in b:          tc = []          t.append(tc)          for c in r:              if c == "T":                  tc.append("O")              else:                  tc.append(c)      return t    def replaceTX(b):      t=[]      for r in b:          tc = []          t.append(tc)          for c in r:              if c == "T":                  tc.append("X")              else:                  tc.append(c)      return t    def checkright(b,i,j,k):      c = b[i][j]            flag = True      for os in range(1,k):          if j+os >= len(b) or c != b[i][j+os]:              flag = False              break      return flag    def checkdown(b,i,j,k):      c = b[i][j]            flag = True      for os in range(1,k):          if i+os >= len(b) or c != b[i+os][j]:              flag = False              break      return flag    def checkdownright(b,i,j,k):      c = b[i][j]            flag = True      for os in range(1,k):          if i+os >= len(b) or j+os >= len(b) or c != b[i+os][j+os]:              flag = False              break      return flag    def checkdownleft(b,i,j,k):      c = b[i][j]            flag = True      for os in range(1,k):          if i+os >= len(b) or j-os < 0 or c != b[i+os][j-os]:              flag = False              break      return flag    if __name__ == "__main__":      readFile('A-small-attempt0.in')  <CODESPLIT> 53
def solve(r, c, m):        size = r*c      free = size - m      if size == m:          #impossible          return None         elif free == 1:          result = []          for i in range(r):              result.append(["*"]*c)          result[0][0] = "c"          return result        elif m == 0:          result = []          for i in range(r):              result.append(["."]*c)          result[0][0] = "c"          return result        elif r == 1 or c == 1:          result = []          for i in range(r):              result.append(["."]*c)            if r==1:              for j in range(m):                  result[0][j] = "*"              result[0][-1] = "c"          elif c==1:              for k in range(m):                  result[k][0] = "*"              result[-1][0] = "c"            return result             else:          result = []          for i in range(r):              result.append(["*"]*c)            import math            dimX = round(math.sqrt(free))          dimY = math.ceil(free/dimX)          take = (dimX * dimY) - free            #print(free, dimX, dimY, take)                    if dimY > c or dimX > r:              #change dim                if dimY <= r and dimX <= c:                  #transpose                  (dimX,dimY) = (dimY,dimX)                else:                  minDim = min(c, r)                  dimX = minDim                  dimY = math.ceil(free/dimX)                  take = (dimX * dimY) - free                    if (dimY > c or dimX > r) and (dimY <= r and dimX <= c):                      #transpose                       (dimX,dimY) = (dimY,dimX)            for i in range(dimX):              for j in range(dimY):                  result[-i-1][-j-1] = "."            #take          diag = 0          tx = 0          ty = 0          for k in range(take):              result[-dimX+tx][-dimY+ty] = "*"                if dimY < dimX:                  #add new row first                  if tx==0:                      tx=ty+1                      ty=0                  else:                      ty += 1                      tx -= 1              else:                  if ty==0:                      ty=tx+1                      tx=0                  else:                      ty -= 1                      tx += 1            #check row          for row in range(r):              count_free = 0              for col in range(c):                  if result[row][col] == ".":                      count_free += 1                if count_free == 1: #fault                  print(printResult(result))                  print(r,c,m,"row check")                  return None            #check col          for col in range(c):              count_free = 0              for row in range(r):                  if result[row][col] == ".":                      count_free += 1                            if count_free == 1: #fault                  print(printResult(result))                  print(r,c,m,"col check")                  return None                        result[-1][-1] = "c"                    return result      def printResult(result):      if not result:          return "Impossible"      else:          t = []          for l in result:              t.append("".join(l))          return "\n".join(t)    def main(file):      f = open(file)      fout = open(file[:-2]+"out", "w")        t = int(f.readline().strip())        for i in range(t):          (r, c, m) = tuple([int(x) for x in f.readline().split()])          result = printResult(solve(r, c, m))            fout.write("Case #%d:\n" % (i+1,))          fout.write(result+"\n")        f.close()      fout.close()      if __name__ == "__main__":      main("C-small-attempt2.in")        #print(printResult(solve(2,5,5)))  <CODESPLIT> 53
def readFile(file):      name = file[:file.index('.')]      ##print(name)      f = open(file)      fout = open(name+'.out','w')      cases = int(f.readline().strip())      for i in range(cases):          case = f.readline().strip().split()          a = int(case[0])          b = int(case[1])          result = execute(i,a,b)          print(result)          fout.write(result)    def execute(index,a,b):      print(index,a,b)      count=0      result=[]        for x in range(a,b+1):          numbers = generateRecycle(x)          for y in numbers:              if y > x and y <= b:                  result.append((x,y))                  count+=1        testValue(result)        #print(count)      #print(result)            return ''.join(['Case #',str(index+1),': ',str(count),'\n'])            def generateRecycle(x):      result =[]      strVal = str(x)      if(len(strVal)>1):          t = strVal          for i in range(len(strVal)):              t = ''.join((t[len(t)-1],t[:len(t)-1]))              if int(t) != x :                  result.append(int(t))                return set(result)        def testValue(result):      for i1 in range(len(result)):          for i2 in range(i1+1,len(result)):              r1 = result[i1]              r2 = result[i2]              if(r1[0]==r2[1] and r1[1]==r2[0]) or (r1[0]==r2[0] and r1[1]==r2[1]):                  print("error",r1,r2)    if __name__ == "__main__":      readFile('C-small-attempt0.in')  <CODESPLIT> 53
from bisect import *  a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]  A = a[:10]  def subdfs(pre, mid, d, t, n):      if d == t:          k = long(''.join([pre, mid, pre[::-1]]))          k = k * k          if k > n:              return [1, 0]          sqk = str(k)          if sqk == sqk[::-1]:              A.append(k)              return [0, 1]          else:              return [0, 0]      res = subdfs(pre + '0', mid, d + 1, t, n)      if res[0]: return res      if not res[1]: return res      res2 = subdfs(pre + '1', mid, d + 1, t, n)      if res2[0]: return [1, res[1] + res2[1]]      return [0, res[1] + res2[1]]    def dfs(d, n):      subdfs('1', '', 0, d, n)      subdfs('2' + '0' * d, '', d, d, n)      subdfs('1', '0', 0, d, n)      subdfs('1', '1', 0, d, n)      subdfs('1', '2', 0, d, n)      subdfs('2' + '0' * d, '0', d, d, n)      subdfs('2' + '0' * d, '1', d, d, n)    def solve(pre):      read_ints = lambda: map(int, raw_input().split())      l, r = read_ints()      cl = bisect_left(A, l)      cr = bisect_right(A, r)      cl_ = cr_ = 0      for i in xrange(40):          if a[i] < l: cl_ += 1      for i in xrange(40):          if a[i] <= r: cr_ += 1      #print pre, cr_ - cl_      print pre, cr - cl    for k in xrange(1, 48):      dfs(k, 10 ** 100 + 1)  A.sort()  N = int(raw_input())  for i in xrange(1, N + 1):      solve("Case #%d:" % i)  <CODESPLIT> 54
T = int(raw_input())  for t in xrange(T):      line = map(int, raw_input().split())      N, S, p = line[0:3]      a = line[3:]      cnt = 0      a.sort(reverse=True)      for x in a:          if (x + 2) / 3 >= p:              cnt += 1          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:              cnt += 1              S -= 1          else:              break      print "Case #%d: %d" % (t + 1, cnt)  <CODESPLIT> 54
from collections import deque  from bisect import *  def solve():      n = int(raw_input())      a = map(float, raw_input().split())      b = map(float, raw_input().split())      a.sort()      b.sort()      da = deque(a)      db = deque(b)      k = 0      while da:          if da[0] < db[0]:              da.popleft()              db.pop()          else:              da.popleft()              db.popleft()              k += 1      print k,      k = 0      for i, x in enumerate(a):          j = bisect(b, x)          k = max(k, j - i)      print k  for t in xrange(int(raw_input())):      print "Case #%d:" % (t+1),      solve()  <CODESPLIT> 54
def solve(pre):      read_ints = lambda: map(int, raw_input().split())      h, w = read_ints()      to = [read_ints() for _ in xrange(h)]      lawn = [[100] * w for _ in xrange(h)]      for i, r in enumerate(to):          cut = max(r)          for j in xrange(w):              lawn[i][j] = min(lawn[i][j], cut)      for i, c in enumerate(zip(*to)):          cut = max(c)          for j in xrange(h):              lawn[j][i] = min(lawn[j][i], cut)      if lawn == to:          print pre, "YES"      else:          print pre, "NO"    n = int(raw_input())  for i in xrange(n):      solve("Case #%d:" % (i + 1))  <CODESPLIT> 54
def solve():      c, f, x = map(float, raw_input().split())      ans = 1e40      cur = 0.0      psp = 2.0      while cur < ans + 1e-8:          ans = min(ans, cur + x / psp)          cur += c / psp          psp += f      return ans  for t in xrange(int(raw_input())):      print "Case #%d: %.7f" % (t + 1, solve())  <CODESPLIT> 54
def solve():      r1 = int(raw_input())      a1 = [map(int, raw_input().split()) for i in xrange(4)]      r2 = int(raw_input())      a2 = [map(int, raw_input().split()) for i in xrange(4)]      ans = -1      for i in xrange(1, 17):          if i in a1[r1-1] and i in a2[r2-1]:              if ans != -1:                  return "Bad magician!"              ans = i      if ans == -1:          return "Volunteer cheated!"      return ans  for t in xrange(int(raw_input())):      print "Case #%d:" % (t + 1), solve()  <CODESPLIT> 54
import string  n = int(raw_input())  S = """  y qee  ejp mysljylc kd kxveddknmc re jsicpdrysi  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd  de kr kd eoya kw aej tysr re ujdr lkgc jv  z  """  T = """  a zoo  our language is impossible to understand  there are twenty six factorial possibilities  so it is okay if you want to just give up  q  """  trans = {}  for i in xrange(len(S)):      trans[S[i]] = T[i]  A = ""  B = ""  for (c, d) in trans.items():      A += c      B += d  for i in xrange(n):      print "Case #%d: %s" % (i + 1, raw_input().strip().translate(string.maketrans(A, B)))  <CODESPLIT> 54
def solve(pre):      b = [raw_input().strip() for _ in xrange(4)]      raw_input()      for s in b + zip(*b) + [''.join(b[i][i] for i in xrange(4)), ''.join(b[3-i][i] for i in xrange(4))]:          for c in 'XO':              if s.count('T') + s.count(c) == 4:                  print pre, c, "won"                  return      if ''.join(b).count('.'):          print pre, "Game has not completed"      else:          print pre, "Draw"    n = int(raw_input())  for i in xrange(n):      solve("Case #%d:" % (i + 1))  <CODESPLIT> 54
from itertools import product  def solve():      h, w, m = map(int, raw_input().split())      if h == 1:          print 'c' + '.' * (h * w - m - 1) + '*' * m      elif w == 1:          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:              print c      elif h * w - m == 1:          print 'c' + '*' * (w - 1)          for _ in xrange(h-1):              print '*' * w      else:          m = h * w - m          for i in xrange(h-1):              for j in xrange(w-1):                  t = (i + 2) * 2 + (j + 2) * 2 - 4                  r = (i + 2) * (j + 2)                  if t <= m <= r:                      a = [['*'] * w for _ in xrange(h)]                      for k in xrange(i+2):                          a[k][0] = '.'                          a[k][1] = '.'                      for k in xrange(j+2):                          a[0][k] = '.'                          a[1][k] = '.'                      for y, x in product(range(2, i+2), range(2, j+2)):                          if y == 1 and x == 1:                              continue                          if t >= m:                              break                          a[y][x] = '.'                          t += 1                      a[0][0] = 'c'                      for s in a:                          print ''.join(s)                      return          print 'Impossible'  for t in xrange(int(raw_input())):      print "Case #%d:" % (t + 1)      solve()  <CODESPLIT> 54
def solve(a, b):      n = len(str(a))      N = 10 ** n      cnt = 0      for x in xrange(a, b):          y = x          S = set([y])          for j in xrange(n-1):              y = y * 10              y += y / N              y %= N              if a <= x < y <= b and y not in S:                  cnt += 1                  S.add(y)      return cnt    T = int(raw_input())  for t in xrange(T):      a, b = map(int, raw_input().split())      print "Case #%d: %d" % (t + 1, solve(a, b))  <CODESPLIT> 54
# coding: utf-8  import sys  import os.path  import itertools  from itertools import groupby    def read(f):      return list( int(v) for v in f.readline().split() )    def answer(f, X, ans):      out = "Case #{}: {}".format(X, ans)      f.write(out)      f.write("\n")      print(out)    def testcases(f):      T = int(f.readline())      for X in range(1, T + 1):          A, B = read(f)          yield X, A, B    def ispalindrome(v):      s = str(v)      for i in range(len(s) // 2):          if s[i] != s[-i-1]:              return False      return True    def main(inf, outf):      MAX = 1000      fslst = []      for i in itertools.count():          if ispalindrome(i):              squere = i * i              print(MAX, squere, ispalindrome(squere))              if squere > MAX:                  break              if ispalindrome(squere):                  fslst.append(squere)      for X, A, B in testcases(inf):          cnt = 0          for fs in fslst:              if A <= fs <= B:                  cnt += 1          answer(outf, X, cnt)    if __name__=="__main__":      infname = sys.argv[1]      outfname = os.path.splitext(infname)[0] + ".out"      with open(infname, "r") as inf:          with open(outfname, "w") as outf:              main(inf, outf)  <CODESPLIT> 55
# coding:utf-8  import sys    def testcases():      with open(sys.argv[1], "r") as f:          f.readline()  # skip number of testcases          for X, T in enumerate(f, 1):              yield X, [int(t) for t in T.split()]    def main():      for X, T in testcases():          N = T[0]   # the number of Googlers          S = T[1]   # the number of surprising triplets of scores          p = T[2]   # best result of at least            y = 0            for t in T[3:]:              d, m = divmod(t, 3)              if m == 0:                  if p <= d:                      y += 1                  elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:                      y += 1                      S -= 1              elif m == 1:                  if p <= d + 1:                      y += 1              else:                  if p <= d + 1:                      y += 1                  elif p <= d + 2 and S:                      y += 1                      S -= 1            print("Case #{:d}: {:d}".format(X, y))    if __name__=="__main__":      main()  <CODESPLIT> 55
# coding: utf-8  import sys  import os.path  import itertools  from itertools import groupby  import math    def debug(v):      pass#print(v)    def read(f):      t = tuple(int(v) for v in f.readline().split())      debug(t)      return t    def readf(f):      t = tuple(float(v) for v in f.readline().split())      debug(t)      return t    def answer(f, X, Y, Z):      out = "Case #{}: {} {}".format(X, Y, Z)      f.write(out)      f.write("\n")      print(out)        def main(inf, outf):      T, = read(inf)      for casenmbr in range(1, T + 1):          N = read(inf)          naomi_blks = sorted(readf(inf))          ken_blks = sorted(readf(inf))          # print("------")          # print(naomi_blks)          # print(ken_blks)            y = len([None for naomi in naomi_blks if ken_blks[0] < naomi])            z = 0          for naomi in naomi_blks:              for i in range(len(ken_blks)):                  if naomi < ken_blks[i]:                      del ken_blks[i]                      break              else:                  z += 1                  del ken_blks[0]            answer(outf, casenmbr, y, z)      if __name__=="__main__":      infname = sys.argv[1]      outfname = os.path.splitext(infname)[0] + ".out"      with open(infname, "r") as inf:          with open(outfname, "w") as outf:              main(inf, outf)  <CODESPLIT> 55
# coding: utf-8  import sys  import os.path  from itertools import groupby    def read(f):      return list( int(v) for v in f.readline().split() )    def answer(f, X, ans):      out = "Case #{}: {}".format(X, ans)      f.write(out)      f.write("\n")      print(out)    def testcases(f):      T = int(f.readline())      for X in range(1, T + 1):          N, M = read(f)          GRASS = []          for n in range(N):              GRASS.append( read(f) )          result = yield X, N, M, GRASS    def main(inf, outf):      for X, N, M, GRASS in testcases(inf):          maxN = list( max(gn) for gn in GRASS )          maxM = list( max( gn[m] for gn in GRASS ) for m in range(M) )            ans = "YES"          for n, m in ( (n, m) for m in range(M) for n in range(N) ):              if ( GRASS[n][m] < maxN[n] and                   GRASS[n][m] < maxM[m] ):                  ans = "NO"                  break                    answer(outf, X, ans)    if __name__=="__main__":      infname = sys.argv[1]      outfname = os.path.splitext(infname)[0] + ".out"      with open(infname, "r") as inf:          with open(outfname, "w") as outf:              main(inf, outf)  <CODESPLIT> 55
# coding: utf-8  import sys  import os.path  import itertools  from itertools import groupby  import math    def debug(v):      pass#print(v)    def read(f):      t = tuple(int(v) for v in f.readline().split())      debug(t)      return t    def readf(f):      t = tuple(float(v) for v in f.readline().split())      debug(t)      return t    def answer(f, X, ans):      out = "Case #{}: {}".format(X, ans)      f.write(out)      f.write("\n")      print(out)        def main(inf, outf):      T, = read(inf)      for casenmbr in range(1, T + 1):          C, F, X = readf(inf)            power = 2          farmtime = round(C / power, 7)          keikatime = 0          totaltime = round(X / power, 7)            while True:              keikatime += farmtime              power += F              farmtime = round(C / power, 7)              nokoritime = round(X / power, 7)              if keikatime + nokoritime > totaltime:                  break              totaltime = keikatime + nokoritime            answer(outf, casenmbr, totaltime)      if __name__=="__main__":      infname = sys.argv[1]      outfname = os.path.splitext(infname)[0] + ".out"      with open(infname, "r") as inf:          with open(outfname, "w") as outf:              main(inf, outf)  <CODESPLIT> 55
# coding: utf-8  import sys  import os.path  import itertools  from itertools import groupby  import math    def debug(v):      pass #print(v)    def read(f):      t = tuple(int(v) for v in f.readline().split())      debug(t)      return t    def answer(f, X, ans):      out = "Case #{}: {}".format(X, ans)      f.write(out)      f.write("\n")      print(out)        def main(inf, outf):      T, = read(inf)      for X in range(1, T + 1):          row1, = read(inf)          cards1 = tuple(read(inf) for i in range(4))          row2, = read(inf)          cards2 = tuple(read(inf) for i in range(4))            kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])            if kouho:              if len(kouho) == 1:                  ans = kouho.pop()              else:                  ans = "Bad magician!"          else:              ans = "Volunteer cheated!"            answer(outf, X, ans)      if __name__=="__main__":      infname = sys.argv[1]      outfname = os.path.splitext(infname)[0] + ".out"      with open(infname, "r") as inf:          with open(outfname, "w") as outf:              main(inf, outf)  <CODESPLIT> 55
import sys    def testcases():      with open(sys.argv[1], "r") as f:          f.readline()  # skip number of testcases          for X, T in enumerate(f, 1):              yield X, T[:-1]    def main():      for X, T in testcases():          tbl = str.maketrans("abcdefghijklmnopqrstuvwxyz",                              "yhesocvxduiglbkrztnwjpfmaq")          S = T.translate(tbl)          print("Case #{:d}: {}".format(X, S))    if __name__=="__main__":    main()      <CODESPLIT> 55
# coding: utf-8  import sys  from itertools import groupby    def testcases():      with open(sys.argv[1], "r") as f:          T = int(f.readline())          for X in range(1, T + 1):              BOARD = [                  f.readline().strip(),                  f.readline().strip(),                  f.readline().strip(),                  f.readline().strip(),              ]              f.readline()              yield X, BOARD    def main():      for X, BOARD in testcases():          points = [0] * 10          for iR, cols in enumerate(BOARD):              cols = list( p(c) for c in cols )                #               points[iR] = sum(cols)                # c              for iC, c in enumerate(cols):                  points[4 + iC] += c  # c                #               points[8] += cols[0 + iR]              points[9] += cols[3 - iR]            status = "Draw"          for pp in points:              if pp >= 1000:                  status = "Game has not completed"              elif pp in (4, 103):                  status = "X won"                  break              elif pp in (40, 130):                  status = "O won"                  break            print("Case #{}: {}".format(X, status))      def p(c):      if  c == 'X':          return 1      elif c == 'O':          return 10      elif c == 'T':          return 100      else:          return 1000    if __name__=="__main__":      main()  <CODESPLIT> 55
# coding: utf-8  import sys  import os.path  import itertools  from itertools import groupby  import math    def debug(v):      pass#print(v)    def read(f):      t = tuple(int(v) for v in f.readline().split())      debug(t)      return t    def readf(f):      t = tuple(float(v) for v in f.readline().split())      debug(t)      return t    def answer(f, X, ans):      out = "Case #{}:\n{}".format(X, ans)      f.write(out)      f.write("\n")      print(out)    def answer_cells(f, X, cells):      out = "Case #{}:".format(X)      f.write(out)      f.write("\n")      print(out)      for row in cells:          out = "".join(row)          f.write(out)          f.write("\n")          print(out)    def main(inf, outf):      T, = read(inf)      for casenmbr in range(1, T + 1):          R, C, M = read(inf)            if M == 0:              cells = [['.'] * C for i in range(R)]              cells[0][0] = 'c'              answer_cells(outf, casenmbr, cells)              continue            empty = R * C - M            if empty == 1:              cells = [['*'] * C for i in range(R)]              cells[0][0] = 'c'              answer_cells(outf, casenmbr, cells)              continue            if R == 1 or C == 1:              cells = [['.'] * C for i in range(R)]              m = 0              for r in range(R):                  for c in range(C):                      cells[r][c] = '*'                      m += 1                      if m == M:                          break                  else:                      continue                  break              cells[-1][-1] = 'c'              answer_cells(outf, casenmbr, cells)              continue            if empty in (2, 3, 5, 7):              answer(outf, casenmbr, "Impossible")              continue            if (R == 2 or C == 2) and empty % 2:              answer(outf, casenmbr, "Impossible")              continue            cells = [['*'] * C for i in range(R)]              cells[0][0] = 'c'          empty -= 1          cc = 1          rr = 1          while empty > 0:              if cc < C:                  for r in range(rr):                      if empty == 2 and r == rr - 1:                          break                      cells[r][cc] = '.'                      empty -= 1                      if empty == 0:                          break                  cc += 1              if rr < R and empty > 0:                  for c in range(cc):                      if empty == 2 and c == cc - 1:                          break                      cells[rr][c] = '.'                      empty -= 1                      if empty == 0:                          break                  rr += 1                        # cnt = 0          # for row in cells:          #     for v in row:          #         if v == '*':          #             cnt += 1          # if cnt != M:          #     raise "!"          answer_cells(outf, casenmbr, cells)      if __name__=="__main__":      infname = sys.argv[1]      outfname = os.path.splitext(infname)[0] + ".out"      with open(infname, "r") as inf:          with open(outfname, "w") as outf:              main(inf, outf)  <CODESPLIT> 55
import sys    def testcases():      with open(sys.argv[1], "r") as f:          f.readline()  # skip number of testcases          for X, T in enumerate(f, 1):              yield X, [int(t) for t in T.split()]    def main():      for X, T in testcases():          A = T[0]          B = T[1]          y = 0          strA = str(A)          for n in range(B, A - 1, - 1):              b = str(n)              chk = set()              for i in range(1, len(b)):                  a = b[i:] + b[:i]                  if a not in chk and strA <= a < b:                      chk.add(a)                      y += 1            print("Case #{:d}: {:d}".format(X, y))    if __name__=="__main__":      main()  <CODESPLIT> 55
def sqrt(x, ge):      if x == 1:          return 1      sx = x >> 1      step = sx >> 1        while step:          if sx ** 2 >= x:              sx = sx - step          else:              sx = sx + step          step = step >> 1        if ge:          while not sx ** 2 < x:              sx = sx - 1          while not sx ** 2 >= x:              sx = sx + 1      else:          while not sx ** 2 > x:              sx = sx + 1          while not sx ** 2 <= x:              sx = sx - 1        return sx      def get_start_pali(a):      s = str(a)      ls = len(s)      if ls == 1:          return s, True      elif ls & 1:          return s[:ls >> 1 + 1], True      else:          return s[:ls >> 1], False      def get_next_pali(p, m):      if len(p) == p.count("9"):          if m:              return "1" + "0" * (len(p) - 1), False          else:              return "1" + "0" * len(p), True      else:          return str(int(p) + 1), m      def pali_to_num(p, m):      if m:          return int(p + p[-2::-1])      else:          return int(p + p[::-1])      def is_pali(a):      s = str(a)      hls = len(s) >> 1      return s[:hls] == s[:-hls - 1:-1]    for i in range(int(input())):      a, b = tuple(map(int, input().split()))      sqa, sqb = sqrt(a, True), sqrt(b, False)        p, m = get_start_pali(sqa)      while pali_to_num(p, m) < sqa:          p, m = get_next_pali(p, m)        count = 0        while True:          curr = pali_to_num(p, m)          if curr > sqb:              break          if is_pali(curr ** 2):              count = count + 1          p, m = get_next_pali(p, m)        print("Case #{}: {}".format(i + 1, count))  <CODESPLIT> 56
def passes(p, t): #normal, surprising      q, r = divmod(t, 3)      if r == 0:          return q >= p, q + 1 >= p and q      elif r == 1:          return q + 1 >= p, q + 1 >= p and q      elif r == 2:          return q + 1 >= p, q + 2 >= p    for case in range(int(input())):      st = input().strip().split()      n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))      result = 0      for i in t:          normal, surprising = passes(p, i)          if normal:              result += 1          elif surprising and s != 0:              result += 1              s -= 1      print("Case #{}: {}".format(case + 1, result))  <CODESPLIT> 56
import collections  import functools  import operator      def optimal_war_step(blocks, value):        win_blocks = set(filter(lambda block: block > value, blocks))      blocks.discard(min(win_blocks if win_blocks else blocks))      return bool(win_blocks)      def deceitful_war(ken, naomi, epsilon = 10 ** (-6)):        while ken:            min_ken = min(ken)          max_ken = max(ken)          min_naomi = min(naomi)            if min_ken > min_naomi and any(map(lambda bs: operator.lt(*bs), zip(sorted(naomi), sorted(ken)))):                yield max_ken - epsilon            else:                yield 1.0 - epsilon            naomi.discard(min_naomi)      for i in range(int(input())):        input()      naomi = set(map(float, str.split(input())))      ken = set(map(float, str.split(input())))        dwar_ken = ken.copy()      dwar_naomi = naomi.copy()      dwar = collections.Counter(map(functools.partial(optimal_war_step, dwar_ken), deceitful_war(dwar_ken, dwar_naomi)))      war = collections.Counter(map(functools.partial(optimal_war_step, ken), naomi))      print(str.format("Case #{}: {} {}", i + 1, dwar[False], war[False]))  <CODESPLIT> 56
from itertools import chain      for i in range(int(input())):      n, m = tuple(map(int, input().split()))      l = dict(chain.from_iterable(map(lambda j: zip(zip([j] * m, range(m)), map(int, input().split())), range(n))))      ans = "YES"        while len(l):          ly, lx = min(l, key=l.get)          lowest = l[(ly, lx)]            if all(map(lambda j: l.get((ly, j), lowest) == lowest, range(m))):              for j in range(m):                  l.pop((ly, j), None)            elif all(map(lambda j: l.get((j, lx), lowest) == lowest, range(n))):              for j in range(n):                  l.pop((j, lx), None)            else:              ans = "NO"              break        print("Case #{}: {}".format(i + 1, ans))  <CODESPLIT> 56
for i in range(int(input())):        c, f, x = tuple(map(float, str.split(input())))        base_time = 0.0      base_rate = 2.0      farms_count = 0      best_time = None        current_time = base_time + x / (base_rate + farms_count * f)        while best_time is None or best_time > current_time:            best_time = current_time          base_time += c / (base_rate + farms_count * f)          farms_count += 1            current_time = base_time + x / (base_rate + farms_count * f)        print(str.format("Case #{}: {}", i + 1, best_time))  <CODESPLIT> 56
def read_case():        answer = int(input())      lines = tuple(map(lambda _: set(str.split(input())), range(4)))      return lines[answer - 1]      for i in range(int(input())):        intersection = read_case() & read_case()      count = len(intersection)      if count == 1:            answer = intersection.pop()        elif count > 1:            answer = "Bad magician!"        elif count < 1:            answer = "Volunteer cheated!"        print(str.format("Case #{}: {}", i + 1, answer))  <CODESPLIT> 56
for case in range(int(input())):      a, b = tuple(map(int, input().split()))      result = 0      ast, bst = str(a), str(b)      for x in range(a, b + 1):          xst = str(x)          added = list()          for j in range(len(xst)):              xstr = xst[j:] + xst[:j]              if xstr < ast or xstr > bst:                  continue              elif xst < xstr and xstr not in added:                  added.append(xstr)                  result += 1      print("Case #{}: {}".format(case + 1, result))  <CODESPLIT> 56
def yoba(s, ch):      lines = [True] * 10      for i in range(4):          for j in range(4):              lines[j] = lines[j] and (s[i][j] in (ch, "T"))              lines[j + 4] = lines[j + 4] and (s[j][i] in (ch, "T"))          lines[8] = lines[8] and (s[i][i] in (ch, "T"))          lines[9] = lines[9] and (s[3 - i][i] in (ch, "T"))      return any(lines)    for i in range(int(input())):      s = tuple(map(lambda _: input(), range(4)))        if yoba(s, "X"):          ans = "X won"      elif yoba(s, "O"):          ans = "O won"      elif "." not in "".join(s):          ans = "Draw"      else:          ans = "Game has not completed"        input()      print("Case #{}: {}".format(i + 1, ans))  <CODESPLIT> 56
import itertools      '''  ...  ...  ...  ...  ...  '''    for i in range(int(input())):        r, c, m = tuple(map(int, str.split(input())))      count = r * c - m      field = dict(map(lambda c: (c, "*"), itertools.product(range(c), range(r))))      answer = "Impossible"        if m == 0:            answer = field        elif 1 in (r, c):            for p in itertools.islice(itertools.product(range(c), range(r)), count):                field[p] = "."            answer = field        elif count in (0, 2, 3, 5, 7):            pass        elif count == 1:            answer = field        elif count // 2 < c or count == c * 2 + 1:            if count % 2 != 0:                tail = 3              ncount = count - 3            else:                tail = 0              ncount = count            for x in range(ncount // 2):                field[(x, 0)] = field[(x, 1)] = "."            for x in range(tail):                field[(x, 2)] = "."            answer = field        elif not (c == 2 and count % c == 1):            for x in range(c):                field[(x, 0)] = field[(x, 1)] = "."            count -= 2 * c          tail = 0          if count % c == 1:                tail = 2              count -= 1            y = 2          while count > 0:                rx = min(count, c)              for x in range(rx):                    field[(x, y)] = "."                count -= rx              y += 1            for x in range(tail):                field[(x, y)] = "."            answer = field        field[(0, 0)] = "c"      print(str.format("Case #{}:", i + 1))      if isinstance(answer, dict):            for y in range(r):                print(str.join("", map(lambda x: field[(x, y)], range(c))))        else:            print(answer)  <CODESPLIT> 56
for case in range(int(input())):      a, b = tuple(map(int, input().split()))      result = 0      ast, bst = str(a), str(b)      for x in range(a, b + 1):          xst = str(x)          added = list()          for j in range(len(xst)):              xstr = xst[j:] + xst[:j]              if xstr < ast or xstr > bst:                  continue              elif xst < xstr and xstr not in added:                  added.append(xstr)                  result += 1      print("Case #{}: {}".format(case + 1, result))  <CODESPLIT> 56
import codejam    possibles = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]    for case in xrange(codejam.readint()):      A, B = map(int, codejam.readstring().split())      count = 0      for possible in possibles:          if A > possible:              continue            if B < possible:              break            count += 1        print "Case #%d: %d" % (case + 1, count)  <CODESPLIT> 57
import sys    def readint():      return int(sys.stdin.readline())    def readintarray():      return map(int, sys.stdin.readline().strip().split())    def readpairs(start=0):      elems = readintarray()[start:]      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]    def readstring():      return sys.stdin.readline()[:-1]    <CODESPLIT> 57
import sys    def readint():      return int(sys.stdin.readline())    def readfloatarray():      return map(float, sys.stdin.readline().strip().split())    def readintarray():      return map(int, sys.stdin.readline().strip().split())    def readpairs(start=0):      elems = readintarray()[start:]      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]    def readstring():      return sys.stdin.readline()[:-1]    <CODESPLIT> 57
import sys    def readint():      return int(sys.stdin.readline())    def readintarray():      return map(int, sys.stdin.readline().strip().split())    def readpairs(start=0):      elems = readintarray()[start:]      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]    def readstring():      return sys.stdin.readline()[:-1]    <CODESPLIT> 57
import sys    def readint():      return int(sys.stdin.readline())    def readfloatarray():      return map(float, sys.stdin.readline().strip().split())    def readintarray():      return map(int, sys.stdin.readline().strip().split())    def readpairs(start=0):      elems = readintarray()[start:]      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]    def readstring():      return sys.stdin.readline()[:-1]    <CODESPLIT> 57
import sys    def readint():      return int(sys.stdin.readline())    def readintarray():      return map(int, sys.stdin.readline().strip().split())    def readpairs(start=0):      elems = readintarray()[start:]      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]    def readstring():      return sys.stdin.readline()[:-1]    <CODESPLIT> 57
from codejam import *  from string import maketrans    inp = "ejp mysljylc kd kxveddknmc re jsicpdrysi"\        "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"\        "de kr kd eoya kw aej tysr re ujdr lkgc jv zq"  out = "our language is impossible to understand"\      "there are twenty six factorial possibilities"\      "so it is okay if you want to just give up qz"    for case in xrange(readint()):      trantab = maketrans(inp, out)      line = readstring()      print "Case #%d: %s" % (case + 1, line.translate(trantab))  <CODESPLIT> 57
import sys    def readint():      return int(sys.stdin.readline())    def readintarray():      return map(int, sys.stdin.readline().strip().split())    def readpairs(start=0):      elems = readintarray()[start:]      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]    def readstring():      return sys.stdin.readline()[:-1]    <CODESPLIT> 57
import time  import itertools    from codejam import *      directions = list(itertools.product([1, 0, -1], [1, 0, -1]))  def count_neighbors(table, r, c):      cols = len(table[0])      rows = len(table)      return sum(table[r + x][c + y] == "*" for x, y in directions                   if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)    def is_valid(table):      cols = len(table[0])      rows = len(table)      for r in xrange(rows):          for c in xrange(cols):              has_zero = any(table[r + x][c + y] == 0 for x, y in directions                               if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)              if table[r][c] != "*" and not has_zero:                  return False        return True      def draw_table(table, hide=False):      cols = len(table[0])      rows = len(table)      ascii_table = ""      for r in xrange(rows):          for c in xrange(cols):              if table[r][c] != "*":                  ch = "c" if r == 0 and c == 0 else "."                  table[r][c] = count_neighbors(table, r, c) if not hide else ch                ascii_table += str(table[r][c])            ascii_table += "\n"        return ascii_table[:-1]    def solve(R, C, M):      r = c = 0      current_mines = R * C      table = [["*"] * C for k in xrange(R)]      while M < current_mines:          if table[r][c] == '*':              table[r][c] = "."              current_mines -= 1            if current_mines > M and r + 1 < R and table[r+1][c] == "*":              table[r+1][c] = "."              current_mines -= 1            draw_table(table)          c += 1          if c >= C:              c = 0              r += 1        return table    for i in xrange(readint()):      R, C, M = readintarray()        print "Case #%d:" % (i + 1)      if M < (R * C) - 1:          table = solve(R, C, M)          if is_valid(table):              print draw_table(table, hide=True)          else:              table = solve(C, R, M)              rotated = [["*"] * C for k in xrange(R)]              for r in xrange(R - 1, -1, -1):                  for c in xrange(C):                      rotated[R - r - 1][c] = table[c][r]                print draw_table(rotated, hide=True) if is_valid(rotated) else "Impossible"        elif M == R * C:          print "Impossible"        else:          table = [["*"] * C for k in xrange(R)]          table[0][0] = '.'          print draw_table(table, hide=True)  <CODESPLIT> 57
from codejam import *    for case in xrange(readint()):      A, B = readintarray()      res = 0      for i in xrange(A, B + 1):          for j in xrange(i + 1, B + 1):              ist = str(i)              jst = str(j)              if len(ist) != len(jst):                  continue                if ist in (jst + jst):                  res += 1        print "Case #%d: %d" % (case + 1, res)  <CODESPLIT> 57
import sys  import time  import itertools #use combinations!  import math    def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case  	with file(filepath, 'rb') as f_in:  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			yield line_index, line.strip().split(' ')    def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case  	with file(filepath, 'rb') as f_in:  		case_counter = 1  		case = []  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			case.append(line.strip().split(' '))  			if not line_index % n:  				yield case_counter, case  				case_counter += 1  				case = []    def iterate_cases_glpc(filepath):		#glpc - given lines per case  	with file(filepath, 'rb') as f_in:  		case_counter = 0  		new_case = True  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			if new_case:  				new_case = False  				case_counter += 1  				case = []  				assert len(line.strip().split(' ')) == 1  				lines_left = int(line.strip())  				if not lines_left:  					new_case = True  					yield case_counter, case  				continue  			if lines_left:  				lines_left -= 1  				case.append(line.strip().split(' '))  			if not lines_left:  				new_case = True  				yield case_counter, case  			  def part_of_list_to_int(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(int(elem))  		else:  			output.append(elem)  	return output    def list_to_int(array):  	return part_of_list_to_int(array, [True] * len(array))    def part_of_list_to_float(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(float(elem))  		else:  			output.append(elem)  	return output    def list_to_float(array):  	return part_of_list_to_float(array, [True] * len(array))    def get_max_array_on_index(array, index):  	elem_len = len(array[0])  	assert index < elem_len  	for elem in array:  		assert elem_len == len(elem)  	max_sub = array[0][index]  	max_elem = array[0]  	for elem in array:  		if elem[index] > max_sub:  			max_sub = elem[index]  			max_elem = elem  	return max_elem    def list_index_in_sorted_with_position(a_list, value, pos):  	list_len = len(a_list)  	if list_len == 1:  		if a_list[0] == value:  			return pos  		return -1  	if a_list[list_len/2] > value:  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)  	else:  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))  	  def list_index_in_sorted_list(a_list, value):  	return list_index_in_sorted_with_position(a_list, value, 0)  	  ############################################################  #### add solution here 									####  #### don't forget to change data from str to int/float  ####  ############################################################  def check_palindrome(value):  	val_str = str(value)  	length = len(val_str)  	for i in xrange(length):  		if val_str[i] != val_str[length - 1 - i]:  			return False  	return True  	#print "\t\t%d: '%s'" % (value, val_str)    def calc_result(case):  	A = int(case[0])  	B = int(case[1])  	  	A_sqrt = int(math.ceil(math.sqrt(A)))  	B_sqrt = int(math.floor(math.sqrt(B)))  	  	print "\tinterval: %s" % [A, B]  	print "\tsqrt_int: %s" % [A_sqrt, B_sqrt]  	  	count = 0  	for i in xrange(A_sqrt, B_sqrt + 1):  		if check_palindrome(i):  			if check_palindrome(i * i):  				count += 1  				print "\tfound: %d, %d" % (i, i * i)  	  	print "\ttot: %d" % count  	print   	result = "%s" % count  	return result    def main(filepath):  	start_time = time.time()  	with file('output.txt', 'wb') as f_out:  		  		######################################  		#### select input iteration type: ####  		####	- iterate_cases_1lpc	  ####  		####	- iterate_cases_nlpc +n	  ####  		####	- iterate_cases_glpc	  ####  		######################################  		for case_index, case in iterate_cases_1lpc(filepath):  			  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)  			result = calc_result(case)  			  			#######################  			#### format output ####  			#######################  			f_out.write("Case #%d: %s\n" % (case_index, result))  				  if __name__ == '__main__':  	main(sys.argv[1])  <CODESPLIT> 58
import sys    class Triplet(object):  	def __init__(self, i, j, k):  		self.i = i  		self.j = j  		self.k = k  		self.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))  		self.valid = self.max_diff <= 2  		self.surprise = self.max_diff == 2  	  	def get_tuple(self):  		return (self.i, self.j, self.k)  	  	def get_redundancies(self):  		return [(self.i, self.j, self.k),  				(self.i, self.k, self.j),  				(self.j, self.i, self.k),  				(self.j, self.k, self.i),  				(self.k, self.i, self.j),  				(self.k, self.j, self.i)]    class Googler(object):  	def __init__(self, total_points):  		self.total_points = total_points  		self.regular_triplets = []  		self.surprise_triplets = []  		  		for i in xrange(0, 11):  			if i > total_points:  				break  			for j in xrange(i, 11):  				if i + j > total_points:  					break  				k = total_points - i - j  				if k > 10:  					break  				triplet = Triplet(i, j, k)  				self.add(triplet)  		  		self.can_surprise = len(self.surprise_triplets) > 0  		self.actual_triplet = None  		self.best_result = -1  		  	def add(self, triplet):  		if not triplet.valid:  			return  		if triplet.surprise:  			self.add_uniquely(triplet, is_surprise=True)  		else:  			self.add_uniquely(triplet, is_surprise=False)  			  	def add_uniquely(self, triplet, is_surprise):  		if is_surprise:  			input_list = self.surprise_triplets  		else:  			input_list = self.regular_triplets  		for triplet_redundancy in triplet.get_redundancies():  			if triplet_redundancy in input_list:  				return  		input_list.append(triplet.get_tuple())  	  	def __str__(self):  		return "regular: %s\nsurprise: %s" % (self.regular_triplets,  											  self.surprise_triplets)  	  	def set_googler(self, is_surprise=False):  		if not is_surprise:  			self.actual_triplet = self.regular_triplets[0]  		else:  			self.actual_triplet = self.surprise_triplets[0]  		self.calc_best_result()  	  	def calc_best_result(self):  		self.best_result = max(self.actual_triplet)    		  class Contest(object):  	def __init__(self, num_of_googlers, results):  		self.num = num_of_googlers  		self.googlers = []  		for i in xrange(self.num):  			self.googlers.append(Googler(results[i]))  	  	def calc(self, num_of_surprises, p):  		max_googlers_over_p = 0  		for surprise_perm in self.get_permutations(num_of_surprises):  			if not self.validate_permutation(surprise_perm):  				continue  			count = 0  			for index, googler in enumerate(self.googlers):  				googler.set_googler(index in surprise_perm)  				if googler.best_result >= p:  					count += 1  			if count >= max_googlers_over_p:  				max_googlers_over_p = count  		return max_googlers_over_p  	  	def get_permutations(self, num_of_surprises):  		results = get_perms(0, self.num, num_of_surprises)  		if not results:  			return [[]]  		return results  	  	def validate_permutation(self, perm):  		for googler_index in perm:  			if not self.googlers[googler_index].can_surprise:  				return False  		return True    def get_perms(start_index, finish_index, amount):  	if amount == 0:  		return []  	result_list = []  	for i in xrange(start_index, finish_index):  		if amount == 1:  			result_list.append([i])  			continue  		for result in get_perms(i + 1, finish_index, amount - 1):  			new_result = [i]  			new_result.extend(result)  			result_list.append(new_result)  	return result_list  		  def main(filepath):  	with file('dancing_output.txt', 'wb') as f_out:  		with file(filepath, 'rb') as f_in:  			for line_index, line in enumerate(f_in):  				if line_index == 0: #T  					continue  				input_list = line.strip().split(' ')  				num_of_googlers = int(input_list[0])  				num_of_surprises = int(input_list[1])  				p = int(input_list[2])  				results = []  				for res in input_list[3:]:  					results.append(int(res))  				contest = Contest(num_of_googlers, results)  				result = contest.calc(num_of_surprises, p)  				  				print  				print line.strip()  				print result  				  				f_out.write("Case #%d: %d\n" % (line_index, result))  				  if __name__ == '__main__':  	main(sys.argv[1]) <CODESPLIT> 58
import sys  import time  import itertools #use combinations!  import random    def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case  	with file(filepath, 'rb') as f_in:  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			yield line_index, line.strip().split(' ')    def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case  	with file(filepath, 'rb') as f_in:  		case_counter = 1  		case = []  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			case.append(line.strip().split(' '))  			if not line_index % n:  				yield case_counter, case  				case_counter += 1  				case = []    def iterate_cases_glpc(filepath):		#glpc - given lines per case  	with file(filepath, 'rb') as f_in:  		case_counter = 0  		new_case = True  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			if new_case:  				new_case = False  				case_counter += 1  				case = []  				assert len(line.strip().split(' ')) == 1  				lines_left = int(line.strip())  				if not lines_left:  					new_case = True  					yield case_counter, case  				continue  			if lines_left:  				lines_left -= 1  				case.append(line.strip().split(' '))  			if not lines_left:  				new_case = True  				yield case_counter, case  			  def part_of_list_to_int(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(int(elem))  		else:  			output.append(elem)  	return output    def list_to_int(array):  	return part_of_list_to_int(array, [True] * len(array))    def part_of_list_to_float(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(float(elem))  		else:  			output.append(elem)  	return output    def list_to_float(array):  	return part_of_list_to_float(array, [True] * len(array))    def get_max_array_on_index(array, index):  	elem_len = len(array[0])  	assert index < elem_len  	for elem in array:  		assert elem_len == len(elem)  	max_sub = array[0][index]  	max_elem = array[0]  	for elem in array:  		if elem[index] > max_sub:  			max_sub = elem[index]  			max_elem = elem  	return max_elem    def list_index_in_sorted_with_position(a_list, value, pos):  	list_len = len(a_list)  	if list_len == 1:  		if a_list[0] == value:  			return pos  		return -1  	if a_list[list_len/2] > value:  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)  	else:  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))  	  def list_index_in_sorted_list(a_list, value):  	return list_index_in_sorted_with_position(a_list, value, 0)    def copy_list(list):  	res = []  	for elem in list:  		res.append(elem)  	return res	    ############################################################  #### add solution here 									####  #### don't forget to change data from str to int/float  ####  ############################################################    def war_answer_simulator(blocks, choice):  	over_arr = []  	for elem in blocks:  		if elem > choice:  			over_arr.append(elem)  	if not over_arr:  		return min(blocks)  	return min(over_arr)    def war_counter(a, b):  	count = 0  	while len(a) and len(b):  		if a[0] > b[0]:  			count += 1  		else:  			b.pop(0)  		a.pop(0)  	return count    def dec_counter(a, b):  	count = 0  	while len(a) and len(b):  		if a[0] < b[0]:  			pass  		else:  			b.pop(0)  			count += 1  		a.pop(0)  	return count	  	  def solve(N, N_blocks, K_blocks):  	res = None  	  	N_blocks.sort()  	K_blocks.sort()  	N_blocks_copy = copy_list(N_blocks)  	K_blocks_copy = copy_list(K_blocks)  	  	N_blocks_copy.reverse()  	K_blocks_copy.reverse()  	  	war_count = war_counter(N_blocks_copy, K_blocks_copy)  	print 'war', war_count  	  	dec_count = dec_counter(N_blocks, K_blocks)  	print 'dec', dec_count  	  	return '%d %d' % (dec_count, war_count)  	  	  def calc_result(case):  	result = None  	  	N = int(case[0][0])  	N_blocks = list_to_float(case[1])  	K_blocks = list_to_float(case[2])  	print N  	print N_blocks  	print K_blocks  	  	result = solve(N, N_blocks, K_blocks)  	print result  	  	return result    def main(filepath):  	start_time = time.time()  	with file('output.txt', 'wb') as f_out:  		  		######################################  		#### select input iteration type: ####  		####	- iterate_cases_1lpc	  ####  		####	- iterate_cases_nlpc +n	  ####  		####	- iterate_cases_glpc	  ####  		######################################  		for case_index, case in iterate_cases_nlpc(filepath, 3):  			  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)  			result = calc_result(case)  			  			#######################  			#### format output ####  			#######################  			f_out.write("Case #%d: %s\n" % (case_index, result))  				  if __name__ == '__main__':  	main(sys.argv[1])  <CODESPLIT> 58
import sys  import time  import itertools #use combinations!    def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case  	with file(filepath, 'rb') as f_in:  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			yield line_index, line.strip().split(' ')    def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case  	with file(filepath, 'rb') as f_in:  		case_counter = 1  		case = []  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			case.append(line.strip().split(' '))  			if not line_index % n:  				yield case_counter, case  				case_counter += 1  				case = []    def iterate_cases_glpc(filepath):		#glpc - given lines per case  	with file(filepath, 'rb') as f_in:  		case_counter = 0  		new_case = True  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			if new_case:  				new_case = False  				case_counter += 1  				case = []  				assert len(line.strip().split(' ')) == 2  				N = int(line.strip().split(' ')[0])  				M = int(line.strip().split(' ')[1])  				lines_left = N  				case.append(N)  				case.append(M)  				if not lines_left:  					new_case = True  					yield case_counter, case  				continue  			if lines_left:  				lines_left -= 1  				case.append(line.strip().split(' '))  			if not lines_left:  				new_case = True  				yield case_counter, case  			  def part_of_list_to_int(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(int(elem))  		else:  			output.append(elem)  	return output    def list_to_int(array):  	return part_of_list_to_int(array, [True] * len(array))    def part_of_list_to_float(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(float(elem))  		else:  			output.append(elem)  	return output    def list_to_float(array):  	return part_of_list_to_float(array, [True] * len(array))    def get_max_array_on_index(array, index):  	elem_len = len(array[0])  	assert index < elem_len  	for elem in array:  		assert elem_len == len(elem)  	max_sub = array[0][index]  	max_elem = array[0]  	for elem in array:  		if elem[index] > max_sub:  			max_sub = elem[index]  			max_elem = elem  	return max_elem    def list_index_in_sorted_with_position(a_list, value, pos):  	list_len = len(a_list)  	if list_len == 1:  		if a_list[0] == value:  			return pos  		return -1  	if a_list[list_len/2] > value:  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)  	else:  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))  	  def list_index_in_sorted_list(a_list, value):  	return list_index_in_sorted_with_position(a_list, value, 0)  	  ############################################################  #### add solution here 									####  #### don't forget to change data from str to int/float  ####  ############################################################  def test_row(row, value):  	for elem in row:  		if elem > value:  			return False  	return True    def calc_result(case):  	#print "\t%s" % case[2:]  	N = case[0]  	M = case[1]  	rows = []  	for str_row in case[2:]:  		rows.append(list_to_int(str_row))  	#print "\trows: %s" % rows  	columns = []  	for i in xrange(M):  		column = []  		for j in xrange(N):  			column.append(rows[j][i])  		columns.append(column)  	#print "\tcolumns: %s" % columns  	  	for i in xrange(N):  		for j in xrange(M):  			if not (test_row(rows[i], rows[i][j]) or test_row(columns[j], rows[i][j])):  				print "i,j: %d,%d" % (i, j)  				result = "NO"  				print "\t%s" % result  				return result  	  	result = "YES"  	print "\t%s" % result  	return result    def main(filepath):  	start_time = time.time()  	with file('output.txt', 'wb') as f_out:  		  		######################################  		#### select input iteration type: ####  		####	- iterate_cases_1lpc	  ####  		####	- iterate_cases_nlpc +n	  ####  		####	- iterate_cases_glpc	  ####  		######################################  		for case_index, case in iterate_cases_glpc(filepath):  			  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)  			result = calc_result(case)  			  			#######################  			#### format output ####  			#######################  			f_out.write("Case #%d: %s\n" % (case_index, result))  				  if __name__ == '__main__':  	main(sys.argv[1])  <CODESPLIT> 58
import sys  import time  import itertools #use combinations!    def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case  	with file(filepath, 'rb') as f_in:  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			yield line_index, line.strip().split(' ')    def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case  	with file(filepath, 'rb') as f_in:  		case_counter = 1  		case = []  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			case.append(line.strip().split(' '))  			if not line_index % n:  				yield case_counter, case  				case_counter += 1  				case = []    def iterate_cases_glpc(filepath):		#glpc - given lines per case  	with file(filepath, 'rb') as f_in:  		case_counter = 0  		new_case = True  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			if new_case:  				new_case = False  				case_counter += 1  				case = []  				assert len(line.strip().split(' ')) == 1  				lines_left = int(line.strip())  				if not lines_left:  					new_case = True  					yield case_counter, case  				continue  			if lines_left:  				lines_left -= 1  				case.append(line.strip().split(' '))  			if not lines_left:  				new_case = True  				yield case_counter, case  			  def part_of_list_to_int(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(int(elem))  		else:  			output.append(elem)  	return output    def list_to_int(array):  	return part_of_list_to_int(array, [True] * len(array))    def part_of_list_to_float(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(float(elem))  		else:  			output.append(elem)  	return output    def list_to_float(array):  	return part_of_list_to_float(array, [True] * len(array))    def get_max_array_on_index(array, index):  	elem_len = len(array[0])  	assert index < elem_len  	for elem in array:  		assert elem_len == len(elem)  	max_sub = array[0][index]  	max_elem = array[0]  	for elem in array:  		if elem[index] > max_sub:  			max_sub = elem[index]  			max_elem = elem  	return max_elem    def list_index_in_sorted_with_position(a_list, value, pos):  	list_len = len(a_list)  	if list_len == 1:  		if a_list[0] == value:  			return pos  		return -1  	if a_list[list_len/2] > value:  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)  	else:  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))  	  def list_index_in_sorted_list(a_list, value):  	return list_index_in_sorted_with_position(a_list, value, 0)    def copy_list(list):  	res = []  	for elem in list:  		res.append(elem)  	return res	    ############################################################  #### add solution here 									####  #### don't forget to change data from str to int/float  ####  ############################################################    def solve(C, F, X):  	farms_num = 0  	waiting_for_farms = 0  	production_rate = 2  	final_run_time = X / production_rate  	result = final_run_time + waiting_for_farms  	  	print "%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f" % (farms_num,  																				production_rate,  																				final_run_time,  																				waiting_for_farms,  																				result)  		    	  	while True:  		farms_num += 1  		waiting_for_farms += C / production_rate  		production_rate += F  		final_run_time = X / production_rate  		new_result = final_run_time + waiting_for_farms  		print "%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f" % (farms_num,  																					production_rate,  																					final_run_time,  																					waiting_for_farms,  																					new_result)  		if new_result > result:  			return result  		result = new_result  	  def calc_result(case):  	result = None  	  	C = float(case[0])  	F = float(case[1])  	X = float(case[2])  	print C, F, X  	  	result = solve(C, F, X)  	print result  	  	return result    def main(filepath):  	start_time = time.time()  	with file('output.txt', 'wb') as f_out:  		  		######################################  		#### select input iteration type: ####  		####	- iterate_cases_1lpc	  ####  		####	- iterate_cases_nlpc +n	  ####  		####	- iterate_cases_glpc	  ####  		######################################  		for case_index, case in iterate_cases_1lpc(filepath):  			  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)  			result = calc_result(case)  			  			#######################  			#### format output ####  			#######################  			f_out.write("Case #%d: %.07f\n" % (case_index, result))  				  if __name__ == '__main__':  	main(sys.argv[1])  <CODESPLIT> 58
import sys  import time  import itertools #use combinations!    def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case  	with file(filepath, 'rb') as f_in:  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			yield line_index, line.strip().split(' ')    def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case  	with file(filepath, 'rb') as f_in:  		case_counter = 1  		case = []  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			case.append(line.strip().split(' '))  			if not line_index % n:  				yield case_counter, case  				case_counter += 1  				case = []    def iterate_cases_glpc(filepath):		#glpc - given lines per case  	with file(filepath, 'rb') as f_in:  		case_counter = 0  		new_case = True  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			if new_case:  				new_case = False  				case_counter += 1  				case = []  				assert len(line.strip().split(' ')) == 1  				lines_left = int(line.strip())  				if not lines_left:  					new_case = True  					yield case_counter, case  				continue  			if lines_left:  				lines_left -= 1  				case.append(line.strip().split(' '))  			if not lines_left:  				new_case = True  				yield case_counter, case  			  def part_of_list_to_int(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(int(elem))  		else:  			output.append(elem)  	return output    def list_to_int(array):  	return part_of_list_to_int(array, [True] * len(array))    def part_of_list_to_float(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(float(elem))  		else:  			output.append(elem)  	return output    def list_to_float(array):  	return part_of_list_to_float(array, [True] * len(array))    def get_max_array_on_index(array, index):  	elem_len = len(array[0])  	assert index < elem_len  	for elem in array:  		assert elem_len == len(elem)  	max_sub = array[0][index]  	max_elem = array[0]  	for elem in array:  		if elem[index] > max_sub:  			max_sub = elem[index]  			max_elem = elem  	return max_elem    def list_index_in_sorted_with_position(a_list, value, pos):  	list_len = len(a_list)  	if list_len == 1:  		if a_list[0] == value:  			return pos  		return -1  	if a_list[list_len/2] > value:  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)  	else:  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))  	  def list_index_in_sorted_list(a_list, value):  	return list_index_in_sorted_with_position(a_list, value, 0)    def copy_list(list):  	res = []  	for elem in list:  		res.append(elem)  	return res	    ############################################################  #### add solution here 									####  #### don't forget to change data from str to int/float  ####  ############################################################    def intersect(arr_A, arr_B):  	print '\t\t%s\n\t\t%s' % (arr_A, arr_B)  	res = []  	for a in arr_A:  		if arr_B.count(a):  			res.append(a)  	print '\t\t%s' % res  	return res    def solve(row_A_selected, board_A,  		  row_B_selected, board_B):  	res = intersect(board_A[row_A_selected - 1],   					board_B[row_B_selected - 1])  	if len(res) == 0:  		return 'Volunteer cheated!'  	if len(res) == 1:  		return res[0]  	return 'Bad magician!'  	  def calc_result(case):  	result = None  	  	row_A_selected = int(case[0][0])  	row_B_selected = int(case[5][0])  	board_A = case[1:5]  	board_B = case[6:10]  	  	print "row_A_selected: %s" % row_A_selected  	print "row_B_selected: %s" % row_B_selected  	print   	print board_A  	print   	print board_B  	print  	  	result = solve(row_A_selected, board_A,  				   row_B_selected, board_B)  	print result  	  	  	return result    def main(filepath):  	start_time = time.time()  	with file('output.txt', 'wb') as f_out:  		  		######################################  		#### select input iteration type: ####  		####	- iterate_cases_1lpc	  ####  		####	- iterate_cases_nlpc +n	  ####  		####	- iterate_cases_glpc	  ####  		######################################  		for case_index, case in iterate_cases_nlpc(filepath, 10):  			  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)  			result = calc_result(case)  			  			#######################  			#### format output ####  			#######################  			f_out.write("Case #%d: %s\n" % (case_index, result))  				  if __name__ == '__main__':  	main(sys.argv[1])  <CODESPLIT> 58
import sys    class Translation(object):  	def __init__(self):  		self.letters = {}  		self.letters['z'] = 'q'	# from text under 'Problem'  		self.letters['q'] = 'z'  		self.letters[' '] = ' '  		self.count = 0  	  	def update_letter(self, source, image):  		if source in self.letters.keys():  			if self.letters[source] != image:  				raise Exception('old: %s-->%s. new: %s-->%s' % (source,   																self.letters[source],  																source,  																image))  		else:  			self.letters[source] = image  	  	def update_word(self, source, image):  		for char_index, _ in enumerate(source):  			self.update_letter(source[char_index], image[char_index])  	  	def update_line(self, source, image):  		for word_index, _ in enumerate(source.strip().split(' ')):  			self.update_word(source.strip().split(' ')[word_index],  							 image.strip().split(' ')[word_index])  	  	def print_dict(self):  		for i in xrange(ord('a'), ord('z') + 1):  			print "%s-->%s" % (chr(i), self.letters.get(chr(i), 'None'))  	  	def translate_line(self, line):  		out = ""  		for char in line:  			out += self.letters[char]  		return out  		  def main(filepath):  	translation = Translation()  	before = []  	after = []  	with file('tounges_before.txt', 'rb') as f_before:  		for line in f_before:  			before.append(line)  		  	with file('tounges_after.txt', 'rb') as f_after:  		for line in f_after:  			after.append(line)  	  	if len(before) != len(after):  		raise Exception('the before and after files are not of the same size')  	  	for line_index in xrange(len(before)):  		translation.update_line(before[line_index], after[line_index])  	  	translation.print_dict()  	  	with file('tounges_output.txt', 'wb') as f_out:  		with file(filepath, 'rb') as f_in:  			for line_index, line in enumerate(f_in):  				if line_index == 0: #T  					continue  				result = translation.translate_line(line.strip())  				print  				print line.strip()  				print result  				f_out.write("Case #%d: %s\n" % (line_index, result))  			  if __name__ == '__main__':  	main(sys.argv[1]) <CODESPLIT> 58
import sys  import time  import itertools #use combinations!    def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case  	with file(filepath, 'rb') as f_in:  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			yield line_index, line.strip().split(' ')    def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case  	with file(filepath, 'rb') as f_in:  		case_counter = 1  		case = []  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			case.append(line.strip().split(' '))  			if not line_index % n:  				yield case_counter, case  				case_counter += 1  				case = []    def iterate_cases_glpc(filepath):		#glpc - given lines per case  	with file(filepath, 'rb') as f_in:  		case_counter = 0  		new_case = True  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			if new_case:  				new_case = False  				case_counter += 1  				case = []  				assert len(line.strip().split(' ')) == 1  				lines_left = int(line.strip())  				if not lines_left:  					new_case = True  					yield case_counter, case  				continue  			if lines_left:  				lines_left -= 1  				case.append(line.strip().split(' '))  			if not lines_left:  				new_case = True  				yield case_counter, case  			  def part_of_list_to_int(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(int(elem))  		else:  			output.append(elem)  	return output    def list_to_int(array):  	return part_of_list_to_int(array, [True] * len(array))    def part_of_list_to_float(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(float(elem))  		else:  			output.append(elem)  	return output    def list_to_float(array):  	return part_of_list_to_float(array, [True] * len(array))    def get_max_array_on_index(array, index):  	elem_len = len(array[0])  	assert index < elem_len  	for elem in array:  		assert elem_len == len(elem)  	max_sub = array[0][index]  	max_elem = array[0]  	for elem in array:  		if elem[index] > max_sub:  			max_sub = elem[index]  			max_elem = elem  	return max_elem    def list_index_in_sorted_with_position(a_list, value, pos):  	list_len = len(a_list)  	if list_len == 1:  		if a_list[0] == value:  			return pos  		return -1  	if a_list[list_len/2] > value:  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)  	else:  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))  	  def list_index_in_sorted_list(a_list, value):  	return list_index_in_sorted_with_position(a_list, value, 0)  	  ############################################################  #### add solution here 									####  #### don't forget to change data from str to int/float  ####  ############################################################    def check_row(row):  	if row.count('X') == 4:  		return 'X'  	if row.count('O') == 4:  		return 'O'  	if row.count('X') == 3 and row.count('T') == 1:  		return 'X'  	if row.count('O') == 3 and row.count('T') == 1:  		return 'O'  	if row.count('.') > 0:  		return '.'  	return 'F'  		    def calc_result(case):  	case = case[:-1]  	print "\t%s" % case  	  	rows = []  	for row in case:  		#print "\trow: '%s'" % row[0]  		rows.append(row[0])  	  	for i in xrange(4):  		column = ""  		for j in xrange(4):  			column += case[j][0][i]  		#print "\trow: '%s'" % column  		rows.append(column)  	  	diag1 = ""  	diag2 = ""  	for i in xrange(4):  		diag1 += case[i][0][i]  		diag2 += case[3-i][0][i]  	#print "\trow: '%s'" % diag1  	#print "\trow: '%s'" % diag2  	rows.append(diag1)  	rows.append(diag2)  	  	res = []  	for row in rows:  		res.append(check_row(row))  	  	if res.count('X'):  		if res.count('O'):  			raise IOError('both X and O won')  		else:  			result = "X won"  	else:  		if res.count('O'):  			result = "O won"  		else:  			if res.count('.'):  				result = "Game has not completed"  			else:  				result = "Draw"  	  	print "\t%s" % res  	print "\t%s" % result  	  	return result    def main(filepath):  	start_time = time.time()  	with file('output.txt', 'wb') as f_out:  		  		######################################  		#### select input iteration type: ####  		####	- iterate_cases_1lpc	  ####  		####	- iterate_cases_nlpc +n	  ####  		####	- iterate_cases_glpc	  ####  		######################################  		for case_index, case in iterate_cases_nlpc(filepath, 5):  			  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)  			result = calc_result(case)  			  			#######################  			#### format output ####  			#######################  			f_out.write("Case #%d: %s\n" % (case_index, result))  				  if __name__ == '__main__':  	main(sys.argv[1])  <CODESPLIT> 58
import sys  import time  import itertools #use combinations!  import random    def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case  	with file(filepath, 'rb') as f_in:  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			yield line_index, line.strip().split(' ')    def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case  	with file(filepath, 'rb') as f_in:  		case_counter = 1  		case = []  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			case.append(line.strip().split(' '))  			if not line_index % n:  				yield case_counter, case  				case_counter += 1  				case = []    def iterate_cases_glpc(filepath):		#glpc - given lines per case  	with file(filepath, 'rb') as f_in:  		case_counter = 0  		new_case = True  		for line_index, line in enumerate(f_in):  			if line_index == 0: #T  				continue  			if new_case:  				new_case = False  				case_counter += 1  				case = []  				assert len(line.strip().split(' ')) == 1  				lines_left = int(line.strip())  				if not lines_left:  					new_case = True  					yield case_counter, case  				continue  			if lines_left:  				lines_left -= 1  				case.append(line.strip().split(' '))  			if not lines_left:  				new_case = True  				yield case_counter, case  			  def part_of_list_to_int(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(int(elem))  		else:  			output.append(elem)  	return output    def list_to_int(array):  	return part_of_list_to_int(array, [True] * len(array))    def part_of_list_to_float(array, flags):  	assert len(array) == len(flags)  	output = []  	for index, elem in enumerate(array):  		if flags[index]:  			output.append(float(elem))  		else:  			output.append(elem)  	return output    def list_to_float(array):  	return part_of_list_to_float(array, [True] * len(array))    def get_max_array_on_index(array, index):  	elem_len = len(array[0])  	assert index < elem_len  	for elem in array:  		assert elem_len == len(elem)  	max_sub = array[0][index]  	max_elem = array[0]  	for elem in array:  		if elem[index] > max_sub:  			max_sub = elem[index]  			max_elem = elem  	return max_elem    def list_index_in_sorted_with_position(a_list, value, pos):  	list_len = len(a_list)  	if list_len == 1:  		if a_list[0] == value:  			return pos  		return -1  	if a_list[list_len/2] > value:  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)  	else:  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))  	  def list_index_in_sorted_list(a_list, value):  	return list_index_in_sorted_with_position(a_list, value, 0)    def copy_list(list):  	res = []  	for elem in list:  		res.append(elem)  	return res	    ############################################################  #### add solution here 									####  #### don't forget to change data from str to int/float  ####  ############################################################    def conj_mat(a):  	R = len(a)  	C = len(a[0])  	res = [['.' for _ in xrange(R)] for __ in xrange(C)]  	for i in xrange(R):  		for j in xrange(C):  			res[j][i] = a[i][j]  	return res    def one_line_builder(R, C, M):  	res = []  	res.extend(['*'] * M)  	res.extend(['.'] * (C - M))  	res[-1] = 'c'  	return [res]  	  def two_line_builder(R, C, M):  	line = []  	line.extend(['*'] * (M / 2))  	line.extend(['.'] * (C - M / 2))  	res = [line, copy_list(line)]  	res[1][-1] = 'c'  	if M%2 == 1:  		res[0][-1] = '*'  	return res  	  def three_line_builder(R, C, M):  	res = [['.' for _ in xrange(C)] for __ in xrange(R)]  	res[-1][-1] = 'c'  	m = min([M, R * C - 9])  	stop_flag = False  	for j in xrange(C):  		if stop_flag:  			break  		for i in xrange(R):  			if m == 0:  				stop_flag = True  				break  			res[i][j] = '*'  			m -= 1  	print i,j  	if i == 2:  		res[1][j-1] = '.'  		if j == C - 3:  			res[0][j] = '*'  		else:  			res[0][-1] = '*'  	  	if M <= R * C - 9:  		return res  	else:  		m = M - (R * C - 9)  		assert m not in [2, 4, 6, 7, 9]  		assert m > 0  		assert m < 10  		  		res[-3][-3] = '*'  		m -= 1  		if m == 0: return res  		res[-2][-3] = '*'  		res[-1][-3] = '*'  		m -= 2  		if m == 0: return res  		res[-3][-2] = '*'  		res[-3][-1] = '*'  		m -= 2  		if m == 0: return res  		res[-2][-2] = '*'  		res[-2][-1] = '*'  		res[-1][-2] = '*'  		m -= 3  		if m == 0: return res  		assert False  	  	  	  def over_three_line_builder(R, C, M):  	if M <= (R - 3) * C:  		res = [['*' for _ in xrange(C)] for __ in xrange(M / C)]  		flag = False  		if (M % C) != (C - 1):  			line = ['*' for _ in xrange(M % C)]  			line.extend(['.' for _ in xrange(C - (M % C))])  		else:  			line = ['*' for _ in xrange((M % C) - 1)]  			line.extend(['.' for _ in xrange((C - (M % C)) + 1)])  			flag = True  		res.append(line)  		index = len(res)  		res.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])  		if flag:  			res[index][0] = '*'  		res[-1][-1] = 'c'  		assert len(res) == R  		assert len(res[0]) == C  		return res  	else:  		res = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]  		M -= (R - 3) * C  		tmp = three_line_builder(3, C, M)  		if len(tmp) != 3: # error msg  			return tmp  		res.extend(tmp)  		return res  	  def solve(R, C, M):  	res = None  	  	if M == R * C:  		return 'Impossible'  	if R >= 3 and C >= 3:  		if R*C - M in [7, 5, 3, 2]:  			return 'Impossible'  		return over_three_line_builder(R, C, M)  		  	elif R != 1 and C != 1:  #which means one of them is 2, and the other not 1  		if (R*C - M) % 2 == 1:  			if M < R*C - 1:  				return 'Impossible'  		if M + 2 == R * C:  			return 'Impossible'  		else:  			if R == 2:  				return two_line_builder(R, C, M)  			else:  				tmp = two_line_builder(C, R, M)  				return conj_mat(tmp)  	  	else:					#which means one of them is 1  		if R == 1:  			return one_line_builder(R, C, M)  		else:  			tmp = one_line_builder(C, R, M)  			return conj_mat(tmp)  		  	return res    def mat_to_str(a):  	if a in ['Impossible', 'Not Implemented']:  		return a  	str_out = ''  	for row in a:  		for elem in row:  			str_out += elem  		str_out += '\n'  	return str_out[:-1]  	  def calc_result(case):  	result = None  	  	R = int(case[0])  	C = int(case[1])  	M = int(case[2])  	print R, C, M  	  	result = solve(R, C, M)  	  	str_out = mat_to_str(result)  	m = str_out.count('*')  	assert (m==0 or m==M)  	print str_out  	  	return '\n%s' % str_out    def main(filepath):  	start_time = time.time()  	with file('output.txt', 'wb') as f_out:  		  		######################################  		#### select input iteration type: ####  		####	- iterate_cases_1lpc	  ####  		####	- iterate_cases_nlpc +n	  ####  		####	- iterate_cases_glpc	  ####  		######################################  		for case_index, case in iterate_cases_1lpc(filepath):  			  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)  			result = calc_result(case)  			  			#######################  			#### format output ####  			#######################  			f_out.write("Case #%d: %s\n" % (case_index, result))  				  if __name__ == '__main__':  	main(sys.argv[1])  <CODESPLIT> 58
import sys    def cycle_shift(in_str):  	return "%s%s" % (in_str[-1], in_str[:-1])    def get_cyclic_shifts(num):  	results = []  	str_num = str(num)  	for _ in xrange(len(str_num) - 1):  		str_num = cycle_shift(str_num)  		if str_num[0] == '0':  			continue  		number = int(str_num)  		if not number in results:  			results.append(number)  	return results  	  def get_rec_pairs(A, B):  	rec_pairs = []  	for i in xrange(A, B + 1):  		shifts = get_cyclic_shifts(i)  		for shift in shifts:  			if (shift > i and  				shift <= B):  				rec_pairs.append((i, shift))  	return rec_pairs  	  def main(filepath):  	with file('numbers_output.txt', 'wb') as f_out:  		with file(filepath, 'rb') as f_in:  			for line_index, line in enumerate(f_in):  				if line_index == 0: #T  					continue  				input_list = line.strip().split(' ')  				A = int(input_list[0])  				B = int(input_list[1])  				  				rec_pairs = get_rec_pairs(A, B)  				result = len(rec_pairs)  							  				print  				print line.strip()  				print result  				  				f_out.write("Case #%d: %d\n" % (line_index, result))  				  if __name__ == '__main__':  	main(sys.argv[1]) <CODESPLIT> 58
# coding: cp932  import sys  f   = file(sys.argv[1])  out = file(sys.argv[2], 'w')    caseCnt = int(f.readline())    Num = [  	0,  	1,  	4,  	9,  	121,  	484,  	10201,  	12321,  	14641,  	40804,  	44944,  	1002001,  	1234321,  	4008004,  	100020001,  	102030201,  	104060401,  	121242121,  	123454321,  	125686521,  	400080004,  	404090404,  	10000200001,  	10221412201,  	12102420121,  	12345654321,  	40000800004,  	1000002000001,  	1002003002001,  	1004006004001,  	1020304030201,  	1022325232201,  	1024348434201,  	1210024200121,  	1212225222121,  	1214428244121,  	1232346432321,  	1234567654321,  	4000008000004,  	4004009004004,  ]    for case in range(1, caseCnt+1):  	L, H = f.readline().split()  	L = int(L); H = int(H)  	assert L <= H  	  	for i in range(len(Num)):  		if L <= Num[i]:  			break  	else:  		print>>out, 'Case #%d:'%case, 0  		continue    	lb = i - 1    	for i in range(1, len(Num)+1):  		if H >= Num[len(Num)-i]:  			break  	else:  		print>>out, 'Case #%d:'%case, 0  		continue  	ub = len(Num)-i  		  	print>>out, 'Case #%d:'%case, ub - lb    out.close()  <CODESPLIT> 59
# coding: shift-jis    import sys  f = file("B-small-attempt0.in")  #f = file("test.in")  #w = sys.stdout  w = file("answer.txt", "w")  cnt = int(f.readline()[:-1])  for no in range(cnt):  	l = f.readline()[:-1].split()  	T, s, p = map(int, l[:3])  	ts = map(int, l[3:])  	ns = p*3-2 if p*3-2 > 0 else 0  	ss = p*3-4 if p*3-4 > 0 else 31  	l = filter(lambda x: x<ns, ts)  	c = min([len(filter(lambda x: x>=ss, l)), s])  	  	print>>w, "Case #%d:"%(no+1), T-len(l)+c      <CODESPLIT> 59
# coding: cp932      lines = iter('''  4  1  0.5  0.6  2  0.7 0.2  0.8 0.3  3  0.5 0.1 0.9  0.6 0.4 0.3  9  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458  '''.splitlines(False)[1:])  import sys  out = sys.stdout    sys.setrecursionlimit(1500)    lines = iter(open(r'D-small-attempt2.in').readlines(False))  out = open('d-small.answer', 'w')    #lines = iter(open(r'D-large.in').readlines(False))  #out = open('d-large.answer', 'w')    caseCnt = int(next(lines))    def solve(N, K):  	if N == [] and K == []:  		return 0  	if K[-1] > N[-1]:  		return solve(N[:-1], K[1:])  	else:  		return solve(N[:-1], K[:-1])+1    for case in range(1, caseCnt+1):  	C = int(next(lines))  	N = sorted(map(float, next(lines).split()), reverse=True)  	K = sorted(map(float, next(lines).split()), reverse=True)  	  	# if C == 1:  		# if N[0] > K[0]:  			# print('Case #%d: 1 1'%case, file=out)  		# else:  			# print('Case #%d: 0 0'%case, file=out)  		# continue  	  	W=0  	k = 0  	for i, n in enumerate(N):  		if n < K[k]:  			k += 1  		else:  			W += 1  	  	D = solve(N, K)  	print('Case #%d: %d %d'%(case, D, W), file=out)  	#import pdb;pdb.set_trace()  	  <CODESPLIT> 59
# coding: cp932  import sys  f   = file(sys.argv[1])  out = file(sys.argv[2], 'w')    caseCnt = int(f.readline())    for case in range(1, caseCnt+1):  	V, H = f.readline().split()  	V = int(V); H = int(H)  	  	field = [map(int, list(f.readline().split())) for _ in range(V)]  	#print field  	  	rowMax = [max(row) for row in field]  	colMax = [max([row[i] for row in field]) for i in range(H)]  	#print rowMax, colMax  		  	result = 'YES'  	for row in range(V):  		for col in range(H):  			if field[row][col] < rowMax[row] and field[row][col] < colMax[col]:  				result = 'NO'  				break  		else:  			continue  		break  	print>>out, 'Case #%d:'%case, result    out.close()  <CODESPLIT> 59
# coding: cp932      lines = iter('''  5  30.0 1.0 2.0  30.0 2.0 100.0  30.50000 3.14159 1999.19990  500.0 4.0 2000.0  100.0 1.0 100000.0  '''.splitlines(False)[1:])    lines = iter(open(r'B-small-attempt0.in').readlines(False))    caseCnt = int(next(lines))    for case in range(1, caseCnt+1):  	C, F, X = map(float, next(lines).split())  	  	v = 2.0  	total = 0.0  	goal = X/v  	while 1:  		farm = C/v + total  		if farm >= goal:  			answer = goal  			break  		v += F  		total = farm  		if goal > X/v + total:  			goal = X/v + total	  	print('Case #%d: %0.6lf'%(case, answer))  	#import pdb;pdb.set_trace()  	    <CODESPLIT> 59
# coding: cp932    #input = open(r'C:\MyDocument\home\gcj\2014-04-12\a.sample')  input = open(r'C:\MyDocument\home\gcj\2014-04-12\A-small-attempt0.in')  caseCnt = int(input.readline())  for caseNo in range(1, caseCnt+1):  	ans1 = int(input.readline())  	for i in range(1, 5):  		line = input.readline()  		if ans1 == i:  			candidates = set(map(int, line.split()))  		  	ans2 = int(input.readline())  	for i in range(1, 5):  		line = input.readline()  		if ans2 == i:  			answers = candidates.intersection(set(map(int, line.split())))  		  	if len(answers) == 0:  		print('Case #%d: Volunteer cheated!'%caseNo)  	elif len(answers) > 1:  		print('Case #%d: Bad magician!'%caseNo)  	elif len(answers) == 1:  		answer = answers.pop()  		print('Case #%d: %d'%(caseNo, answer))  <CODESPLIT> 59
# coding: shift-jis    a = "abcdefghijklmnopqrstuvwxyz"  d = {}  for c in a:  	d[c] = "*"    i = "ejp mysljylc kd kxveddknmc re jsicpdrysi"  o = "our language is impossible to understand"  for k, v in zip(i, o):  	d[k] = v  i = "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"  o = "there are twenty six factorial possibilities"  for k, v in zip(i, o):  	d[k] = v  i = "de kr kd eoya kw aej tysr re ujdr lkgc jv"  o = "so it is okay if you want to just give up"  for k, v in zip(i, o):  	d[k] = v      i = "y qee"  o = "a zoo"  for k, v in zip(i, o):  	d[k] = v  d['z'] = 'q'  import sys  f = file("A-small-attempt1.in")  #w = sys.stdout  w = file("answer.txt", "w")  cnt = int(f.readline()[:-1])  for no in range(cnt):  	i = f.readline()[:-1]  	o = ""  	for k in i:  		o += d[k]  	print>>w, "Case #%d:"%(no+1), o      <CODESPLIT> 59
# coding: cp932  import sys  f   = file(sys.argv[1])  out = file(sys.argv[2], 'w')    caseCnt = int(f.readline())    for case in range(1, caseCnt+1):  	board = [  		f.readline()[:4],  		f.readline()[:4],  		f.readline()[:4],  		f.readline()[:4],  	]  	f.readline()  	xwin = False  	owin = False  	rest = False  	#   	for row in board:  		if row.replace('T', 'X') == 'XXXX':  			xwin = True  		elif row.replace('T', 'O') == 'OOOO':  			owin = True  		if '.' in row: rest = True  	# c  	for i in range(4):  		col = ''.join([row[i] for row in board])  		if col.replace('T', 'X') == 'XXXX':  			xwin = True  		elif col.replace('T', 'O') == 'OOOO':  			owin = True  	#   	up = ''.join([row[i] for i, row in enumerate(board)])  	if up.replace('T', 'X') == 'XXXX':  		xwin = True  	elif up.replace('T', 'O') == 'OOOO':  		owin = True  	down = ''.join([row[3-i] for i, row in enumerate(board)])  	if down.replace('T', 'X') == 'XXXX':  		xwin = True  	elif down.replace('T', 'O') == 'OOOO':  		owin = True  	  	assert not (xwin==owin==True)  	  	if xwin:  		result = 'X won'  	elif owin:  		result = 'O won'  	elif rest:  		result = 'Game has not completed'  	else:  		result = 'Draw'  		  	print>>out, 'Case #%d:'%case, result    out.close()  <CODESPLIT> 59
# coding: cp932    lines = iter('''  13  5 5 23  3 1 1  1 3 1  2 2 1  4 7 3  10 10 82  10 1 4  1 10 5  2 10 8  10 2 8  2 10 9  10 2 7  5 3 3  '''.splitlines(False)[1:])  import sys  out = sys.stdout    sys.setrecursionlimit(1500)      class MyException(Exception):  	pass  lines = iter(open(r'C-small-attempt7.in').readlines(False))  out = open('c-small.answer', 'w')    #lines = iter(open(r'C-large.in').readlines(False))  #out = open('c-large.answer', 'w')  def solve(C, R, M):  	board = [['.']*C for _ in range(R)]  	board[-1][-1] = 'c'  	try:  		for r in range(R-2):  			for c in range(C-2):  				if r == R-3 and c == C-3:  					raise StopIteration()  				board[r][c] = '*'  				M -= 1  				if M == 0:  					return board   	except StopIteration:  		pass  		  	if M % 2 == 0:  		for r in range(R-3):  			board[r][C-1] = '*'  			board[r][C-2] = '*'  			M -= 2  			if M == 0:  				return board  		for c in range(C-3):  			board[R-1][c] = '*'  			board[R-2][c] = '*'  			M -= 2  			if M == 0:  				return board  		  		  		raise MyException()  	else:  		board[R-3][C-3] = '*'  		M -= 1  		if M == 0:  			return board  		for r in range(R-2):  			board[r][C-1] = '*'  			board[r][C-2] = '*'  			M -= 2  			if M == 0:  				return board  		for c in range(C-2):  			board[R-1][c] = '*'  			board[R-2][c] = '*'  			M -= 2  			if M == 0:  				return board  		  		raise MyException()  		  	  caseCnt = int(next(lines))    for case in range(1, caseCnt+1):  	R,C,M = map(int, next(lines).split())  	  	print('Case #%d:'%case, file=out)  	if M == 0:  		print('c' + '.'*(C-1), file=out)  		for _ in range(R-1):  			print('.'*C, file=out)  	elif R*C==M+1:  		print('c' + '*'*(C-1), file=out)  		for _ in range(R-1):  			print('*'*C, file=out)  	elif C == 1 and R == 1:  		print('Impossible', file=out)  	elif C == 1:  		if M > R-1:  			print('Impossible', file=out)  		else:  			print('c', file=out)  			for _ in range(R-M-1):  				print('.', file=out)  			for _ in range(M):  				print('*', file=out)  	elif R == 1:  		if M > C-1:  			print('Impossible', file=out)  		else:  			print('c' + '.'*(C-M-1) + '*'*M, file=out)  	elif C == 2:  		if M %2 or M//2 > R-2:  			print('Impossible', file=out)  		else:  			print('c.', file=out)  			for _ in range(R-M//2-1):  				print('..', file=out)  			for _ in range(M//2):  				print('**', file=out)  	elif R == 2:  		if M %2 or M//2 > C-2:  			print('Impossible', file=out)  		else:  			print('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)  			print(      '.'*(C-M//2)   + '*'*(M//2), file=out)  	elif M > R*C-4:  		print('Impossible', file=out)  	else:  		try:  			board = solve(C, R, M)  			for line in board:  				print(''.join(line), file=out)  		except MyException:  			print('Impossible', file=out)  	# if C == 1:  		# if N[0] > K[0]:  			# print('Case #%d: 1 1'%case, file=out)  		# else:  			# print('Case #%d: 0 0'%case, file=out)  		# continue  	  	#import pdb;pdb.set_trace()  	  <CODESPLIT> 59
# coding: shift-jis    import sys  #f = file("test.in")  #w = sys.stdout  f = file("C-small-attempt0.in")  w = file("answer.txt", "w")  cnt = int(f.readline()[:-1])  from math import log  for no in range(cnt):  	A, B = map(int, f.readline()[:-1].split())  	  	count = 0  	for n in range(A, B):  		d = int(log(n, 10))+1  		s = set()  		for e in range(1, d):  			c = 10**e  			r = (n % c)*10**(d-e)  			b = n / c  			if r+b>n and r+b<=B and (n, r+b) not in s:  				s.add((n, r+b))  				count += 1  				  	print>>w, "Case #%d:"%(no+1), count      <CODESPLIT> 59
lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,      100020001,102030201,104060401,121242121,123454321,125686521,400080004,      404090404,10000200001,10221412201,12102420121,12345654321,40000800004,      1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,      1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,      1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,      102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,      123456787654321,400000080000004]      def solve(lo,hi):      global lst      count = 0      for i in range(len(lst)):          if (lst[i] >= lo and lst[i] <= hi ):              count += 1      return count    fname = raw_input("name of file: ")  oname = raw_input("output file name:")  f = open(fname,"r")  out = open(oname,"w")  n = int(f.readline()[:-1])  case_num = 1  for line in f:      args = line[:-1].split()      lo = int(args[0])      hi = int(args[1])      out.write("Case #%d: %d\n" %(case_num,solve(lo,hi)))      case_num += 1        out.close()  f.close()        <CODESPLIT> 60
fileName = raw_input("File name: ")    f = open(fileName,"r")    t = int(f.readline()[:-1])    tests = []    for i in range (t):      tests += [f.readline()[:-1]]    f.close()      def compute(raw):      dataN = [] # keeps the max mark for not surprising      dataS = [] # keeps the max marks for surprisings            items = raw.split()             for i in range (int(items[0])):          ti = int(items[3+i])          if ti < 1:              dataS += [0]              dataN += [0]          elif ti > 28:              dataS += [10]              dataN += [10]          else:              dataN += [int((ti+2)/3)] # put the values for all participants              dataS += [int((ti+4)/3)]                                  p = int(items[2])      s = int(items[1])            n_vals = dataN      n_vals.sort()              i=0      minimum = 0 # how many numbers greater than p are there in "not surprising"      if n_vals[0] < p:          while n_vals[-1-i] >= p:              minimum += 1              i += 1      else:          minimum = len(n_vals)                  s_vals = dataS      s_vals.sort()      i=0      maximum = 0 # how many numbers greater than p are there in "surprising"      if s_vals[0] < p:          while s_vals[-1-i] >= p:              maximum += 1              i += 1      else:          maximum = len(n_vals)                    # we can make at most (max) but can take only (min + s)      return min(maximum, minimum+s)           for i in range (t):      print "Case #%d: %d" %(i+1,compute(tests[i]))            <CODESPLIT> 60
filename = raw_input("Name of file: ")  infile = open(filename, "r")  outfile = open(filename + ".out", "w")      T = int(infile.readline()[:-1])  ## Code starts here    def playDecWars(her, his):      n = len(her)      count = 0      while n > 0:          if her[0] < his[0]:              del(her[0])              del(his[-1])          else:              del(her[0])              del(his[0])              count += 1          n -= 1      return count    def playWars(her, his):      n = len(her)      count = 0      while n > 0:          if her[0] > his[-1]:              count += 1              del(her[0])              del(his[0])          else:              his_index = 0              for num in his:                  if num > her[0]:                      break                  his_index += 1              del(her[0])              del(his[his_index])          n -= 1      return count    for t in range(1, T + 1):      n = int(infile.readline()[:-1])      her = infile.readline()[:-1].split(" ")      his = infile.readline()[:-1].split(" ")      her = [float(x) for x in her]      his = [float(x) for x in his]        her.sort()      his.sort()        d_wars = playDecWars(her[:], his[:])      wars = playWars(her[:], his[:])            outfile.write("Case #%d: %d %d\n" % (t, d_wars, wars))                        ## code ends here    outfile.close()  infile.close()  <CODESPLIT> 60
fileName = raw_input("File name: ")  f = open(fileName,"r")      n = int(f.readline()[:-1])    def check_row(board, index):      row = board[index]      M = row[0]      index = 0      for i in range(len(row)):          num = row[i]          if(num > M):              M = num              index = i      for i in range(len(row)):          num = row[i]          if(num < M):              if not check_col(board,i,num):                  return False      return True      def check_col(board,index,number):      for i in range(len(board)):          if board[i][index] > number:              return False      return True    def check_all(board):      for i in range(len(board)):          if not check_row(board, i):              return False      return True         outputFileName = raw_input("output file name: ")  of = open(outputFileName,"w")    for i in range(n):      board = []      mn = f.readline()[:-1].split()      m = int(mn[0])      n = int(mn[1])      for j in range(m):           row = f.readline()[:-1].split()          #print row          row_lst = []          for s in row:              row_lst += [int(s)]          board += [row]      if check_all(board):          of.write( "Case #%d: %s\n" %(i+1, "YES"))      else:          of.write( "Case #%d: %s\n" %(i+1, "NO"))    of.close()  f.close()    #print might_have_finished, boards    ##for i in range(n): # print out  ##    print "Case #%d: %s" %(i+1, translate(cases[i]))                        <CODESPLIT> 60
filename = raw_input("Name of file: ")  infile = open(filename, "r")  outfile = open(filename + ".out", "w")      T = int(infile.readline()[:-1])  ## Code starts here      def getMinTime(c, f, x):      p0 = 2.0      s_prev = x / p0      s_curr = c / p0      prev_item = 0      next_item = x / (p0 + f)      n = 1      while s_prev + prev_item > s_curr + next_item:          s_prev = s_curr          prev_item = next_item          s_curr += c / (p0 + (n * f))          next_item = x / (p0 + ((n + 1) * f))          n += 1      return s_prev + prev_item    for t in range(1, T + 1):      items = infile.readline()[:-1].split(" ")      c = float(items[0])      f = float(items[1])      x = float(items[2])      time = getMinTime(c, f, x)      outfile.write("Case #%d: %.7f\n" %(t, time))                        ## code ends here    outfile.close()  infile.close()  <CODESPLIT> 60
filename = raw_input("Name of file: ")  f = open(filename, "r")  o = open(filename + ".out", "w")      T = int(f.readline()[:-1])  ## Code starts here    many_possible = "Bad magician!"  zero_possible = "Volunteer cheated!"    for t in range(1, T + 1):      first = int(f.readline()[:-1]) - 1      grid1 = []      for i in range(4):          grid1 += [f.readline()[:-1].split(" ")]                second = int(f.readline()[:-1]) - 1      grid2 = []      for i in range(4):          grid2 += [f.readline()[:-1].split(" ")]        possible = []      for num in grid1[first]:          if num in grid2[second]:              possible += [num]        if len(possible) == 1:          o.write("Case #%d: %s\n" %(t, possible[0]))      elif len(possible) == 0:          o.write("Case #%d: %s\n" %(t, zero_possible))      else:          o.write("Case #%d: %s\n" %(t, many_possible))                  ## code ends here    o.close()  f.close()  <CODESPLIT> 60
from string import *  dictionary = {      "a":"y",      "b":"h",      "c":"e",      "d":"s",      "e":"o",      "f":"c",      "g":"v",      "h":"x",      "i":"d",      "j":"u",      "k":"i",      "l":"g",      "m":"l",      "n":"b",      "o":"k",      "p":"r",      "q":"z",      "r":"t",      "s":"n",      "t":"w",      "u":"j",      "v":"p",      "w":"f",      "x":"m",      "y":"a",      "z":"q",      " ":" "          }    def translate(sen):            new_sen = ""        for char in sen: #translate each charecter          new_sen += dictionary[char]                return new_sen    fileName = raw_input("File name: ")  f = open(fileName,"r")    n = int(f.readline()[:-1])  cases = [] #keeps the input msgs    for i in range(n):      cases += [f.readline()[:-1]]    f.close()      for i in range(n): # print out      print "Case #%d: %s" %(i+1, translate(cases[i]))                        <CODESPLIT> 60
fileName = raw_input("File name: ")  f = open(fileName,"r")      n = int(f.readline()[:-1])  boards = []    def check_tuple(row):      has_o = False      has_x = False      for char in row:          if(char == "."):              return (False, "Game has not completed")          if(char == "x" or char == "X"):              has_x = True          if(char == "o" or char == "O"):              has_o = True                if has_o and has_x:          return (False, "Draw")      if has_o:          return (True, "O won")      return (True, "X won")    def check_rows(board):      for row in board:          result = check_tuple(row)          if result[0]:              return result      return (False, "Unknown result")    def check_columns(board):      for i in range(len(board)):          col = ""          col += board[0][i]          col += board[1][i]          col += board[2][i]          col += board[3][i]          result = check_tuple(col)          if result[0]:              return result      return (False, "Unknown result")    def check_diagonals(board):      main_diag = ""      main_diag += board[0][0]      main_diag += board[1][1]      main_diag += board[2][2]      main_diag += board[3][3]      result = check_tuple(main_diag)      if result[0]:          return result            sec_diag = ""      sec_diag += board[0][3]      sec_diag += board[1][2]      sec_diag += board[2][1]      sec_diag += board[3][0]        result = check_tuple(sec_diag)      if result[0]:          return result        return (False,"Unknown reason")                                def check_board(board,might_have_finished):      result = check_rows(board)      if result[0]:          return result[1]            result = check_columns(board)      if result[0]:          return result[1]            result = check_diagonals(board)      if result[0]:          return result[1]        if(might_have_finished):          return "Game has not completed"      return "Draw"                                    for i in range(n):      board = []      might_have_finished = False      for j in range(4):           row = f.readline()[:-1]          #print row          #row_lst = [[row[0]],[row[1]],[row[2]],[row[3]]]          if "." in row:              might_have_finished = True          board += [row]      print "Case #%d: %s" %(i+1, check_board(board,might_have_finished))      f.readline()    f.close()  #print might_have_finished, boards    ##for i in range(n): # print out  ##    print "Case #%d: %s" %(i+1, translate(cases[i]))                        <CODESPLIT> 60
filename = raw_input("Name of file: ")  infile = open(filename, "r")  outfile = open(filename + ".out", "w")      T = int(infile.readline()[:-1])  ## Code starts here    def addMinesDiagonally(r, c, m):      field = []      for i in range (r):          row = []          for j in range(c):              row += ["."]          field += [row]                for i in range (r + c):          ver = min (i, r - 1)          hor = max (0, 1 + i - r)          while ver >= 0 and hor <= c - 1 and m > 0:              if m == 1 and hor == c - 2 and ver == r - 2:                  ver -= 1                  hor += 1              field[ver][hor] = "*"              ver -= 1              hor += 1              m -= 1                return field    def isPossible(field):      if field[-1][-1] != ".":          return False      up = True      left = True      diag = True      if len(field) > 1 and field[-2][-1] != ".":              up = len(field[-1]) <= 1      if len(field[-1]) > 1 and field[-1][-2] != ".":              left = len(field) <= 1      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != ".":          diag = False      return (up and left and diag) or \             ((not up) and (not left) and (not diag))          for t in range(1, T + 1):      items = infile.readline()[:-1].split(" ")      r = int(items[0])      c = int(items[1])      m = int(items[2])      field = addMinesDiagonally(r, c, m)      if isPossible(field):          field[-1][-1] = "c"          s = ""          for line in field:              for cell in line:                  s += cell              s += "\n"          outfile.write("Case #%d:\n%s\n" %(t, s[:-1]))      else:          s = "IMPOSSIBLE!!!!\n"          for line in field:              for cell in line:                  s += cell              s += "\n"          outfile.write("Case #%d:\n%s\n" %(t, s[:-1]))          #outfile.write("Case #%d:\n%s\n" %(t, "Impossible"))                        ## code ends here    outfile.close()  infile.close()  <CODESPLIT> 60
from string import *    def compute(A,B):      start = A        count = 0        while start < B:          temp = str(start)+str(start)[:len(str(start))-1]          for i in range (len(str(start))):              if int(temp[i:len(str(start))+i]) > start and int(temp[i:len(str(start))+i]) <= B:                  count += 1                    start += 1        return count            fileName = raw_input("File name: ")  f = open(fileName,"r")  n = int(f.readline()[:-1])  i=0  for line in f:        items = (line[:-1]).split()      #items.split()        A = int(items[0])      B = int(items[1])      print "Case #%d: %d" %(i+1,compute(A,B))      i+=1        f.close()  <CODESPLIT> 60
#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013  #for the Google Code Jam programming contest    ###############################################################################  # Imports go here  ###############################################################################    from __future__ import division  import numpy as np  import math    ###############################################################################  # Global variables (for caching, etc.) go here  ###############################################################################    #Set up the input/output files: problem-tagsuffix.in / *.out  problem = "C"  tag = "small" #commonly sample, small, or large  #tag = "large"  #tag = "sample"  suffix = "-attempt0" #used sometimes for indexing later input files  #suffix = ""  #From http://oeis.org/A002779/b002779.txt  #Lazy route for the first two sets!  #Numbers that are both squares and palindromes  table_of_fairs = np.array([0, 1, 4, 9, 121, 484, 676, 10201, 12321, 14641,   40804, 44944, 69696, 94249, 698896, 1002001, 1234321, 4008004, 5221225, 6948496,   100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004,   404090404, 522808225, 617323716, 942060249, 10000200001, 10221412201, 12102420121,   12345654321, 40000800004, 637832238736, 1000002000001, 1002003002001, 1004006004001,   1020304030201, 1022325232201, 1024348434201, 1086078706801, 1210024200121,   1212225222121, 1214428244121, 1230127210321, 1232346432321, 1234567654321,   1615108015161, 4000008000004, 4004009004004, 4051154511504, 5265533355625,   9420645460249, 100000020000001, 100220141022001, 102012040210201, 102234363432201,   121000242000121, 121242363242121, 123212464212321, 123456787654321,   123862676268321, 144678292876441, 165551171155561, 400000080000004,   900075181570009, 4099923883299904, 10000000200000001, 10002000300020001,   10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001,   10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201,   10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121,   12120030703002121, 12122232623222121, 12124434743442121, 12321024642012321,   12323244744232321, 12341234943214321, 12343456865434321, 12345678987654321,   40000000800000004, 40004000900040004, 94206450305460249, 1000000002000000001,   1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201,   1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121,   1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321,   1232344458544432321, 1234323468643234321, 4000000008000000004, 4253436912196343524,   6158453974793548516, 100000000020000000001, 100002000030000200001, 100004000060000400001,   100020201040102020001, 100022201252102220001, 100024201484102420001,   100200120040021002001, 100202122050221202001, 100204124080421402001,   100220341262143022001, 100222343474343222001, 102010002040200010201,   102012022050220210201, 102014042080240410201, 102030405060504030201,   102032425272524230201, 102132537636735231201, 102210100272001012201, 102212122262221212201,   102214144272441412201, 102230523292325032201, 102232545484545232201, 102234567696765432201,   104190107303701091401, 121000000242000000121, 121002200252002200121, 121004400282004400121,   121020021070120020121, 121022221262122220121, 121024421474124420121, 121220122262221022121,   121222324272423222121, 121240161292161042121, 121242363484363242121, 121244565696565442121,   123210002464200012321, 123212222474222212321, 123230205292502032321, 123232425484524232321,   123234645696546432321, 123432124686421234321, 123434346696643434321, 184398883818388893481,   400000000080000000004, 400004000090000400004, 522815090696090518225, 906086675171576680609,   942064503484305460249, 6916103777337773016196, 10000000000200000000001, 10000220001410002200001,   10002002100400120020001, 10002222123632122220001, 10020010200400201002001, 10020230421612403202001,   10022014302620341022001, 10022234545854543222001, 10201000020402000010201, 10201222221612222210201,   10203022140604122030201, 10203244363836344230201, 10221210222622201212201, 10221432643834623412201,   10223234344844343232201, 10224609234443290642201, 12100000002420000000121, 12100242003630024200121,  12102202302620320220121, 12102444325852344420121, 12122010222622201022121, 12122252443834425222121,   12124214524842541242121, 12321000024642000012321, 12321244225852244212321, 12323222344844322232321,   12343210246864201234321, 12384043938083934048321, 12599536942224963599521, 16593841302620314839561,   40000000000800000000004, 1000000000002000000000001, 1000002000003000002000001,   1000004000006000004000001, 1000020200104010020200001, 1000022200125210022200001, 1000024200148410024200001, 1000200030004000300020001, 1000202030205020302020001, 1000204030408040304020001, 1000220232126212320220001, 1000222232347432322220001, 1002001002004002001002001, 1002003004005004003002001, 1002005006008006005002001, 1002021222306032221202001, 1002023224327234223202001, 1002201232026202321022001, 1002203234227224323022001, 1002221454348434541222001, 1002223456569656543222001, 1020100000204020000010201, 1020102020205020202010201, 1020104040208020404010201, 1020120402306032040210201, 1020122422327232242210201, 1020300010207020100030201, 1020302030406040302030201, 1020304050607060504030201, 1020320414309034140230201, 1020322434528254342230201, 1020324454749474544230201, 1022121002226222001212201, 1022123024227224203212201, 1022141424528254241412201, 1022143446549456443412201, 1022321210249420121232201, 1022323232448442323232201, 1022325254649464525232201, 1210000000024200000000121, 1210002200025200022000121, 1210004400028200044000121, 1210020020107010200200121, 1210022220126210222200121, 1210024420147410244200121, 1210220032026202300220121, 1210222232227222322220121, 1210242254148414522420121, 1210244454369634544420121, 1212201002226222001022121, 1212203204227224023022121, 1212221040509050401222121, 1212223242528252423222121, 1212225444549454445222121, 1212421234248424321242121, 1212423436449446343242121, 1232100000246420000012321, 1232102220247420222012321, 1232120202329232020212321, 1232122422348432242212321, 1232124642369632464212321, 1232322032448442302232321, 1232324252649462524232321, 1234321002468642001234321, 1234323224469644223234321, 1821056104269624016501281, 4000000000008000000000004, 4000004000009000004000004, 4618627222542452227268164, 6942236477330337746322496, 9420645034800084305460249, 40460195511188111559106404, 100000000000020000000000001, 100000220000141000022000001, 100002002010040010200200001, 100002222012363210222200001, 100020001200040002100020001, 100020221222161222122020001, 100022003410262014300220001, 100022223434585434322220001, 100200100020040020001002001, 100200320240161042023002001, 100202104032060230401202001, 100202324254383452423202001, 100220121220262022121022001, 100220341462383264143022001, 100222125432484234521222001, 102010000002040200000010201, 102010222202161202222010201, 102012022032060230220210201, 102012244234383432442210201, 102030201204060402102030201, 102030423426181624324030201, 102032223434282434322230201, 102212100022262220001212201, 102212322442383244223212201, 102214124054282450421412201, 102232321224484422123232201, 121000000000242000000000121, 121000242000363000242000121, 121002202210262012202200121, 121002444212585212444200121, 121022001220262022100220121, 121022243242383242342220121, 121024203630484036302420121, 121220100022262220001022121, 121220342242383242243022121, 121222304234282432403222121, 121242121242484242121242121, 123210000002464200000012321, 123210244202585202442012321, 123212222232484232222212321, 123232201224484422102232321, 123432100024686420001234321, 400000000000080000000000004, 923860899791363197998068329, 4872133543202112023453312784, 9658137819052882509187318569, 10000000000000200000000000001, 10000002000000300000020000001, 10000004000000600000040000001, 10000020200010401000202000001, 10000022200012521000222000001, 10000024200014841000242000001, 10000200021000400012000200001, 10000202021020502012020200001, 10000204021040804012040200001, 10000220221212621212202200001, 10000222221234743212222200001, 10002000102000400020100020001, 10002002102200500220120020001, 10002004102400800420140020001, 10002020304030603040302020001, 10002022304232723240322020001, 10002200143002620034100220001, 10002202143222722234120220001, 10002220345234843254302220001, 10002222345456965454322220001, 10020010000200400200001002001, 10020012002200500220021002001, 10020014004200800240041002001, 10020030220410601402203002001, 10020032222412721422223002001, 10020210221220602212201202001, 10020212223240704232221202001, 10020230441632823614403202001, 10020232443654945634423202001, 10022010100002720000101022001, 10022012102202620220121022001, 10022014104402720440141022001, 10022030322230903222303022001, 10022032324432823442323022001, 10022034326634943662343022001, 10022210341004940014301222001, 10022212343224842234321222001, 10022214345444944454341222001, 10201000000020402000000010201, 10201002020020502002020010201, 10201004040020802004040010201, 10201020402030603020402010201, 10201022422032723022422010201, 10201200001200700210000210201, 10201202021220602212020210201, 10201204041240704214040210201, 10201220403410901430402210201, 10201222423432823432422210201, 10201224443454945434442210201, 10203020102040604020102030201, 10203022122240704222122030201, 10203040506070807060504030201, 10203042526272927262524030201, 10203220123022922032102230201, 10203222143242824234122230201, 10203224163462926436142230201, 10221210000222622200001212201, 10221212022222722222021212201, 10221230422432823422403212201, 10221232444434943444423212201, 10221412221442824412221412201, 10221414243462926434241412201, 10223232102244844220123232201, 10223234124444944442143232201, 12100000000002420000000000121, 12100002200002520000220000121, 12100004400002820000440000121, 12100020020010701002002000121, 12100022220012621002222000121, 12100024420014741002442000121, 12100220023002620032002200121, 12100222223022722032222200121, 12100242243214841234224200121, 12100244443236963234444200121, 12102200102202620220100220121, 12102202302402720420320220121, 12102220124030903042102220121, 12102222324232823242322220121, 12102224524434943442542220121, 12102420145204840254102420121, 12102422345424942454322420121, 12122010000222622200001022121, 12122012202222722220221022121, 12122032240432823404223022121, 12122034442434943424443022121, 12122230223242824232203222121, 12122232425262926252423222121, 12124212102424842420121242121, 12124214304624942640341242121, 12321000000024642000000012321, 12321002220024742002220012321, 12321020202032923020202012321, 12321022422034843022422012321, 12321024642036963024642012321, 12321222023224842232022212321, 12321224243244944234242212321, 12323220102244844220102232321, 12323222322444944422322232321, 12343210000246864200001234321, 12343212222246964222221234321, 16799008923862526832980099761, 40000000000000800000000000004, 40000004000000900000040000004, 44431002775280908257720013444, 98693567900935453900976539689, 1000000000000002000000000000001, 1000000220000014100000220000001, 1000002002001004001002002000001, 1000002222001236321002222000001, 1000020000300004000030000200001, 1000020220302216122030220200001, 1000022002321026201232002200001, 1000022222323458543232222200001, 1000200010020004000200100020001, 1000200230042016102400320020001, 1000202012221206021222102020001, 1000202232243438343422322020001, 1000220012320026200232100220001, 1000220232344238324432320220001, 1000222014541248421454102220001, 1002001000002004002000001002001, 1002001220222016102220221002001, 1002003004005006005004003002001, 1002003224225238325224223002001, 1002021020302206022030201202001, 1002021240524418144250421202001, 1002023024325228225234203202001, 1002201210022026202200121022001, 1002201430264038304620341022001, 1002203214225228225224123022001, 1002221232322248422232321222001, 1020100000000204020000000010201, 1020100222200216120022220010201, 1020102022021206021202202010201, 1020102244221438341224422010201, 1020120200302206022030020210201, 1020120422504418144052240210201, 1020122222343228223432222210201, 1020302010020406040200102030201, 1020302232242418142422322030201, 1020304032241608061422304030201, 1020322212322428242232122230201, 1022121000002226222000001212201, 1022121222422238322242221212201, 1022123024025228225204203212201, 1022141220304428244030221412201, 1022323210022448442200123232201, 1210000000000024200000000000121, 1210000242000036300002420000121, 1210002202201026201022022000121, 1210002444201258521024442000121, 1210022000320026200230002200121, 1210022242322238322232422200121, 1210024202541048401452024200121, 1210220010022026202200100220121, 1210220252044038304402520220121, 1210222212423228223242122220121, 1210242012342048402432102420121, 1212201000002226222000001022121, 1212201242222238322222421022121, 1212203204205228225024023022121, 1212223020322428242230203222121, 1212421210024248424200121242121, 1232100000000246420000000012321, 1232100244200258520024420012321, 1232102222221248421222222012321, 1232122200322248422230022212321, 1232322010022448442200102232321, 1234321000002468642000001234321, 4000000000000008000000000000004, 4844486878939076709398786844484, 6574372239019762679109322734756, 9403095533541415141453355903049, 9659504223792743472973224059569, 9848294822582726272852284928489  ])    #and here we've filtered the table  filtered_table = np.array([0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001,         1234321, 4008004, 100020001, 102030201, 104060401, 121242121,         123454321, 125686521, 400080004, 404090404, 10000200001,         10221412201, 12102420121, 12345654321, 40000800004, 1000002000001,         1002003002001, 1004006004001, 1020304030201, 1022325232201,         1024348434201, 1210024200121, 1212225222121, 1214428244121,         1232346432321, 1234567654321, 4000008000004, 4004009004004,         100000020000001, 100220141022001, 102012040210201, 102234363432201,         121000242000121, 121242363242121, 123212464212321, 123456787654321,         400000080000004, 10000000200000001, 10002000300020001,         10004000600040001, 10020210401202001, 10022212521222001,         10024214841242001, 10201020402010201, 10203040504030201,         10205060806050201, 10221432623412201, 10223454745432201,         12100002420000121, 12102202520220121, 12104402820440121,         12122232623222121, 12124434743442121, 12321024642012321,         12323244744232321, 12343456865434321, 12345678987654321,         40000000800000004, 40004000900040004, 1000000002000000001,         1000220014100220001, 1002003004003002001, 1002223236323222001,         1020100204020010201, 1020322416142230201, 1022123226223212201,         1022345658565432201, 1210000024200000121, 1210242036302420121,         1212203226223022121, 1212445458545442121, 1232100246420012321,         1232344458544432321, 1234323468643234321, 4000000008000000004,         100000000020000000001, 100002000030000200001, 100004000060000400001,         100020201040102020001, 100022201252102220001, 100024201484102420001,         100200120040021002001, 100202122050221202001, 100204124080421402001,         100220341262143022001, 100222343474343222001, 102010002040200010201,         102012022050220210201, 102014042080240410201, 102030405060504030201,         102032425272524230201, 102212122262221212201, 102214144272441412201,         102232545484545232201, 102234567696765432201, 121000000242000000121,         121002200252002200121, 121004400282004400121, 121022221262122220121,         121024421474124420121, 121220122262221022121, 121222324272423222121,         121242363484363242121, 121244565696565442121, 123210002464200012321,         123212222474222212321, 123232425484524232321, 123234645696546432321,         123432124686421234321, 123434346696643434321, 400000000080000000004,         400004000090000400004, 10000000000200000000001,         10000220001410002200001, 10002002100400120020001,         10002222123632122220001, 10020010200400201002001,         10020230421612403202001, 10022014302620341022001,         10022234545854543222001, 10201000020402000010201,         10201222221612222210201, 10203022140604122030201,         10203244363836344230201, 10221210222622201212201,         10221432643834623412201, 10223234344844343232201,         12100000002420000000121, 12100242003630024200121,         12102202302620320220121, 12102444325852344420121,         12122010222622201022121, 12122252443834425222121,         12124214524842541242121, 12321000024642000012321,         12321244225852244212321, 12323222344844322232321,         12343210246864201234321, 40000000000800000000004,         1000000000002000000000001, 1000002000003000002000001,         1000004000006000004000001, 1000020200104010020200001,         1000022200125210022200001, 1000024200148410024200001,         1000200030004000300020001, 1000202030205020302020001,         1000204030408040304020001, 1000220232126212320220001,         1000222232347432322220001, 1002001002004002001002001,         1002003004005004003002001, 1002005006008006005002001,         1002021222306032221202001, 1002023224327234223202001,         1002201232026202321022001, 1002203234227224323022001,         1002221454348434541222001, 1002223456569656543222001,         1020100000204020000010201, 1020102020205020202010201,         1020104040208020404010201, 1020120402306032040210201,         1020122422327232242210201, 1020302030406040302030201,         1020304050607060504030201, 1020322434528254342230201,         1020324454749474544230201, 1022121002226222001212201,         1022123024227224203212201, 1022141424528254241412201,         1022143446549456443412201, 1022323232448442323232201,         1022325254649464525232201, 1210000000024200000000121,         1210002200025200022000121, 1210004400028200044000121,         1210022220126210222200121, 1210024420147410244200121,         1210220032026202300220121, 1210222232227222322220121,         1210242254148414522420121, 1210244454369634544420121,         1212201002226222001022121, 1212203204227224023022121,         1212223242528252423222121, 1212225444549454445222121,         1212421234248424321242121, 1212423436449446343242121,         1232100000246420000012321, 1232102220247420222012321,         1232122422348432242212321, 1232124642369632464212321,         1232322032448442302232321, 1232324252649462524232321,         1234321002468642001234321, 1234323224469644223234321,         4000000000008000000000004, 4000004000009000004000004,         100000000000020000000000001, 100000220000141000022000001,         100002002010040010200200001, 100002222012363210222200001,         100020001200040002100020001, 100020221222161222122020001,         100022003410262014300220001, 100022223434585434322220001,         100200100020040020001002001, 100200320240161042023002001,         100202104032060230401202001, 100202324254383452423202001,         100220121220262022121022001, 100220341462383264143022001,         100222125432484234521222001, 102010000002040200000010201,         102010222202161202222010201, 102012022032060230220210201,         102012244234383432442210201, 102030201204060402102030201,         102030423426181624324030201, 102032223434282434322230201,         102212100022262220001212201, 102212322442383244223212201,         102214124054282450421412201, 102232321224484422123232201,         121000000000242000000000121, 121000242000363000242000121,         121002202210262012202200121, 121002444212585212444200121,         121022001220262022100220121, 121022243242383242342220121,         121024203630484036302420121, 121220100022262220001022121,         121220342242383242243022121, 121222304234282432403222121,         121242121242484242121242121, 123210000002464200000012321,         123210244202585202442012321, 123212222232484232222212321,         123232201224484422102232321, 123432100024686420001234321,         400000000000080000000000004, 10000000000000200000000000001,         10000002000000300000020000001, 10000004000000600000040000001,         10000020200010401000202000001, 10000022200012521000222000001,         10000024200014841000242000001, 10000200021000400012000200001,         10000202021020502012020200001, 10000204021040804012040200001,         10000220221212621212202200001, 10000222221234743212222200001,         10002000102000400020100020001, 10002002102200500220120020001,         10002004102400800420140020001, 10002020304030603040302020001,         10002022304232723240322020001, 10002200143002620034100220001,         10002202143222722234120220001, 10002220345234843254302220001,         10002222345456965454322220001, 10020010000200400200001002001,         10020012002200500220021002001, 10020014004200800240041002001,         10020030220410601402203002001, 10020032222412721422223002001,         10020210221220602212201202001, 10020212223240704232221202001,         10020230441632823614403202001, 10020232443654945634423202001,         10022012102202620220121022001, 10022014104402720440141022001,         10022032324432823442323022001, 10022034326634943662343022001,         10022212343224842234321222001, 10022214345444944454341222001,         10201000000020402000000010201, 10201002020020502002020010201,         10201004040020802004040010201, 10201020402030603020402010201,         10201022422032723022422010201, 10201202021220602212020210201,         10201204041240704214040210201, 10201222423432823432422210201,         10201224443454945434442210201, 10203020102040604020102030201,         10203022122240704222122030201, 10203040506070807060504030201,         10203042526272927262524030201, 10203222143242824234122230201,         10203224163462926436142230201, 10221210000222622200001212201,         10221212022222722222021212201, 10221230422432823422403212201,         10221232444434943444423212201, 10221412221442824412221412201,         10221414243462926434241412201, 10223232102244844220123232201,         10223234124444944442143232201, 12100000000002420000000000121,         12100002200002520000220000121, 12100004400002820000440000121,         12100022220012621002222000121, 12100024420014741002442000121,         12100220023002620032002200121, 12100222223022722032222200121,         12100242243214841234224200121, 12100244443236963234444200121,         12102200102202620220100220121, 12102202302402720420320220121,         12102222324232823242322220121, 12102224524434943442542220121,         12102420145204840254102420121, 12102422345424942454322420121,         12122010000222622200001022121, 12122012202222722220221022121,         12122032240432823404223022121, 12122034442434943424443022121,         12122230223242824232203222121, 12122232425262926252423222121,         12124212102424842420121242121, 12124214304624942640341242121,         12321000000024642000000012321, 12321002220024742002220012321,         12321022422034843022422012321, 12321024642036963024642012321,         12321222023224842232022212321, 12321224243244944234242212321,         12323220102244844220102232321, 12323222322444944422322232321,         12343210000246864200001234321, 12343212222246964222221234321,         40000000000000800000000000004, 40000004000000900000040000004,         1000000000000002000000000000001, 1000000220000014100000220000001,         1000002002001004001002002000001, 1000002222001236321002222000001,         1000020000300004000030000200001, 1000020220302216122030220200001,         1000022002321026201232002200001, 1000022222323458543232222200001,         1000200010020004000200100020001, 1000200230042016102400320020001,         1000202012221206021222102020001, 1000202232243438343422322020001,         1000220012320026200232100220001, 1000220232344238324432320220001,         1000222014541248421454102220001, 1002001000002004002000001002001,         1002001220222016102220221002001, 1002003004005006005004003002001,         1002003224225238325224223002001, 1002021020302206022030201202001,         1002021240524418144250421202001, 1002023024325228225234203202001,         1002201210022026202200121022001, 1002201430264038304620341022001,         1002203214225228225224123022001, 1002221232322248422232321222001,         1020100000000204020000000010201, 1020100222200216120022220010201,         1020102022021206021202202010201, 1020102244221438341224422010201,         1020120200302206022030020210201, 1020120422504418144052240210201,         1020122222343228223432222210201, 1020302010020406040200102030201,         1020302232242418142422322030201, 1020304032241608061422304030201,         1020322212322428242232122230201, 1022121000002226222000001212201,         1022121222422238322242221212201, 1022123024025228225204203212201,         1022141220304428244030221412201, 1022323210022448442200123232201,         1210000000000024200000000000121, 1210000242000036300002420000121,         1210002202201026201022022000121, 1210002444201258521024442000121,         1210022000320026200230002200121, 1210022242322238322232422200121,         1210024202541048401452024200121, 1210220010022026202200100220121,         1210220252044038304402520220121, 1210222212423228223242122220121,         1210242012342048402432102420121, 1212201000002226222000001022121,         1212201242222238322222421022121, 1212203204205228225024023022121,         1212223020322428242230203222121, 1212421210024248424200121242121,         1232100000000246420000000012321, 1232100244200258520024420012321,         1232102222221248421222222012321, 1232122200322248422230022212321,         1232322010022448442200102232321, 1234321000002468642000001234321,         4000000000000008000000000000004], dtype=object)    ###############################################################################  # Helper functions go here  ###############################################################################    def read_input(infile):      """This function should take an open input file, load in all of the      relevant information for a single case of the problem, and output it      as a single object.          """      #Some utility functions to read in particular types of input      def read_int():          return int(infile.readline().strip())      def read_ints():          return np.array(infile.readline().split(), dtype=int)      def read_bigints():          line = infile.readline().split()          return np.array(map(lambda x: int(x), line))      def read_float():          return float(infile.readline().strip())      def read_floats():          return np.array(infile.readline().split(), dtype=float)      def read_string():          return infile.readline().strip()      def read_strings():          return np.array(infile.readline().split(), dtype=object) #change the dtype?            A, B = read_bigints()            return (A, B)    def is_palindrome(num):      digits = []      num = int(num)      while num > 0:          digits.append(num % 10)          num = num / 10 #n.b. int division (discard remainder)        return digits == digits[::-1]        for i in range(len(digits) / 2): #n.b. int division (skips center)          if digits[i] != digits[-i+1]:              return False      return True    def solve_case_simple(case):      A, B = case            if B > table_of_fairs[-1]:          raise ValueError, "Ranges too big for lookup table!"            valid = (A <= filtered_table) * (filtered_table <= B)      return valid.sum()    def solve_case(case):      """Take the input data (structured in case) and perform any necessary      calculations to obtain the desired output, formatted as the appropriate      string.          """            output = solve_case_simple(case)      return output    ###############################################################################  # Main execution path  ###############################################################################    if __name__ == "__main__":      #Open up the input & output files      infile = open("%s-%s%s.in" % (problem, tag, suffix), 'r')      outfile = open("%s-%s%s.out" % (problem, tag, suffix), 'w')            #Read in the number of cases (the first input line) to iterate through      cases = int(infile.readline().strip('\n'))      for i in range(cases):                    #Read in the input data for this case          case = read_input(infile)                    #Solve the problem for this case          output = solve_case(case)                    #Write out the output of this case          outfile.write('Case #%i: %s\n' % (i+1, output))          print 'Case #%i: %s\n' % (i+1, output)            #Close files      infile.close()      outfile.close() <CODESPLIT> 61
#Code copyright Brett Olsen, 2012    #Standard imports  import numpy as N    #Some switching behavior to set standard input/output files  #Set these three variables to adjust behavior  case = 1  problem = "B"  practice = False    if practice:      practice = "-practice"  else:      practice = "-attempt0"  if case == 0:      infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')      outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')          elif case == 1:      infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')      outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')      elif case == 2:      infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')      outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')     else:      raise ValueError, 'Invalid case'        #Hash table:  -1 is never, +1 is always, 0 is sometimes  lookup = {}    def check_total(total, p):      assert type(total) == int      resid = total % 3        min_nosurprise = (total / 3)          max_nosurprise = (total / 3) + min(1, resid)            #print min_nosurprise, max_nosurprise            #If the residual is 1, then being surprising won't change the max value      #similarly, if we're already at the maximum, it can't change      #similarly, if residual is 0 and the min value is already 0, it can't change      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):          if max_nosurprise >= p:              return 1          else:              return -1        if max_nosurprise >= p:          return 1      elif max_nosurprise == p-1:          return 0      else:          return -1        #Read in the number of cases (the first input line) we need to iterate through  cases = int(infile.readline().strip('\n'))  for i in range(cases):      print 'case %i of %i' % (i+1, cases)  ##################NEW CODE GOES HERE###########################################          #Read in all relevant data for each case      line = infile.readline().split()      N = int(line[0])      S = int(line[1])      p = int(line[2])      points = []      for item in line[3:]:          points.append(int(item))      assert N == len(points)      assert p <= 10      assert p >= 0      assert S >= 0      assert S <= N            always = 0      possible = 0            for total in points:          if (total, p) in lookup:              depends = lookup[total, p]          else:              depends = check_total(total, p)                    if depends == 1:              always += 1          elif depends == 0:              possible += 1            #Do calculations to generate the output      output = '%i' % (always + min(possible, S))        ##################NEW CODE GOES HERE###########################################          #Write out the results for this case      outfile.write('Case #%i: %s\n' % (i+1, output))        #Close files  infile.close()  outfile.close() <CODESPLIT> 61
#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013  #for the Google Code Jam programming contest    ###############################################################################  # Imports go here  ###############################################################################    #For faster numerical analysis  import numpy as np    import sys    #Needed for the memoization decorator  import collections  import functools    ###############################################################################  # Global variables (for caching, etc.) go here  ###############################################################################    ###############################################################################  # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)  ###############################################################################    class memoize(object):     """Decorator. Caches a function's return value each time it is called.     If called later with the same arguments, the cached value is returned     (not reevaluated).     """     def __init__(self, func):        self.func = func        self.cache = {}     def __call__(self, *args):        if not isinstance(args, collections.Hashable):           # uncacheable. a list, for instance.           # better to not cache than blow up.           return self.func(*args)        if args in self.cache:           return self.cache[args]        else:           value = self.func(*args)           self.cache[args] = value           return value     def __repr__(self):        '''Return the function's docstring.'''        return self.func.__doc__     def __get__(self, obj, objtype):        '''Support instance methods.'''        return functools.partial(self.__call__, obj)    ###############################################################################  # Functions  ###############################################################################    def precalculate():      """Perform any calculations that need to be performed before the main path      (e.g., preparing lookup tables, etc.)            N.B. Make sure you make any important variables global so that other      functions can access them.      """      pass    def read_input(infile):      """This function should take an open input file, load in all of the      relevant information for a single case of the problem, and output it      as a single object.          """      #Some utility functions to read in particular types of input      def read_int():          return int(infile.readline().strip())      def read_ints():          return np.array(infile.readline().split(), dtype=int)      def read_bigints(): #For ints that won't fit directly in an int32 array          line = infile.readline().split()          return np.array(map(lambda x: int(x), line))      def read_float():          return float(infile.readline().strip())      def read_floats():          return np.array(infile.readline().split(), dtype=float)      def read_string():          return infile.readline().strip()      def read_strings():          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype            N = read_int()      naomi = read_floats()      ken = read_floats()      naomi.sort()      ken.sort()      assert len(naomi) == N      assert len(ken) == N            return naomi, ken    def ken_choice(told_naomi, ken, ken_free):      #Ken's strategy is as follows:  if he has no block heavier than what Naomi      #tells him, then he chooses his smallest block.  Otherwise, he chooses the smallest      #block that is heavier than what she tells him.      #N.B. ken should be provided as a sorted list from smallest to largest.      N = len(ken)      lowest = None      for j in range(N):          if not ken_free[j]:              continue          if lowest is None:              lowest, idx = ken[j], j          if ken[j] > told_naomi:              return ken[j], j      return lowest, idx    def normal_war(naomi, ken):      #Naomi's strategy is to play blocks from largest to smallest,      #Ken's strategy is to play the smallest block that could beat Naomi's,      #or the smallest block if he has none that can do so.      #Runs as N^2, fast enough even with N=1000            #Appears to be validated as the best strategy, checked it with       #a complete exponential solution on the small import - no differences.      N = len(naomi)      ken_free = np.ones(N, dtype=bool)      score = 0      for i in range(N)[::-1]:          chosen_naomi = naomi[i]          chosen_ken, j = ken_choice(chosen_naomi, ken, ken_free)          ken_free[j] = False                    if chosen_naomi > chosen_ken:              score += 1      return score      def new_deceitful_war(naomi, ken):      score = 0            N = len(naomi)            for i in range(N):          if naomi[-1] > ken[-1]:              score += 1              naomi = naomi[:-1]              ken = ken[:-1]          else:              naomi = naomi[1:]              ken = ken[:-1]      return score      def deceitful_war(naomi, ken):      #Naomi certainly can't win with blocks that are lower than all of Ken's      #blocks.  But Naomi can lie about these blocks' weight to use up key blocks      #of Ken's.                   #, and will also lose against all of Ken's blocks that are larger      #than all of her blocks.  So Naomi can lie using her lowest blocks to      #use up Ken's highest blocks to remove these guaranteed losses.                  #Naomi's strategy is to use her no-hopers (those that are lower      #than all of Ken's blocks) to fish out Ken's highest weight blocks.      #Then she uses her lowest blocks to fish out any of Ken's best blocks      #that will beat all of hers      N = len(naomi)      no_hopers = 0      for i in range(N):          if naomi[i] < ken[0]:              no_hopers += 1      #Some of Ken's blocks might be larger than all of hers      def_losses = 0      for i in range(N)[::-1]:          if ken[i] > naomi[-1]:              def_losses += 1            #Then she goes through the rest and tries to win in order      edge = max(no_hopers, def_losses)      naomi = naomi[edge:]      ken = ken[:N-edge]        '''      print "After removing sure losers:"      print N, N-edge, edge      if N - edge > 0:          if min(naomi) < max(ken):              print naomi              print ken      '''        #print len(naomi), len(ken), edge        score = 0      for i in range(N - edge):          if naomi[i] > ken[i]:              score += 1                    return score    def solve_case(case):      """Take the input data (structured in case) and perform any necessary      calculations to obtain the desired output, formatted as the appropriate      string.          """            naomi, ken = case      print naomi      print ken            new = new_deceitful_war(naomi, ken)            good, bad = deceitful_war(naomi, ken), normal_war(naomi, ken)            if not new == good:          print 'Hey!', new, good            output = "%i %i" % (new, bad)      return output    ###############################################################################  # Main execution path  ###############################################################################    if __name__ == "__main__":      #Do any pre-calculations required      precalculate()            #Open up the input & output files based on the provided input file      assert len(sys.argv) == 2 #only one argument      assert sys.argv[1][-3:] == ".in" #input must end with .in      infile = open("%s" % sys.argv[1], 'r')      outfile = open("%s.out" % sys.argv[1][:-3], 'w')            #Read in the number of cases (the first input line) to iterate through      cases = int(infile.readline().strip('\n'))      for i in range(cases):                    #Read in the input data for this case          case = read_input(infile)                    #Solve the problem for this case          output = solve_case(case)                    #Write out the output of this case          outfile.write('Case #%i: %s\n' % (i+1, output))          print 'Case #%i: %s\n' % (i+1, output)            #Close files      infile.close()      outfile.close() <CODESPLIT> 61
#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013  #for the Google Code Jam programming contest    ###############################################################################  # Imports go here  ###############################################################################    from __future__ import division  import numpy as np    ###############################################################################  # Global variables (for caching, etc.) go here  ###############################################################################    #Set up the input/output files: problem-tagsuffix.in / *.out  problem = "B"  tag = "small" #commonly sample, small, or large  #tag = "large"  #tag = "sample"  suffix = "-attempt0" #used sometimes for indexing later input files  #suffix = ""    ###############################################################################  # Helper functions go here  ###############################################################################      def read_input(infile):      """This function should take an open input file, load in all of the      relevant information for a single case of the problem, and output it      as a single object.          """      #Some utility functions to read in particular types of input      def read_int():          return int(infile.readline().strip())      def read_ints():          return np.array(infile.readline().split(), dtype=int)      def read_float():          return float(infile.readline().strip())      def read_floats():          return np.array(infile.readline().split(), dtype=float)      def read_string():          return infile.readline().strip()      def read_strings():          return np.array(infile.readline().split(), dtype=object) #change the dtype?            N, M = read_ints()            lawn = np.empty((N, M), dtype=int)      for i in range(N):          row = read_ints()          assert len(row) == M          lawn[i,:] = row            return lawn    def solve_case(case):      """Take the input data (structured in case) and perform any necessary      calculations to obtain the desired output, formatted as the appropriate      string.          """            lawn = case      undefined = np.zeros(lawn.shape, dtype=bool)            colvals, rowvals = np.meshgrid(range(lawn.shape[1]), range(lawn.shape[0]))            while not undefined.all():          #Find the lowest still-defined point in the lawn          valid = undefined == False          minval = lawn[valid].min()                minindex = np.where(lawn[valid] == minval)[0][0]          minrow = rowvals[valid][minindex]          mincol = colvals[valid][minindex]          #Check to see if this point's row could have been mowed          if (lawn[minrow,:][valid[minrow,:]] == minval).all():              #Undefine this row              undefined[minrow,:] = True              continue                    #Otherwise, check to see if this point's column could have been mowed          if (lawn[:,mincol][valid[:,mincol]] == minval).all():              #Undefine this column              undefined[:,mincol] = True              continue                    #Otherwise, it's invalid!          return "NO"            return "YES"    ###############################################################################  # Main execution path  ###############################################################################    if __name__ == "__main__":      #Open up the input & output files      infile = open("%s-%s%s.in" % (problem, tag, suffix), 'r')      outfile = open("%s-%s%s.out" % (problem, tag, suffix), 'w')            #Read in the number of cases (the first input line) to iterate through      cases = int(infile.readline().strip('\n'))      for i in range(cases):                    #Read in the input data for this case          case = read_input(infile)                    #Solve the problem for this case          output = solve_case(case)                    #Write out the output of this case          outfile.write('Case #%i: %s\n' % (i+1, output))          print 'Case #%i: %s\n' % (i+1, output)            #Close files      infile.close()      outfile.close() <CODESPLIT> 61
#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013  #for the Google Code Jam programming contest    ###############################################################################  # Imports go here  ###############################################################################    #For faster numerical analysis  import numpy as np    import sys    #Needed for the memoization decorator  import collections  import functools    ###############################################################################  # Global variables (for caching, etc.) go here  ###############################################################################    ###############################################################################  # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)  ###############################################################################    class memoize(object):     """Decorator. Caches a function's return value each time it is called.     If called later with the same arguments, the cached value is returned     (not reevaluated).     """     def __init__(self, func):        self.func = func        self.cache = {}     def __call__(self, *args):        if not isinstance(args, collections.Hashable):           # uncacheable. a list, for instance.           # better to not cache than blow up.           return self.func(*args)        if args in self.cache:           return self.cache[args]        else:           value = self.func(*args)           self.cache[args] = value           return value     def __repr__(self):        '''Return the function's docstring.'''        return self.func.__doc__     def __get__(self, obj, objtype):        '''Support instance methods.'''        return functools.partial(self.__call__, obj)    ###############################################################################  # Functions  ###############################################################################    def precalculate():      """Perform any calculations that need to be performed before the main path      (e.g., preparing lookup tables, etc.)            N.B. Make sure you make any important variables global so that other      functions can access them.      """      pass    def read_input(infile):      """This function should take an open input file, load in all of the      relevant information for a single case of the problem, and output it      as a single object.          """      #Some utility functions to read in particular types of input      def read_int():          return int(infile.readline().strip())      def read_ints():          return np.array(infile.readline().split(), dtype=int)      def read_bigints(): #For ints that won't fit directly in an int32 array          line = infile.readline().split()          return np.array(map(lambda x: int(x), line))      def read_float():          return float(infile.readline().strip())      def read_floats():          return np.array(infile.readline().split(), dtype=float)      def read_string():          return infile.readline().strip()      def read_strings():          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype            C, F, X = read_floats()            case = (C, F, X)            return case    def solve_case(case):      """Take the input data (structured in case) and perform any necessary      calculations to obtain the desired output, formatted as the appropriate      string.          """      C, F, X = case            rate = 2.0      cookies = 0.0      time = 0.0            #If it takes more cookies to buy a farm than we need to win, just wait and win:      if C >= X:          return X / rate            while cookies < X:          #If we don't have enough cookies to buy a farm, we have to wait until we do          if cookies < C:              wait_time = (C - cookies) / rate              time += wait_time              cookies = C          #Now we do have enough cookies to buy a farm. Should we keep waiting or buy?          time_if_wait = (X - C) / rate          time_if_buy = X / (rate + F)          if time_if_wait < time_if_buy:              return time + time_if_wait          else:              rate += F              cookies = 0.0    ###############################################################################  # Main execution path  ###############################################################################    if __name__ == "__main__":      #Do any pre-calculations required      precalculate()            #Open up the input & output files based on the provided input file      assert len(sys.argv) == 2 #only one argument      assert sys.argv[1][-3:] == ".in" #input must end with .in      infile = open("%s" % sys.argv[1], 'r')      outfile = open("%s.out" % sys.argv[1][:-3], 'w')            #Read in the number of cases (the first input line) to iterate through      cases = int(infile.readline().strip('\n'))      for i in range(cases):                    #Read in the input data for this case          case = read_input(infile)                    #Solve the problem for this case          output = solve_case(case)                    #Write out the output of this case          outfile.write('Case #%i: %s\n' % (i+1, output))          print 'Case #%i: %s\n' % (i+1, output)            #Close files      infile.close()      outfile.close() <CODESPLIT> 61
#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013  #for the Google Code Jam programming contest    ###############################################################################  # Imports go here  ###############################################################################    #For faster numerical analysis  import numpy as np    import sys    #Needed for the memoization decorator  import collections  import functools    ###############################################################################  # Global variables (for caching, etc.) go here  ###############################################################################    ###############################################################################  # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)  ###############################################################################    class memoize(object):     """Decorator. Caches a function's return value each time it is called.     If called later with the same arguments, the cached value is returned     (not reevaluated).     """     def __init__(self, func):        self.func = func        self.cache = {}     def __call__(self, *args):        if not isinstance(args, collections.Hashable):           # uncacheable. a list, for instance.           # better to not cache than blow up.           return self.func(*args)        if args in self.cache:           return self.cache[args]        else:           value = self.func(*args)           self.cache[args] = value           return value     def __repr__(self):        '''Return the function's docstring.'''        return self.func.__doc__     def __get__(self, obj, objtype):        '''Support instance methods.'''        return functools.partial(self.__call__, obj)    ###############################################################################  # Functions  ###############################################################################    def precalculate():      """Perform any calculations that need to be performed before the main path      (e.g., preparing lookup tables, etc.)            N.B. Make sure you make any important variables global so that other      functions can access them.      """      pass    def read_input(infile):      """This function should take an open input file, load in all of the      relevant information for a single case of the problem, and output it      as a single object.          """      #Some utility functions to read in particular types of input      def read_int():          return int(infile.readline().strip())      def read_ints():          return np.array(infile.readline().split(), dtype=int)      def read_bigints(): #For ints that won't fit directly in an int32 array          line = infile.readline().split()          return np.array(map(lambda x: int(x), line))      def read_float():          return float(infile.readline().strip())      def read_floats():          return np.array(infile.readline().split(), dtype=float)      def read_string():          return infile.readline().strip()      def read_strings():          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype            ans1 = read_int()      grid1 = np.zeros((4,4), dtype=int)      for i in range(4):          grid1[i] = read_ints()            ans2 = read_int()      grid2 = np.zeros((4,4), dtype=int)      for i in range(4):          grid2[i] = read_ints()                  case = (ans1, grid1, ans2, grid2)            return case    def solve_case(case):      """Take the input data (structured in case) and perform any necessary      calculations to obtain the desired output, formatted as the appropriate      string.          """            ans1, grid1, ans2, grid2 = case            valid = set(grid1[ans1-1]) & set(grid2[ans2-1])            #print valid      #print ans1, grid1, ans2, grid2      #print grid1[ans1], grid2[ans2]            if len(valid) == 1:          output = valid.pop()      elif len(valid) > 1:          output = "Bad magician!"      elif len(valid) < 1:          output = "Volunteer cheated!"      return output    ###############################################################################  # Main execution path  ###############################################################################    if __name__ == "__main__":      #Do any pre-calculations required      precalculate()            #Open up the input & output files based on the provided input file      assert len(sys.argv) == 2 #only one argument      assert sys.argv[1][-3:] == ".in" #input must end with .in      infile = open("%s" % sys.argv[1], 'r')      outfile = open("%s.out" % sys.argv[1][:-3], 'w')            #Read in the number of cases (the first input line) to iterate through      cases = int(infile.readline().strip('\n'))      for i in range(cases):                    #Read in the input data for this case          case = read_input(infile)                    #Solve the problem for this case          output = solve_case(case)                    #Write out the output of this case          outfile.write('Case #%i: %s\n' % (i+1, output))          print 'Case #%i: %s\n' % (i+1, output)            #Close files      infile.close()      outfile.close() <CODESPLIT> 61
#Code copyright Brett Olsen, 2012    #Standard imports  import numpy as N  from string import translate, maketrans    #Some switching behavior to set standard input/output files  #Set these three variables to adjust behavior  case = 1  problem = "A"  practice = False    if practice:      practice = "-practice"  else:      practice = "-attempt0"  if case == 0:      infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')      outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')          elif case == 1:      infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')      outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')      elif case == 2:      infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')      outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')     else:      raise ValueError, 'Invalid case'        alpha = 'abcdefghijklmnopqrstuvwxyz '  trans = 'ynficwlbkuomxsevzpdrjgthaq '  table = maketrans(trans, alpha)        #Read in the number of cases (the first input line) we need to iterate through  cases = int(infile.readline().strip('\n'))  for i in range(cases):  ##################NEW CODE GOES HERE###########################################          #Read in all relevant data for each case      instr = infile.readline().strip('\n')            #Do calculations to generate the output            output = translate(instr, table)              ##################NEW CODE GOES HERE###########################################          #Write out the results for this case      outfile.write('Case #%i: %s\n' % (i+1, output))        #Close files  infile.close()  outfile.close() <CODESPLIT> 61
#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013  #for the Google Code Jam programming contest    ###############################################################################  # Imports go here  ###############################################################################    from __future__ import division  import numpy as np    ###############################################################################  # Global variables (for caching, etc.) go here  ###############################################################################    #Set up the input/output files: problem-tagsuffix.in / *.out  problem = "A"  tag = "small" #commonly sample, small, or large  suffix = "-attempt1" #used sometimes for indexing later input files    ###############################################################################  # Helper functions go here  ###############################################################################    def read_input(infile):      """This function should take an open input file, load in all of the      relevant information for a single case of the problem, and output it      as a single object.          """      #Some utility functions to read in particular types of input      def read_int():          return int(infile.readline().strip())      def read_ints():          return np.array(infile.readline().split(), dtype=int)      def read_float():          return float(infile.readline().strip())      def read_floats():          return np.array(infile.readline().split(), dtype=float)      def read_string():          return infile.readline().strip()      def read_strings():          return np.array(infile.readline().split(), dtype=object) #change the dtype?            board = np.empty((4,4), dtype=int)            dic = {'X': 1, 'T': 2, 'O': 3, '.': 4}            #Read in rows      for i in range(4):          line = read_string()          for j in range(4):              board[i,j] = dic[line[j]]      infile.readline()            return board    def iswin(row):      if 4 in row:          return None #gap      if (row <= 2).all():          return "X won"      if (row >= 2).all():          return "O won"      return None    def solve_case(case):      """Take the input data (structured in case) and perform any necessary      calculations to obtain the desired output, formatted as the appropriate      string.          """            board = case        #Look for win conditions      for i in range(4):          row = board[i,:]          if iswin(row) is not None:              return iswin(row)                for i in range(4):          col = board[:,i]          if iswin(col) is not None:              return iswin(col)                vals = np.arange(4)      diag = board[vals,vals]      if iswin(diag) is not None:          return iswin(diag)            diag = board[vals, vals[::-1]]      if iswin(diag) is not None:          return iswin(diag)        #Check if the board is completed (has empty squares left)      if 4 in board:          return "Game has not completed"            return "Draw"    ###############################################################################  # Main execution path  ###############################################################################    if __name__ == "__main__":      #Open up the input & output files      infile = open("%s-%s%s.in" % (problem, tag, suffix), 'r')      outfile = open("%s-%s%s.out" % (problem, tag, suffix), 'w')            #Read in the number of cases (the first input line) to iterate through      cases = int(infile.readline().strip('\n'))      for i in range(cases):                    #Read in the input data for this case          case = read_input(infile)                    #Solve the problem for this case          output = solve_case(case)                    #Write out the output of this case          outfile.write('Case #%i: %s\n' % (i+1, output))          print 'Case #%i: %s\n' % (i+1, output)            #Close files      infile.close()      outfile.close() <CODESPLIT> 61
#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013  #for the Google Code Jam programming contest    ###############################################################################  # Imports go here  ###############################################################################    #For faster numerical analysis  import numpy as np    import sys    #Needed for the memoization decorator  import collections  import functools    ###############################################################################  # Global variables (for caching, etc.) go here  ###############################################################################    ###############################################################################  # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)  ###############################################################################    class memoize(object):     """Decorator. Caches a function's return value each time it is called.     If called later with the same arguments, the cached value is returned     (not reevaluated).     """     def __init__(self, func):        self.func = func        self.cache = {}     def __call__(self, *args):        if not isinstance(args, collections.Hashable):           # uncacheable. a list, for instance.           # better to not cache than blow up.           return self.func(*args)        if args in self.cache:           return self.cache[args]        else:           value = self.func(*args)           self.cache[args] = value           return value     def __repr__(self):        '''Return the function's docstring.'''        return self.func.__doc__     def __get__(self, obj, objtype):        '''Support instance methods.'''        return functools.partial(self.__call__, obj)    ###############################################################################  # Functions  ###############################################################################    def precalculate():      """Perform any calculations that need to be performed before the main path      (e.g., preparing lookup tables, etc.)            N.B. Make sure you make any important variables global so that other      functions can access them.      """      pass    def read_input(infile):      """This function should take an open input file, load in all of the      relevant information for a single case of the problem, and output it      as a single object.          """      #Some utility functions to read in particular types of input      def read_int():          return int(infile.readline().strip())      def read_ints():          return np.array(infile.readline().split(), dtype=int)      def read_bigints(): #For ints that won't fit directly in an int32 array          line = infile.readline().split()          return np.array(map(lambda x: int(x), line))      def read_float():          return float(infile.readline().strip())      def read_floats():          return np.array(infile.readline().split(), dtype=float)      def read_string():          return infile.readline().strip()      def read_strings():          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype            R, C, M = read_ints()            return R, C, M    def solve_case(case):      """Take the input data (structured in case) and perform any necessary      calculations to obtain the desired output, formatted as the appropriate      string.          """      R, C, M = case            free = R * C - M      assert free >= 1            board = np.zeros((R, C), dtype=int) - 1            def write_board(board):          d = {0:'.', 1:'c', 2:'*'}          s = "\n"          for row in board:              for num in row:                  try:                      s += d[num]                  except KeyError:                      #s += "X"                      raise ValueError("Board not filled in!")              s += "\n"          return s            #Clicking in the corner is always optimal!      board[0,0] = 1            #Always possible with no mines!      if M == 0:          board[board == -1] = 0          return write_board(board)            #Always possible with one free square, if you click on the free square.      if free == 1:          #Fill all the empty squares in with mines          board[board == -1] = 2          return write_board(board)                      #Fill in the shortest sides while we have enough mines to do so:      while min(R, C) <= M:          if R < C:              board[:,C-1] = 2              C -= 1              M -= R          elif C <= R:              board[R-1,:] = 2              R -= 1              M -= C            def cascades(board, r, c):          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]          for r in rows:              for c in cols:                  if board[r,c] == 2: #Mine next to given position                      return False          return True            #If we have no mines left, we win as long as the initial click cascades:      if M == 0:          board[board == -1] = 0          if cascades(board, 0, 0):              return write_board(board)          else:              return "\nImpossible"            #Now we have a rectangular free space with less than a full row or column      #to fill.            #If there's so many mines that we fill in all but one square on either      #the row or column, it can't be done.      if M > (R + C - 5):          return "\nImpossible"                if M > 0 and (R <= 2 or C <= 2):          return "\nImpossible"                #Otherwise, we fill in mines from the corner opposite to the click      print M, R + C - 5      fill_num = min(M, R - 2)      print M, fill_num      board[(R - fill_num):,C-1] = 2      M -= fill_num            fill_num = min(M, C - 3)      print M, fill_num      board[R-1,(C - fill_num - 1):] = 2      M -= fill_num      #assert M == 0            board[board == -1] = 0      return write_board(board)    ###############################################################################  # Main execution path  ###############################################################################    if __name__ == "__main__":      #Do any pre-calculations required      precalculate()            #Open up the input & output files based on the provided input file      assert len(sys.argv) == 2 #only one argument      assert sys.argv[1][-3:] == ".in" #input must end with .in      infile = open("%s" % sys.argv[1], 'r')      outfile = open("%s.out" % sys.argv[1][:-3], 'w')            #Read in the number of cases (the first input line) to iterate through      cases = int(infile.readline().strip('\n'))      for i in range(cases):                    #Read in the input data for this case          case = read_input(infile)                    #Solve the problem for this case          output = solve_case(case)                    #Write out the output of this case          outfile.write('Case #%i: %s\n' % (i+1, output))          print 'Case #%i: %s\n' % (i+1, output)            #Close files      infile.close()      outfile.close() <CODESPLIT> 61
#Code copyright Brett Olsen, 2012    #Standard imports  import numpy as N    #Some switching behavior to set standard input/output files  #Set these three variables to adjust behavior  case = 1  problem = "C"  practice = False    if practice:      practice = "-practice"  else:      practice = "-attempt0"  if case == 0:      infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')      outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')          elif case == 1:      infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')      outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')      elif case == 2:      infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')      outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')     else:      raise ValueError, 'Invalid case'        def permute(num, maxval):      assert type(num) == int      output = []      digits = int(N.ceil(N.log10(num)))      current = num      for i in range(digits-1):          current = current / 10 + 10**(digits-1) * (current % 10)          if current <= num: #We only want permutations greater than num (for uniqueness)              continue          if current > maxval: #only permutations less than the maximum value              continue          if current not in output:              output.append(current)  #    return output      return len(output)        def count_recycled(A, B):      count = 0      for num in xrange(A, B+1):          count += permute(num, B)      return count        #Read in the number of cases (the first input line) we need to iterate through  cases = int(infile.readline().strip('\n'))  for i in range(cases):  ##################NEW CODE GOES HERE###########################################          #Read in all relevant data for each case      A, B = infile.readline().split()      A = int(A)      B = int(B)            #Do calculations to generate the output      output = '%i' % count_recycled(A, B)        ##################NEW CODE GOES HERE###########################################          #Write out the results for this case      outfile.write('Case #%i: %s\n' % (i+1, output))        #Close files  infile.close()  outfile.close() <CODESPLIT> 61
#!/usr/local/bin/python  import sys, string, math      # check if num x is palindrome  def is_palindrome(x):      candidate = list(str(x))      while len(candidate) > 1:          if candidate.pop(0) != candidate.pop():              return False      return True      #square  def square(x):      return x * x      #solve case function  def solve_case(ab, case_number):      fs = 0      root = int(math.sqrt(ab[0]))      sq = square(root)      if sq < ab[0]:          root += 1          sq = square(root)        while sq <= ab[1]:          if is_palindrome(root) and is_palindrome(sq):              fs += 1            #prepare for next          root += 1          sq = square(root)        print "Case #%d: %d" % (case_number, fs)      #main  def main():      r = sys.stdin      if len(sys.argv) > 1:          r = open(sys.argv[1], 'r')        total_cases = r.readline()      for case_number in range(1, int(total_cases) + 1):          ab = map(int, r.readline().strip().split(' '))          solve_case(ab, case_number)    # invoke main  if __name__ == "__main__":      main() <CODESPLIT> 62
#!/usr/bin/python  import sys, string    mod_plus_conv_with_s = {0:1, 1:1, 2:2}  mod_plus_conv_without_s = {0:0, 1:1, 2:1}    #solve case function  def solve_case(s, p, scores,case_number):  	ans = 0  	for score in scores:  		if p <= (score / 3) + mod_plus_conv_without_s[score % 3]:  			ans = ans + 1  		elif s > 0 and (score / 3) > 0:   			if p <= (score / 3) + mod_plus_conv_with_s[score % 3]:  				ans = ans + 1  				s = s - 1  	print "Case #%d: %d" % (case_number, ans)    #main  r = sys.stdin    if len(sys.argv) > 1:  	r = open(sys.argv[1], 'r')    total_cases = r.readline()  for case_number in range(1, int(total_cases) + 1):  	case_line = map(int, r.readline().rstrip().split(' '))  	solve_case(case_line[1], case_line[2], case_line[3:], case_number)    <CODESPLIT> 62
# !/usr/bin/python  import sys, string    #solve case function  def solve_case(naomi_blocks, ken_blocks, case_number):      naomi_blocks_for_deceitful = naomi_blocks[:]      ken_blocks_for_deceitful = ken_blocks[:]      deceitful_war_point = 0      while len(naomi_blocks_for_deceitful) > 0:          naomi_call = naomi_blocks_for_deceitful.pop(0)          min_ken_call = ken_blocks_for_deceitful[0]          if naomi_call < min_ken_call:              naomi_call = ken_blocks_for_deceitful[-1] - 0.000001          else:              # Naomi may call the same kg many times but Ken should not realize it ;)              # The important point is that she must call heavier than Ken's max.              naomi_call = ken_blocks_for_deceitful[-1] + 0.000001            ken_candidate = filter(lambda x: x > naomi_call, ken_blocks_for_deceitful)          if len(ken_candidate) > 0:              ken_call = ken_blocks_for_deceitful.pop(ken_blocks_for_deceitful.index(ken_candidate.pop(0)))          else:              ken_call = ken_blocks_for_deceitful.pop(0)            if naomi_call > ken_call:              deceitful_war_point += 1        war_point = 0      while len(naomi_blocks) > 0:          naomi_call = naomi_blocks.pop(0)          ken_candidate = filter(lambda x: x > naomi_call, ken_blocks)          if len(ken_candidate) > 0:              ken_call = ken_blocks.pop(ken_blocks.index(ken_candidate.pop(0)))          else:              ken_call = ken_blocks.pop(0)            if naomi_call > ken_call:              war_point += 1        print "Case #%d: %d %d" % (case_number, deceitful_war_point, war_point)    #main  r_file = sys.stdin    if len(sys.argv) > 1:      r_file = open(sys.argv[1], 'r')    total_cases = r_file.readline()  for case_number in range(1, int(total_cases) + 1):      r_file.readline()      n_values = map(float, r_file.readline().split(' '))      k_values = map(float, r_file.readline().split(' '))      solve_case(sorted(n_values), sorted(k_values), case_number)    <CODESPLIT> 62
#!/usr/local/bin/python  import sys, string      #solve case function  def solve_case(nm, lawn, case_number):      zipped_lawn = zip(*lawn)      for n in range(0, nm[0]):          max_lawn_n = max(lawn[n])          for m in range(0, nm[1]):              max_lawn_m = max(zipped_lawn[m])              if lawn[n][m] < max_lawn_n and lawn[n][m] < max_lawn_m:                  print "Case #%d: NO" % case_number                  return        print "Case #%d: YES" % case_number      #main  def main():      r = sys.stdin      if len(sys.argv) > 1:          r = open(sys.argv[1], 'r')        total_cases = r.readline()      for case_number in range(1, int(total_cases) + 1):          nm = map(int, r.readline().strip().split(' '))          lawn = []          for n in range(0, nm[0]):              lawn.append(map(int, r.readline().strip().split(' ')))          solve_case(nm, lawn, case_number)    # invoke main  if __name__ == "__main__":      main() <CODESPLIT> 62
#!/usr/bin/python  import sys, string    #solve case function  def solve_case(c, f, x, case_number):      rate = 2.0      time = 0.0      rest = x      while True:          time_to_c = c / rate          time_to_x = rest / rate          if time_to_c < time_to_x:              time_to_x_with_boost = time_to_c + (rest / (rate + f))              if time_to_x_with_boost < time_to_x:                  rate += f                  time += time_to_c              else:                  break          else:              break      time += rest / rate      print "Case #%d: %.7f" % (case_number, time)    #main  r = sys.stdin    if len(sys.argv) > 1:      r = open(sys.argv[1], 'r')    total_cases = r.readline()  for case_number in range(1, int(total_cases) + 1):      values = map(float, r.readline().split(' '))      solve_case(values[0], values[1], values[2], case_number)  <CODESPLIT> 62
#!/usr/bin/python  import sys, string    #solve case function  def solve_case(answers, arrangements_of_cards, case_number):      first_candidates = arrangements_of_cards[0][answers[0] - 1]      second_candidates = arrangements_of_cards[1][answers[1] - 1]      answer = set(first_candidates) & set(second_candidates)      length_of_answer = len(answer)      if length_of_answer > 1:          print "Case #%d: Bad magician!" % case_number      elif length_of_answer < 1:          print "Case #%d: Volunteer cheated!" % case_number      else:          # There is only one element in the set!          print "Case #%d: %d" % (case_number, answer.pop())    #main  r = sys.stdin    if len(sys.argv) > 1:      r = open(sys.argv[1], 'r')    total_cases = r.readline()  for case_number in range(1, int(total_cases) + 1):      answers = []      arrangements_of_cards = []      answers.append(int(r.readline()))      arrangements_of_cards.append([])      for row in range(0, 4):          arrangements_of_cards[0].append(map(int, r.readline().split(' ')))      answers.append(int(r.readline()))      arrangements_of_cards.append([])      for row in range(0, 4):          arrangements_of_cards[1].append(map(int, r.readline().split(' ')))      solve_case(answers, arrangements_of_cards, case_number)  <CODESPLIT> 62
#!/usr/bin/python  import sys, string    # make the googlerese dic  gdic = {}  sample_googlerese = "yqeeejpmysljylckdkxveddknmcrejsicpdrysirbcpcypcrtcsradkhwyfrepkymveddknkmkrkcddekrkdeoyakwaejtysrreujdrlkgcjv"  sample_plain_text = "azooourlanguageisimpossibletounderstandtherearetwentysixfactorialpossibilitiessoitisokayifyouwanttojustgiveup"  for gletter, pletter in zip(sample_googlerese, sample_plain_text):  	if gletter in gdic:  		if not gdic[gletter] == pletter:  			print "ERROR!! Can't analyze the sample text."  			sys.exit()  	else:  		gdic[gletter] = pletter    if len(gdic) == 25:  	candidate_gletter = set(string.ascii_lowercase) - set(sample_googlerese)  	candidate_pletter = set(string.ascii_lowercase) - set(sample_plain_text)  	if len(candidate_gletter) == 1 and len(candidate_pletter) == 1:  		gdic[candidate_gletter.pop()] = candidate_pletter.pop()    gdic[' '] = ' '    # open the file  r = sys.stdin    if len(sys.argv) > 1:  	r = open(sys.argv[1], 'r')    # solve the cases   total_cases = r.readline()  for case_number in range(1, int(total_cases) + 1):  	googlerese_text = r.readline().rstrip()  	plain_text = ""	  	for gletter in googlerese_text:  		plain_text = plain_text + gdic[gletter]    	print "Case #%d: %s" % (case_number, plain_text)  <CODESPLIT> 62
#!/usr/bin/python  import sys, string    #output result  def output(case_number, status):      print "Case #%d: %s" % (case_number, status)    #solve case function  def solve_case(board, case_number):      has_game_completed = True        # check row      for column in range(0, 4):          x = 0          o = 0          for row in range(0, 4):              if board[column][row] == 'X':                  x += 1              elif board[column][row] == 'O':                  o += 1              elif board[column][row] == 'T':                  x += 1                  o += 1              else:                  has_game_completed = False            # check if X or O won already          if x > 3:              output(case_number, "X won")              return          if o > 3:              output(case_number, "O won")              return        # check column      for row in range(0, 4):          x = 0          o = 0          for column in range(0, 4):              if board[column][row] == 'X':                  x += 1              elif board[column][row] == 'O':                  o += 1              elif board[column][row] == 'T':                  x += 1                  o += 1            # check if X or O won already          if x > 3:              output(case_number, "X won")              return          if o > 3:              output(case_number, "O won")              return        # check diagonal 1      x = 0      o = 0      for rc in range(0, 4):          if board[rc][rc] == 'X':              x += 1          elif board[rc][rc] == 'O':              o += 1          elif board[rc][rc] == 'T':              x += 1              o += 1        # check if X or O won already      if x > 3:          output(case_number, "X won")          return      if o > 3:          output(case_number, "O won")          return        # check diagonal 2      x = 0      o = 0      for rc in range(0, 4):          if board[rc][3 - rc] == 'X':              x += 1          elif board[rc][3 - rc] == 'O':              o += 1          elif board[rc][3 - rc] == 'T':              x += 1              o += 1        # check if X or O won already      if x > 3:          output(case_number, "X won")          return      if o > 3:          output(case_number, "O won")          return        if has_game_completed:          output(case_number, "Draw")      else:          output(case_number, "Game has not completed")    #main  def main():      r = sys.stdin      if len(sys.argv) > 1:          r = open(sys.argv[1], 'r')        total_cases = r.readline()      for case_number in range(1, int(total_cases) + 1):          board = []          for row in range(0, 4):              board.append(list(r.readline().strip()))            #skip the last empty line          r.readline()          solve_case(board, case_number)    # invoke main  if __name__ == "__main__":      main() <CODESPLIT> 62
# !/usr/bin/python  import sys  import math      def print_basic_board(no_mine, r, c):      printed_c = False      for row in range(0, r):          line = []          for column in range(0, c):              if printed_c:                  if no_mine > 0:                      line.append(".")                      no_mine -= 1                  else:                      line.append("*")              else:                  line.append("c")                  no_mine -= 1                  printed_c = True          print "".join(line)      def print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c):      printed_c = False      for row in range(0, r):          line = []          for column in range(0, c):              if printed_c:                  if row < no_mine_row and column < no_mine_column:                      line.append(".")                  elif rest_no_mine_for_column > 0 and column == no_mine_column:                      line.append(".")                      rest_no_mine_for_column -= 1                  elif rest_no_mine_for_row > 0 and row == no_mine_row:                      line.append(".")                      rest_no_mine_for_row -= 1                  else:                      line.append("*")              else:                  line.append("c")                  printed_c = True          print "".join(line)      #solve case function  def solve_case(r, c, m, case_number):      print "Case #%d:" % case_number      no_mine = r * c - m      if r < 2 or c < 2 or no_mine == 1:          print_basic_board(no_mine, r, c)      else:          no_mine_row_max = int(math.ceil(float(no_mine) / 2))          if no_mine_row_max > r:              no_mine_row_max = r          for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):              if no_mine_column > c:                  break              for no_mine_row in range(2, no_mine_row_max + 1):                  rest_no_mine = no_mine - (no_mine_column * no_mine_row)                  if rest_no_mine < 0:                      continue                  if rest_no_mine == 1:                      continue                    if rest_no_mine == 0:                      print_board(no_mine_row, no_mine_column, 0, 0, r, c)                      return                  if rest_no_mine <= no_mine_row and no_mine_column < c:                      print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)                      return                  if rest_no_mine <= no_mine_column and no_mine_row < r:                      print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)                      return                    if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:                      for rest_no_mine_for_row in range(2, no_mine_column):                          rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row                          if rest_no_mine_for_column < no_mine_row:                              print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c)                              return            print "Impossible"    #main  r_file = sys.stdin    if len(sys.argv) > 1:      r_file = open(sys.argv[1], 'r')    total_cases = r_file.readline()  for case_number in range(1, int(total_cases) + 1):      values = map(int, r_file.readline().split(' '))      solve_case(values[0], values[1], values[2], case_number)    <CODESPLIT> 62
#!/usr/bin/python  import sys, string, math    #solve case function  def solve_case(min, max, case_number):  	ans = 0    	for candidate in range(min, max + 1):  		candidate_str = str(candidate)  		ignore = []  		for rot in range(1, len(candidate_str)):  			rot_candidate = int(candidate_str[rot:] + candidate_str[:rot])  			if not rot_candidate in ignore:  				if rot_candidate <= max and candidate < rot_candidate:  					ans = ans + 1  				ignore.append(rot_candidate)    	print "Case #%d: %d" % (case_number, ans)    #main  r = sys.stdin    if len(sys.argv) > 1:  	r = open(sys.argv[1], 'r')    total_cases = r.readline()  for case_number in range(1, int(total_cases) + 1):  	case = map(int, r.readline().rstrip().split(' '))  	solve_case(case[0], case[1], case_number)    <CODESPLIT> 62
import sys  import math    def is_square(n):      if n in square:          return True      if is_fair(n):          root = int(math.sqrt(n))          if root**2 != n:              return False          ss = is_fair(root)          if ss: square.add(n)          return ss      return False    def is_fair(n):      if n in fair:          return True      if n in unfair:          return False      sn = str(n)      l = len(sn)      mid = math.ceil(n/2)      if sn[0:mid] == sn[mid::-1]:          fair.add(n)          return True      else:          unfair.add(n)          return False    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)                    fair = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])      unfair = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])      square = set([1, 4])        t = int(f.readline())      for _t in range(t):          s = f.readline()          if s:              x, y = s.split()              Total = sum([is_square(n) for n in range(int(x), int(y)+1)])                           print ("Case #" + str(_t+1) + ": " + str(Total))          <CODESPLIT> 63
import sys    def decode_data(input):      output = ""      for letter in input:          if letter in library:              output += library[letter]      return output    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())          for _t in range(t):          s = f.readline()          s = s.split()          N = int(s[0])          S = int(s[1])          p = int(s[2])          low_scores = (p - 1) * 2          ti = s[3:]          ti.sort()          r = 0          ti = [int(x) for x in ti]          for i in ti:              score = i - low_scores              if p <= i:                  if score >= p:                      r += 1                      #print ([score, " > ", p])                  elif score >= p - 2 and S > 0:                      S -= 1                      r +=1          print ("Case #" + str(_t+1) + ": " + str(r))          <CODESPLIT> 63
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in range(t):          N = int(f.readline())          Naomi = sorted([float(x) for x in f.readline().split()])          Ken = sorted([float(x) for x in f.readline().split()])          NMax = max(Naomi)          DWScore = 0          WScore = 0          NaomiW = [x for x in Naomi]          KenW = [x for x in Ken]          for i in range(N):              if(Naomi[-1] > Ken[-1]):                  DWScore += 1                  Naomi.pop()                  Ken.pop()              else:                  Naomi.pop(0)                  Ken.pop()          for i in range(N):              Na = NaomiW.pop(0)              KWinners = [x for x in KenW if x > Na]              if len(KWinners) > 0:                  KenW.remove(KWinners[0])              else:                  KenW.pop(0)                  WScore += 1          print ("Case #" + str(_t+1) + ": " + str(DWScore) + " " + str(WScore))          <CODESPLIT> 63
import sys    def decode_data(input, x, y, z):      rotated = zip(*input[::-1])      #for row in rotated:          #print (row)      #for row in input:          #print (row)      for i in range(x):          for j in range(y):              if not input[i][j] == "1":                  continue                          if sum((int(xx) for xx in input[i])) != y and \                 sum((int(xx) for xx in rotated[j])) != x:                  return "NO"      return "YES"    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in range(t):          x, y = f.readline().split()          s = [f.readline().split() for i in range(int(x))]          print ("Case #" + str(_t+1) + ": " + decode_data(s, int(x), int(y), 2))          <CODESPLIT> 63
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in range(t):            C, F, X = [float(x) for x in f.readline().split()]            base = X / 2.0            new_strategy = old_strategy = base          time_building = 0          farms = 0          fastest_speed = 2          while new_strategy <= old_strategy:              old_strategy = new_strategy              time_building += C / fastest_speed              farms += 1              fastest_speed += F              new_strategy = time_building + X / fastest_speed                                  print ("Case #" + str(_t+1) + ": " + str(old_strategy))          <CODESPLIT> 63
import sys    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in range(t):          X = int(f.readline())          cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]          row = cardsX[X-1]          Y = int(f.readline())          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]          column = cardsY[Y-1]          card = [x for x in row if x in column]          if len(card) > 1:              answer = "Bad magician!"          elif len(card) == 0:              answer = "Volunteer cheated!"          else:              answer = str(card[0])          print ("Case #" + str(_t+1) + ": " + answer)          <CODESPLIT> 63
import sys    library = {'a': 'y', 'o': 'e', 'z': 'q', 'q' : 'z'}    def parse_example(input, output):      for key, value in zip(input, output):          library[key] = value    parse_example("ejp mysljylc kd kxveddknmc re jsicpdrysi", "our language is impossible to understand")  parse_example("rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd", "there are twenty six factorial possibilities")  parse_example("de kr kd eoya kw aej tysr re ujdr lkgc jv", "so it is okay if you want to just give up")    def decode_data(input):      output = ""      for letter in input:          if letter in library:              output += library[letter]      return output    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      d = {'O':0, 'B':1}      for _t in range(t):          s = f.readline()          print ("Case #" + str(_t+1) + ": " + decode_data(s))          <CODESPLIT> 63
import sys    def decode_data(input):      output = ""      Total = 0      for row in input:          T = row.count("T")          X = row.count("X")          O = row.count("O")          #print (row, T, X, O, Total)          if X + T == 4:              return "X won"          elif O + T == 4:              return "O won"          else:              Total += T + X + O                    rotated = zip(*input[::-1])      for row in rotated:          T = row.count("T")          X = row.count("X")          O = row.count("O")          if X + T == 4:              return "X won"          elif O + T == 4:              return "O won"        row = [input[x][x] for x in range(4)]      row.count("T")      X = row.count("X")      O = row.count("O")      if X + T == 4:          return "X won"      elif O + T == 4:          return "O won"        row = [input[3-x][x] for x in range(4)]      T = row.count("T")      X = row.count("X")      O = row.count("O")      if X + T == 4:          return "X won"      elif O + T == 4:          return "O won"        if Total < 16:          return "Game has not completed"      else:          return "Draw"      return output    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in range(t):          s = [f.readline() for i in range(4)]          print ("Case #" + str(_t+1) + ": " + decode_data(s))          f.readline()          <CODESPLIT> 63
import sys  import pprint    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())      for _t in range(t):            R, C, M = [int(x) for x in f.readline().split()]          free_spots = R * C - M - 1            if M == 0:              answer = [["." for x in range(C)] for y in range(R)]              answer[0][0] = "c"          elif R == 1:              answer = [["c"] + ["." for x in range(free_spots)] + ["*" for m in range(M)]]          elif C == 1:              answer = [["c"] + ["." for x in range(free_spots)] + ["*" for m in range(M)]]              answer = zip(*answer[::-1])          elif free_spots >= 3: # and M % R >= 2:              answer = [["*" for x in range(C)] for y in range(R)]              answer[0][0] = "c"              answer[0][1] = "."              answer[1][1] = "."              answer[1][0] = "."              free_spots -= 3              tr, br, c = 0, 1, 2              if c >= C:                  tr, br, c = 2, 3, 0              for _i in range(free_spots):                  #pprint.pprint(answer)                  if answer[tr][c] == "*":                      answer[tr][c] = "."                  elif answer[br][c] == "*":                      answer[br][c] = "."                      if c < C-1:                          c+=1                      else:                          tr, br = tr + 2, br + 2                          c = 0                          if br == R:                              br, tr = br-1, tr-1                            else:              answer = ["Impossible",]                                print ("Case #" + str(_t+1) + ":")          for _i in answer:              print "".join(_i)          <CODESPLIT> 63
import sys    def digits(number, base = 10):    while number:      yield number % base      number //= base    if __name__ == "__main__":      f = sys.stdin      if len(sys.argv) >= 2:          fn = sys.argv[1]          if fn != '-':              f = open(fn)        t = int(f.readline())          for _t in range(t):          s = f.readline()          s = s.split()          A = int(s[0])          B = int(s[1])          score = 0          #print (A, B, [x for x in range(A, B)][-1])          for i in range(A, B):              #print (A, B, [x for x in range(i+1, B+1)][-1])              for j in range(i+1, B+1):                  id = [d for d in digits(i)]                  jd = [d for d in digits(j)]                  if  sorted(id) == sorted(jd):                      checklist = [jd[n:] + jd[:n] for n in range(len(id))]                      if id in checklist:                          score +=1                      #print(checklist)          print ("Case #" + str(_t+1) + ": " + str(score))          <CODESPLIT> 63
#include <iostream>  #include<fstream>  //#include<ostream>  using namespace std;    //#define InputOutputToFile    int main(void)  {  #ifdef InputOutputToFile  	//cin redirection  	std::ifstream fin("cin.txt");  	std::streambuf *inbuf = std::cin.rdbuf(fin.rdbuf());    	//cout redirection  	std::streambuf* cout_sbuf = std::cout.rdbuf(); // save original sbuf   	std::ofstream   fout("cout.txt");   	std::cout.rdbuf(fout.rdbuf()); // redirect 'cout' to a 'fout'   	//std::cout.rdbuf(cout_sbuf); // restore the original stream buffer   #endif    	int run = 0;  	cin>>run;  	bool itrFlg = false;  	int iter = 0;  	while(run--)  	{  		if(itrFlg)  			cout<<endl;  		itrFlg = true;    		unsigned long long a=0,b=0;  		unsigned long long num=0,rev=0,lastDigit=0,check=0;  		long double sqroot1=0,sqroot2=0,sqroot_param=0;  		unsigned int palCount=0;  	  		cin>>a>>b;  	  		for (unsigned long long i=a;i<=b;i++)  		{  			num=i;  			lastDigit=0;  			rev=0;  			while(num>0)  			{  				rev=rev*10;  				rev=rev+num%10;  				num /=10;  			}		  			if (i==rev)   			{  				//cout<<"First time :: Reverse is :: "<<rev<<" and Input is :: "<<i<<endl;  				//cout<<"PALINDROME :: "<<rev<<endl;			  				sqroot_param = rev;			  				sqroot1 = sqrt (sqroot_param);  				//cout<<"Sqr root1 is :: "<<sqroot1<<endl;  				check = sqroot1;  				//cout<<"Check value is :: "<<check<<endl;  				sqroot2 = check;  				//cout<<"Sqr root2 is :: "<<sqroot2<<endl;  				if(sqroot1 == sqroot2)  				{  					num = check;  					rev = 0;  					while(num>0)  					{  						rev=rev*10;  						rev=rev+num%10;  						num /=10;  					}				  					if (check == rev)   					{  						//cout<<"Second time :: Reverse is :: "<<rev<<" and Input is :: "<<check<<endl;  						palCount++;  					}  				}  			}  		}  		//cout<<"Fair and sqr count is ::"<<palCount<<endl;    		//Result Display  		cout<<"Case #"<<++iter<<": "<<palCount;  	}    	return 0;  } <CODESPLIT> 64
#include<iostream>  #include <string>  #include<fstream>  #include<ostream>  #include<vector>  using namespace std;  #define InputOutputToFile    int main(void)  {  #ifdef InputOutputToFile  	  	//cin redirection  	std::ifstream fin("cin.txt");  	std::streambuf *inbuf = std::cin.rdbuf(fin.rdbuf());    	//cout redirection  	std::streambuf* cout_sbuf = std::cout.rdbuf(); // save original sbuf   	std::ofstream   fout("cout.txt");   	std::cout.rdbuf(fout.rdbuf()); // redirect 'cout' to a 'fout'   	//std::cout.rdbuf(cout_sbuf); // restore the original stream buffer   #endif    	int run = 0;  	cin>>run;  	int cs = 1;  	bool itrFlg = false;    	while(run--)  	{  		if(itrFlg)  			cout<<endl;  		itrFlg = true;    		int g = 0;  		cin>>g;  		int s = 0;  		cin>>s;  		int at = 0;  		cin>>at;  		vector<int> vc;  		vector<int>::iterator it_vc;  		int tmp=0;    		for(int i=0;i<g;i++)  		{  			cin>>tmp;  			vc.push_back(tmp);  		}    		int scr[3];    		int div = 0;  		int mod = 0;    		int count = 0;  		bool flag = true;    		for(it_vc = vc.begin();it_vc<vc.end();it_vc++)  		{  			flag = true;  			div = 0;  			mod = 0;  			tmp = *it_vc;  			div = tmp/3;  			mod = tmp%3;  			if(mod == 0)  			{  				scr[0]=scr[1]=scr[2]=div;  			}  			else if( mod == 1)  			{  				scr[0]=scr[1]=div;  				scr[2] = div+1;  			}  			else if( mod == 2)  			{  				scr[0]=div;  				scr[1]=scr[2]=div+1;  			}  			  			if(scr[2]>=at)  			{  				count++;  				flag = false;  			}  			  			if(s && flag)  			{  				if(scr[2]>0 && (scr[2] == (at-1)) && (scr[1] == (at-1)))  				{  					scr[2]++;  					scr[1]--;  					count++;  					s--;  					flag = false;  				}  			}  		}  		cout<<"Case #"<<cs<<": "<<count;  		cs++;  	}    	return 0;  }  <CODESPLIT> 64
#include<iostream>  #include <string>  #include<fstream>  #include<ostream>  #include<vector>  #include<algorithm>  #include<set>  #include<deque>  #include<map>  #include<math.h>  using namespace std;    #define InputOutputToFile    void merge(double arr[],int min,int mid,int max)  {    double tmp[15];    int i,j,k,m;     j=min;    m=mid+1;    for(i=min; j<=mid && m<=max ; i++)    {       if(arr[j]<=arr[m])       {           tmp[i]=arr[j];           j++;       }       else       {           tmp[i]=arr[m];           m++;       }    }    if(j>mid)    {       for(k=m; k<=max; k++)       {           tmp[i]=arr[k];           i++;       }    }    else    {       for(k=j; k<=mid; k++)       {          tmp[i]=arr[k];          i++;       }    }    for(k=min; k<=max; k++)       arr[k]=tmp[k];  }    void part(double arr[],int min,int max)  {  	int mid;  	if(min<max)  	{  		mid=(min+max)/2;  		part(arr,min,mid);  		part(arr,mid+1,max);  		merge(arr,min,mid,max);  	}  }          int main(void)  {  #ifdef InputOutputToFile  	  	//cin redirection  	std::ifstream fin("cin.txt");  	std::streambuf *inbuf = std::cin.rdbuf(fin.rdbuf());    	//cout redirection  	std::streambuf* cout_sbuf = std::cout.rdbuf(); // save original sbuf   	std::ofstream   fout("cout.txt");   	std::cout.rdbuf(fout.rdbuf()); // redirect 'cout' to a 'fout'   	//std::cout.rdbuf(cout_sbuf); // restore the original stream buffer     	//cout.txt file using c library  	//FILE* fp=fopen("C:\\Programming_VS2010\\InterviewStreet\\InsertionSort\\cout.txt","w");  #endif    	int run = 0;  	cin>>run;  	int cs = 1;  	int count=0;  	  	double *N;  	double *K;  	//double *Nt;  	//double *Kt;    	int i=0;  	int j=0;  	int dwin=0;  	int nwin=0;    	bool itrFlg = false;  	while(run--)  	{  		if(itrFlg)  		{  			N=NULL;  			K=NULL;  			//Nt=NULL;  			//Kt=NULL;  			count=0;  			i=0;  			j=0;  			dwin=0;  			nwin=0;  			cout<<endl;  			//fprintf(fp,"\n");  		}  		itrFlg = true;    		cin>>count;  		N=(double*)malloc(count*sizeof(double));  		K=(double*)malloc(count*sizeof(double));  		//Nt=(double*)malloc(count*sizeof(double));  		//Kt=(double*)malloc(count*sizeof(double));    		for(i=0;i<count;i++)  			cin>>N[i];  		for(i=0;i<count;i++)  			cin>>K[i];  		  		part(N,0,count-1);  		part(K,0,count-1);  		  		//Deceitful War  		/*  		for(i=0;i<count;i++)  		{  			Nt[i]=N[i];  			Kt[i]=K[i];  		}  		*/  		i=0,j=0;  		int tmp=count;  		while(tmp>0)  		{  			if( N[i] > K[j] )  			{  				dwin++;  				i++;  				j++;  			}  			else  			{  				i++;  			}  			tmp--;  		}      		//Normal War  		i=j=count-1;  		tmp=count;  		while(tmp>0)  		{  			if(N[i]>K[j])  			{  				nwin++;  				i--;  			}  			else  			{  				i--;  				j--;  			}  			tmp--;  		}    		cout<<"Case #"<<cs<<": "<<dwin<<" "<<nwin;  		cs++;    		//logs-start  		/*cout<<"Naomi Data"<<endl;  		for(i=0;i<count;i++)  			cout<<"N["<<i<<"] :: "<<N[i]<<endl;    		cout<<"Ken Data"<<endl;  		for(i=0;i<count;i++)  			cout<<"K["<<i<<"] :: "<<K[i]<<endl;*/  		//logs-end  		  	}    	//fflush(fp);  	//fclose(fp);  	return 0;  } <CODESPLIT> 64
#include <iostream>  #include<fstream>  //#include<ostream>  using namespace std;    #define InputOutputToFile    int main(void)  {  #ifdef InputOutputToFile  	//cin redirection  	std::ifstream fin("cin.txt");  	std::streambuf *inbuf = std::cin.rdbuf(fin.rdbuf());    	//cout redirection  	std::streambuf* cout_sbuf = std::cout.rdbuf(); // save original sbuf   	std::ofstream   fout("cout.txt");   	std::cout.rdbuf(fout.rdbuf()); // redirect 'cout' to a 'fout'   	//std::cout.rdbuf(cout_sbuf); // restore the original stream buffer   #endif    	int run = 0;  	cin>>run;  	bool itrFlg = false;  	int iter = 0;  	while(run--)  	{  		++iter;  		if(itrFlg)  			cout<<endl;  		itrFlg = true;  		int N;  		cin>>N;  		int M;  		cin>>M;    		int**ptr = new int*[N];  		for(int a=0;a<N;a++)  			ptr[a] = new int[M];    		int i,j;  		int temp;  		for(i=0;i<N;i++)  		{  			for(j=0;j<M;j++)  			{  				cin>>temp;  				ptr[i][j] = temp;  			}  		}  		  		if( (N>=3 && M>3) || (N>3 && M>=3))  		{  			char** mover = new char*[N];  			for(int a=0;a<(N);a++)  				mover[a] = new char[M];  		  			for(i=0;i<(N);i++)  			{  				for(j=0;j<(M);j++)  				{  					mover[i][j] = 'N';  				}  			}  			for(i=1;i<N-1;i++)  			{  				j=0;  				while(j<(M-1))  				{  					if(ptr[i][j] <= ptr[i][j+1])  						mover[i][++j] = 'Y';  					else  						break;  				}  				j=M-1;  				while(j>0)  				{  					if(ptr[i][j] <= ptr[i][j-1])  						mover[i][--j] = 'Y';  					else  						break;  				}  			}    			for(j=1;j<M-1;j++)  			{  				i=0;  				while(i<(N-1))  				{  					if(ptr[i][j] <= ptr[i+1][j])  						mover[++i][j] = 'Y';  					else  						break;  				}  				i=N-1;  				while(i>0)  				{  					if(ptr[i][j] <= ptr[i-1][j])  						mover[--i][j] = 'Y';  					else  						break;  				}  			}    			for(j=0;j<M;j++)  				mover[0][j] = 'Y';    			for(j=0;j<M;j++)  				mover[N-1][j] = 'Y';    			for(i=0;i<N;i++)  				mover[i][0] = 'Y';    			for(i=0;i<N;i++)  				mover[i][M-1] = 'Y';    			for(i=1;i<(N-1);i++)  			{  				bool bigl = false;  				j=1;  				while( (j<(M-1)) && (ptr[i][0] >= ptr[i][j]) )  					j++;  				if(j==(M-1))  					bigl = true;  				  				if(bigl)  				{  					j=1;  					while(j<(M-1))  					{  						if(ptr[i][0] == ptr[i][j])  							mover[i][j]='Y';  						j++;  					}  				}    				bool bigr = false;  				j=M-2;  				while( j>0 && (ptr[i][M-1]>=ptr[i][j]))  					j--;  				if(j == 0)  					bigr = true;    				if(bigr)  				{  					j=M-2;  					while(j>0)  					{  						if(ptr[i][M-1] == ptr[i][j])  							mover[i][j]='Y';  						j--;  					}  				}  			}    			for(j=1;j<(M-1);j++)  			{  				bool bigl = false;  				i=1;  				while( (i<(N-1)) && (ptr[0][j] >= ptr[i][j]) )  					i++;  				if(i==(N-1))  					bigl = true;  				  				if(bigl)  				{  					i=1;  					while(i<(N-1))  					{  						if(ptr[0][j] == ptr[i][j])  							mover[i][j]='Y';  						i++;  					}  				}    				bool bigr = false;  				i=N-2;  				while( i>0 && (ptr[N-1][j]>=ptr[i][j]))  					i--;  				if(i == 0)  					bigr = true;    				if(bigr)  				{  					i=N-2;  					while(i>0)  					{  						if(ptr[N-1][j] == ptr[i][j])  							mover[i][j]='Y';  						i--;  					}  				}  			}        			//logs  			/*for(i=0;i<(N);i++)  			{  				for(j=0;j<(M);j++)  				{  					cout<<mover[i][j]<<" ";  				}  				cout<<endl;  			}*/    			bool Nflag = false;    			for(i=0;i<(N);i++)  			{  				for(j=0;j<(M);j++)  				{  					if(mover[i][j] == 'N')  					{  						cout<<"Case #"<<iter<<": NO";  						Nflag = true;  						break;  					}  				}  				if(Nflag)  					break;  			}  			if(!Nflag)  				cout<<"Case #"<<iter<<": YES";  			  			//logs  		}  		else if ( (N==1) || (N==2) || (M==1) || (M==2) )  		{  			cout<<"Case #"<<iter<<": YES";  		}  		else if( (N==3) && (M==3) )  		{  			if(ptr[1][1] >= ptr[1][0])  				cout<<"Case #"<<iter<<": YES";  			else if(ptr[1][1] >= ptr[1][2])  				cout<<"Case #"<<iter<<": YES";  			else if(ptr[1][1] >= ptr[0][1])  				cout<<"Case #"<<iter<<": YES";  			else if(ptr[1][1] >= ptr[2][1])  				cout<<"Case #"<<iter<<": YES";  			else  				cout<<"Case #"<<iter<<": NO";  		}    	}    	return 0;  }    //logs  			/*  			for(i=0;i<N;i++)  			{  				for(j=0;j<M;j++)  				{  					cout<<ptr[i][j]<<" ";  				}  				cout<<endl;  			}  		  			for(i=0;i<(N-2);i++)  			{  				for(j=0;j<(M-2);j++)  				{  					cout<<mover[i][j]<<" ";  				}  				cout<<endl;  			}*/  			  //logs  			/*  			for(i=0;i<(N);i++)  			{  				for(j=0;j<(M);j++)  				{  					cout<<mover[i][j]<<" ";  				}  				cout<<endl;  			}*/ <CODESPLIT> 64
#include<iostream>  #include <string>  #include<fstream>  #include<ostream>  #include<vector>  #include<algorithm>  #include<set>  #include<deque>  #include<map>  #include<math.h>  using namespace std;    #define InputOutputToFile    int main(void)  {  #ifdef InputOutputToFile  	  	//cin redirection  	std::ifstream fin("cin.txt");  	std::streambuf *inbuf = std::cin.rdbuf(fin.rdbuf());    	//cout redirection  	std::streambuf* cout_sbuf = std::cout.rdbuf(); // save original sbuf   	std::ofstream   fout("cout.txt");   	std::cout.rdbuf(fout.rdbuf()); // redirect 'cout' to a 'fout'   	//std::cout.rdbuf(cout_sbuf); // restore the original stream buffer     	//cout.txt file using c library  	FILE* fp=fopen("C:\\Programming_VS2010\\InterviewStreet\\InsertionSort\\cout.txt","w");  #endif    	int run = 0;  	cin>>run;  	int cs = 1;  	/*  	long double d =100.0000000;  	long double i=6.0000000;  	long double j=d/i;  	cout<<"j :: "<<j<<endl;  	printf("j :: %f\n",j);  	*/    	double c=0.0000000;  	double f=0.0000000;  	double x=0.0000000;  	double tt=0.0000000;  	double r=2.0000000;  	double tmp1=0.0000000;  	double tmp2=0.0000000;  	bool flag=true;    	bool itrFlg = false;  	while(run--)  	{  		if(itrFlg)  		{  			c=0.0000000;  			f=0.0000000;  			x=0.0000000;  			r=2.0000000;  			tt=0.0000000;  			tmp1=0.0000000;  			tmp2=0.0000000;  			flag=true;  			//cout<<endl;  			fprintf(fp,"\n");  		}  		itrFlg = true;  		  		cin>>c>>f>>x;    		if( c>x )  		{  			tt=x/r;  			flag=false;  		}  		  		while(flag)  		{  			tmp1=0.0000000;  			tmp2=0.0000000;    			tmp1=x/r;  			tmp2=(c/r)+(x/(r+f));    			if(tmp1>tmp2)  			{  				tt=tt+(c/r);  				r=r+f;  			}  			else  			{  				flag=false;  				tt=tt+tmp1;  			}    		}      		//cout<<"Case #"<<cs<<": "<<tt;    		fprintf(fp,"Case #%d: %.7f",cs,tt);  		cs++;  	}  	fflush(fp);  	fclose(fp);  	return 0;  } <CODESPLIT> 64
#include<iostream>  #include <string>  #include<fstream>  #include<ostream>  #include<vector>  #include<algorithm>  #include<set>  #include<deque>  #include<map>  #include<math.h>  using namespace std;    #define InputOutputToFile    int main(void)  {  #ifdef InputOutputToFile  	  	//cin redirection  	std::ifstream fin("cin.txt");  	std::streambuf *inbuf = std::cin.rdbuf(fin.rdbuf());    	//cout redirection  	std::streambuf* cout_sbuf = std::cout.rdbuf(); // save original sbuf   	std::ofstream   fout("cout.txt");   	std::cout.rdbuf(fout.rdbuf()); // redirect 'cout' to a 'fout'   	//std::cout.rdbuf(cout_sbuf); // restore the original stream buffer   #endif    	int run = 0;  	cin>>run;  	int cs = 1;    	int arr1[4][4];  	int arr2[4][4];    	int ans1=0;  	int ans2=0;  	int matchPos1=-1;  	int matchPos2=-1;  	int matchCount=0;    	int i=0,j=0;  	//resets the arrays  	for(i=0;i<4;i++)  		for(j=0;j<4;j++)  			arr1[i][j]=arr2[i][j]=0;    	bool itrFlg = false;  	while(run--)  	{  		if(itrFlg)  		{  			ans1=0;  			ans2=0;  			matchPos1=-1;  			matchPos2=-1;  			matchCount=0;  			//resets the arrays  			for(i=0;i<4;i++)  				for(j=0;j<4;j++)  					arr1[i][j]=arr2[i][j]=0;  			cout<<endl;  		}  		itrFlg = true;    		cin>>ans1;  		for(i=0;i<4;i++)  			for(j=0;j<4;j++)  				cin>>arr1[i][j];    		cin>>ans2;  		for(i=0;i<4;i++)  			for(j=0;j<4;j++)  				cin>>arr2[i][j];  	  		//converting them to point correct row in arrays  		ans1--;  		ans2--;    		//Match the rows  		for(i=0;i<4;i++)  		{  			for(j=0;j<4;j++)  			{  				//cout<<"arr1["<<ans1<<"]["<<i<<"] ::"<<arr1[ans1][i]<<endl;  				//cout<<"arr2["<<ans2<<"]["<<j<<"] ::"<<arr2[ans2][j]<<endl;  				if(arr1[ans1][i] == arr2[ans2][j])  				{  					matchPos1=i;  					matchPos2=j;  					matchCount++;  				}  			}  		}    		if( matchCount>1 )  			cout<<"Case #"<<cs<<": "<<"Bad magician!";  		else if( matchCount == 0 )  			cout<<"Case #"<<cs<<": "<<"Volunteer cheated!";  		else if( matchCount==1 && (arr1[ans1][matchPos1] == arr2[ans2][matchPos2]) )  			cout<<"Case #"<<cs<<": "<<arr1[ans1][matchPos1];    		cs++;    		//logs-start  		/*  		cout<<"Answer one :: "<<ans1<<endl;  		cout<<"arr1 values\n";  		for(i=0;i<4;i++)  		{  			for(j=0;j<4;j++)  			{  				cout<<arr1[i][j];  				if(j<3)  					cout<<" ";  			}  			cout<<endl;  		}  		cout<<"Answer two :: "<<ans2<<endl;  		cout<<"arr2 values\n";  		for(i=0;i<4;i++)  		{  			for(j=0;j<4;j++)  			{  				cout<<arr2[i][j];  				if(j<3)  					cout<<" ";  			}  			cout<<endl;  		}*/  		//logs-end  				  	}    	return 0;  } <CODESPLIT> 64
#include<iostream>  #include <string>  #include<fstream>  #include<ostream>  using namespace std;  #define InputOutputToFile    int main(void)  {  #ifdef InputOutputToFile  	  	//cin redirection  	std::ifstream fin("cin.txt");  	std::streambuf *inbuf = std::cin.rdbuf(fin.rdbuf());    	//cout redirection  	std::streambuf* cout_sbuf = std::cout.rdbuf(); // save original sbuf   	std::ofstream   fout("cout.txt");   	std::cout.rdbuf(fout.rdbuf()); // redirect 'cout' to a 'fout'   	//std::cout.rdbuf(cout_sbuf); // restore the original stream buffer   #endif  	int run = 0;  	cin>>run;  	fflush(stdin);  	string input;  	getline(cin,input);  	int cs = 1;  	bool flag = false;    	while(run--)  	{  		//string input="ejp mysljylc kd kxveddknmc re jsicpdrysi";  		if(flag)  			cout<<endl;  		flag = true;  		//cin>>input;  		input.clear();  		getline(cin,input);  		char ch;  		int j=0;  		  		  		char a[26]={'y','n','f','i','c','w','l','b','k','u','o','m','x','s','e','v','z','p','d','r','j','g','t','h','a','q'};  		for(int i=0; i < (int)input.length() ; i++)  		{	  			if(input[i]==' ')  				continue;  			else  			{  				ch=input[i];			  				for(j=0;j<26;j++)  				{  					if(ch == a[j])  						break;  				}			  				input[i]=(char)j+97;  			}  		}  		cout<<"Case #"<<cs<<": "<<input;  		cs++;  	}  	return 0;  } <CODESPLIT> 64
  #include <iostream>  #include<fstream>  //#include<ostream>  using namespace std;    //#define InputOutputToFile    int main(void)  {  #ifdef InputOutputToFile  	//cin redirection  	std::ifstream fin("cin.txt");  	std::streambuf *inbuf = std::cin.rdbuf(fin.rdbuf());    	//cout redirection  	std::streambuf* cout_sbuf = std::cout.rdbuf(); // save original sbuf   	std::ofstream   fout("cout.txt");   	std::cout.rdbuf(fout.rdbuf()); // redirect 'cout' to a 'fout'   	//std::cout.rdbuf(cout_sbuf); // restore the original stream buffer   #endif    	int run = 0;  	cin>>run;  	bool itrFlg = false;  	int iter = 0;  	while(run--)  	{  		if(itrFlg)  			cout<<endl;  		itrFlg = true;    		char row[4][4];  		int Tloc[1][2];  		char diag[4];  		char diag1[4];  		int i,j;  		char c;  		char win = '0';  		bool emptyflg = false;  		bool Tflg = false;  		fflush(stdin);    		for(i=0;i<4;i++) // Taking input  		{  			for(j=0;j<4;j++)  			{  				cin>>c;  				row[i][j] = c;  				if(c == 'T')// storing T position & enabling Tflg  				{  					Tloc[0][0] = i;  					Tloc[0][1] = j;  					Tflg = true;  				}  				else if(c == '.') // enabling emptyflg  					emptyflg = true;  				  				if(i==j)  					diag[i] = c;    				if( (i==0) && (j==3) )  					diag1[0] = c;  				else if( (i==1) && (j==2) )  					diag1[1] = c;  				else if( (i==2) && (j==1) )  					diag1[2] = c;  				else if( (i==3) && (j==0) )  					diag1[3] = c;  			}  		}    		for(i=0;i<4;i++) // Checking rows for win  		{  			if(row[i][0] == 'X')  			{  				if( (row[i][1] == 'X') && (row[i][2] == 'X') && (row[i][3] == 'X') )  				{  					win = 'X';  					break;  				}  			}  			else if(row[i][0] == 'O')  			{  				if( (row[i][1] == 'O') && (row[i][2] == 'O') && (row[i][3] == 'O') )  				{  					win = 'O';  					break;  				}  			}    		}  		  		if(win == '0')   		{  			for(i=0;i<4;i++) // checking Coloumns for win  			{  				if(row[0][i] == 'X')  				{  					if( (row[1][i] == 'X') && (row[2][i] == 'X') && (row[3][i] == 'X') )  					{  						win = 'X';  						break;  					}  				}  				else if(row[0][i] == 'O')  				{  					if( (row[1][i] == 'O') && (row[2][i] == 'O') && (row[3][i] == 'O') )  					{  						win = 'O';  						break;  					}  				}    			}  		}    		if(win == '0') // checking Diag for win  		{  			if(diag[0] == 'X')  			{  				if( (diag[1] == 'X') && (diag[2] == 'X') && (diag[3] == 'X') )  				{  					win = 'X';  				}  			}  			else if(diag[0] == 'O')  			{  				if( (diag[1] == 'O') && (diag[2] == 'O') && (diag[3] == 'O') )  				{  					win = 'O';  				}  			}  		}    		if(win == '0') // checking Diag for win  		{  			if(diag1[0] == 'X')  			{  				if( (diag1[1] == 'X') && (diag1[2] == 'X') && (diag1[3] == 'X') )  				{  					win = 'X';  				}  			}  			else if(diag1[0] == 'O')  			{  				if( (diag1[1] == 'O') && (diag1[2] == 'O') && (diag1[3] == 'O') )  				{  					win = 'O';  				}  			}  		}    		if(win == '0' && Tflg) // if T is there   		{  			switch(Tloc[0][1])  			{  				case 0:  					if(row[Tloc[0][0]][1] == 'X')  					{  						if( (row[Tloc[0][0]][2] == 'X') && (row[Tloc[0][0]][3] == 'X') ) // T is at [0]  						{  							win = 'X';  						}  					}  					else if(row[Tloc[0][0]][1] == 'O')  					{  						if( (row[Tloc[0][0]][2] == 'O') && (row[Tloc[0][0]][3] == 'O') ) // T is at [0]  						{  							win = 'O';  						}  					}  					break;    				case 1:  					if(row[Tloc[0][0]][0] == 'X')  					{  						if( (row[Tloc[0][0]][2] == 'X') && (row[Tloc[0][0]][3] == 'X') ) // T is at [1]  						{  							win = 'X';  						}  					}  					else if(row[Tloc[0][0]][0] == 'O')  					{  						if( (row[Tloc[0][0]][2] == 'O') && (row[Tloc[0][0]][3] == 'O') ) // T is at [1]  						{  							win = 'O';  						}  					}  					break;    				case 2:  					if(row[Tloc[0][0]][0] == 'X')  					{  						if( (row[Tloc[0][0]][1] == 'X') && (row[Tloc[0][0]][3] == 'X') ) // T is at [2]  						{  							win = 'X';  						}  					}  					else if(row[Tloc[0][0]][0] == 'O')  					{  						if( (row[Tloc[0][0]][1] == 'O') && (row[Tloc[0][0]][3] == 'O') ) // T is at [2]  						{  							win = 'O';  						}  					}  					break;    				case 3:  					if(row[Tloc[0][0]][0] == 'X')  					{  						if( (row[Tloc[0][0]][1] == 'X') && (row[Tloc[0][0]][2] == 'X') ) // T is at [3]  						{  							win = 'X';  						}  					}  					else if(row[Tloc[0][0]][0] == 'O')  					{  						if( (row[Tloc[0][0]][1] == 'O') && (row[Tloc[0][0]][2] == 'O') ) // T is at [3]  						{  							win = 'O';  						}  					}  					break;  			}  		}    		if(win == '0' && Tflg) // if T is there in Dia  		{  			if(Tloc[0][0] == Tloc[0][1])  			{  				switch(Tloc[0][0])  				{  				case 0:  					if(diag[1] == 'X')  					{  						if( (diag[2] == 'X') && (diag[3] == 'X') )  						{  							win = 'X';  						}  					}  					else if(diag[1] == 'O')  					{  						if( (diag[2] == 'O') && (diag[3] == 'O') )  						{  							win = 'O';  						}  					}  					break;  				  				case 1:  					if(diag[0] == 'X')  					{  						if( (diag[2] == 'X') && (diag[3] == 'X') )  						{  							win = 'X';  						}  					}  					else if(diag[0] == 'O')  					{  						if( (diag[2] == 'O') && (diag[3] == 'O') )  						{  							win = 'O';  						}  					}  					break;  				  				case 2:  					if(diag[0] == 'X')  					{  						if( (diag[1] == 'X') && (diag[3] == 'X') )  						{  							win = 'X';  						}  					}  					else if(diag[0] == 'O')  					{  						if( (diag[1] == 'O') && (diag[3] == 'O') )  						{  							win = 'O';  						}  					}  					break;  				  				case 3:  					if(diag[1] == 'X')  					{  						if( (diag[2] == 'X') && (diag[0] == 'X') )  						{  							win = 'X';  						}  					}  					else if(diag[1] == 'O')  					{  						if( (diag[2] == 'O') && (diag[0] == 'O') )  						{  							win = 'O';  						}  					}  					break;  				}  			}  		}    		if(win == '0' && Tflg)  		{  			if( (Tloc[0][0] == 0) && (Tloc[0][1] == 3) && (diag1[0] == 'T') ) //Diag1[0]  			{  				if(diag1[1] == 'X')  				{  					if( (diag1[2] == 'X') && (diag1[3] == 'X') )  					{  						win = 'X';  					}  				}  				else if(diag1[1] == 'O')  				{  					if( (diag1[2] == 'O') && (diag1[3] == 'O') )  					{  						win = 'O';  					}  				}  			}  			else if( (Tloc[0][0] == 1) && (Tloc[0][1] == 2) && (diag1[1] == 'T') )  			{  				if(diag1[0] == 'X')  				{  					if( (diag1[2] == 'X') && (diag1[3] == 'X') )  					{  						win = 'X';  					}  				}  				else if(diag1[0] == 'O')  				{  					if( (diag1[2] == 'O') && (diag1[3] == 'O') )  					{  						win = 'O';  					}  				}  			}  			else if( (Tloc[0][0] == 2) && (Tloc[0][1] == 1) && (diag1[2] == 'T') )  			{  				if(diag1[1] == 'X')  				{  					if( (diag1[0] == 'X') && (diag1[3] == 'X') )  					{  						win = 'X';  					}  				}  				else if(diag1[1] == 'O')  				{  					if( (diag1[0] == 'O') && (diag1[3] == 'O') )  					{  						win = 'O';  					}  				}  			}  			else if( (Tloc[0][0] == 3) && (Tloc[0][1] == 0) && (diag1[3] == 'T') )  			{  				if(diag1[1] == 'X')  				{  					if( (diag1[2] == 'X') && (diag1[0] == 'X') )  					{  						win = 'X';  					}  				}  				else if(diag1[1] == 'O')  				{  					if( (diag1[2] == 'O') && (diag1[0] == 'O') )  					{  						win = 'O';  					}  				}  			}  		}    		//Result Display  		cout<<"Case #"<<++iter<<": ";  		if(win == '0' && emptyflg)  			cout<<"Game has not completed";  		else if( win == '0' && !emptyflg)  			cout<<"Draw";  		else if( win == 'X')  			cout<<"X won";  		else if( win == 'O')  			cout<<"O won";    		  		//logs  	}    	return 0;  }  //logs  		/*for(i=0;i<4;i++)  		{  			for(j=0;j<4;j++)  			{  				cout<<row[i][j];  			}  			cout<<endl;  		}  		cout<<endl;*/ <CODESPLIT> 64
#include<iostream>  #include <string>  #include<fstream>  #include<ostream>  #include<vector>  #include<algorithm>  #include<set>  #include<deque>  #include<map>  #include<math.h>  using namespace std;    #define InputOutputToFile    #define ROW 50  #define COL 50    int main(void)  {  #ifdef InputOutputToFile  	  	//cin redirection  	std::ifstream fin("cin.txt");  	std::streambuf *inbuf = std::cin.rdbuf(fin.rdbuf());    	//cout redirection  	std::streambuf* cout_sbuf = std::cout.rdbuf(); // save original sbuf   	std::ofstream   fout("cout.txt");   	std::cout.rdbuf(fout.rdbuf()); // redirect 'cout' to a 'fout'   	//std::cout.rdbuf(cout_sbuf); // restore the original stream buffer     	//cout.txt file using c library  	//FILE* fp=fopen("C:\\Programming_VS2010\\InterviewStreet\\InsertionSort\\cout.txt","w");  #endif    	int run = 0;  	cin>>run;  	int cs = 1;    	int i=0;  	int j=0;  	char board[ROW][COL];  	for(i=0;i<ROW;i++)  		for(j=0;j<COL;j++)  			board[i][j]='.';  	int row=0;  	int col=0;  	int mcount=0;  	int tmp=0;  	bool itrFlg = false;  	while(run--)  	{  		if(itrFlg)  		{  			row=0;  			col=0;  			mcount=0;  			tmp=0;  			//reset the board  			for(i=0;i<ROW;i++)  				for(j=0;j<COL;j++)  					board[i][j]='.';    			cout<<endl;  			//fprintf(fp,"\n");  		}    		itrFlg = true;  		cin>>row>>col>>mcount;    		if( mcount==1 && row==2 && col==2)  		{  			cout<<"Case #"<<cs<<":"<<endl<<"Impossible";  		}  		else if( mcount > ((row-1)*(col-1)+1) )  		{  			cout<<"Case #"<<cs<<":"<<endl<<"Impossible";  		}  		else  		{  			tmp=mcount;  			for(i=0;i<row;i++)  			{  				for(j=0;j<col;j++)  				{  					if(tmp>0)  					{  						board[i][j]='*';  						tmp--;  					}  					else  						break;  				}  				if(tmp==0)  					break;  			}  			//cout<<"i::"<<i<<" j::"<<j<<endl;  			if(j<(col-1))  				board[i][j]='c';  			else if(i<(row-1))  				board[i+1][0]='c';  			//print the board  			cout<<"Case #"<<cs<<":"<<endl;  			for(i=0;i<row;i++)  			{  				for(j=0;j<col;j++)  				{  					cout<<board[i][j];  				}  				if( i < (row-1))  					cout<<endl;  			}  		}  		  		cs++;  	}    	return 0;  } <CODESPLIT> 64
#include<iostream>  #include <string>  #include<fstream>  #include<ostream>  #include<vector>  #include<algorithm>  #include<set>  using namespace std;    #define InputOutputToFile    int main(void)  {  #ifdef InputOutputToFile  	  	//cin redirection  	std::ifstream fin("cin.txt");  	std::streambuf *inbuf = std::cin.rdbuf(fin.rdbuf());    	//cout redirection  	std::streambuf* cout_sbuf = std::cout.rdbuf(); // save original sbuf   	std::ofstream   fout("cout.txt");   	std::cout.rdbuf(fout.rdbuf()); // redirect 'cout' to a 'fout'   	//std::cout.rdbuf(cout_sbuf); // restore the original stream buffer   #endif    	int run = 0;  	cin>>run;    	int min = 0;  	int max = 0;    	bool itrFlg = false;  	set<int> st_rec;  	set<int> st_all;  	set<int>::iterator it_st_rec;  	set<int>::iterator it_st_all;    	//int count = 0;  	int cs = 1;    	while(run--)  	{  		st_rec.clear();  		st_all.clear();  		//count = 0;    		if(itrFlg)  			cout<<endl;  		itrFlg = true;    		min = 0;  		max = 0;  		cin>>min;  		cin>>max;  		  		for(; min<=max;min++)  		{  			if(max<=20)  				break;    			if(min<=11)  				min = 12;    			if(min<=99)  			{  				int arr_1[2] = {0,0};  				int arr_2[2] = {0,0};  				int tmp  = 0;  				tmp = min;  				arr_2[1]=arr_1[1] = tmp%10;  				tmp = tmp/10;  				arr_2[0]=arr_1[0] = tmp%10;  							  				while(next_permutation(arr_2,arr_2+2))  				{  					if((arr_2[1] == arr_1[0]) && (arr_2[0] == arr_1[1]))  					{  						tmp = arr_2[0]*10 + arr_2[1];  						it_st_all = st_all.find(tmp);  						it_st_rec = st_rec.find(tmp);  						if( (it_st_all == st_all.end()) && (it_st_rec == st_rec.end()) && tmp<=max)  						{  							//count++;  							st_rec.insert(min);  							st_all.insert(min);  							st_all.insert(tmp);  						}  					}  				}  			}  			else if(min<=999)  			{  				int arr_1[3] = {0,0,0};  				int arr_2[3] = {0,0,0};  				int tmp  = 0;  				tmp = min;  				arr_2[2]=arr_1[2] = tmp%10;  				tmp = tmp/10;  				arr_2[1]=arr_1[1] = tmp%10;  				tmp = tmp/10;  				arr_2[0]=arr_1[0] = tmp%10;  				  				while(next_permutation(arr_2,arr_2+3))  				{  					if( ((arr_2[0] == arr_1[2]) && (arr_2[1] == arr_1[0]) && (arr_2[2] == arr_1[1])) || ((arr_2[0] == arr_1[1]) && (arr_2[1] == arr_1[2]) && (arr_2[2] == arr_1[0])) )   					{  						tmp = arr_2[0]*100 + arr_2[1]*10 + arr_2[2];  						it_st_all = st_all.find(tmp);  						it_st_rec = st_rec.find(tmp);  						if( (it_st_all == st_all.end()) && (it_st_rec == st_rec.end()) && tmp<=max && tmp>=min)  						{  							//count++;  							st_rec.insert(min);  							st_all.insert(min);  							st_all.insert(tmp);  						}  					}  				}  			}    		}/*  		for(it_st_all = st_all.begin(); it_st_all != st_all.end(); it_st_all++)  			cout<<*(it_st_all)<<" ";  		cout<<endl;    		for(it_st_rec = st_rec.begin(); it_st_rec != st_rec.end(); it_st_rec++)  			cout<<*(it_st_rec)<<" ";  		cout<<endl;  		*/  		cout<<"Case #"<<cs<<": "<<(int)st_rec.size();  		cs++;    	}    	return 0;  }    <CODESPLIT> 64
# python 3    import math    def is_palindrome(num):      s = str(num)      end_idx = len(s)-1      for i in range(len(s)//2):          if s[i] != s[end_idx-i]:              return False      return True    def is_valid_base(base):      return is_palindrome(base) and is_palindrome(base*base)    def process_case(lo, hi):      cnt = 0      base_lo = math.ceil(math.sqrt(lo))      base_hi = math.floor(math.sqrt(hi))      for base in range(base_lo, base_hi+1):          if is_valid_base(base):              cnt += 1      return cnt    def result_gen(lines):      ncases = int(next(lines))      for ci in range(1,ncases+1):          lo,hi = line_of_numbers(next(lines))          result = process_case(lo, hi)          yield 'Case #{0}: {1}\n'.format(ci, result)        def line_of_numbers(s):      return [int(sub) for sub in s.split()]    def input_gen(f_in):      for line in f_in:          if line.endswith('\n'):              line = line[:-1]          yield line    def start(basename):      infile = basename + '.in'      outfile = basename + '.out'      f_in = open(infile, 'r')      f_out = open(outfile, 'w')      f_out.writelines(result_gen(input_gen(f_in)))      f_in.close()      f_out.close()    ##start('C-test')  start('C-small-attempt0')  ##start('C-large')  <CODESPLIT> 65
# python 3  import string  import itertools  import sys    def threshold(p, maxdiff):      minval = max(p - maxdiff, 0)      return p + minval + minval    def process_case(numdata):      N,S,p = numdata[0:3]      scores = numdata[3:]      thre_normal = threshold(p, 1)      thre_surprise = threshold(p, 2)      result = 0      for tot in scores:          if tot >= thre_normal:              result += 1          elif S > 0 and tot >= thre_surprise:              result += 1              S -= 1      return result    def result_gen(lines):      ncases = int(next(lines))      for ci in range(1,ncases+1):          result = process_case(line_of_numbers(next(lines)))          yield 'Case #{0}: {1}\n'.format(ci, result)        def line_of_numbers(s):      return [int(sub) for sub in s.split()]    def input_gen(f_in):      for line in f_in:          if line.endswith('\n'):              line = line[:-1]          yield line    def start(basename):      infile = basename + '.in'      outfile = basename + '.out'      f_in = open(infile, 'r')      f_out = open(outfile, 'w')      f_out.writelines(result_gen(input_gen(f_in)))      f_in.close()      f_out.close()    ##start('B-test')  start('B-small-attempt0')  ##start('B-large')  <CODESPLIT> 65
# python 3  import string  import itertools  import sys    def war_points(N, naomi_sorted, ken_sorted):      j=0      naomi_points = 0      for i in range(N):          while j < N and naomi_sorted[i] > ken_sorted[j]:              j += 1          if j < N:              j += 1          else:              naomi_points += 1      return naomi_points        def deceitful_war_points(N, naomi_sorted, ken_sorted):      j=0      naomi_points = 0      for i in range(N):          while j < N and ken_sorted[i] > naomi_sorted[j]:              j += 1          if j < N:              naomi_points += 1              j += 1      return naomi_points    def process_case(N, naomi_sorted, ken_sorted):      x1 = deceitful_war_points(N, naomi_sorted, ken_sorted)      x2 = war_points(N, naomi_sorted, ken_sorted)      return (x1, x2)    def result_gen(lines):      ncases = int(next(lines))      for ci in range(1,ncases+1):          N = int(next(lines))          naomi_sorted = line_of_floats_sorted(next(lines))          ken_sorted = line_of_floats_sorted(next(lines))          x1, x2 = process_case(N, naomi_sorted, ken_sorted)          yield 'Case #{0}: {1} {2}\n'.format(ci, x1, x2)        def line_of_floats_sorted(s):      fv = [float(sub) for sub in s.split()]      fv.sort()      return fv    def input_gen(f_in):      for line in f_in:          if line.endswith('\n'):              line = line[:-1]          yield line    def start(basename):      infile = basename + '.in'      outfile = basename + '.out'      f_in = open(infile, 'r')      f_out = open(outfile, 'w')      f_out.writelines(result_gen(input_gen(f_in)))      f_in.close()      f_out.close()    ##start('D-test')  start('D-small-attempt0')  ##start('D-large')  <CODESPLIT> 65
# python 3  import string  import itertools  import sys    def is_valid(height, max1, max2):      if height < max1 and height < max2:          return False      return True    def process_case(heights):      nrows = len(heights)      ncols = len(heights[0])      col_max_vals = [max((heights[r][c] for r in range(nrows)))                      for c in range(ncols)]      row_max_vals = [max((heights[r][c] for c in range(ncols)))                      for r in range(nrows)]      for r in range(nrows):          for c in range(ncols):              if not is_valid(heights[r][c], row_max_vals[r], col_max_vals[c]):                  return 'NO'      return 'YES'    def result_gen(lines):      ncases = int(next(lines))      for ci in range(1,ncases+1):          nrows, ncols = line_of_numbers(next(lines))          heights = [line_of_numbers(next(lines)) for r in range(nrows)]          result = process_case(heights)          yield 'Case #{0}: {1}\n'.format(ci, result)        def line_of_numbers(s):      return [int(sub) for sub in s.split()]    def input_gen(f_in):      for line in f_in:          if line.endswith('\n'):              line = line[:-1]          yield line    def start(basename):      infile = basename + '.in'      outfile = basename + '.out'      f_in = open(infile, 'r')      f_out = open(outfile, 'w')      f_out.writelines(result_gen(input_gen(f_in)))      f_in.close()      f_out.close()    ##start('B-test')  start('B-small-attempt0')  ##start('B-large')  <CODESPLIT> 65
# python 3  import string  import itertools  import sys    BASE_RATE = 2.0    def process_case(C, F, X):      rate = BASE_RATE      total_time = 0.0      while True:                  xtime = X / rate          ctime = C / rate          ext_rate = rate + F          ext_time = ctime + (X / ext_rate)          if xtime <= ext_time:              total_time += xtime              break          total_time += ctime          rate = ext_rate      return total_time    def result_gen(lines):      ncases = int(next(lines))      for ci in range(1,ncases+1):          C, F, X = line_of_floats(next(lines))          result = process_case(C, F, X)          yield 'Case #{0}: {1:.7f}\n'.format(ci, result)    def line_of_floats(s):      return [float(sub) for sub in s.split()]    def input_gen(f_in):      for line in f_in:          if line.endswith('\n'):              line = line[:-1]          yield line    def start(basename):      infile = basename + '.in'      outfile = basename + '.out'      f_in = open(infile, 'r')      f_out = open(outfile, 'w')      f_out.writelines(result_gen(input_gen(f_in)))      f_in.close()      f_out.close()    ##start('B-test')  start('B-small-attempt0')  ##start('B-large')  <CODESPLIT> 65
# python 3  import string  import itertools  import sys    def process_case(row1, tab1, row2, tab2):      s1 = set(tab1[row1])      s2 = set(tab2[row2])      xset = s1 & s2      if len(xset) == 1:          result = xset.pop()      elif len(xset) == 0:          result = 'Volunteer cheated!'      else:          result = 'Bad magician!'      return result    def result_gen(lines):      ncases = int(next(lines))      for ci in range(1,ncases+1):          row1 = int(next(lines)) - 1          tab1 = [line_of_numbers(next(lines)) for i in range(4)]          row2 = int(next(lines)) - 1          tab2 = [line_of_numbers(next(lines)) for i in range(4)]          result = process_case(row1, tab1, row2, tab2)          yield 'Case #{0}: {1}\n'.format(ci, result)        def line_of_numbers(s):      return [int(sub) for sub in s.split()]    def input_gen(f_in):      for line in f_in:          if line.endswith('\n'):              line = line[:-1]          yield line    def start(basename):      infile = basename + '.in'      outfile = basename + '.out'      f_in = open(infile, 'r')      f_out = open(outfile, 'w')      f_out.writelines(result_gen(input_gen(f_in)))      f_in.close()      f_out.close()    ##start('A-test')  start('A-small-attempt0')  ##start('A-large')  <CODESPLIT> 65
# python 3  import string  import itertools  import sys    samples = [('a zoo',              'y qee'),             ('our language is impossible to understand',              'ejp mysljylc kd kxveddknmc re jsicpdrysi'),             ('there are twenty six factorial possibilities',              'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd'),             ('so it is okay if you want to just give up',              'de kr kd eoya kw aej tysr re ujdr lkgc jv')]               def process_case(line, trans):      return ''.join(trans[ch] for ch in line)    def prepare_translation():      trans = {}      for eg_seqs in samples:          for echar,gchar in zip(*eg_seqs):              trans[gchar] = echar      miss_g = set(string.ascii_lowercase) - set(trans.keys())      miss_e = set(string.ascii_lowercase) - set(trans.values())      if (len(miss_g) == 1 and len(miss_e) == 1):          trans[miss_g.pop()] = miss_e.pop();      return trans    def result_gen(lines):      trans = prepare_translation()      ncases = int(next(lines))      for ci in range(1,ncases+1):          result = process_case(next(lines), trans)          yield 'Case #{0}: {1}\n'.format(ci, result)        def line_of_numbers(s):      return [int(sub) for sub in s.split()]    def input_gen(f_in):      for line in f_in:          if line.endswith('\n'):              line = line[:-1]          yield line    def start(basename):      infile = basename + '.in'      outfile = basename + '.out'      f_in = open(infile, 'r')      f_out = open(outfile, 'w')      f_out.writelines(result_gen(input_gen(f_in)))      f_in.close()      f_out.close()    ##start('A-test')  start('A-small-attempt0')  ##start('A-large')  <CODESPLIT> 65
# python 3  import string  import itertools  import sys    P1 = 'X'  P2 = 'O'  PA = 'T'  EMPTY = '.'    def no_empty_fields(board):      for row in board:          for field in row:              if field==EMPTY:                  return False      return True    def is_winning_series(board, r0, c0, dr, dc, player):      r,c = r0,c0      for i in range(4):          if board[r][c] != player and board[r][c] != PA:              return False          r,c = r+dr,c+dc      return True    def win_condition(board, player):      if is_winning_series(board, 0,0, 1,1, player):          return True      if is_winning_series(board, 0,3, 1,-1, player):          return True      for i in range(4):          if is_winning_series(board, 0,i, 1,0, player):              return True          if is_winning_series(board, i,0, 0,1, player):              return True      return False    def process_case(board):      for player in {P1, P2}:          if win_condition(board, player):              return '{0} won'.format(player)      if no_empty_fields(board):          return 'Draw'      return 'Game has not completed'    def result_gen(lines):      ncases = int(next(lines))      for ci in range(1,ncases+1):          board = [[ch for ch in next(lines)] for i in range(4)]          next(lines)          result = process_case(board)          yield 'Case #{0}: {1}\n'.format(ci, result)        def line_of_numbers(s):      return [int(sub) for sub in s.split()]    def input_gen(f_in):      for line in f_in:          if line.endswith('\n'):              line = line[:-1]          yield line    def start(basename):      infile = basename + '.in'      outfile = basename + '.out'      f_in = open(infile, 'r')      f_out = open(outfile, 'w')      f_out.writelines(result_gen(input_gen(f_in)))      f_in.close()      f_out.close()    ##start('A-test')  start('A-small-attempt0')  ##start('A-large')  <CODESPLIT> 65
# python 3  import string  import itertools  import sys  from pprint import pprint    def mines_refill(board, xr, xc, nfree):      to_refill = xr*xc - nfree      for r in reversed(range(2, xr)):          for c in reversed(range(2, xc)):              if not to_refill:                  return              assert(board[r][c] == '.')              board[r][c] = '*'              to_refill -= 1      # Bad board, but valid one      for r in reversed(range(xr)):          for c in reversed(range(xc)):              if not to_refill:                  return              if board[r][c] == '.':                  board[r][c] = '*'                  to_refill -= 1      assert(to_refill == 0)        def generate_board(nrows, ncols, nmines):      nfree = nrows*ncols - nmines      xr=1; xc=1;      while True:          if xr*xc >= nfree:              break          if xr < nrows:              xr += 1          if xr*xc >= nfree:              break          if xc < ncols:              xc += 1      board = [['*' for c in range(ncols)] for r in range(nrows)]      for r in range(xr):          for c in range(xc):              board[r][c] = '.'      mines_refill(board, xr, xc, nfree)      board[0][0] = 'c'      return board            def find_click_point(board):      nrows = len(board)      ncols = len(board[0])      for r in range(nrows):          for c in range(ncols):              if board[r][c] == 'c':                  return (r,c)      raise ValueError('Start point not present')    def enum_neighbour_coords(r0, c0, nrows, ncols):      for r in range(r0-1, r0+2):          if r<0 or r>=nrows:              continue          for c in range(c0-1, c0+2):              if c<0 or c>=ncols:                  continue              yield (r,c)    def click_board(board, click_coords):      nrows = len(board)      ncols = len(board[0])      points = [click_coords]      while points:          r0,c0 = points.pop()          mines_cnt = 0          for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):              if board[r][c] == '*':                  mines_cnt += 1          board[r0][c0] = str(mines_cnt)          if not mines_cnt:              for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):                  if board[r][c] == '.':                      points.append((r,c))    def all_fields_checked(board):      nrows = len(board)      ncols = len(board[0])      for r in range(nrows):          for c in range(ncols):              if board[r][c] == '.':                  return False      return True    def is_board_oneclick(original_board):      board = [row[:] for row in original_board] # deep copy      assert(board[0][0] == 'c')      r,c = find_click_point(board)      click_board(board, (r,c))      is_oneclick = all_fields_checked(board)      return is_oneclick    def board2result(board):      return [''.join(row) for row in board]    def process_case(nrows, ncols, nmines):      board = generate_board(nrows, ncols, nmines)      if is_board_oneclick(board):          result = board2result(board)      else:          result = ['Impossible']      return result    def result_gen(lines):      ncases = int(next(lines))      for ci in range(1,ncases+1):          R, C, M = line_of_numbers(next(lines))          result = process_case(R, C, M)          yield 'Case #{0}:\n'.format(ci, result)          for res_line in result:              yield res_line + '\n'        def line_of_numbers(s):      return [int(sub) for sub in s.split()]    def input_gen(f_in):      for line in f_in:          if line.endswith('\n'):              line = line[:-1]          yield line    def start(basename):      infile = basename + '.in'      outfile = basename + '.out'      f_in = open(infile, 'r')      f_out = open(outfile, 'w')      f_out.writelines(result_gen(input_gen(f_in)))      f_in.close()      f_out.close()    ##start('C-test')  start('C-small-attempt0')  ##start('C-large')  <CODESPLIT> 65
# python 3  import string  import itertools  import sys    def gen_rotations(num):      digits = [ch for ch in str(num)]      for i in range(1, len(digits)):          if digits[i] != '0':              result = 0              for d in digits[i:]:                  result = 10*result + ord(d) - ord('0')              for d in digits[:i]:                  result = 10*result + ord(d) - ord('0')              if result == num:                  return              yield result        def process_case(a,b):      result = 0      for n in range(a,b+1):          for m in gen_rotations(n):              if (n < m <= b):                  result += 1      return result    def result_gen(lines):      ncases = int(next(lines))      for ci in range(1,ncases+1):          a,b = line_of_numbers(next(lines))          result = process_case(a,b)          yield 'Case #{0}: {1}\n'.format(ci, result)        def line_of_numbers(s):      return [int(sub) for sub in s.split()]    def input_gen(f_in):      for line in f_in:          if line.endswith('\n'):              line = line[:-1]          yield line    def start(basename):      infile = basename + '.in'      outfile = basename + '.out'      f_in = open(infile, 'r')      f_out = open(outfile, 'w')      f_out.writelines(result_gen(input_gen(f_in)))      f_in.close()      f_out.close()    ##start('C-test')  start('C-small-attempt0')  ##start('C-large')  <CODESPLIT> 65
from optparse import OptionParser  import string  import pickle    def solve(lower, upper, cache):      counter = 0      for item in cache:          if item > upper:              break          if item < lower:              continue          counter += 1      return counter    def is_palindrome(test_int):      str_arg = str(test_int)      return str_arg == str_arg[::-1]    def generate_cache():      """ Generates a list of 'fair and square' numbers between 1 and 10^100        By observation of generating the first few of these numbers it became      obvious that the 'roots' fitted a very specific pattern, they are either      single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;      multiple digits with a 2 at the beginning and end and 1s and 0s in the      middle or an odd number of digits with a single 2 in the centre and 1s and      0s elsewhere.        This function therefore only looks at these numbers to build a list of all      valid results. """      # Put 9 in to start with as it's the only one that uses a 3.      cache = [9,]      counter = 1      if upper_bound is None:          upper_bound = pow(2,25)      while counter < upper_bound:          binary_part = "{0:b}".format(counter)          # Look for palindromes beginning with a 1          half_int = binary_part          # Check the odd length palindrome          pal_int = int(half_int + half_int[:-1][::-1])          pal_square = pal_int * pal_int          if is_palindrome(pal_square):              cache.append(pal_square)          # Check the even length palindrome          pal_int = int(half_int + half_int[::-1])          pal_square = pal_int * pal_int          if is_palindrome(pal_square):              cache.append(pal_square)          half_int = "%s%s" % (binary_part, 2)          # Check the odd length palindrome only when adding a 2          pal_int = int(half_int + half_int[:-1][::-1])          pal_square = pal_int * pal_int          if is_palindrome(pal_square):              cache.append(pal_square)          # Look for palindromes beginning with a 2          half_int = "2%s" % binary_part[1:]          # Check the odd length palindrome          pal_int = int(half_int + half_int[:-1][::-1])          pal_square = pal_int * pal_int          if is_palindrome(pal_square):              cache.append(pal_square)          # Check the even length palindrome          pal_int = int(half_int + half_int[::-1])          pal_square = pal_int * pal_int          if is_palindrome(pal_square):              cache.append(pal_square)          counter += 1      return sorted(cache)      def main():      parser = OptionParser()      parser.add_option("-f", "--file", dest="filename",                        help="read input from FILE", metavar="FILE")      parser.add_option("-c", "--cache", dest="cache_filename",                        help="read/write cache from/to CACHE_FILE", metavar="CACHE_FILE")      parser.add_option("-g", "--generate-cache", dest="generate_cache",                        help="generate the cache file", action="store_true")      cache = None      (options, args) = parser.parse_args()      if options.generate_cache:          # Generate a cache file before going through answers so that we don't          # waste precious time later.          cache = generate_cache()          if not options.cache_filename:              output_file = open(options.cache_filename, "w")              pickle.dump(cache, output_file)              output_file.close()      else:          cache_file = open(options.cache_filename, "r")          cache = pickle.load(cache_file)          cache_file.close()      if not options.filename:          parser.error("Must provide a filename.")      input_file = open(options.filename, "r")      total_cases = int(input_file.readline())      case_number = 0      while case_number < total_cases:          case_number += 1          lower,upper = input_file.readline().split()          lower = int(lower)          upper = int(upper)          data_args = (lower, upper, cache)          print "Case #%d: %s" % (case_number, solve(*data_args))    if __name__ == "__main__":      main() <CODESPLIT> 66
from optparse import OptionParser    def solve(N,S,p,t):      # Easy pickings, if p is 0 then all must win.      if p == 0:          return N      outright_wins = 0      potential_surprises = 0      win_cutoff = (p * 3) - 3      surprise_cutoff = win_cutoff - 2      for score in t:          if score == 0:              continue          elif score > win_cutoff:              outright_wins += 1          elif score > surprise_cutoff:              potential_surprises += 1      if potential_surprises < S:          return outright_wins + potential_surprises      else:          return outright_wins + S    def parse_case(data_line):      bits = data_line.split()      N = int(bits[0])      S = int(bits[1])      p = int(bits[2])      t = [int(x) for x in bits[3:]]      return N,S,p,t    def main():      parser = OptionParser()      parser.add_option("-f", "--file", dest="filename",                        help="read input from FILE", metavar="FILE")        (options, args) = parser.parse_args()      if not options.filename:          parser.error("Must provide a filename.")      input_file = open(options.filename, "r")      total_cases = int(input_file.readline())      case_number = 0      while case_number < total_cases:      	case_number += 1      	data_args = parse_case(input_file.readline())      	print "Case #%d: %d" % (case_number, solve(*data_args))    if __name__ == "__main__":  	main() <CODESPLIT> 66
# Written for Python 2.7.5    from optparse import OptionParser  from StringIO import StringIO  import sys    # Expected format of TEST_CASES is a list of tuples of (input, expected_output)  TEST_CASES = [      ("""4  1  0.5  0.6  2  0.7 0.2  0.8 0.3  3  0.5 0.1 0.9  0.6 0.4 0.3  9  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458  ""","""Case #1: 0 0  Case #2: 1 0  Case #3: 2 1  Case #4: 8 4  """)  ]    def parse_input(input_reader):      case_count = int(input_reader.readline())      case_idx = 0      while case_count > case_idx:          case_idx += 1          block_count = int(input_reader.readline())          naomi_blocks = [float(x) for x in input_reader.readline().split(" ")]          ken_blocks = [float(x) for x in input_reader.readline().split(" ")]          input_values = {"case":case_idx,                          "naomi": naomi_blocks,                          "ken": ken_blocks,                          "block_count": block_count                          }          yield input_values      def solve_problem(output_writer=sys.stdout, **kwargs):      ken = sorted(kwargs["ken"])      naomi = sorted(kwargs["naomi"])      case = kwargs["case"]      block_count = kwargs["block_count"]        dw_idx = 0      w_idx = 0        w_score = 0      dw_score = 0        for block in naomi:          if block > ken[dw_idx]:              dw_score += 1              dw_idx += 1      naomi = sorted(naomi, key=lambda x: -x)      ken = sorted(ken, key=lambda x: -x)      for block in naomi:          if block > ken[w_idx]:              w_score += 1          else:              w_idx += 1        print >> output_writer, "Case #%d: %d %d" % (case, dw_score, w_score)              # Implementation of code to solve the problem.      # Use 'print >> output_writer, "Thing"' to output values.    def solve_inputs(input_reader, output_writer):      """      Loop through each problem input in input reader and solve it.        Outputs responses to output_writer.      """      for input_values in parse_input(input_reader):          solve_problem(output_writer=output_writer, **input_values)    def run_tests():      idx = 0      all_pass = True      for problem_input, expected_output in TEST_CASES:          idx += 1          input_reader = StringIO(problem_input)          output_writer = StringIO()          solve_inputs(input_reader, output_writer)          problem_output = output_writer.getvalue()          if problem_output == expected_output:              print "Test %d: Success" % idx          else:              all_pass = False              print "Test %d: Failure" % idx          input_reader.close()          output_writer.close()      if all_pass:          print "All tests were successful!"      else:          print "Something didn't match - try again."    def main():      parser = OptionParser()      parser.add_option("-f", "--file",                        dest="filename_stem",                        help="read input from FILE.in and write to FILE.out",                        metavar="FILE")        (options, args) = parser.parse_args()      if options.filename_stem:          print "Running in file mode."          input_reader = open("%s.in" % options.filename_stem, "r")          output_writer = open("%s.out" % options.filename_stem, "w")          solve_inputs(input_reader, output_writer)      else:          print "Running in test mode."          run_tests()    if __name__ == "__main__":      main() <CODESPLIT> 66
from optparse import OptionParser  import string    def solve(rows,cols,width,height):      # Calculate the lowest setting that can be used when cutting a row or col.      row_mins = [max(row) for row in rows]      col_mins = [max(col) for col in cols]      for row_idx in range(height):          for col_idx in range(width):              if row_mins[row_idx] > rows[row_idx][col_idx] \                 and col_mins[col_idx] > rows[row_idx][col_idx]:                  return "NO"      return "YES"      def parse_case(data,width,height):      data_line = [int(entry) for entry in reduce(lambda x,y: x+y, data, [])]      rows = []      cols = []      for idx in range(height):          offset = idx * width          # Pull rows          rows.append(data_line[offset:offset+width])      for idx in range(width):          # Pull columns          cols.append(data_line[idx::width][:height])      return (rows, cols, width, height)    def main():      parser = OptionParser()      parser.add_option("-f", "--file", dest="filename",                        help="read input from FILE", metavar="FILE")        (options, args) = parser.parse_args()      if not options.filename:          parser.error("Must provide a filename.")      input_file = open(options.filename, "r")      total_cases = int(input_file.readline())      case_number = 0      while case_number < total_cases:          case_number += 1          height,width = input_file.readline().split()          width = int(width)          height = int(height)          data = []          for idx in range(height):              data.append(input_file.readline().split())          data_args = parse_case(data, width, height)          print "Case #%d: %s" % (case_number, solve(*data_args))    if __name__ == "__main__":      main() <CODESPLIT> 66
# Written for Python 2.7.5    from optparse import OptionParser  from StringIO import StringIO  from math import ceil  import sys    # Expected format of TEST_CASES is a list of tuples of (input, expected_output)  TEST_CASES = [      ("""4  30.0 1.0 2.0  30.0 2.0 100.0  30.50000 3.14159 1999.19990  500.0 4.0 2000.0  ""","""Case #1: 1.0000000  Case #2: 39.1666667  Case #3: 63.9680013  Case #4: 526.1904762  """)  ]    """  Z is number of farms held  tF(Z) is time to build a farm = C / (2+(F*Z))  tX(Z) is time to win = X / (2+(F*Z))  No point incresing Z when tX(Z) < (tX(Z+1) + tF(Z)      == X / (2+(F*Z)) < (X / (2+(F*(Z+1))) + (C / (2+(F*Z)))      == (X - C) / (2+(F*Z)) < X / (2+(F*(Z+1)))      == (X - C) * (2+(F*Z)+F) < X * (2+(F*Z))      == 2X - 2C + XFZ - CFZ + XF - CF < 2X + XFZ      == XF - CF - 2C < CFZ      == (XF - CF - 2C) / CF < Z  """    def parse_input(input_reader):      case_count = int(input_reader.readline())      case_idx = 0      while case_count > case_idx:          case_idx += 1          input_line = input_reader.readline().rstrip("\n").split(" ")          input_values = {"C": float(input_line[0]),                          "F": float(input_line[1]),                          "X": float(input_line[2]),                          "case": case_idx}          yield input_values    def solve_problem(output_writer=sys.stdout, **kwargs):      case = kwargs['case']      C_val = kwargs['C']      F_val = kwargs['F']      X_val = kwargs['X']        best_Z = ((X_val * F_val) - (C_val * F_val) - (2 * C_val)) / (C_val * F_val)      best_Z = int(ceil(best_Z))      if best_Z < 0:          best_Z = 0        tX = lambda z: (X_val / (2+(F_val * z)))      tF = lambda z: (C_val / (2+(F_val * z)))        total_time = reduce(lambda x,y: x + tF(y), range(best_Z), tX(best_Z))      print >> output_writer, "Case #%d: %.7f" % (case, total_time)    def solve_inputs(input_reader, output_writer):      """      Loop through each problem input in input reader and solve it.        Outputs responses to output_writer.      """      for input_values in parse_input(input_reader):          solve_problem(output_writer=output_writer, **input_values)    def run_tests():      idx = 0      all_pass = True      for problem_input, expected_output in TEST_CASES:          idx += 1          input_reader = StringIO(problem_input)          output_writer = StringIO()          solve_inputs(input_reader, output_writer)          problem_output = output_writer.getvalue()          if problem_output == expected_output:              print "Test %d: Success" % idx          else:              all_pass = False              print "Test %d: Failure" % idx          input_reader.close()          output_writer.close()      if all_pass:          print "All tests were successful!"      else:          print "Something didn't match - try again."    def main():      parser = OptionParser()      parser.add_option("-f", "--file",                        dest="filename_stem",                        help="read input from FILE.in and write to FILE.out",                        metavar="FILE")        (options, args) = parser.parse_args()      if options.filename_stem:          print "Running in file mode."          input_reader = open("%s.in" % options.filename_stem, "r")          output_writer = open("%s.out" % options.filename_stem, "w")          solve_inputs(input_reader, output_writer)      else:          print "Running in test mode."          run_tests()    if __name__ == "__main__":      main() <CODESPLIT> 66
# Written for Python 2.7.5    from optparse import OptionParser  from StringIO import StringIO  import sys    # Expected format of TEST_CASES is a list of tuples of (input, expected_output)  TEST_CASES = [      ("""3  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  3  1 2 5 4  3 11 6 15  9 10 7 12  13 14 8 16  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  2  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  3  1 2 3 4  5 6 7 8  9 10 11 12  13 14 15 16  ""","""Case #1: 7  Case #2: Bad magician!  Case #3: Volunteer cheated!  """),      ("""1  1  15 9 16 5  6 10 1 3  2 4 12 11  13 14 8 7  1  5 10 9 6  12 15 1 11  14 16 4 2  13 3 8 7""","""Case #1: Bad magician!  """)  ]    BAD_MAGIC = "Bad magician!"  CHEATING = "Volunteer cheated!"    def parse_input(input_reader):      case_count = int(input_reader.readline())      case_idx = 0      while case_count > case_idx:          case_idx += 1          rows = []          for loop_idx in (1,2):              row_idx = int(input_reader.readline())              for idx in (1,2,3,4):                  if idx == row_idx:                      rows.append(set(input_reader.readline().rstrip("\n").split(" ")))                  else:                      input_reader.readline()          input_values = {"rows":rows,                          "case":case_idx}          yield input_values      def solve_problem(output_writer=sys.stdout, **kwargs):      rows = kwargs['rows']      case = kwargs['case']      intersect = rows[0].intersection(rows[1])      if not intersect:          msg = CHEATING      elif len(intersect) == 1:          msg = intersect.pop()      else:          msg = BAD_MAGIC      print >>output_writer, "Case #%d: %s" % (case, msg)    def solve_inputs(input_reader, output_writer):      """      Loop through each problem input in input reader and solve it.        Outputs responses to output_writer.      """      for input_values in parse_input(input_reader):          solve_problem(output_writer=output_writer, **input_values)    def run_tests():      """      Check the sample input and output match.      """      idx = 0      all_pass = True      for problem_input, expected_output in TEST_CASES:          idx += 1          input_reader = StringIO(problem_input)          output_writer = StringIO()          solve_inputs(input_reader, output_writer)          problem_output = output_writer.getvalue()          if problem_output == expected_output:              print "Test %d: Success" % idx          else:              all_pass = False              print "Test %d: Failure" % idx          input_reader.close()          output_writer.close()      if all_pass:          print "All tests were successful!"      else:          print "Something didn't match - try again."          print problem_output    def main():      parser = OptionParser()      parser.add_option("-f", "--file",                        dest="filename_stem",                        help="read input from FILE.in and write to FILE.out",                        metavar="FILE")        (options, args) = parser.parse_args()      if options.filename_stem:          print "Running in file mode."          input_reader = open("%s.in" % options.filename_stem, "r")          output_writer = open("%s.out" % options.filename_stem, "w")          solve_inputs(input_reader, output_writer)      else:          print "Running in test mode."          run_tests()    if __name__ == "__main__":      main() <CODESPLIT> 66
from optparse import OptionParser  import string    def solve(data_line):      english, googlerese = generate_map()      transmap = string.maketrans(googlerese, english)      return string.translate(data_line, transmap, "\n")    def parse_case(data_line):      return (data_line, )    def generate_map():      """ Use the known phrases we have to generate a translation map.  If          there's exactly one letter missing after analysing these phrases (which          there is) we can work it out by seeing what's left over."""      known_mappings = {"a zoo": "y qee",                        "our language is impossible to understand": "ejp mysljylc kd kxveddknmc re jsicpdrysi",                        "there are twenty six factorial possibilities": "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",                        "so it is okay if you want to just give up": "de kr kd eoya kw aej tysr re ujdr lkgc jv",                       }      all_letters = "abcdefghijklmnopqrstuvwxyz"      letter_map = {}      for english, googlerese in known_mappings.items():          pairs = zip(english, googlerese)          for e,g in pairs:              if e not in letter_map:                  letter_map[e] = g      if len(letter_map) == 26:          e_letter = ""          g_letter = ""          for letter in all_letters:              if not e_letter and letter not in letter_map.keys():                  e_letter = letter              if not g_letter and letter not in letter_map.values():                  g_letter = letter          letter_map[e_letter] = g_letter      return "".join(letter_map.keys()), "".join(letter_map.values())    def main():      parser = OptionParser()      parser.add_option("-f", "--file", dest="filename",                        help="read input from FILE", metavar="FILE")        (options, args) = parser.parse_args()      if not options.filename:          parser.error("Must provide a filename.")      input_file = open(options.filename, "r")      total_cases = int(input_file.readline())      case_number = 0      while case_number < total_cases:      	case_number += 1      	data_args = parse_case(input_file.readline())      	print "Case #%d: %s" % (case_number, solve(*data_args))    if __name__ == "__main__":  	main() <CODESPLIT> 66
from optparse import OptionParser  import string    def solve(data):      GAME_INCOMPLETE = 0      GAME_DRAWN = 1      GAME_WON = 2      winner = None      state = GAME_DRAWN      for row in data:          if "." in row:              state = GAME_INCOMPLETE          elif "X" not in row:              winner = "O"              state = GAME_WON              break          elif "O" not in row:              winner = "X"              state = GAME_WON              break      if state == GAME_WON:          return "%s won" % winner      elif state == GAME_INCOMPLETE:          return "Game has not completed"      else:          return "Draw"    def parse_case(data):      data_line = "".join(data)      rows = []      for idx in range(4):          offset = idx * 4          # Pull rows          rows.append(data_line[offset:offset+4])          # Pull columns          rows.append(data_line[idx::4])      # Pull diagonals      rows.append(data_line[0::5])      rows.append(data_line[3:-1:3])      return (rows, )    def main():      parser = OptionParser()      parser.add_option("-f", "--file", dest="filename",                        help="read input from FILE", metavar="FILE")        (options, args) = parser.parse_args()      if not options.filename:          parser.error("Must provide a filename.")      input_file = open(options.filename, "r")      total_cases = int(input_file.readline())      case_number = 0      while case_number < total_cases:          case_number += 1          data = []          for idx in range(4):              data.append(input_file.readline()[:4])          input_file.readline()          data_args = parse_case(data)          print "Case #%d: %s" % (case_number, solve(*data_args))    if __name__ == "__main__":      main() <CODESPLIT> 66
# Written for Python 2.7.5    from optparse import OptionParser  from StringIO import StringIO  import sys    # Expected format of TEST_CASES is a list of tuples of (input, expected_output)  TEST_CASES = [      ("""5  5 5 23  3 1 1  2 2 1  4 7 3  10 10 82  ""","""Case #1:  Impossible  Case #2:  c  .  *  Case #3:  Impossible  Case #4:  c......  .......  .......  ....***  Case #5:  c........*  .........*  **********  **********  **********  **********  **********  **********  **********  **********  """),      ("""3  5 4 3  5 3 8  5 5 14  ""","""Case #1:  c...  ....  ....  ...*  ..**  Case #2:  Impossible  Case #3:  c...*  ....*  ...**  *****  *****  """)  ]    IMPOSSIBLE = "Impossible"    """  S is number of safe squares = (R*C) - M  If S == 1 then always possible:      Assume click in top left, all else mines  Special cases (R or C is small):  If R == 1 or C == 1 then always possible:      Assume click in top left and all safe squares in a line  Else if R == 2 or C == 2 then possible iff S % 2 == 0:      Assume click in top left and all safe squares are in a 2 * X line  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)     OR if S % 2 == 0   """    def parse_input(input_reader):      case_count = int(input_reader.readline())      case_idx = 0      while case_count > case_idx:          case_idx += 1          input_line = [int(x) for x in input_reader.readline().split()]          input_values = {"case": case_idx,                          "R": input_line[0],                          "C": input_line[1],                          "M": input_line[2]}          yield input_values      def solve_problem(output_writer=sys.stdout, **kwargs):      case = kwargs['case']      rows = kwargs['R']      cols = kwargs['C']      mines = kwargs['M']      safe_squares = ((rows * cols) - mines)      print >> output_writer, "Case #%d:" % case      row_string = "{:*<%ds}" % cols      impossible = False      if safe_squares == 1:          print >> output_writer, row_string.format("c")          for row in range(1, rows):              print >> output_writer, row_string.format("")      elif rows == 1:          safe_string = "c" + ("." * (safe_squares - 1))          print >> output_writer, row_string.format(safe_string)      elif cols == 1:          for row in range(rows):              cell = ""              if row == 0:                  cell = "c"              elif row < safe_squares:                  cell = "."              print >> output_writer, row_string.format(cell)      elif safe_squares == 2:          impossible = True      elif rows == 2:          safe_cols, remainder = divmod(safe_squares, 2)          if remainder == 1:              impossible = True          else:              safe_string = "." * (safe_cols - 1)              print >> output_writer, row_string.format("c%s" % safe_string)              print >> output_writer, row_string.format(".%s" % safe_string)      elif cols == 2:          safe_rows, remainder = divmod(safe_squares, 2)          if remainder == 1:              impossible = True          else:              for row in range(rows):                  cells = ""                  if row == 0:                      cells = "c."                  elif row < safe_rows:                      cells = ".."                  print >> output_writer, row_string.format(cells)      else:          safe_rows, remainder = divmod(safe_squares, cols)          if remainder == 1 and cols == 3 and safe_rows == 2:              impossible = True          elif safe_rows > 1:              if remainder == 1 and safe_rows == 2:                  mid_safe = "." * (cols-2)                  for row in range(rows):                      cell_one = "."                      mid_cells = mid_safe                      last_cell = "."                      if row == 0:                          cell_one = "c"                      elif safe_rows == 0:                          cell_one = "."                          mid_cells = "." * (remainder + 1)                      elif safe_rows < 0:                          cell_one = ""                          mid_cells = ""                      if safe_rows < 3:                          last_cell = ""                      print >> output_writer, row_string.format("%s%s%s" % (cell_one, mid_cells, last_cell))                      safe_rows -= 1              elif remainder == 1:                  mid_safe = "." * (cols-2)                  for row in range(rows):                      cell_one = "."                      mid_cells = mid_safe                      last_cell = "."                      if row == 0:                          cell_one = "c"                      elif safe_rows == 0:                          cell_one = "."                          mid_cells = "." * remainder                      elif safe_rows < 0:                          cell_one = ""                          mid_cells = ""                      if safe_rows < 2:                          last_cell = ""                      print >> output_writer, row_string.format("%s%s%s" % (cell_one, mid_cells, last_cell))                      safe_rows -= 1              else:                  full_safe = "." * cols                  for row in range(rows):                      cells = full_safe                      if row == 0:                          cells = "c" + ("." * (cols - 1))                      elif row == safe_rows:                          cells = "." * remainder                      elif row > safe_rows:                          cells = ""                      print >> output_writer, row_string.format(cells)          else:              safe_cols, remainder = divmod(safe_squares, 2)              if remainder == 1 and safe_cols < 4:                  impossible = True              elif remainder == 0:                  print >> output_writer, row_string.format("c%s" % ("." * (safe_cols - 1)))                  print >> output_writer, row_string.format("." * safe_cols)                  for row in range(2, rows):                      print >> output_writer, row_string.format("")              else:                  safe_cols -= 1                  print >> output_writer, row_string.format("c%s" % ("." * (safe_cols - 1)))                  print >> output_writer, row_string.format("." * safe_cols)                  print >> output_writer, row_string.format("...")                  for row in range(3, rows):                      print >> output_writer, row_string.format("")      if impossible:          print >> output_writer, IMPOSSIBLE    def solve_inputs(input_reader, output_writer):      """      Loop through each problem input in input reader and solve it.        Outputs responses to output_writer.      """      for input_values in parse_input(input_reader):          solve_problem(output_writer=output_writer, **input_values)    def run_tests():      idx = 0      all_pass = True      for problem_input, expected_output in TEST_CASES:          idx += 1          input_reader = StringIO(problem_input)          output_writer = StringIO()          solve_inputs(input_reader, output_writer)          problem_output = output_writer.getvalue()          if problem_output == expected_output:              print "Test %d: Success" % idx          else:              all_pass = False              print "Test %d: Failure" % idx              print problem_output          input_reader.close()          output_writer.close()      if all_pass:          print "All tests were successful!"      else:          print "Something didn't match - try again."    def main():      parser = OptionParser()      parser.add_option("-f", "--file",                        dest="filename_stem",                        help="read input from FILE.in and write to FILE.out",                        metavar="FILE")        (options, args) = parser.parse_args()      if options.filename_stem:          print "Running in file mode."          input_reader = open("%s.in" % options.filename_stem, "r")          output_writer = open("%s.out" % options.filename_stem, "w")          solve_inputs(input_reader, output_writer)      else:          print "Running in test mode."          run_tests()    if __name__ == "__main__":      main() <CODESPLIT> 66
from optparse import OptionParser  import math    # The largest number B can be  MAX_NUMBER = 2000000    # COUNT_MAP will store the number of recycled pairs that can exist for a  # list of cycles of length n (these are the triangular numbers).  # Calculate this now so that we don't waste time with it later on.  COUNT_MAP = { 1: 0 }  index = 1  while index < math.log10(MAX_NUMBER):      index += 1      COUNT_MAP[index] = index * (index - 1) / 2    def solve(minimum, maximum):      # Store the result      total_cycles = 0      # The numbers we need to check.  We'll remove numbers from this once we've      # used them in a cycle so that we don't attempt to reprocess them.      iter_range = range(minimum, maximum + 1)      # Keep looping untli we've gone through all the numbers.      while iter_range:          # Remove the first number          number = iter_range[0]          iter_range.remove(number)          # Add this to the list of numbers in a potential cycle.          cycle_numbers = [number,]          # Using strings for this feels icky but the modulo arithmetic seems          # equally icky :-(          # Double up the number in a string and we'll use slices to get the          # cycles.          string_rep = "%s%s" % (number, number)          digits = len(string_rep) / 2          start_index, end_index = 0, digits          while start_index < digits:              start_index += 1              end_index += 1              new_number = int(string_rep[start_index:end_index])              if new_number == number:                  # If we're repeating then there's no need to take more slices                  start_index = digits              elif new_number > number and new_number <= maximum:                  # We should already have dealt with numbers lower than this,                  # and we don't want anything above the maximum. Anything else                  # add to the cycle options and remove from the list of numbers                  # to check.                  cycle_numbers.append(new_number)                  iter_range.remove(new_number)          total_cycles += COUNT_MAP[len(cycle_numbers)]      return total_cycles    def parse_case(data_line):      bits = data_line.split()      minimum = int(bits[0])      maximum = int(bits[1])      return (minimum, maximum, )    def main():      parser = OptionParser()      parser.add_option("-f", "--file", dest="filename",                        help="read input from FILE", metavar="FILE")        (options, args) = parser.parse_args()      if not options.filename:          parser.error("Must provide a filename.")      input_file = open(options.filename, "r")      total_cases = int(input_file.readline())      case_number = 0      while case_number < total_cases:      	case_number += 1      	data_args = parse_case(input_file.readline())      	print "Case #%d: %s" % (case_number, solve(*data_args))    if __name__ == "__main__":      main() <CODESPLIT> 66
import sys, math    def isPalindrome(n):  	n = str(n)	  	for i in xrange(len(n)/2):  		if n[i] != n[(-i-1)]:  			return False  	return True    ##########################################################  # Main    inputFileName = sys.argv[1]    f = file(inputFileName)  fout = file("output.txt", "w")    T = eval(f.readline())    for case in xrange(T):  	data = f.readline().split()  	A = eval(data[0])  	B = eval(data[1])    	i = A  	found = []  	while i <= B:  		if isPalindrome(i):  			sqrtI = math.sqrt(i)  			if sqrtI == int(sqrtI):  				if isPalindrome(int(sqrtI)):  					found.append(i)  		i += 1    	##### Output writing  	fout.write("Case #%d: %d\n" %(case + 1, len(found)))  <CODESPLIT> 67
arq = file("input.in")  n_cases = eval(arq.readline())  out = file("output.txt", "w")    for case in xrange(n_cases):    	data = arq.readline()  	data = data.strip()  	data = data.split(" ")    	n = eval(data[0])  	s = eval(data[1])  	p = eval(data[2])    	scores = []  	n_googlers_with_best_result = 0  	candidates = 0    	for j in data[3:]:  		i = eval(j)  		if i%3 == 0:  			score = i/3  			scores.append([score, score, score])  		elif (i+1)%3 == 0:  			score = (i+1)/3  			scores.append([score-1, score, score])  		else: #(i+2)%3 == 0  			score = (i+2)/3  			scores.append([score-1, score-1, score])    	for score in scores:  		if score[2] >= p:  			n_googlers_with_best_result +=1  		elif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:  			candidates += 1    	n_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)    	out.write("Case #%d: %d\n" % (case+1, n_googlers_with_best_result))  <CODESPLIT> 67
import sys    def pointsWar(naomi, ken, N):  	points = 0  	iNaomi = 0  	iKen = 0  	while iNaomi < N and iKen < N:  		if naomi[iNaomi] > ken[iKen]:  			points += 1  		else:  			iNaomi += 1  		iKen += 1  	return points    def pointsDeceitfulWar(naomi, ken, N):  	points = N  	iNaomi = 0  	iKen = 0  	while iNaomi < N and iKen < N:  		if naomi[iNaomi] > ken[iKen]:  			iKen += 1  		else:  			points -= 1  		iNaomi += 1  	return points    ##########################################################  # Main    inputFileName = sys.argv[1]    f = file(inputFileName)  fout = file("output.txt", "w")    T = int(f.readline())    for case in xrange(T):  	N = int(f.readline().strip())  	naomi = f.readline().strip().split()  	ken = f.readline().strip().split()    	for i in xrange(N):  		naomi[i] = (float(naomi[i]),"N")  		ken[i] = (float(ken[i]),"K")    	naomi.sort()  	ken.sort()    	##### Output writing  	fout.write("Case #%d: %d %d\n" %(case + 1, pointsDeceitfulWar(naomi, ken, N), pointsWar(naomi, ken, N)))  <CODESPLIT> 67
import sys    def testLine(i, lawn):  	return (2 not in lawn[i])    def testColumn(j, lawn):  	possible = True  	for line in lawn:  		if line[j] == 2:  			possible = False  			break  	return possible    ##########################################################  # Main    inputFileName = sys.argv[1]    f = file(inputFileName)  fout = file("output.txt", "w")    T = eval(f.readline())    for case in xrange(T):  	data = f.readline().split()  	N = eval(data[0])  	M = eval(data[1])  	possible = True  	if N == 1 or M == 1:  		for i in xrange(N):  			f.readline()  	else:  		lawn = []  		for i in xrange(N):  			line = f.readline().strip().split()  			for j in xrange(M):  				line[j] = eval(line[j])  			lawn.append(line)  		i = 0  		while i < N and possible:  			for j in xrange(M):  				if lawn[i][j] == 1:  					if not testLine(i, lawn):  						if not testColumn(j, lawn):  							possible = False  			i += 1    	##### Output writing  	fout.write("Case #%d: " %(case + 1))  	if possible:  		fout.write("YES\n")  	else:  		fout.write("NO\n")  <CODESPLIT> 67
import sys    def oneMoreFarm(C, F, nFarms):  	return C/(2.0 + nFarms*F)  	    ##########################################################  # Main    inputFileName = sys.argv[1]    f = file(inputFileName)  fout = file("output.txt", "w")    T = int(f.readline().strip())    for case in xrange(T):    	data = f.readline().split()  	C = eval(data[0])  	F = eval(data[1])  	X = eval(data[2])    	tmin = X/2.0  	foundMin = False    	S = 0  	nFarms = 0    	while not foundMin:  		nFarms += 1  		S += oneMoreFarm(C, F, nFarms - 1)  		t = S + X/(2.0 + nFarms*F)  		if t < tmin:  			tmin = t  		else:  			foundMin = True    	##### Output writing  	fout.write("Case #%d: %.7f\n" %(case + 1, tmin))  <CODESPLIT> 67
import sys	    inputFileName = sys.argv[1]    f = file(inputFileName)  fout = file("output.txt", "w")    T = eval(f.readline())    for case in xrange(T):    	####First question  	A1 = int(f.readline().strip())    	for i in xrange(4):  		if i == A1 - 1:  			possibles1 = f.readline().strip().split(" ")  		else:  			f.readline().strip().split(" ")    	####Second question  	A2 = int(f.readline().strip())    	for i in xrange(4):  		if i == A2 - 1:  			possibles2 = f.readline().strip().split(" ")  		else:  			f.readline().strip().split(" ")    	final = []  	for item in possibles2:  		if item in possibles1:  			final.append(item)    	##### Output writing  	if len(final) == 0:	  		fout.write("Case #%d: Volunteer cheated!\n" %(case + 1))  	elif len(final) == 1:  		fout.write("Case #%d: %s\n" %(case + 1, final[0]))  	else:  		fout.write("Case #%d: Bad magician!\n" %(case + 1))  <CODESPLIT> 67
# Making up a dictionary  # Sample  googlerese = "ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv"  english = "our language is impossible to understand there are twenty six factorial possibilities so it is okay if you want to just give up"  # Hints  d = {"y":"a", "e":"o", "q":"z"}    for i in xrange(len(googlerese)):  	d[googlerese[i]] = english[i]    # One letter still missing: z:q  d["z"] = "q"    inp = file("input.in")  n = eval(inp.readline())  out = file("output.txt", "w")    for i in xrange(n):  	G = inp.readline().strip()  	S = ""  	for letter in G:  		S += d[letter]  	out.write("Case #%d: " %(i + 1) + S + "\n")  <CODESPLIT> 67
import sys    def testSymbol(symbol, game):  	if testLines(symbol, game):  		return True  	elif testColumns(symbol, game):  		return True  	elif testDiagonals(symbol, game):  		return True  	else:  		return False    def testLines(symbol, game):  	i = 0  	won = False  	while (i < 4 and not won):  		line = game[i]  		c = line.count(symbol)  		if c == 4 or (c == 3 and "T" in line):  			won = True  		i += 1  	return won    def transpose(game):  	for i in xrange(3):  		for j in xrange(i + 1, 4):  			aux = game[i][j]  			game[i][j] = game[j][i]  			game[j][i] = aux  	return game    def testColumns(symbol, game):  	game = transpose(game)  	return testLines(symbol, game)    def testDiagonals(symbol, game):  	won1 = True  	won2 = True  	i = 0  	while i < 4 and (won1 or won2):  		if game[i][i] not in [symbol, "T"]:  			won1 = False  		if game[i][3 - i] not in [symbol, "T"]:  			won2 = False  		i += 1  	return (won1 or won2)		    inputFileName = sys.argv[1]    f = file(inputFileName)  fout = file("output.txt", "w")    T = eval(f.readline())    for i in xrange(T):  	game = []  	for j in xrange(4):  		line = f.readline().strip()  		gameLine = 4*[None]  		for k in xrange(4):  			gameLine[k] = line[k]  		game.append(gameLine)  	f.readline()  	if testSymbol("X", game):  		gameResult = "X"  	elif testSymbol("O", game):  		gameResult = "O"  	elif "." not in game[0] and "." not in game[1] and "." not in game[2] and "." not in game[3]:  		gameResult = "Draw\n"  	else:  		gameResult = "Game has not completed\n"    	fout.write("Case #%d: " %(i + 1))  	if gameResult in ["X", "O"]:  		fout.write("%s won\n" %(gameResult))  	else:  		fout.write(gameResult)  <CODESPLIT> 67
import sys    def transpose(result, R, C):  	resultSplitted = result.split("\n")  	aux = R*[""]  	for i in xrange(R):  		for j in xrange(C):  		    aux[i] += resultSplitted[j][i]  		aux[i] += "\n"  	result = ""  	for item in aux:  		result += item + "\n"  	return result.strip()    ##########################################################  # Main    inputFileName = sys.argv[1]    f = file(inputFileName)  fout = file("output.txt", "w")    T = int(f.readline())    for case in xrange(T):  	data = f.readline().strip().split(" ")  	R = int(data[0])  	C = int(data[1])  	M = int(data[2])    	result = ""    	x = min(R,C)  	y = max(R,C)    	#if x == 2 and M%2 == 1 and M < R*C - 1:  	#	result = "Impossible"  	#elif x == 3 and M > y and M != R*C - 1:  #		result = "Impossible"  	if M > (y - 2)*x and M != y*x - 1:  		N = M - (y-2)*x  		if N%2 == 1 or y*x - M == 2:  			result = "Impossible"  	if result != "Impossible":  		i = 0  		while M > 0: # 2  			if i < y - 2:  				if M >= x:  					result += x*"*" + "\n"  					M -= x  					i += 1  				elif M <= x - 2:  					result += M*"*" + (x - M) * "." + "\n"  					M = 0  					i += 1  				elif i + 2 < y - 1:  					result += (M-1)*"*" + (x - M + 1) * "." + "\n" + "*" + (x-1)*"." + "\n"  					M = 0  					i += 2  				else:  					result = "Impossible"  					break  			else:  				if M%2 != 0:  					result += x*"*" + "\n"  					result += (x-1)*"*" + "c"  				else:  					n = M/2  					result += n*"*" + (x-n)*"." + "\n"  					result += n*"*" + (x-n-1)*"." + "c"  				M = 0  				i += 2  					  		while i <= y - 1 and result != "Impossible":  			if i == y - 1:  				result += (x-1)*"." + "c"  			else:  				result += x*"." + "\n"  			i += 1  	  	if R < C and result != "Impossible":  		result = transpose(result, R, C)    	##### Output writing  	fout.write("Case #%d:\n%s\n" %(case + 1, result))  <CODESPLIT> 67
def find_recycled(n, b):  	ns = str(n)  	reclist = []  	for i in xrange(1, len(ns), 1):  		nrec = ns[i:len(ns)] + ns[0:i]  		if nrec[0] != "0":  			nrec = eval(nrec)  			if nrec <= b and nrec > n and (n, nrec) not in reclist:  				reclist.append((n,nrec))  	return len(reclist)    inp = file("input.in")  T = eval(inp.readline())  out = file("output.txt", "w")    for i in xrange(T):  	a, b = inp.readline().strip().split()  	a = eval(a)  	b = eval(b)  	nrec = 0  	reclist = []  	for n in xrange(a, b):  		if n > 11:  			nrec += find_recycled(n, b)  	out.write("Case #%d: %d\n" %(i + 1, nrec))  			  <CODESPLIT> 67
import math    def isPalindrome(s):    length = len(s)    for i in xrange(length / 2):      if s[i] != s[length - 1 - i]:         return False    return True    n = int(raw_input())  for i in range(n):    a, b = map(int, raw_input().strip().split(' '))    count = 0    for j in range(a, b+1):      if isPalindrome(str(j)):        s = math.sqrt(j)        if s == int(s) and isPalindrome(str(int(s))):          count += 1    print 'Case #%i: %i' % (i+1, count)  <CODESPLIT> 68
import sys    T = int(sys.stdin.readline())  for i in range(T):      line = sys.stdin.readline().strip()      values = map(int, line.split(' '))      N = values[0]      S = values[1]      p = values[2]      totals = values[3:]      ans = 0      for total in totals:          base = total / 3          remainder = total - (base * 3)          scores = [base, base, base]          j = 0          while remainder > 0:              scores[j] += 1              remainder -= 1              j = (j + 1) % 3          if max(scores) >= p:              ans += 1          else:              if S > 0:                  remainder = total - (base * 3)                  if remainder == 0 and base > 0:                      if base + 2 >= p:                          ans += 1                          S -= 1                  elif base + min(remainder, 2) >= p:                      ans += 1                      S -= 1      print 'Case #%s: %s' % (i+1, ans)  <CODESPLIT> 68
from copy import deepcopy  import time    def dwar(N, K):    N = sorted(N)    K = sorted(K)        naomi = 0        #if naomi can win then she should lose her lowest piece to do so    #if kevin can win then he should lose his highest piece    while len(N) > 0:      # Naomi can win.      if N[-1] > K[-1]:        # Kevin loses highest piece.        k = K.pop()        # Naomi loses lowest piece necessary.        for i, n in enumerate(N):          if N[i] > k:            choosen = i            break        del(N[choosen])        naomi += 1      # Naomi cannot win.      else:        # Naomi loses lowest piece.        N = N[1:]        k = K.pop()    return naomi    def war(N, K):    N = sorted(N)    K = sorted(K)        naomi = 0    while len(N) > 0:      n = N.pop()      chosen = None      for i, k in enumerate(K):        if k > n:          chosen = i          break      if not chosen == None:        del(K[chosen])      else:        naomi += 1    return naomi    T = int(raw_input())  for t in range(T):    _ = raw_input()    N = map(float, raw_input().split())    K = map(float, raw_input().split())        print 'Case #%i: %i %i' % (t+1, dwar(N, K), war(N, K))  <CODESPLIT> 68
def up_down(board, height, y, x):    # Move up from (x, y).    above = y - 1    while above >= 0:      if board[above][x] > board[y][x]:         return False      above -= 1    # Move down from (x, y).    below = y + 1    while below < height:      if board[below][x] > board[y][x]:         return False      below += 1    return True      def left_right(board, width, y, x):    # Move left from (x, y).    before = x - 1    while before >= 0:      if board[y][before] > board[y][x]:         return False      before -= 1    # Move right from (x, y).    after = y + 1    while after < width:      if board[y][after] > board[y][x]:         return False      after += 1    return True      def check(board, height, width):    if height == 1 or width == 1:      return 'YES'    for i in range(height):      for j in range(width):        if (not up_down(board, height, i, j)) and (not left_right(board, width, i, j)):          return 'NO'    return 'YES'    n = int(raw_input().strip())  for i in range(n):    height, width = map(int,  raw_input().strip().split(' '))    board = []    for _ in range(height):      row = map(int, raw_input().strip().split(' '))      board.append(row)    print 'Case #%i: %s' % (i+1, check(board, height, width))  <CODESPLIT> 68
import sys  import time as tm  sys.setrecursionlimit(15000)    def solve(C, F, X, rate, time):    if (time + (X / rate)) < ((C / rate) + ((X / (rate+F)) + time)):      return time + (X / rate)    else:      return solve(C, F, X, rate+F, time + (C / rate))    T = int(raw_input())  for t in range(T):    C, F, X = map(float, raw_input().split())    print 'Case #%i: %.7f' % (t+1, solve(C, F, X, 2, 0))  <CODESPLIT> 68
T = int(raw_input())  for i in range(T):    index = int(raw_input())    X = []    for j in range(4):      X.append(map(int, raw_input().split()))    x1 = X[index-1]    index = int(raw_input())    X = []    for j in range(4):      X.append(map(int, raw_input().split()))    x2 = X[index-1]    ans = set(x1).intersection(set(x2))    if len(ans) == 0:      print 'Case #%i: Volunteer cheated!' % (i+1)    elif len(ans) == 1:      print 'Case #%i: %i' % (i+1, ans.pop())    else:      print 'Case #%i: Bad magician!' % (i+1)  <CODESPLIT> 68
import sys    data = [      ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'],      ['rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'],      ['de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up']]    trans = {'y': 'a', 'e': 'o', 'q': 'z', 'z': 'q'}  for row in data:      [googlerese, english] = row      for i in range(0, len(googlerese)):          if not googlerese[i] in trans:              trans[googlerese[i]] = english[i]    def translate(googlerese):      english = ''      for c in googlerese:          english += trans[c]      return english    T = int(sys.stdin.readline())  for i in range(T):      print 'Case #%s: %s' % (i+1, translate(sys.stdin.readline().strip()))  <CODESPLIT> 68
def check(board):    # Check rows.    for i in range(4):      row = board[i]      if set(row) in [set(['X', 'T']), set(['X'])]:        return 'X won'      if set(row) in [set(['O', 'T']), set(['O'])]:        return 'O won'        # Check columns.    for i in range(4):      column = []      for j in range(4):        column.append(board[j][i])      if set(column) in [set(['X', 'T']), set(['X'])]:        return 'X won'      if set(column) in [set(['O', 'T']), set(['O'])]:        return 'O won'        # Check diagonal top_left->bottom_right    diag1 = [board[0][0], board[1][1], board[2][2], board[3][3]]    if set(diag1) in [set(['X', 'T']), set(['X'])]:        return 'X won'    if set(diag1) in [set(['O', 'T']), set(['O'])]:      return 'O won'        # Check diagonal top_right->bottom_left    diag2 = [board[3][0], board[2][1], board[1][2], board[0][3]]    if set(diag2) in [set(['X', 'T']), set(['X'])]:        return 'X won'    if set(diag2) in [set(['O', 'T']), set(['O'])]:      return 'O won'        for i in range(4):      for j in range(4):        if board[i][j] == '.':          return 'Game has not completed'    return 'Draw'    n = int(raw_input().strip())  for i in range(n):    board = []    for j in range(4):      line = raw_input()      board.append([c for c in line])    raw_input()    print 'Case #%i: %s' % (i+1, check(board))  <CODESPLIT> 68
from copy import deepcopy  import time    def solve(W, H, M):    board = [['*' for x in xrange(H)] for x in xrange(W)]    board[0][0] = 'c'        S = [((H*W)-1, board, 0, 0, set())]    H -= 1    W -= 1    while len(S) > 0:      state = S.pop()      mines = state[0]      board = deepcopy(state[1])      x = state[2]      y = state[3]      visited = deepcopy(state[4])      visited.add((x, y))            if mines == M:        s = ''        for row in board:          s += ''.join(row)          s += '\n'        return s            elif mines > M:        # Up        if x > 0 and board[x-1][y] == '*':          board[x-1][y] = '.'          mines -= 1                # Down        if x < W and board[x+1][y] == '*':          board[x+1][y] = '.'          mines -= 1                # Left        if y > 0 and board[x][y-1] == '*':          board[x][y-1] = '.'          mines -= 1                # Right        if y < H and board[x][y+1] == '*':          board[x][y+1] = '.'          mines -= 1                # Up and Left        if x > 0 and y > 0 and board[x-1][y-1] == '*':          board[x-1][y-1] = '.'          mines -= 1                # Up and Right        if x > 0 and y < H and board[x-1][y+1] == '*':          board[x-1][y+1] = '.'          mines -= 1                # Down and Left        if x < W and y > 0 and board[x+1][y-1] == '*':          board[x+1][y-1] = '.'          mines -= 1                # Down and Right        if x < W and y < H and board[x+1][y+1] == '*':          board[x+1][y+1] = '.'          mines -= 1                # Up        if x > 0 and not (x-1, y) in visited:          S.append((mines, board, x-1, y, visited))                # Down        if x < W and not (x+1, y) in visited:          S.append((mines, board, x+1, y, visited))                # Left        if y > 0 and not (x, y-1) in visited:          S.append((mines, board, x, y-1, visited))                # Right        if y < H and not (x, y+1) in visited:          S.append((mines, board, x, y+1, visited))                # Up and Left        if x > 0 and y > 0 and not (x-1, y-1) in visited:          S.append((mines, board, x-1, y-1, visited))                # Up and Right        if x > 0 and y < H and not (x-1, y+1) in visited:          S.append((mines, board, x-1, y+1, visited))                # Down and Left        if x < W and y > 0 and not (x+1, y-1) in visited:          S.append((mines, board, x+1, y-1, visited))                # Down and Right        if x < W and y < H and not (x+1, y+1) in visited:          S.append((mines, board, x+1, y+1, visited))    return 'Impossible'    T = int(raw_input())  for t in range(T):    W, H, M = map(int, raw_input().split())    print 'Case #%i:\n%s' % (t+1, solve(W, H, M).strip())  <CODESPLIT> 68
import sys    def isRecycledPair(n, m):      m = str(m)      for i in range(len(m)):          m = m[-1] + m[:-1]          if n == int(m):              return True      return False    T = int(sys.stdin.readline())  for i in range(T):      [A, B] = map(int, sys.stdin.readline().strip().split(' '))      count = 0      for n in range(A, B+1):          for m in range(n, B+1):              if n != m and isRecycledPair(n, m):                  count += 1      print 'Case #%s: %s' % (i + 1, count)  <CODESPLIT> 68
#!/usr/bin/env python    import collections    import pickle  import re  import sys    INPUT = "tiny"  if 1:      INPUT = "C-small-attempt0.in"    def debug(*args):      pass #print str(args)    class Memoize:      def __init__(self,function):          self._cache = {}          self._callable = function                    def __call__(self, *args, **kwds):          cache = self._cache          key = self._getKey(*args,**kwds)          try: return cache[key]          except KeyError:              cachedValue = cache[key] = self._callable(*args,**kwds)              return cachedValue            def _getKey(self,*args,**kwds):          return kwds and (args, ImmutableDict(kwds)) or args    def is_palindrome(N):      s = str(N)      return s == ''.join(reversed(s))    def fair_and_square_set(max_N):      p = "squareset_%d" % max_N      try:          s = pickle.load(file(p))          return s      except:          pass      s = set()      for i in range(1,max_N+1):          if is_palindrome(i) and is_palindrome(i*i):              s.add(i*i)      pickle.dump(s, file(p, "wb"))      return s    MAX_N = int(1e7)  SQUARE_SET = fair_and_square_set(MAX_N)  #print(SQUARE_SET)    def do_trial(A, B):      count = 0      for ss in SQUARE_SET:          if A <= ss <= B:              count += 1      return count    f = file(INPUT)  T = int(f.readline()[:-1])  for i in range(T):      A, B = [int(x) for x in f.readline().split()]      v = do_trial(A, B)      print "Case #%d: %s" % (i+1, v)  <CODESPLIT> 69
#!/usr/bin/env python    import pdb  import re  import sys    INPUT = "tiny"    INPUT = "B-small-attempt0.in.txt"    def debug(*args):      pass #print str(args)    def zdebug(*args):      print ''.join(str(s) for s in args)    def can_score_p(N, p):      low_p = max(p-1, 0)      if low_p + low_p + p <= N:          return "Y"      low_p = max(p-2, 0)      if low_p + low_p + p <= N:          return "S"      return "N"    def do_trial(N, S, p, *scores):      d = { "Y" : 0, "N" : 0, "S" : 0 }      for s in scores:          v = can_score_p(s, p)          debug("score %s p=%s : %s" % (s, p, v))          d[v] = d[v] + 1      return d["Y"] + min(d["S"], S)    f = file(INPUT)  T = int(f.readline()[:-1])  for i in range(T):      l = [int(x) for x in f.readline()[:-1].split()]      v = do_trial(*l)      print "Case #%d: %s" % (i+1, v)  <CODESPLIT> 69
#!/usr/bin/env python    import collections    import math  import re  import sys    #sys.setrecursionlimit(50)    INPUT = "tiny"  INPUT = "D-small-attempt0.in"  #INPUT = "D-large.in"    def debug(*args):      return      sys.stderr.write(str(args) + "\n")    class Memoize:      def __init__(self,function):          self._cache = {}          self._callable = function                    def __call__(self, *args, **kwds):          cache = self._cache          key = self._getKey(*args,**kwds)          try: return cache[key]          except KeyError:              cachedValue = cache[key] = self._callable(*args,**kwds)              return cachedValue            def _getKey(self,*args,**kwds):          return kwds and (args, ImmutableDict(kwds)) or args        def war_wins(N, K):      wins = 0      debug(N, K)      #import pdb; pdb.set_trace()      while 1:          if len(N) == 0:              return wins          N,n = N[:-1], N[-1]          if n > K[-1]:              wins += 1              K = K[1:]              continue          for idx, v in enumerate(K):              if v > n:                  break          K = K[:idx] + K[idx+1:]    def dwar_wins(N, K):      wins = 0      while 1:          if len(N) == 0:              return wins          n, N = N[0], N[1:]          if n > K[0]:              wins += 1              K = K[1:]          else:              K = K[:-1]      def do_trial(N, K):      N.sort()      K.sort()      dww = dwar_wins(N, K)      ww = war_wins(N, K)      return "%d %d" % (dww, ww)    f = file(INPUT)  T = int(f.readline()[:-1])  for i in range(T):      f.readline()      N = [float(x) for x in f.readline().split()]      K = [float(x) for x in f.readline().split()]      v = do_trial(N, K)      print "Case #%d: %s" % (i+1, v)  <CODESPLIT> 69
#!/usr/bin/env python    import collections    import re  import sys    INPUT = "tiny"  if 1:      INPUT = "B-small-attempt0.in"    def debug(*args):      pass #print str(args)    class Memoize:      def __init__(self,function):          self._cache = {}          self._callable = function                    def __call__(self, *args, **kwds):          cache = self._cache          key = self._getKey(*args,**kwds)          try: return cache[key]          except KeyError:              cachedValue = cache[key] = self._callable(*args,**kwds)              return cachedValue            def _getKey(self,*args,**kwds):          return kwds and (args, ImmutableDict(kwds)) or args    def do_trial(lawn):      w = len(lawn[0])      h = len(lawn)      x_maxes = [max(lawn_row) for lawn_row in lawn]      y_maxes = [max(lawn[y][x] for y in range(h)) for x in range(w)]      def lawn_row(y):          x_max = x_maxes[y]          return tuple([min(y_maxes[x], x_max) for x in range(w)])      new_lawn = tuple([lawn_row(y) for y in range(h)])      #import pdb; pdb.set_trace()      if new_lawn == lawn:          return "YES"      return "NO"    f = file(INPUT)  T = int(f.readline()[:-1])  for i in range(T):      w, h = [int(x) for x in f.readline().split()]      lawn = []      for k in range(w):          lawn.append(tuple([int(x) for x in f.readline().split()]))      lawn = tuple(lawn)      #if i==2:      #    import pdb; pdb.set_trace()      v = do_trial(lawn)      print "Case #%d: %s" % (i+1, v)  <CODESPLIT> 69
#!/usr/bin/env python    import collections    import math  import re  import sys    sys.setrecursionlimit(5000)    INPUT = "tiny"  INPUT = "B-large.in"  INPUT = "B-small-attempt0.in"    def debug(*args):      return      sys.stderr.write(str(args) + "\n")    class Memoize:      def __init__(self,function):          self._cache = {}          self._callable = function                    def __call__(self, *args, **kwds):          cache = self._cache          key = self._getKey(*args,**kwds)          try: return cache[key]          except KeyError:              cachedValue = cache[key] = self._callable(*args,**kwds)              return cachedValue            def _getKey(self,*args,**kwds):          return kwds and (args, ImmutableDict(kwds)) or args        def do_trial(C, F, X, rate=2.0):      #import pdb; pdb.set_trace()      win_time_wait = X / rate      buy_time = C / rate      win_time_buy_1 = buy_time + X / (rate+F)      if win_time_wait < win_time_buy_1:          return win_time_wait      return buy_time + do_trial(C, F, X, rate+F)    f = file(INPUT)  T = int(f.readline()[:-1])  for i in range(T):      C, F, X = [float(x) for x in f.readline().split()]      v = do_trial(C, F, X)      print "Case #%d: %s" % (i+1, v)  <CODESPLIT> 69
#!/usr/bin/env python    import collections    import math  import re  import sys    INPUT = "tiny"  if 1:      INPUT = "A-large.in"      INPUT = "A-small-attempt0.in"    def debug(*args):      return      sys.stderr.write(str(args) + "\n")    class Memoize:      def __init__(self,function):          self._cache = {}          self._callable = function                    def __call__(self, *args, **kwds):          cache = self._cache          key = self._getKey(*args,**kwds)          try: return cache[key]          except KeyError:              cachedValue = cache[key] = self._callable(*args,**kwds)              return cachedValue            def _getKey(self,*args,**kwds):          return kwds and (args, ImmutableDict(kwds)) or args        def do_trial(a1, r1, a2, r2):      p1 = set(r1[a1-1])      p2 = set(r2[a2-1])      u = p1.intersection(p2)      if len(u) < 1:          return "Volunteer cheated!"      if len(u) > 1:          return "Bad magician!"      return list(u)[0]    f = file(INPUT)  T = int(f.readline()[:-1])  for i in range(T):      rows1 = []      a1 = int(f.readline()[:-1])      for r in range(4):          rows1.append([int(x) for x in f.readline().split()])      a2 = int(f.readline()[:-1])      rows2 = []      for r in range(4):          rows2.append([int(x) for x in f.readline().split()])      v = do_trial(a1, rows1, a2, rows2)      print "Case #%d: %s" % (i+1, v)  <CODESPLIT> 69
#!/usr/bin/env python    import pdb  import re  import sys    INPUT = "tiny"  if 1:      INPUT = "A-small-attempt2.in.txt"    I=re.sub(" ", "", "ejp mysljylc kd kxveddknmc re jsicpdrysirbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jv")  O=re.sub(" ", "", "our language is impossible to understandthere are twenty six factorial possibilitiesso it is okay if you want to just give up")    #print I, O    MAP={ 'z' : 'q', 'q' : 'z' }  for i,o in zip(I,O):      MAP[i] = o    def debug(*args):      pass #print str(args)    def debug(*args):      print str(args)    def do_trial(l):      t = list(l)      t1 = [MAP.get(x, x) for x in t]      return ''.join(t1)    f = file(INPUT)  T = int(f.readline()[:-1])  for i in range(T):      l = f.readline()[:-1]      v = do_trial(l)      print "Case #%d: %s" % (i+1, v)  <CODESPLIT> 69
#!/usr/bin/env python    import collections    import re  import sys    INPUT = "tiny"  if 1:      INPUT = "A-small-attempt0.in"    def debug(*args):      pass #print str(args)    class Memoize:      def __init__(self,function):          self._cache = {}          self._callable = function                    def __call__(self, *args, **kwds):          cache = self._cache          key = self._getKey(*args,**kwds)          try: return cache[key]          except KeyError:              cachedValue = cache[key] = self._callable(*args,**kwds)              return cachedValue            def _getKey(self,*args,**kwds):          return kwds and (args, ImmutableDict(kwds)) or args        def check(board, x, y, dx, dy):      #import pdb; pdb.set_trace()      c = collections.Counter((board[x+dx*i][y+dy*i] for i in range(4)))      if c.get("X", 0) + c.get("T", 0) == 4: return "X won"      if c.get("O", 0) + c.get("T", 0) == 4: return "O won"    def do_trial(board):      #return "X won" #(the game is over, and X won)      #"O won" (the game is over, and O won)      #"Draw" (the game is over, and it ended in a draw)      #"Game has not completed" (the game is not over yet)      for x in range(4):          v = check(board, x, 0, 0, 1)          if v: return v          v = check(board, 0, x, 1, 0)          if v: return v      v = check(board, 0, 0, 1, 1)      if v: return v      v = check(board, 3, 0, -1, 1)      if v: return v      if '.' in ''.join(board):          return "Game has not completed"      return "Draw"    f = file(INPUT)  T = int(f.readline()[:-1])  for i in range(T):      lines = [f.readline()[:-1] for j in range(4)]      f.readline()      v = do_trial(lines)      print "Case #%d: %s" % (i+1, v)  <CODESPLIT> 69
#!/usr/bin/env python    import collections    import math  import re  import sys    #sys.setrecursionlimit(50)    INPUT = "tiny"  #INPUT = "C-large.in"  INPUT = "C-small-attempt1.in"    def debug(*args):      #return      sys.stderr.write(str(args) + "\n")    class Memoize:      def __init__(self,function):          self._cache = {}          self._callable = function                    def __call__(self, *args, **kwds):          cache = self._cache          key = self._getKey(*args,**kwds)          try: return cache[key]          except KeyError:              cachedValue = cache[key] = self._callable(*args,**kwds)              return cachedValue            def _getKey(self,*args,**kwds):          return kwds and (args, ImmutableDict(kwds)) or args        IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])    for i in range(2,51):      IMPOSSIBLE.add((2,i,1))      IMPOSSIBLE.add((i,2,1))    SOLN = {      (1,2,1) : ["c*"],      (2,1,1) : ["c", "*"],      (2,2,3) : ["c*", "**"],  }    def solve(R, C, M):      if M == 0:          s = ["c%s" % ('.' * (C-1))]          for i in range(R-1):              s.append('.' * C)          return s      t = (R, C, M)      if t in IMPOSSIBLE:          debug("** %s %s %s" % t)          raise ValueError      if t in SOLN:          return SOLN[t]        # last row?      if C < M and R > 2:          try:              return solve(R-1, C, M-C) + ["*" * C]          except ValueError:              pass        if C <= R:          if M >= C and R > 2:              return solve(R-1, C, M-C) + ["*" * C]      else:          if M >= R and C > 2:              return ["%s*" % s for s in solve(R, C-1, M-R)]      if R > 2:          # fill in last row          mines = min(C, M)          if mines == C - 1:              mines -= 1          try:              return solve(R-1, C, M-mines) + [("." * (C - mines)) + ("*" * mines)]          except ValueError:              if C > 2:                  mines = min(R, M)              if mines == R - 1:                  mines -= 1              s = ["%s%s" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]              return s      debug(R, C, M)      return []    def do_trial(R, C, M):      try:          r = solve(R,C,M)          s = "\n" + '\n'.join(r)          assert len(r) == R          for r1 in r:              assert len(r1) == C          assert len(''.join(k for k in s if k == '*')) == M          return s      except ValueError:          return "\nImpossible"      def all():      for R in range(1,50):          for C in range(1,50):              for M in range(R*C):                  print(R, C, M)                  print(do_trial(R, C, M))      sys.exit(0)    #all()    f = file(INPUT)  T = int(f.readline()[:-1])  for i in range(T):      R, C, M = [int(x) for x in f.readline().split()]      #import pdb; pdb.set_trace()      v = do_trial(R, C, M)      print "Case #%d: %s" % (i+1, v)  <CODESPLIT> 69
#!/usr/bin/env python    import pdb  import re  import sys    INPUT = "tiny"    INPUT = "C-small-attempt0.in.txt"    def debug(*args):      pass #print str(args)    if 0:      def debug(*args):          sys.stderr(''.join(str(s) for s in args) + "\n")    def recycleables(N, A, B):      t = set()      s = str(N)      for i in range(len(s)):          s1 = int(s[i:] + s[:i])          if A <= s1 <= B:              t.add(s1)      return t    def do_trial(A, B):      total = 0      seen = set()      for i in xrange(A, B+1):          if i not in seen:              t = recycleables(i, A, B)              z = len(t)              total += z * (z-1) / 2              seen.update(t)      return total    f = file(INPUT)  T = int(f.readline()[:-1])  for i in range(T):      A, B = [int(x) for x in f.readline()[:-1].split()]      v = do_trial(A, B)      print "Case #%d: %s" % (i+1, v)  <CODESPLIT> 69
