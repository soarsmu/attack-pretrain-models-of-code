"""Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  """\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      I = map(float, infile.next().split())\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      C, F, X = I\n      n = [0]\n      r = 2.\n  \n      res = X / r\n      while True:\n          n.append(n[-1] + C / r)\n          r += F\n          nres = n[-1] + X / r\n          if nres >= res:\n              break\n          res = nres\n  \n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n <CODESPLIT> 0
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  def isqrt(x):\n      "returns int(floor(sqrt(x))) using only integer math"\n      assert x >= 0, 'Undefined %r' % locals()\n      n = int(x)\n      if n == 0:\n          return 0\n      a, b = divmod(n.bit_length(), 2)\n      x = 2**(a+b)\n      while True:\n          y = (x + n//x)//2\n          if y >= x:\n              return x\n          x = y\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, **ignore):\n      P = map(int, infile.next().split())\n      return locals()\n  \n  def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      low = isqrt(P[0])\n      high = isqrt(P[1])+1\n  \n      def is_pal(n):\n          n = str(n)\n          for i in range(len(n)/2+1):\n              if n[i]!=n[len(n)-1-i]:\n                  return False\n          return True\n  \n      res = 0\n      for i in range(low, high+1):\n          if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):\n              res += 1\n  \n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n <CODESPLIT> 0
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  \n  \n  class Solver(object):\n      cache = {}\n  \n      def __init__(self, infile, testcase):\n          self.testcase = testcase\n          self.P = P = map(int, infile.next().split())\n  \n      def init_cache(self):\n          if 'main' in self.cache:\n              return\n  \n      def solve(self):\n  \n          N, S, p = self.P[:3]\n          G = sorted(self.P[3:], reverse=True)\n  \n          r = 0\n          s = 0\n          for g in G:\n              if g >= 3 * p - 2 and g >= p:\n                  r += 1\n              elif g >= 3 * p - 4 and g >= p:\n                  if s == S:\n                      break\n                  r += 1\n                  s += 1\n  \n          return r\n  \n  \n  def main():\n      T = int(sys.stdin.next())\n      for t in xrange(T):\n          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 0
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, **ignore):\n      P = map(int, infile.next().split())\n      S = [map(int, infile.next().split()) for i in range(P[0])]\n      return locals()\n  \n  def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n      \n      S = np.array(S)\n      done = np.zeros(P, dtype=int)\n      for row in range(P[0]):\n          m = S[row].max()\n          done[row][S[row]==m] = 1\n  \n      for col in range(P[1]):\n          m = S[:,col].max()\n          done[:,col][S[:,col]==m] = 1\n  \n      res = 'YES' if done.sum() == P[0]*P[1] else 'NO'\n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n <CODESPLIT> 0
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  \n  \n  class Solver(object):\n      cache = {}\n  \n      def __init__(self, infile, testcase):\n          self.testcase = testcase\n          self.I = I = map(int, infile.next().split())\n  \n  \n      def init_cache(self):\n          if 'main' in self.cache:\n              return\n  \n      def solve(self):\n  \n          I = self.I\n          l = len(str(I[0]))\n  \n          r = 0\n          for i in xrange(I[0], I[1]):\n              ii = str(i)\n              rr = set()\n              for j in xrange(1, l):\n                  if  i < int(ii[j:]+ii[:j]) <= I[1]:\n                      rr.add(ii[j:]+ii[:j])\n              r += len(rr)\n  \n          return r\n  \n  \n  def main():\n      T = int(sys.stdin.next())\n      for t in xrange(T):\n          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 0
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, **ignore):\n      S = [infile.next().strip() for i in range(5)]\n      return locals()\n  \n  def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n      \n      not_draw = False\n      for line in S[:4]:\n          not_win = set()\n          if '.' in line:\n              not_draw = True\n              continue\n          if 'O' in line:\n              not_win.add('X')\n          if 'X' in line:\n              not_win.add('O')\n          if len(not_win) == 1:\n              return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n  \n      ST = []\n      for j in range(4):\n          ST.append(''.join(S[i][j] for i in range(4)))\n      for line in ST:\n          not_win = set()\n          if '.' in line:\n              continue\n          if 'O' in line:\n              not_win.add('X')\n          if 'X' in line:\n              not_win.add('O')\n          if len(not_win) == 1:\n              return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n  \n      line = ''.join(S[i][i] for i in range(4))\n      not_win = set()\n      if '.' not in line:   \n          if 'O' in line:\n              not_win.add('X')\n          if 'X' in line:\n              not_win.add('O')\n          if len(not_win) == 1:\n              return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n  \n      line = ''.join(S[i][3-i] for i in range(4))\n      not_win = set()\n      if '.' not in line:\n          if 'O' in line:\n              not_win.add('X')\n          if 'X' in line:\n              not_win.add('O')\n          if len(not_win) == 1:\n              return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')\n  \n      if not_draw:\n          return 'Case #%s: %s\n' % (testcase, 'Game has not completed')\n      else:\n          return 'Case #%s: %s\n' % (testcase, 'Draw')\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n <CODESPLIT> 0
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  \n  ins = """ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jvqz\n  """\n  \n  outs = """our language is impossible to understand\n  there are twenty six factorial possibilities\n  so it is okay if you want to just give upzq\n  """\n  \n  class Solver(object):\n      cache = {}\n  \n      def __init__(self, infile, testcase):\n          self.testcase = testcase\n          self.S = S = infile.next().strip()\n  \n          self.init_cache()\n  \n      def init_cache(self):\n          if 'main' in self.cache:\n              return\n          t = {}\n          for i in xrange(len(ins)):\n              t[ins[i]] = outs[i]\n          print t\n          self.cache['main'] = t\n  \n      def solve(self):\n  \n          S = self.S\n          \n  \n          return ''.join(self.cache['main'][c] for c in list(S))\n  \n  \n  def main():\n      T = int(sys.stdin.next())\n      for t in xrange(T):\n          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 0
"""Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  """\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      N = int(infile.next())\n      P = map(float, infile.next().split())\n      I = map(float, infile.next().split())\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      N = sorted(P)\n      K = sorted(I)\n  \n      W = 0\n      ik = 0\n      for n in N:\n          while ik < len(K) and K[ik] < n:\n              ik += 1\n              W += 1\n          ik += 1\n  \n      D = 0\n      i = 0\n      for k in K:\n          while i < len(N) and N[i] < k:\n              i += 1\n          i += 1\n          if i <= len(N):\n              D += 1\n  \n      return 'Case #%s: %s %s\n' % (testcase, D, W)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n <CODESPLIT> 0
def solve():\n      c, f, x = map(float, raw_input().split())\n      ans = 1e40\n      cur = 0.0\n      psp = 2.0\n      while cur < ans + 1e-8:\n          ans = min(ans, cur + x / psp)\n          cur += c / psp\n          psp += f\n      return ans\n  for t in xrange(int(raw_input())):\n      print "Case #%d: %.7f" % (t + 1, solve())\n <CODESPLIT> 1
 a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]\n  A = a[:10]\n  def subdfs(pre, mid, d, t, n):\n      if d == t:\n          k = long(''.join([pre, mid, pre[::-1]]))\n          k = k * k\n          if k > n:\n              return [1, 0]\n          sqk = str(k)\n          if sqk == sqk[::-1]:\n              A.append(k)\n              return [0, 1]\n          else:\n              return [0, 0]\n      res = subdfs(pre + '0', mid, d + 1, t, n)\n      if res[0]: return res\n      if not res[1]: return res\n      res2 = subdfs(pre + '1', mid, d + 1, t, n)\n      if res2[0]: return [1, res[1] + res2[1]]\n      return [0, res[1] + res2[1]]\n  \n  def dfs(d, n):\n      subdfs('1', '', 0, d, n)\n      subdfs('2' + '0' * d, '', d, d, n)\n      subdfs('1', '0', 0, d, n)\n      subdfs('1', '1', 0, d, n)\n      subdfs('1', '2', 0, d, n)\n      subdfs('2' + '0' * d, '0', d, d, n)\n      subdfs('2' + '0' * d, '1', d, d, n)\n  \n  def solve(pre):\n      read_ints = lambda: map(int, raw_input().split())\n      l, r = read_ints()\n      cl = bisect_left(A, l)\n      cr = bisect_right(A, r)\n      cl_ = cr_ = 0\n      for i in xrange(40):\n          if a[i] < l: cl_ += 1\n      for i in xrange(40):\n          if a[i] <= r: cr_ += 1\n      print pre, cr - cl\n  \n  for k in xrange(1, 48):\n      dfs(k, 10 ** 100 + 1)\n  A.sort()\n  N = int(raw_input())\n  for i in xrange(1, N + 1):\n      solve("Case #%d:" % i)\n <CODESPLIT> 1
T = int(raw_input())\n  for t in xrange(T):\n      line = map(int, raw_input().split())\n      N, S, p = line[0:3]\n      a = line[3:]\n      cnt = 0\n      a.sort(reverse=True)\n      for x in a:\n          if (x + 2) / 3 >= p:\n              cnt += 1\n          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:\n              cnt += 1\n              S -= 1\n          else:\n              break\n      print "Case #%d: %d" % (t + 1, cnt)\n <CODESPLIT> 1
def solve(pre):\n      read_ints = lambda: map(int, raw_input().split())\n      h, w = read_ints()\n      to = [read_ints() for _ in xrange(h)]\n      lawn = [[100] * w for _ in xrange(h)]\n      for i, r in enumerate(to):\n          cut = max(r)\n          for j in xrange(w):\n              lawn[i][j] = min(lawn[i][j], cut)\n      for i, c in enumerate(zip(*to)):\n          cut = max(c)\n          for j in xrange(h):\n              lawn[j][i] = min(lawn[j][i], cut)\n      if lawn == to:\n          print pre, "YES"\n      else:\n          print pre, "NO"\n  \n  n = int(raw_input())\n  for i in xrange(n):\n      solve("Case #%d:" % (i + 1))\n <CODESPLIT> 1
def solve(a, b):\n      n = len(str(a))\n      N = 10 ** n\n      cnt = 0\n      for x in xrange(a, b):\n          y = x\n          S = set([y])\n          for j in xrange(n-1):\n              y = y * 10\n              y += y / N\n              y %= N\n              if a <= x < y <= b and y not in S:\n                  cnt += 1\n                  S.add(y)\n      return cnt\n  \n  T = int(raw_input())\n  for t in xrange(T):\n      a, b = map(int, raw_input().split())\n      print "Case #%d: %d" % (t + 1, solve(a, b))\n <CODESPLIT> 1
def solve(pre):\n      b = [raw_input().strip() for _ in xrange(4)]\n      raw_input()\n      for s in b + zip(*b) + [''.join(b[i][i] for i in xrange(4)), ''.join(b[3-i][i] for i in xrange(4))]:\n          for c in 'XO':\n              if s.count('T') + s.count(c) == 4:\n                  print pre, c, "won"\n                  return\n      if ''.join(b).count('.'):\n          print pre, "Game has not completed"\n      else:\n          print pre, "Draw"\n  \n  n = int(raw_input())\n  for i in xrange(n):\n      solve("Case #%d:" % (i + 1))\n <CODESPLIT> 1
 n = int(raw_input())\n  S = """\n  y qee\n  ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv\n  z\n  """\n  T = """\n  a zoo\n  our language is impossible to understand\n  there are twenty six factorial possibilities\n  so it is okay if you want to just give up\n  q\n  """\n  trans = {}\n  for i in xrange(len(S)):\n      trans[S[i]] = T[i]\n  A = ""\n  B = ""\n  for (c, d) in trans.items():\n      A += c\n      B += d\n  for i in xrange(n):\n      print "Case #%d: %s" % (i + 1, raw_input().strip().translate(string.maketrans(A, B)))\n <CODESPLIT> 1
 def solve():\n      n = int(raw_input())\n      a = map(float, raw_input().split())\n      b = map(float, raw_input().split())\n      a.sort()\n      b.sort()\n      da = deque(a)\n      db = deque(b)\n      k = 0\n      while da:\n          if da[0] < db[0]:\n              da.popleft()\n              db.pop()\n          else:\n              da.popleft()\n              db.popleft()\n              k += 1\n      print k,\n      k = 0\n      for i, x in enumerate(a):\n          j = bisect(b, x)\n          k = max(k, j - i)\n      print k\n  for t in xrange(int(raw_input())):\n      print "Case #%d:" % (t+1),\n      solve()\n <CODESPLIT> 1
 \n  f = open( sys.argv[1] )\n  f.readline()\n  \n  numcases = 1\n  input = f.readline()\n  while input != "":\n  	inC,inF,inX = [float(x) for x in input.split()]\n  \n  	start = (0.0,0.0,2.0)\n  	h = [start]\n  	checked =set()\n  \n  	while h[0][1] < inX:\n  		x = heapq.heappop(h)\n  \n  		if x in checked:\n  			continue\n  		else:\n  			checked.add(x)	\n  \n  		time,numCookies,rate = x\n  		timeW = (inX - numCookies) / rate\n  		heapq.heappush( h,(time+timeW,numCookies+rate*timeW,rate) )\n  \n  		timeF = (inC - numCookies) / rate\n  		newC = numCookies + rate*timeF\n  		newT = time + timeF\n  		heapq.heappush( h,(newT,(newC - inC),rate+inF) )\n  		heapq.heappush( h,(newT,newC,rate) )\n  \n  	output = "{:.7f}".format(h[0][0])\n  \n  	print "Case #"+str(numcases)+": "+output\n  	input = f.readline()\n  	numcases += 1\n  	\n <CODESPLIT> 2
 \n  def isPalindrome(x):\n      x = str(x)\n      if x[0] != x[-1]:\n          return 0\n      y = x[::-1]\n      if x == y:\n          return 1\n      return 0\n  \n  def generate():\n      digits = [str(x) for x in range(0,10)]\n      dplus = digits + [""]\n  \n      for x in range(1,10):\n          y = x**2\n          if isPalindrome(y):\n              print y\n  \n      for x in range(1,10**4):\n          x = str(x)\n          y = x[::-1]\n          pals = [ int(x+z+y)**2 for z in dplus ]\n          for p in pals:\n              if isPalindrome(p):\n                  print p\n  \n  if __name__ == "__main__":\n      f = open( sys.argv[1] )\n      sqpals = np.array([int(l) for l in f])\n      sqpals.sort()\n      f.close()\n  \n      f = open( sys.argv[2] )\n      t = int(f.readline())\n      t = 1\n      for l in f:\n          a,b = [int(x) for x in l.split()]\n          mt = sqpals >= a\n          lt = sqpals <= b\n          output = sum( mt&lt )\n          print "Case #%s: %s"%(t,output)\n          t += 1\n      \n <CODESPLIT> 2
 \n  \n  if __name__ == "__main__":\n  \n      f = open( "B-small-attempt1.in.txt" )\n      g = open( "output_small.txt", "w" )\n  \n      f.readline()\n      line = f.readline()\n      caseI = 1\n      while line != "":\n          line = [ int(x) for x in line.split() ]\n          N = line[0]\n          surprise = line[1]\n          p = line[2]\n          points = line[3:]\n          points.sort()\n          points.reverse()\n  \n          maxp = 0\n          either = 0\n          make_surprise = 0\n          for x in points:\n              this_p = (x+2)/3\n              if x in [0,1,29,30]:\n                  if this_p >= p:\n                      maxp += 1\n              elif this_p >= p:\n                  either += 1\n                  maxp += 1\n              elif this_p == p-1 and (x+2)%3 > 0:\n                  make_surprise += 1\n              else:\n                  either += 1\n  \n          if make_surprise >= surprise:\n              make_surprise -= surprise\n              maxp += surprise\n              make_surprise = 0\n          else:\n              maxp += make_surprise\n  \n          g.write( "Case #%s: %s\n"%(caseI,maxp) )\n  \n          line = f.readline()\n          caseI += 1\n  \n      f.close()\n      g.close()\n      \n <CODESPLIT> 2
 \n  f = open( sys.argv[1] )\n  t = int(f.readline())\n  \n  t = 1\n  l = f.readline()\n  while l != "":\n      n,m = [int(x) for x in l.split()]\n      lawn = [ [int(x) for x in f.readline().split()] for y in range(n)]\n  \n      rowMax = [ max(x) for x in lawn ]\n      colMax = [ max([x[y] for x in lawn]) for y in range(m) ]\n  \n      output = "YES"\n  \n      for i in range(n):\n          for j in range(m):\n              if lawn[i][j] < rowMax[i]:\n                  if lawn[i][j] < colMax[j]:\n                      output = "NO"\n      \n      print "Case #%s: %s"%(t,output)\n      t += 1\n      l = f.readline()\n <CODESPLIT> 2
 \n  if __name__ == "__main__":\n      f = open( "C-small-attempt0.in.txt" )\n      g = open( "output_small.txt", "w" )\n  \n      numcases = int(f.readline())\n  \n      caseI = 1\n      line = f.readline()\n      while line != "":\n          A,B = [int(x) for x in line.split()]\n  \n          matched = [0]*(B+1)\n          pairs = deque()\n  \n          for x in range(A,B+1):\n              if matched[x]:\n                  continue\n              a = str(x)\n              allcycle = deque()\n              allcycle.append(x)\n              for i in range(1,len(a)):\n                  yL,yR = a[:i],a[i:]\n                  y = int( yR+yL )\n                  if y >= A and y <= B:\n                      allcycle.append(y)\n              allcycle = list(set(allcycle))\n              allcycle.sort()\n              for y in allcycle:\n                  matched[y] = 1\n              for i in range(len(allcycle)):\n                  for j in range(i+1,len(allcycle)):\n                      pairs.append( (allcycle[i],allcycle[j]) )\n          g.write( "Case #%s: %s\n"%(caseI,len(pairs)) )\n          line = f.readline()\n          caseI += 1\n      f.close()\n      g.close()\n <CODESPLIT> 2
 \n  f = open( sys.argv[1] )\n  t = f.readline()\n  \n  t = 1\n  line = f.readline()\n  while line != "":\n      board = [line.strip(),\n               f.readline().strip(),\n               f.readline().strip(),\n               f.readline().strip()]\n  \n      output = ""\n  \n      cols = [ "".join([x[y] for x in board]) for y in range(4)]\n      diags = ["".join([x[y] for x,y in zip(board,range(4))]),\n               "".join([x[y] for x,y in zip(board,range(-1,-5,-1))])]\n      \n      rows = board + cols + diags\n  \n      for row in rows:\n          x = [1 for z in row if z is "X" or z is "T"]\n          if sum(x) == 4:\n              output = "X won"\n              break\n          o = [1 for z in row if z is "O" or z is "T"]\n          if sum(o) == 4:\n              output = "O won"\n              break\n      if output == "":\n          finished = sum([ y.count(".") for y in board ])\n          if finished == 0:\n              output = "Draw"\n          else:\n              output = "Game has not completed"\n      \n      print "Case #%s: %s"%(t,output)\n      t += 1\n      line = f.readline()\n      line = f.readline()\n <CODESPLIT> 2
 \n  s1 = "ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jvyeqz"\n  s2 = "our language is impossible to understand there are twenty six factorial possibilitiesso it is okay if you want to just give upaozq"\n  \n  mapd = string.maketrans(s1,s2)\n  \n  f = open( "A-small-attempt0.in.txt" )\n  g = open( "output_small.txt","w")\n  \n  f.readline()\n  l = f.readline()\n  caseI = 1\n  while l != "":\n      output = l.translate(mapd)\n  \n      g.write( "Case #%s: %s"%(caseI,output) )\n      l = f.readline()\n      caseI += 1\n  f.close()\n  g.close()\n <CODESPLIT> 2
 \n  f = open(sys.argv[1])\n  f.readline()\n  \n  numCase = 1\n  l = f.readline()\n  while l != "":\n  	n = [float(x) for x in f.readline().split()]\n  	k = [float(x) for x in f.readline().split()]\n  \n  	n.sort()\n  	nd = deque(n)\n  	k.sort()\n  	kd = deque(k)\n  \n  	war = 0\n  	while len(nd) > 0:\n  		nblock = nd.pop()\n  		if nblock > kd[-1]:\n  			kd.popleft()\n  			war += 1\n  		else:\n  			kd.pop()\n  \n  	all = [ (x,1) for x in n ]\n  	all.extend( [(x,2) for x in k] )\n  	all.sort()\n  \n  	dwar = 0\n  	nd = deque(n)\n  	kd = deque(k)\n  	while len(nd) > 0:\n  		if nd[0] < kd[0]:\n  			kd.pop()\n  		else:\n  			kd.popleft()\n  			dwar += 1\n  		nd.popleft()\n  		\n  	print "Case #"+str(numCase)+ ": "+str(dwar)+" "+str(war)\n  	\n  \n  	numCase += 1\n  	l = f.readline()\n <CODESPLIT> 2
t = int(raw_input())\n  \n  for case in range(t):\n  \n  	c, f, x = raw_input().split()\n  	c = float(c)\n  	f = float(f)\n  	x = float(x)\n  \n  	t = 0\n  	cps = 2.0\n  	while c/cps < x/cps and t+x/cps > t+c/cps + x/(cps+f):\n  		t += c/cps\n  		cps += f\n  \n  	t += x/cps\n  \n  	print 'Case #'+str(case+1)+':', t\n <CODESPLIT> 3
def esPal(x):\n  	return str(x) == str(x)[::-1]\n  \n  t = int(raw_input())\n  \n  for case in range(t):\n  	line = raw_input().split(' ')\n  	a = int(line[0])\n  	b = int(line[1])\n  \n  	i = int(a**.5)\n  	if i*i != a:\n  		i += 1\n  	max = int(b**.5)\n  	cantidad = 0\n  	while i <= max:\n  		if esPal(i) and esPal(i*i):\n  			cantidad += 1\n  		i += 1\n  \n  	print 'Case #'+str(case+1)+':', cantidad\n <CODESPLIT> 3
t = int(raw_input())\n  \n  max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n  \n  for i in range(t):\n  	line = raw_input().split(' ')\n  	n = int(line[0])\n  	s = int(line[1])\n  	p = int(line[2])\n  \n  	total = 0\n  \n  	for j in range(3, len(line)):\n  		t = int(line[j])\n  		if t == 0:\n  			if p == 0:\n  				total += 1\n  		elif t%3 == 0:\n  			if t/3 >= p:\n  				total +=1\n  			elif t/3 + 1 >= p and s>0:\n  				total +=1\n  				s -=1\n  		elif t%3 == 1:\n  			if (t+2)/3 >= p:\n  				total +=1\n  		else:\n  			if (t+1)/3 >= p:\n  				total +=1\n  			elif (t+1)/3 + 1 >= p and s>0:\n  				total +=1\n  				s -=1\n  \n  \n  \n  	print 'Case #'+str(i+1)+':', total\n  \n  \n <CODESPLIT> 3
t = int(raw_input())\n  \n  for case in range(t):\n  	line = raw_input().split(' ')\n  	n = int(line[0])\n  	m = int(line[1])\n  \n  	l = []\n  	for j in range(n):\n  		a = raw_input().split(' ')\n  		b = []\n  		for x in a:\n  			b.append(int(x))\n  		l.append(b)\n  \n  \n  	cumple = True\n  	for i in range(n):\n  		for j in range(m):\n  			col = True\n  			fil = True\n  			for x in range(n):\n  				if l[x][j] > l[i][j]:\n  					col = False\n  					break\n  			for x in range(m):\n  				if l[i][x] > l[i][j]:\n  					fil = False\n  					break\n  \n  			if not col and not fil:\n  				cumple = False\n  				break\n  \n  		if not cumple:\n  			break\n  \n  	if cumple:\n  		print 'Case #'+str(case+1)+': YES'\n  	else:\n  		print 'Case #'+str(case+1)+': NO'\n <CODESPLIT> 3
t = int(raw_input())\n  \n  def mover(n, i):\n  	s = str(n)\n  	return int(s[i:] + s[:i])\n  \n  for i in range(t):\n  	s = raw_input().split(' ')\n  	a = int(s[0])\n  	b = int(s[1])\n  	total = 0\n  	for n in range(a, b):\n  		ms = []\n  		for k in range(len(s[0])):\n  			m = mover(n, k+1)\n  			if m <= b and m > n and not m in ms:\n  				ms.append(m)\n  				total +=1\n  \n  \n  	print 'Case #'+str(i+1)+':', total\n <CODESPLIT> 3
t = int(raw_input())\n  \n  code = 'yhesocvxduiglbkrztnwjpfmaq'\n  \n  for i in range(t):\n  	l = []\n  	for j in range(4):\n  		l.append(raw_input())\n  	if i != t-1:\n  		raw_input()\n  \n  	v = False\n  	fin = False\n  	for li in l:\n  		x = True\n  		o = True\n  		for c in li:\n  			if c != 'X' and c != 'T':\n  				x = False\n  			if c != 'O' and c != 'T':\n  				o = False\n  			if c == '.':\n  				v = True\n  		if x:\n  			print 'Case #'+str(i+1)+': X won'\n  			fin = True\n  		if o:\n  			print 'Case #'+str(i+1)+': O won'\n  			fin = True\n  \n  	if fin:\n  		continue\n  \n  	for a in range(4):\n  		x = True\n  		o = True\n  		for b in range(4):\n  			if l[b][a] != 'X' and l[b][a] != 'T':\n  				x = False\n  			if l[b][a] != 'O' and l[b][a] != 'T':\n  				o = False\n  		if x:\n  			print 'Case #'+str(i+1)+': X won'\n  			fin = True\n  		if o:\n  			print 'Case #'+str(i+1)+': O won'\n  			fin = True\n  	if fin:\n  		continue\n  \n  	x = True\n  	o = True\n  	for j in range(4):\n  		if l[j][j] != 'X' and l[j][j] != 'T':\n  			x = False\n  		if l[j][j] != 'O' and l[j][j] != 'T':\n  			o = False\n  	if x:\n  		print 'Case #'+str(i+1)+': X won'\n  		continue\n  	if o:\n  		print 'Case #'+str(i+1)+': O won'\n  		continue\n  	x = True\n  	o = True\n  	for j in range(4):\n  		if l[3-j][j] != 'X' and l[3-j][j] != 'T':\n  			x = False\n  		if l[3-j][j] != 'O' and l[3-j][j] != 'T':\n  			o = False\n  	if x:\n  		print 'Case #'+str(i+1)+': X won'\n  		continue\n  	if o:\n  		print 'Case #'+str(i+1)+': O won'\n  		continue\n  \n  	if v:\n  		print 'Case #'+str(i+1)+': Game has not completed'\n  	else:\n  		print 'Case #'+str(i+1)+': Draw'\n <CODESPLIT> 3
t = int(raw_input())\n  \n  code = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']\n  \n  for i in range(t):\n  	line = raw_input()\n  	decoded = ''\n  \n  	for c in line:\n  		if c==' ':\n  			decoded += c\n  		else:\n  			decoded += code[ord(c)-97]\n  \n  	print 'Case #'+str(i+1)+':', decoded\n <CODESPLIT> 3
t = int(raw_input())\n  \n  for case in range(t):\n  	n = int(raw_input())\n  	naomi = [float(i) for i in raw_input().split()]\n  	ken = [float(i) for i in raw_input().split()]\n  \n  	naomi.sort()\n  	ken.sort()\n  	y = 0\n  	z = 0\n  \n  \n  	na = naomi[:]\n  	ke = ken[:]\n  	while len(na) > 0:\n  		nc = na.pop(0)\n  		kc = -1\n  		for i in range(len(ke)):\n  			if ke[i] > nc:\n  				kc = ke.pop(i)\n  				break\n  		if kc == -1:\n  			kc = ke.pop(0)\n  		if nc > kc:\n  			z += 1\n  \n  \n  	na = naomi[:]\n  	ke = ken[:]\n  	while len(ke) > 0:\n  		kc = ke.pop(0)\n  		nc = -1\n  		for i in range(len(na)):\n  			if na[i] > kc:\n  				nc = na.pop(i)\n  				break\n  		if nc == -1:\n  			nc = na.pop(0)\n  		if nc > kc:\n  			y += 1\n  \n  	print 'Case #'+str(case+1)+':', y, z\n <CODESPLIT> 3
f = open('Bsmall.in', 'r')\n  g = open('outputB.txt', 'w')\n  \n  data = [[float(e) for e in line.strip("\n").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  \n  for i, case in enumerate(data):\n      C, F, X = case[0], case[1], case[2]\n      n = 1\n      t = X/2\n      t_next = X/(2 + F) + C/2\n      metric = (t_next < t)\n      while metric:\n          n += 1\n          t = t_next\n          t_next = t_next - X/(2 + F*(n-1)) + C/(2 + F*(n-1)) + X/(2 + F*n)\n          metric = (t_next < t)\n      g.write('Case #%i: %f\n' %(i+1, t))\n  f.close()\n  g.close()\n <CODESPLIT> 4
def check(a,b):\n      c = 0\n      n = 1\n      for i in range(1,4):\n          if i**2 >= a and i**2 <=b:\n              c += 1\n      if 44944 >= a and 44944 <= b:\n          c += 1\n      while n < 10:\n          p1 = int('1'+'1'*n)**2\n          if p1 >= a and p1 <=b:\n              c += 1\n          n += 1\n  \n  \n      if 484 >= a and 484 <= b:\n          c += 1\n  \n      n = 1\n      while True:\n          p2 = int('1'+'0'*n+'1')**2\n          p3 = int('2'+'0'*n+'2')**2\n          if p2 >= a and p2 <= b:\n              c += 1\n          else:\n              break\n          if p3 >= a and p3 <= b:\n              c += 1\n          else:\n              continue\n          n += 1\n  \n      n = 1\n      while True:\n          t = False\n          for m in range(2,5):\n              p4 = int('1'*m+'0'*n+'1'*m)**2\n              if p4 >= a and p4 <= b:\n                  c += 1\n              else:\n                  t = True\n                  break\n          if t:\n              break\n              \n          n += 1\n      return c\n                  \n  dat = raw_input().split()\n  n = int(dat.pop(0))\n  data = [int(e) for e in dat]\n  \n  for i in range(0, n*2, 2):\n      a, b = data[i], data[i+1]\n      print 'Case #%i: '%(i/2+1) + str(check(a,b)) \n  \n      \n <CODESPLIT> 4
f = open('cj2.in','r')\n  out = open('out1.txt','w')\n  inp = [[int(n) for n in s.split()] for s in f.readlines()]\n  \n  def score_partition(score):\n      poss = []\n      if score == 0:\n          return [[0,0,0]]\n      if score == 1:\n          return [[0,0,1]]\n      if score % 3 == 0:\n          poss.append([score/3,score/3,score/3])\n          poss.append([score/3-1,score/3,score/3+1])\n      if score % 3 == 1:\n          poss.append([score/3, score/3,score/3+1])\n          poss.append([score/3-1,score/3+1,score/3+1])\n      if score % 3 == 2:\n          poss.append([score/3,score/3+1,score/3+1])\n          poss.append([score/3,score/3,score/3+2])\n  \n      return poss\n  \n  \n  s = 0\n  c = 1\n  for e in inp[1:len(inp)]:\n      count = 0\n      surprises = e[1]\n      s = 0\n      p = e[2]\n      for i in e[3:len(e)]:\n          scores = score_partition(i)\n          for j in scores: \n              if max(j) >= p:\n                  if max(j)-min(j) == 2:\n                      if s < surprises:\n                          s +=1\n                          count +=1\n                          break\n                  else:\n                      count += 1\n                      break\n                  \n      out.write('Case #'+str(c)+': '+str(count)+'\n')\n      c += 1\n  \n  out.close()\n  f.close()\n                  \n          \n      \n      \n  \n      \n <CODESPLIT> 4
 def check(grid, n, m):\n      for i in range(n):\n          for j in range(m):\n              if neighbor(grid,i,j,n,m):\n                  return False\n      return True\n  \n  def neighbor(grid,i,j,n,m):\n      u = not i\n      d = not (n-i-1)\n      l = not j\n      r = not (m-j-1)\n      if n == 1:\n          return False\n      if m == 1:\n          return False\n      if i > 0:\n          for k in range(i,-1,-1):\n              if grid[k][j] > grid[i][j]:\n                  u = 1\n              \n      if i < n-1:\n          for k in range(i,n):\n              if grid[k][j] > grid[i][j]:\n                  d = 1\n          \n      if j > 0:\n          for k in range(j,-1,-1):\n              if grid[i][k] > grid[i][j]:\n                  l = 1\n          \n      if j < m-1:\n          for k in range(j,m):\n              if grid[i][k] > grid[i][j]:\n                  r = 1\n      return (u*d*l*r)\n          \n  \n  dat = raw_input().split()\n  c = int(dat.pop(0))\n  data = [int(e) for e in dat]\n  index = 0\n  t = 0\n  while t < c:\n      n = data[index]\n      m = data[index+1]\n      index += 2\n      grid = []\n      for i in range(n):\n          grid.append(data[index:index+m])\n          index += m\n      if check(grid, n, m):\n          print 'Case #%i: YES'%(t+1)\n      else:\n          print 'Case #%i: NO'%(t+1)\n      t += 1\n <CODESPLIT> 4
 \n  f = open('csmall.in','r')\n  out = open('out3.txt','w')\n  inp = [[int(n) for n in s.split()] for s in f.readlines()]\n  count = 1\n  \n  for e in inp[1:len(inp)]:\n      interval = xrange(e[0],e[1]+1)\n      exp = xrange(1, int(math.log(interval[-1],10))+1)\n      skip = []\n      pairs = []\n      for i in interval:\n          if str(i)[::-1] == str(i):\n              continue\n          for j in exp:\n              val = int(str(i%10**j)+str(i/10**j))\n              if val in skip:\n                  continue\n              elif val >= interval[0] and val <= interval[-1] and not val == i:\n                  skip.append(i)\n      out.write('Case #'+str(count)+': '+str(len(skip))+'\n')\n      count += 1\n  \n  f.close()\n  out.close()\n <CODESPLIT> 4
 def checkRow(d, t):\n      g = 0\n      for row in d:\n          a = list(row)\n          a.sort()\n          a = ''.join(a)\n          if 'TXXX' in a or 'XXXX' in a:\n              print 'Case #%i: X won' %(t/4+1)\n              return 1\n          if 'OOOT' in a or 'OOOO' in a:\n              print 'Case #%i: O won' %(t/4+1)\n              return 1\n          if '.' in a:\n              g = 10\n      return g\n  \n  def checkCol(d, t):\n      for j in range(4):\n          col = []\n          for row in d:\n              col.append(row[j])\n          a = list(col)\n          a.sort()\n          a = ''.join(a)\n          if 'TXXX' in a or 'XXXX' in a:\n              print 'Case #%i: X won' %(t/4+1)\n              return 1\n          if 'OOOT' in a or 'OOOO' in a:\n              print 'Case #%i: O won' %(t/4+1)\n              return 1\n      return 0\n  \n  def checkDiag(d1, d2, t):\n      a = list(d1)\n      b = list(d2)\n      a.sort()\n      b.sort()\n      a = ''.join(a)\n      b = ''.join(b)\n  \n      if 'TXXX' in a or 'XXXX' in a:\n          print 'Case #%i: X won' %(t/4+1)\n          return 1\n      if 'OOOT' in a or 'OOOO' in a:\n          print 'Case #%i: O won' %(t/4+1)\n          return 1\n  \n      if 'TXXX' in b or 'XXXX' in b:\n          print 'Case #%i: X won' %(t/4+1)\n          return 1\n      if 'OOOT' in b or 'OOOO' in b:\n          print 'Case #%i: O won' %(t/4+1)\n          return 1\n      return 0\n  \n  dat = raw_input()\n  \n  data = dat.split()\n  c = int(data.pop(0))\n  \n  for t in range(0, 4*c, 4):\n      a = checkRow(data[t:t+4],t)\n      if a == 1:\n          continue\n      b = checkCol(data[t:t+4],t)\n      if b:\n          continue\n      d1 = data[t][0]+data[t+1][1]+data[t+2][2]+data[t+3][3]\n      d2 = data[t][3]+data[t+1][2]+data[t+2][1]+data[t+3][0]\n      c = checkDiag(d1, d2,t)\n      if c:\n          continue\n      if (a+b+c) == 0:\n          print 'Case #%i: Draw' %(t/4+1)\n      if a == 10:\n          print 'Case #%i: Game has not completed' %(t/4+1)   \n <CODESPLIT> 4
mapping = {'y':'a','n':'b','f':'c','i':'d','c':'e','w':'f','l':'g','b':'h','k':'i','u':'j','o':'k','m':'l','x':'m','s':'n','e':'o','v':'p','p':'r','d':'s','r':'t','j':'u','g':'v','t':'w','h':'x','a':'y','q':'z','z':'q',' ':' ','\n':'\n'}\n  \n  f = open('cj.in','r')\n  out = open('out.txt','w')\n  inp = [line for line in f]\n  \n  i = 1\n  for G in inp[1:len(inp)]:\n      string = ''\n      for e in G:\n          string+=mapping[e]\n      out.write('Case #'+str(i)+': '+string)\n      i+=1\n  \n  f.close()\n  out.close()\n <CODESPLIT> 4
def war(n, k):\n      k.sort()\n      score = 0\n      for x in n:\n          for i  in xrange(len(k)):\n              if k[i] > x:\n                  score += 1\n                  k.pop(i)\n                  break\n      return len(n) - score    \n              \n  \n  def deceit(n, k):\n      n.sort()\n      k.sort()\n      score = 0\n      for y in k:\n          for i in xrange(len(n)):\n              if n[i] > y:\n                  score +=1\n                  n.pop(i)\n                  break\n      return score\n      \n  \n  f = open('Dsmall.in', 'r')\n  g = open('outputD.txt', 'w')\n  \n  data = [[float(e) for e in line.strip("\n").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  c = 1\n  for i in xrange(0, T*3, 3):\n      N = data[i+1]\n      K = data[i+2]\n  \n      w = war(N, list(K))\n      d = deceit(list(N), list(K))\n      g.write('Case #%i: %i %i\n' %(c, d, w))\n      c += 1\n  \n  f.close()\n  g.close()\n  \n <CODESPLIT> 4
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          C, F, X = map(float, f.readline().split())\n  \n          cps = 2.0\n          t = 0.0\n          best_t = X / cps\n  \n          while True:\n              t += C / cps\n              if t >= best_t:\n                  break\n  \n              cps += F\n              best_t = min(best_t, t + X / cps)\n  \n          print "Case #%d: %.7f" % (_T+1, best_t)\n <CODESPLIT> 5
 \n  def ispal(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  def ispalsq(n):\n      sqrt = int(math.sqrt(n) + .01)\n      if sqrt ** 2 != n:\n          return False\n      return ispal(n) and ispal(sqrt)\n  \n  def search(s, l, idx):\n      if l % 2 == 0:\n          m = s + s[::-1]\n      else:\n          m = s[:-1] + s[::-1]\n      assert ispal(m)\n      n = int(m) ** 2\n      if not ispal(n):\n          return 0\n  \n      r = 1 if (a <= n <= b) else 0\n      for i in xrange(idx, len(s)):\n          s2 = list(s)\n          s2[i] = str(int(s2[i])+1)\n          s2 = ''.join(s2)\n          r += search(s2, l, i)\n      return r\n  \n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          a, b = map(int, f.readline().split())\n  \n          total = 0\n          for l in xrange(1, 150):\n              if 10 ** (l-1) > b:\n                  break\n              total += search("1" + "0" * ((l-1)/2), l, 0)\n          print "Case #%d: %d" % (_t+1, total)\n  \n <CODESPLIT> 5
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          ns = map(int, f.readline().split())\n          n = ns[0]\n          s = ns[1]\n          p = ns[2]\n          assert len(ns) == n + 3\n          scores = ns[3:3+n]\n  \n          sure = 0\n          if_surprising = 0\n          for x in scores:\n              not_surprising = (x + 2) / 3\n              is_surprising = (x + 4) / 3\n              if not_surprising >= p:\n                  sure += 1\n              elif (2 <= x <= 28) and is_surprising >= p:\n                  if_surprising += 1\n          print "Case #%d: %d" % (_t+1, sure + min(if_surprising, s))\n <CODESPLIT> 5
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          n, m = map(int, f.readline().split())\n          b = []\n          for i in xrange(n):\n              b.append(map(int, f.readline().split()))\n              assert len(b[-1]) == m\n  \n          max_h = [0] * n\n          max_v = [0] * m\n  \n          for i in xrange(n):\n              for j in xrange(m):\n                  t = b[i][j]\n                  max_h[i] = max(max_h[i], t)\n                  max_v[j] = max(max_v[j], t)\n          can = True\n          for i in xrange(n):\n              if not can:\n                  break\n              for j in xrange(m):\n                  t = b[i][j]\n                  if max_h[i] > t and max_v[j] > t:\n                      can = False\n                      break\n  \n          print "Case #%d: %s" % (_t+1, "YES" if can else "NO")\n <CODESPLIT> 5
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          a, b = map(int, f.readline().split())\n  \n          total = 0\n          for i in xrange(a, b):\n              s = set()\n              cs = str(i)\n              for j in xrange(1, len(cs)):\n                  k = int(cs[j:] + cs[:j])\n                  if i < k <= b:\n                      s.add(k)\n              total += len(s)\n  \n          print "Case #%d: %d" % (_t + 1, total)\n <CODESPLIT> 5
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          m = []\n          for i in xrange(4):\n              l = f.readline().strip()\n              assert len(l) == 4\n              m.append(l)\n          f.readline()\n  \n          def check(x, y, dx, dy):\n              s = set()\n              for i in xrange(4):\n                  s.add(m[x][y])\n                  x += dx\n                  y += dy\n              if 'T' in s:\n                  s.remove('T')\n              if '.' in s:\n                  return None\n              if len(s) == 1:\n                  return list(s)[0]\n              return None\n  \n          winner = None\n          for i in xrange(4):\n              winner = winner or check(0, i, 1, 0)\n              winner = winner or check(i, 0, 0, 1)\n          winner = winner or check(0, 0, 1, 1)\n          winner = winner or check(0, 3, 1, -1)\n  \n          print "Case #%d:" % (_t+1),\n          if winner:\n              print "%s won" % winner\n          elif any('.' in l for l in m):\n              print "Game has not completed"\n          else:\n              print "Draw"\n <CODESPLIT> 5
 \n  d = {\n          'a':'y',\n          'o':'e',\n          'z':'q',\n          ' ':' ',\n          'r':'p',\n          'l':'m',\n          'n':'s',\n          'g':'l',\n          'u':'j',\n          'e':'c',\n          'i':'k',\n          's':'d',\n          'm':'x',\n          'p':'v',\n          't':'r',\n          'd':'i',\n          'b':'n',\n          'h':'b',\n          'w':'t',\n          'y':'a',\n          'x':'h',\n          'f':'w',\n          'c':'f',\n          'k':'o',\n          'j':'u',\n          'v':'g',\n          'q':'z',\n          '\n':'\n',\n          }\n  \n  r = dict((v,k) for (k,v) in d.items())\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      f.readline()\n      i = 1\n      for l in f:\n          sys.stdout.write("Case #%d: " % i)\n          for c in l:\n              sys.stdout.write(r[c])\n          i += 1\n  \n <CODESPLIT> 5
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          N = int(f.readline())\n          naomi = map(float, f.readline().split())\n          ken = map(float, f.readline().split())\n          assert len(ken) == len(naomi) == N\n  \n          naomi = [(w, 1) for w in naomi]\n          ken = [(w, 0) for w in ken]\n  \n          blocks = ken + naomi\n          blocks.sort(reverse=True)\n          blocks = [p[1] for p in blocks]\n  \n          honest = 0\n          adv = 0\n          for b in blocks:\n              if b == 1:\n                  adv += 1\n                  honest = max(honest, adv)\n              else:\n                  adv -= 1\n  \n          deceitful = 0\n          kept = 0\n          for b in blocks:\n              if b == 1:\n                  kept += 1\n              else:\n                  if kept:\n                      kept -= 1\n                      deceitful += 1\n          print "Case #%d: %d %d" % (_T+1, deceitful, honest)\n <CODESPLIT> 5
 \n  \n  TEST_CASES = [\n      ("""4\n  30.0 1.0 2.0\n  30.0 2.0 100.0\n  30.50000 3.14159 1999.19990\n  500.0 4.0 2000.0\n  ""","""Case #1: 1.0000000\n  Case #2: 39.1666667\n  Case #3: 63.9680013\n  Case #4: 526.1904762\n  """)\n  ]\n  \n  """\n  Z is number of farms held\n  tF(Z) is time to build a farm = C / (2+(F*Z))\n  tX(Z) is time to win = X / (2+(F*Z))\n  No point incresing Z when tX(Z) < (tX(Z+1) + tF(Z)\n      == X / (2+(F*Z)) < (X / (2+(F*(Z+1))) + (C / (2+(F*Z)))\n      == (X - C) / (2+(F*Z)) < X / (2+(F*(Z+1)))\n      == (X - C) * (2+(F*Z)+F) < X * (2+(F*Z))\n      == 2X - 2C + XFZ - CFZ + XF - CF < 2X + XFZ\n      == XF - CF - 2C < CFZ\n      == (XF - CF - 2C) / CF < Z\n  """\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          input_line = input_reader.readline().rstrip("\n").split(" ")\n          input_values = {"C": float(input_line[0]),\n                          "F": float(input_line[1]),\n                          "X": float(input_line[2]),\n                          "case": case_idx}\n          yield input_values\n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      case = kwargs['case']\n      C_val = kwargs['C']\n      F_val = kwargs['F']\n      X_val = kwargs['X']\n  \n      best_Z = ((X_val * F_val) - (C_val * F_val) - (2 * C_val)) / (C_val * F_val)\n      best_Z = int(ceil(best_Z))\n      if best_Z < 0:\n          best_Z = 0\n  \n      tX = lambda z: (X_val / (2+(F_val * z)))\n      tF = lambda z: (C_val / (2+(F_val * z)))\n  \n      total_time = reduce(lambda x,y: x + tF(y), range(best_Z), tX(best_Z))\n      print >> output_writer, "Case #%d: %.7f" % (case, total_time)\n  \n  def solve_inputs(input_reader, output_writer):\n      """\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      """\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print "Test %d: Success" % idx\n          else:\n              all_pass = False\n              print "Test %d: Failure" % idx\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print "All tests were successful!"\n      else:\n          print "Something didn't match - try again."\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file",\n                        dest="filename_stem",\n                        help="read input from FILE.in and write to FILE.out",\n                        metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print "Running in file mode."\n          input_reader = open("%s.in" % options.filename_stem, "r")\n          output_writer = open("%s.out" % options.filename_stem, "w")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print "Running in test mode."\n          run_tests()\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 6
 \n  def solve(lower, upper, cache):\n      counter = 0\n      for item in cache:\n          if item > upper:\n              break\n          if item < lower:\n              continue\n          counter += 1\n      return counter\n  \n  def is_palindrome(test_int):\n      str_arg = str(test_int)\n      return str_arg == str_arg[::-1]\n  \n  def generate_cache():\n      """ Generates a list of 'fair and square' numbers between 1 and 10^100\n  \n      By observation of generating the first few of these numbers it became\n      obvious that the 'roots' fitted a very specific pattern, they are either\n      single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;\n      multiple digits with a 2 at the beginning and end and 1s and 0s in the\n      middle or an odd number of digits with a single 2 in the centre and 1s and\n      0s elsewhere.\n  \n      This function therefore only looks at these numbers to build a list of all\n      valid results. """\n      cache = [9,]\n      counter = 1\n      if upper_bound is None:\n          upper_bound = pow(2,25)\n      while counter < upper_bound:\n          binary_part = "{0:b}".format(counter)\n          half_int = binary_part\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = "%s%s" % (binary_part, 2)\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = "2%s" % binary_part[1:]\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          counter += 1\n      return sorted(cache)\n  \n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n      parser.add_option("-c", "--cache", dest="cache_filename",\n                        help="read/write cache from/to CACHE_FILE", metavar="CACHE_FILE")\n      parser.add_option("-g", "--generate-cache", dest="generate_cache",\n                        help="generate the cache file", action="store_true")\n      cache = None\n      (options, args) = parser.parse_args()\n      if options.generate_cache:\n          cache = generate_cache()\n          if not options.cache_filename:\n              output_file = open(options.cache_filename, "w")\n              pickle.dump(cache, output_file)\n              output_file.close()\n      else:\n          cache_file = open(options.cache_filename, "r")\n          cache = pickle.load(cache_file)\n          cache_file.close()\n      if not options.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(options.filename, "r")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n          case_number += 1\n          lower,upper = input_file.readline().split()\n          lower = int(lower)\n          upper = int(upper)\n          data_args = (lower, upper, cache)\n          print "Case #%d: %s" % (case_number, solve(*data_args))\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 6
 \n  def solve(N,S,p,t):\n      if p == 0:\n          return N\n      outright_wins = 0\n      potential_surprises = 0\n      win_cutoff = (p * 3) - 3\n      surprise_cutoff = win_cutoff - 2\n      for score in t:\n          if score == 0:\n              continue\n          elif score > win_cutoff:\n              outright_wins += 1\n          elif score > surprise_cutoff:\n              potential_surprises += 1\n      if potential_surprises < S:\n          return outright_wins + potential_surprises\n      else:\n          return outright_wins + S\n  \n  def parse_case(data_line):\n      bits = data_line.split()\n      N = int(bits[0])\n      S = int(bits[1])\n      p = int(bits[2])\n      t = [int(x) for x in bits[3:]]\n      return N,S,p,t\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(options.filename, "r")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n      	case_number += 1\n      	data_args = parse_case(input_file.readline())\n      	print "Case #%d: %d" % (case_number, solve(*data_args))\n  \n  if __name__ == "__main__":\n  	main()\n <CODESPLIT> 6
 \n  def solve(rows,cols,width,height):\n      row_mins = [max(row) for row in rows]\n      col_mins = [max(col) for col in cols]\n      for row_idx in range(height):\n          for col_idx in range(width):\n              if row_mins[row_idx] > rows[row_idx][col_idx] \\n                 and col_mins[col_idx] > rows[row_idx][col_idx]:\n                  return "NO"\n      return "YES"\n  \n  \n  def parse_case(data,width,height):\n      data_line = [int(entry) for entry in reduce(lambda x,y: x+y, data, [])]\n      rows = []\n      cols = []\n      for idx in range(height):\n          offset = idx * width\n          rows.append(data_line[offset:offset+width])\n      for idx in range(width):\n          cols.append(data_line[idx::width][:height])\n      return (rows, cols, width, height)\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(options.filename, "r")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n          case_number += 1\n          height,width = input_file.readline().split()\n          width = int(width)\n          height = int(height)\n          data = []\n          for idx in range(height):\n              data.append(input_file.readline().split())\n          data_args = parse_case(data, width, height)\n          print "Case #%d: %s" % (case_number, solve(*data_args))\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 6
 \n  MAX_NUMBER = 2000000\n  \n  COUNT_MAP = { 1: 0 }\n  index = 1\n  while index < math.log10(MAX_NUMBER):\n      index += 1\n      COUNT_MAP[index] = index * (index - 1) / 2\n  \n  def solve(minimum, maximum):\n      total_cycles = 0\n      iter_range = range(minimum, maximum + 1)\n      while iter_range:\n          number = iter_range[0]\n          iter_range.remove(number)\n          cycle_numbers = [number,]\n          string_rep = "%s%s" % (number, number)\n          digits = len(string_rep) / 2\n          start_index, end_index = 0, digits\n          while start_index < digits:\n              start_index += 1\n              end_index += 1\n              new_number = int(string_rep[start_index:end_index])\n              if new_number == number:\n                  start_index = digits\n              elif new_number > number and new_number <= maximum:\n                  cycle_numbers.append(new_number)\n                  iter_range.remove(new_number)\n          total_cycles += COUNT_MAP[len(cycle_numbers)]\n      return total_cycles\n  \n  def parse_case(data_line):\n      bits = data_line.split()\n      minimum = int(bits[0])\n      maximum = int(bits[1])\n      return (minimum, maximum, )\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(options.filename, "r")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n      	case_number += 1\n      	data_args = parse_case(input_file.readline())\n      	print "Case #%d: %s" % (case_number, solve(*data_args))\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 6
 \n  def solve(data):\n      GAME_INCOMPLETE = 0\n      GAME_DRAWN = 1\n      GAME_WON = 2\n      winner = None\n      state = GAME_DRAWN\n      for row in data:\n          if "." in row:\n              state = GAME_INCOMPLETE\n          elif "X" not in row:\n              winner = "O"\n              state = GAME_WON\n              break\n          elif "O" not in row:\n              winner = "X"\n              state = GAME_WON\n              break\n      if state == GAME_WON:\n          return "%s won" % winner\n      elif state == GAME_INCOMPLETE:\n          return "Game has not completed"\n      else:\n          return "Draw"\n  \n  def parse_case(data):\n      data_line = "".join(data)\n      rows = []\n      for idx in range(4):\n          offset = idx * 4\n          rows.append(data_line[offset:offset+4])\n          rows.append(data_line[idx::4])\n      rows.append(data_line[0::5])\n      rows.append(data_line[3:-1:3])\n      return (rows, )\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(options.filename, "r")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n          case_number += 1\n          data = []\n          for idx in range(4):\n              data.append(input_file.readline()[:4])\n          input_file.readline()\n          data_args = parse_case(data)\n          print "Case #%d: %s" % (case_number, solve(*data_args))\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 6
 \n  def solve(data_line):\n      english, googlerese = generate_map()\n      transmap = string.maketrans(googlerese, english)\n      return string.translate(data_line, transmap, "\n")\n  \n  def parse_case(data_line):\n      return (data_line, )\n  \n  def generate_map():\n      """ Use the known phrases we have to generate a translation map.  If\n          there's exactly one letter missing after analysing these phrases (which\n          there is) we can work it out by seeing what's left over."""\n      known_mappings = {"a zoo": "y qee",\n                        "our language is impossible to understand": "ejp mysljylc kd kxveddknmc re jsicpdrysi",\n                        "there are twenty six factorial possibilities": "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n                        "so it is okay if you want to just give up": "de kr kd eoya kw aej tysr re ujdr lkgc jv",\n                       }\n      all_letters = "abcdefghijklmnopqrstuvwxyz"\n      letter_map = {}\n      for english, googlerese in known_mappings.items():\n          pairs = zip(english, googlerese)\n          for e,g in pairs:\n              if e not in letter_map:\n                  letter_map[e] = g\n      if len(letter_map) == 26:\n          e_letter = ""\n          g_letter = ""\n          for letter in all_letters:\n              if not e_letter and letter not in letter_map.keys():\n                  e_letter = letter\n              if not g_letter and letter not in letter_map.values():\n                  g_letter = letter\n          letter_map[e_letter] = g_letter\n      return "".join(letter_map.keys()), "".join(letter_map.values())\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(options.filename, "r")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n      	case_number += 1\n      	data_args = parse_case(input_file.readline())\n      	print "Case #%d: %s" % (case_number, solve(*data_args))\n  \n  if __name__ == "__main__":\n  	main()\n <CODESPLIT> 6
 \n  \n  TEST_CASES = [\n      ("""4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n  ""","""Case #1: 0 0\n  Case #2: 1 0\n  Case #3: 2 1\n  Case #4: 8 4\n  """)\n  ]\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          block_count = int(input_reader.readline())\n          naomi_blocks = [float(x) for x in input_reader.readline().split(" ")]\n          ken_blocks = [float(x) for x in input_reader.readline().split(" ")]\n          input_values = {"case":case_idx,\n                          "naomi": naomi_blocks,\n                          "ken": ken_blocks,\n                          "block_count": block_count\n                          }\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      ken = sorted(kwargs["ken"])\n      naomi = sorted(kwargs["naomi"])\n      case = kwargs["case"]\n      block_count = kwargs["block_count"]\n  \n      dw_idx = 0\n      w_idx = 0\n  \n      w_score = 0\n      dw_score = 0\n  \n      for block in naomi:\n          if block > ken[dw_idx]:\n              dw_score += 1\n              dw_idx += 1\n      naomi = sorted(naomi, key=lambda x: -x)\n      ken = sorted(ken, key=lambda x: -x)\n      for block in naomi:\n          if block > ken[w_idx]:\n              w_score += 1\n          else:\n              w_idx += 1\n  \n      print >> output_writer, "Case #%d: %d %d" % (case, dw_score, w_score)\n  \n      \n  \n  def solve_inputs(input_reader, output_writer):\n      """\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      """\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print "Test %d: Success" % idx\n          else:\n              all_pass = False\n              print "Test %d: Failure" % idx\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print "All tests were successful!"\n      else:\n          print "Something didn't match - try again."\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file",\n                        dest="filename_stem",\n                        help="read input from FILE.in and write to FILE.out",\n                        metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print "Running in file mode."\n          input_reader = open("%s.in" % options.filename_stem, "r")\n          output_writer = open("%s.out" % options.filename_stem, "w")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print "Running in test mode."\n          run_tests()\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 6
__author__ = 'Jeffrey'\n  \n  inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\B-small-attempt0.in"\n  outFileName = inFileName[ : -2] + "out"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          L.append([float(i) for i in f.readline().split()])\n  \n      return T, L\n  \n  \n  def calculateWinTime(C, F, X):\n      R = 2.0 # rate of cookie profit (cookies/s)\n      totalTime = 0.0\n      while (X / R >= C/R + X/(R + F)):\n          totalTime += C / R\n          R += F\n      return totalTime + X / R\n  \n  \n  def playGame(T,L):\n      for i in range(T):\n          result = calculateWinTime(L[i][0], L[i][1], L[i][2])\n          yield "Case #" + str(i + 1) + ": " + "{:0.7f}".format(result)\n  \n  \n  if __name__=="__main__":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      print(L)\n  \n      oF = open(outFileName, "wb")\n      for out in playGame(T, L):\n          print(out)\n          oF.write(bytes(out + "\n",'utf-8'))\n      oF.close()\n <CODESPLIT> 7
 \n  \n  		\n  	\n  def isPalindrome(S):\n  	s = str(S) #so I dont need to make sure its a string\n  	for i in range(len(s)//2):\n  		if not s[i] == s[-1 - i]:\n  			return False\n  	return True\n  \n  def FairAndSquare(infile="C-small-attempt0.in", outfile="C-small-attempt0.out"):\n  	inF = open(infile, 'r')\n  	outF = open(outfile, 'w')\n  	\n  	for t in range(1, int(inF.readline().strip()) + 1):\n  		temp = inF.readline().strip().split()\n  		A = long(temp[0])\n  		B = long(temp[1])\n  		count = long(0)\n  		\n  		i = long(math.ceil(math.sqrt(A)))\n  		m = long(math.floor(math.sqrt(B)))\n  		while i <= m:\n  			if isPalindrome(i):\n  				if isPalindrome(i**2):\n  					count += 1\n  			i += 1\n  					\n  		outF.write("Case #" + str(t) + ": " + str(count) + "\n")\n  	\n  	inF.close()\n  	outF.close()\n  	\n  	f = open(outfile, 'r')\n  	print f.read()\n  	f.close()\n  	\n  	\n  if __name__ == "__main__":\n      FairAndSquare()\n <CODESPLIT> 7
data_dict = {}\n  init = False\n  \n  \n  def partB(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt",\\n                outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt"):\n      \n      linesA = []\n      for line in open(infile, 'r'):\n          linesA.append(line.strip())\n  \n      outA = []\n          \n      T = int(linesA[0])\n      for i in range(1, 1 + T):\n          caseA = linesA[i].split()\n          N = int(caseA[0])\n          S = int(caseA[1])\n          P = int(caseA[2])\n          \n          over_norm = 0\n          over_supr = 0\n          \n          for t in [int(conv) for conv in caseA[3:3+N]]:\n              if data_dict[t][0] >= P:\n                  over_norm += 1\n              elif data_dict[t][1] >= P:\n                  over_supr += 1\n          \n          outA.append(over_norm + min(over_supr, S))\n              \n              \n          \n      \n      out = open(outfile, 'w')\n      print "\nOUTPUT"\n      for i in range(1, 1 + T):\n          if i != 1:\n              out.write("\n")\n          print "Case #" + str(i) + ": " +str(outA[i-1])\n          out.write("Case #" + str(i) + ": " +str(outA[i-1]))\n      out.close()\n  \n  def dict_helper(total, depth=0, lowest=10):\n      pass\n  \n  def build_dict():\n      for i in range(31):\n          fullA = []\n          maxN = 0\n          maxS = 0\n          print str(i) + ": "\n          for a1 in range(0,11):\n              for a2 in range(0,11):\n                  for a3 in range(0,11):\n                      if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):\n                          fullA.append((a1,a2,a3))\n                          \n                          print "\t", fullA[-1],\n                          if max(a1,a2,a3)-min(a1,a2,a3) == 2:\n                              print "*"\n                              maxS = max(maxN, max(a1,a2,a3))\n                          else:\n                              print\n                              maxN = max(maxN, max(a1,a2,a3))\n          data_dict[i]=[maxN, maxS]\n      init = True\n      \n  if __name__ == "__main__":\n      build_dict()\n      partB()\n <CODESPLIT> 7
 \n  def Lawnmower(infile="B-small-attempt0.in", outfile="B-small-attempt0.out"):\n  	inF = open(infile, 'r')\n  	outF = open(outfile, 'w')\n  	\n  	for t in range(1, int(inF.readline().strip()) + 1):\n  		temp = inF.readline().strip().split()\n  		N = int(temp[0])\n  		M = int(temp[1])\n  		L = []\n  		\n  		for i in range(N):\n  			L.append(inF.readline().strip().split()) #using an array should speed up the lookups\n  			for j in range(M):\n  				L[i][j] = int(L[i][j])\n  		\n  		for y in range(N):\n  			for x in range(M):\n  				for i in range(M):\n  					if L[y][i] > L[y][x]:\n  						break\n  				else:\n  					continue\n  				\n  				for i in range(N):\n  					if L[i][x] > L[y][x]:\n  						break\n  				else:\n  					continue\n  				break\n  			else:\n  				continue\n  			break\n  		else:\n  			outF.write("Case #" + str(t) + ": YES\n")\n  			continue\n  		outF.write("Case #" + str(t) + ": NO\n")\n  	\n  	inF.close()\n  	outF.close()\n  	\n  	f = open(outfile, 'r')\n  	print f.read()\n  	f.close()\n  	\n  	\n  if __name__ == "__main__":\n      Lawnmower()\n <CODESPLIT> 7
 \n  def partCa(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/C-small-attempt0.in",\\n                outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/output.txt"):\n      \n      \n      linesA = []\n      for line in open(infile, 'r'):\n          linesA.append(line.strip())\n  \n      outA = []\n          \n      T = int(linesA[0])\n      for i in range(1, 1 + T):\n          caseA = linesA[i].split()\n          A = int(caseA[0])\n          B = int(caseA[1])\n          \n          \n          outA.append(0)\n          for i in range(A,B):\n              for j in range(i + 1, B + 1):\n                  outA[-1] += int(isRecycled(i, j))\n      \n      out = open(outfile, 'w')\n      print "\nOUTPUT"\n      for i in range(1, 1 + T):\n          if i != 1:\n              out.write("\n")\n          print "Case #" + str(i) + ": " +str(outA[i-1])\n          out.write("Case #" + str(i) + ": " +str(outA[i-1]))\n      out.close()\n      \n  def isRecycled(n,m):\n      '''\n      Takes 2 integers and tells you if they are recycled\n      '''\n      a = str(n)\n      b = str(m)\n      if len(a) == len(b):\n          for i in range(len(a)):\n              if (a[i:] + a[:i]) == b:\n                  return True\n          \n      return False\n      \n  if __name__ == "__main__":\n      partCa()\n <CODESPLIT> 7
def checkRow(r):\n  	c = r[0];\n  	\n  	if (c == '.'):\n  		return (False, None)\n  		\n  	for i in range(1,4):\n  		if not (r[i] == c or r[i] == 'T'):\n  			return (False, None)\n  	\n  	return (True, c)\n  \n  def checkCol(L, col):\n  	c = L[0][col];\n  	\n  	if (c == '.'):\n  		return (False, None)\n  		\n  	for i in range(1,4):\n  		if not (L[i][col] == c or L[i][col] == 'T'):\n  			return (False, None)\n  	\n  	return (True, c)\n  	\n  def checkDiag(L):\n  	c = L[0][0];\n  	\n  	for i in range(1,4):\n  		if not (L[i][i] == c or L[i][i] == 'T'):\n  			break\n  	else:\n  		if (c != '.'):\n  			return (True, c)\n  	\n  	c = L[0][3];\n  	\n  	if (c == '.'):\n  		return (False, None)\n  		\n  	for i in range(1,4):\n  		if not (L[i][3-i] == c or L[i][3-i] == 'T'):\n  			break\n  	else:\n  		return (True, c)\n  		\n  	return (False, None)\n  		\n  def checkComplete(L):\n  	for i in range(4):\n  		if '.' in L[i]:\n  			return False\n  	return True\n  \n  def TicTacToeTomek(infile="A-small-attempt0.in", outfile="A-small-attempt0.out"):\n  	f = open(infile, 'r')\n  	out = open(outfile, 'w')\n  	\n  	n = int(f.readline().strip())\n  	\n  	for t in range(1, n + 1):\n  		L = []\n  		for i in range(4):\n  			L.append(f.readline().strip());\n  		\n  		for i in range(4):\n  			result = checkRow(L[i])\n  			if result[0]:\n  				out.write("Case #" + str(t) + ": " + result[1] + " won\n")\n  				break\n  			result = checkCol(L,i)\n  			if result[0]:\n  				out.write("Case #" + str(t) + ": " + result[1] + " won\n")\n  				break\n  		else:\n  			result = checkDiag(L)\n  			if result[0]:\n  				out.write("Case #" + str(t) + ": " + result[1] + " won\n")\n  			else:\n  				if checkComplete(L):\n  					out.write("Case #" + str(t) + ": Draw\n")\n  				else:\n  					out.write("Case #" + str(t) + ": Game has not completed\n")\n  				\n  		f.readline() #skipping empty line\n  	\n  	f.close()\n  	out.close()\n  	\n  	f = open(outfile, 'r')\n  	print f.read()\n  	f.close()\n  	\n  	\n  if __name__ == "__main__":\n      TicTacToeTomek()\n <CODESPLIT> 7
 \n  f = "abcdefghijklmnopqrstuvwxyz"\n  o = "ynficwlbkuomxsevzpdrjgthaq"\n          \n  def partAfile(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/input.txt",\\n                outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/output.txt"):\n      tempF = open(infile, 'r')\n      tempA = []\n      for line in tempF:\n          tempA.append(line.strip())\n          \n      N = int(tempA[0])\n      \n      out = open(outfile, 'w')\n      for i in range(1, 1+N):\n          if i != 1:\n              out.write("\n")\n          print "Case #" + str(i) + ": " +tempA[i].translate(maketrans(o,f))\n          out.write("Case #" + str(i) + ": " +tempA[i].translate(maketrans(o,f)))\n          \n      \n  if __name__ == "__main__":\n      partAfile()\n <CODESPLIT> 7
__author__ = 'Jeffrey'\n  \n  inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-small-attempt0.in"\n  \n  outFileName = inFileName[: -2] + "out"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          f.readline()\n          L.append(([float(j) for j in f.readline().split()], [float(j) for j in f.readline().split()]))\n          L[-1][0].sort()\n          L[-1][1].sort()\n  \n      return T, L\n  \n  \n  def calculateScores(naomi, ken):\n      return [calcDeceit(naomi, ken), calcHonest(naomi, ken)]\n  \n  def calcDeceit(naomi, ken):\n      wins = 0\n      while len(naomi) > 0:\n          if naomi[-1] > ken[-1]:\n              naomi = naomi[ : -1]\n              ken = ken[ : -1]\n              wins += 1\n          else:\n              naomi = naomi[1: ]\n              ken = ken[ : -1]\n      return wins\n  \n  def calcHonest(naomi, ken):\n      wins = 0\n      while len(naomi) > 0:\n          n = naomi.pop(0)\n          k = ken[0]\n          for i in range(len(ken)):\n              kTemp = ken[i]\n              if kTemp > n:\n                  k = ken.pop(i)\n                  break\n          else:\n              ken.pop(0)\n              wins += 1\n      return wins\n  \n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateScores(L[i][0], L[i][1])\n          yield "Case #{}: {} {}".format(i + 1, result[0], result[1])\n  \n  \n  if __name__ == "__main__":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      for l in L:\n          print()\n          for k in l:\n              print(k)\n  \n      oF = open(outFileName, "wb")\n      for out in playGame(T, L):\n          print(out)\n          oF.write(bytes(out + "\n", 'utf-8'))\n      oF.close()\n <CODESPLIT> 7
 \n  def solve_case(c, f, x, case_number):\n      rate = 2.0\n      time = 0.0\n      rest = x\n      while True:\n          time_to_c = c / rate\n          time_to_x = rest / rate\n          if time_to_c < time_to_x:\n              time_to_x_with_boost = time_to_c + (rest / (rate + f))\n              if time_to_x_with_boost < time_to_x:\n                  rate += f\n                  time += time_to_c\n              else:\n                  break\n          else:\n              break\n      time += rest / rate\n      print "Case #%d: %.7f" % (case_number, time)\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      values = map(float, r.readline().split(' '))\n      solve_case(values[0], values[1], values[2], case_number)\n <CODESPLIT> 8
 \n  \n  def is_palindrome(x):\n      candidate = list(str(x))\n      while len(candidate) > 1:\n          if candidate.pop(0) != candidate.pop():\n              return False\n      return True\n  \n  \n  def square(x):\n      return x * x\n  \n  \n  def solve_case(ab, case_number):\n      fs = 0\n      root = int(math.sqrt(ab[0]))\n      sq = square(root)\n      if sq < ab[0]:\n          root += 1\n          sq = square(root)\n  \n      while sq <= ab[1]:\n          if is_palindrome(root) and is_palindrome(sq):\n              fs += 1\n  \n          root += 1\n          sq = square(root)\n  \n      print "Case #%d: %d" % (case_number, fs)\n  \n  \n  def main():\n      r = sys.stdin\n      if len(sys.argv) > 1:\n          r = open(sys.argv[1], 'r')\n  \n      total_cases = r.readline()\n      for case_number in range(1, int(total_cases) + 1):\n          ab = map(int, r.readline().strip().split(' '))\n          solve_case(ab, case_number)\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 8
 \n  mod_plus_conv_with_s = {0:1, 1:1, 2:2}\n  mod_plus_conv_without_s = {0:0, 1:1, 2:1}\n  \n  def solve_case(s, p, scores,case_number):\n  	ans = 0\n  	for score in scores:\n  		if p <= (score / 3) + mod_plus_conv_without_s[score % 3]:\n  			ans = ans + 1\n  		elif s > 0 and (score / 3) > 0: \n  			if p <= (score / 3) + mod_plus_conv_with_s[score % 3]:\n  				ans = ans + 1\n  				s = s - 1\n  	print "Case #%d: %d" % (case_number, ans)\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n  	r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n  	case_line = map(int, r.readline().rstrip().split(' '))\n  	solve_case(case_line[1], case_line[2], case_line[3:], case_number)\n  \n <CODESPLIT> 8
 \n  \n  def solve_case(nm, lawn, case_number):\n      zipped_lawn = zip(*lawn)\n      for n in range(0, nm[0]):\n          max_lawn_n = max(lawn[n])\n          for m in range(0, nm[1]):\n              max_lawn_m = max(zipped_lawn[m])\n              if lawn[n][m] < max_lawn_n and lawn[n][m] < max_lawn_m:\n                  print "Case #%d: NO" % case_number\n                  return\n  \n      print "Case #%d: YES" % case_number\n  \n  \n  def main():\n      r = sys.stdin\n      if len(sys.argv) > 1:\n          r = open(sys.argv[1], 'r')\n  \n      total_cases = r.readline()\n      for case_number in range(1, int(total_cases) + 1):\n          nm = map(int, r.readline().strip().split(' '))\n          lawn = []\n          for n in range(0, nm[0]):\n              lawn.append(map(int, r.readline().strip().split(' ')))\n          solve_case(nm, lawn, case_number)\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 8
 \n  def solve_case(min, max, case_number):\n  	ans = 0\n  \n  	for candidate in range(min, max + 1):\n  		candidate_str = str(candidate)\n  		ignore = []\n  		for rot in range(1, len(candidate_str)):\n  			rot_candidate = int(candidate_str[rot:] + candidate_str[:rot])\n  			if not rot_candidate in ignore:\n  				if rot_candidate <= max and candidate < rot_candidate:\n  					ans = ans + 1\n  				ignore.append(rot_candidate)\n  \n  	print "Case #%d: %d" % (case_number, ans)\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n  	r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n  	case = map(int, r.readline().rstrip().split(' '))\n  	solve_case(case[0], case[1], case_number)\n  \n <CODESPLIT> 8
 \n  def output(case_number, status):\n      print "Case #%d: %s" % (case_number, status)\n  \n  def solve_case(board, case_number):\n      has_game_completed = True\n  \n      for column in range(0, 4):\n          x = 0\n          o = 0\n          for row in range(0, 4):\n              if board[column][row] == 'X':\n                  x += 1\n              elif board[column][row] == 'O':\n                  o += 1\n              elif board[column][row] == 'T':\n                  x += 1\n                  o += 1\n              else:\n                  has_game_completed = False\n  \n          if x > 3:\n              output(case_number, "X won")\n              return\n          if o > 3:\n              output(case_number, "O won")\n              return\n  \n      for row in range(0, 4):\n          x = 0\n          o = 0\n          for column in range(0, 4):\n              if board[column][row] == 'X':\n                  x += 1\n              elif board[column][row] == 'O':\n                  o += 1\n              elif board[column][row] == 'T':\n                  x += 1\n                  o += 1\n  \n          if x > 3:\n              output(case_number, "X won")\n              return\n          if o > 3:\n              output(case_number, "O won")\n              return\n  \n      x = 0\n      o = 0\n      for rc in range(0, 4):\n          if board[rc][rc] == 'X':\n              x += 1\n          elif board[rc][rc] == 'O':\n              o += 1\n          elif board[rc][rc] == 'T':\n              x += 1\n              o += 1\n  \n      if x > 3:\n          output(case_number, "X won")\n          return\n      if o > 3:\n          output(case_number, "O won")\n          return\n  \n      x = 0\n      o = 0\n      for rc in range(0, 4):\n          if board[rc][3 - rc] == 'X':\n              x += 1\n          elif board[rc][3 - rc] == 'O':\n              o += 1\n          elif board[rc][3 - rc] == 'T':\n              x += 1\n              o += 1\n  \n      if x > 3:\n          output(case_number, "X won")\n          return\n      if o > 3:\n          output(case_number, "O won")\n          return\n  \n      if has_game_completed:\n          output(case_number, "Draw")\n      else:\n          output(case_number, "Game has not completed")\n  \n  def main():\n      r = sys.stdin\n      if len(sys.argv) > 1:\n          r = open(sys.argv[1], 'r')\n  \n      total_cases = r.readline()\n      for case_number in range(1, int(total_cases) + 1):\n          board = []\n          for row in range(0, 4):\n              board.append(list(r.readline().strip()))\n  \n          r.readline()\n          solve_case(board, case_number)\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 8
 \n  gdic = {}\n  sample_googlerese = "yqeeejpmysljylckdkxveddknmcrejsicpdrysirbcpcypcrtcsradkhwyfrepkymveddknkmkrkcddekrkdeoyakwaejtysrreujdrlkgcjv"\n  sample_plain_text = "azooourlanguageisimpossibletounderstandtherearetwentysixfactorialpossibilitiessoitisokayifyouwanttojustgiveup"\n  for gletter, pletter in zip(sample_googlerese, sample_plain_text):\n  	if gletter in gdic:\n  		if not gdic[gletter] == pletter:\n  			print "ERROR!! Can't analyze the sample text."\n  			sys.exit()\n  	else:\n  		gdic[gletter] = pletter\n  \n  if len(gdic) == 25:\n  	candidate_gletter = set(string.ascii_lowercase) - set(sample_googlerese)\n  	candidate_pletter = set(string.ascii_lowercase) - set(sample_plain_text)\n  	if len(candidate_gletter) == 1 and len(candidate_pletter) == 1:\n  		gdic[candidate_gletter.pop()] = candidate_pletter.pop()\n  \n  gdic[' '] = ' '\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n  	r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n  	googlerese_text = r.readline().rstrip()\n  	plain_text = ""	\n  	for gletter in googlerese_text:\n  		plain_text = plain_text + gdic[gletter]\n  \n  	print "Case #%d: %s" % (case_number, plain_text)\n <CODESPLIT> 8
 \n  def solve_case(naomi_blocks, ken_blocks, case_number):\n      naomi_blocks_for_deceitful = naomi_blocks[:]\n      ken_blocks_for_deceitful = ken_blocks[:]\n      deceitful_war_point = 0\n      while len(naomi_blocks_for_deceitful) > 0:\n          naomi_call = naomi_blocks_for_deceitful.pop(0)\n          min_ken_call = ken_blocks_for_deceitful[0]\n          if naomi_call < min_ken_call:\n              naomi_call = ken_blocks_for_deceitful[-1] - 0.000001\n          else:\n              naomi_call = ken_blocks_for_deceitful[-1] + 0.000001\n  \n          ken_candidate = filter(lambda x: x > naomi_call, ken_blocks_for_deceitful)\n          if len(ken_candidate) > 0:\n              ken_call = ken_blocks_for_deceitful.pop(ken_blocks_for_deceitful.index(ken_candidate.pop(0)))\n          else:\n              ken_call = ken_blocks_for_deceitful.pop(0)\n  \n          if naomi_call > ken_call:\n              deceitful_war_point += 1\n  \n      war_point = 0\n      while len(naomi_blocks) > 0:\n          naomi_call = naomi_blocks.pop(0)\n          ken_candidate = filter(lambda x: x > naomi_call, ken_blocks)\n          if len(ken_candidate) > 0:\n              ken_call = ken_blocks.pop(ken_blocks.index(ken_candidate.pop(0)))\n          else:\n              ken_call = ken_blocks.pop(0)\n  \n          if naomi_call > ken_call:\n              war_point += 1\n  \n      print "Case #%d: %d %d" % (case_number, deceitful_war_point, war_point)\n  \n  r_file = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r_file = open(sys.argv[1], 'r')\n  \n  total_cases = r_file.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      r_file.readline()\n      n_values = map(float, r_file.readline().split(' '))\n      k_values = map(float, r_file.readline().split(' '))\n      solve_case(sorted(n_values), sorted(k_values), case_number)\n  \n <CODESPLIT> 8
 \n  \n  def compute(C, F, X):\n      k = int(math.floor(X / C - 2.0 / F))\n      if k <= 0:\n          return X / 2\n      total = 0.0\n      for i in xrange(k):\n          total += 1.0 / (2.0 + i * F)\n      return C * total + X / (2.0 + k * F)\n  \n  \n  def parse():\n      C, F, X = map(float, sys.stdin.readline().strip().split())\n      return C, F, X\n  \n  \n  if __name__ == "__main__":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          data = parse()\n          result = compute(*data)\n          print "Case #%d: %0.7f" % (i + 1, result)\n <CODESPLIT> 9
 \n  \n  fairsquares = []\n  \n  \n  def read_fairsquares():\n      global fairsquares\n      f = open('fairsquares.txt')\n      for x in f:\n          fairsquares.append(int(x.strip()))\n  \n  \n  def count_less_than(A):\n      left = 0\n      right = len(fairsquares)\n      while left < right:\n          middle = (left + right) // 2\n          if fairsquares[middle] < A:\n              left = middle + 1\n          else:\n              right = middle\n      return left\n  \n  \n  def compute(A, B):\n      count_b = count_less_than(B + 1)\n      count_a = count_less_than(A)\n      return count_b - count_a\n  \n  \n  def parse():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  \n  if __name__ == "__main__":\n      read_fairsquares()\n      T = int(sys.stdin.readline().strip())\n      count = 1\n      part = 0\n      if len(sys.argv) == 3:\n          part = int(sys.argv[1])\n          count = int(sys.argv[2])\n      for i in xrange(T):\n          data = parse()\n          if i * count >= part * T and i * count < (part + 1) * T:\n              result = compute(*data)\n              print "Case #%d: %s" % (i + 1, result)\n <CODESPLIT> 9
 \n  \n  if __name__ == "__main__":\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          values = map(int, sys.stdin.readline().strip().split(' '))\n          _N, S, p = values[0:3]\n          t = values[3:]\n          min_normal = p + 2 * max(0, p - 1)\n          min_surprising = p + 2 * max(0, p - 2)\n          cnt_normal = len(filter(lambda x : x >= min_normal, t))\n          cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal\n          print "Case #%d: %s" % (i + 1, cnt_normal + min(cnt_surprising, S))\n <CODESPLIT> 9
 \n  \n  def compute(N, M, a):\n      rows = [0] * N\n      cols = [0] * M\n      for r in xrange(N):\n          rows[r] = 0\n          for c in xrange(M):\n              if a[r][c] > rows[r]:\n                  rows[r] = a[r][c]\n      for c in xrange(M):\n          cols[c] = 0\n          for r in xrange(N):\n              if a[r][c] > cols[c]:\n                  cols[c] = a[r][c]\n      for r in xrange(N):\n          for c in xrange(M):\n              if a[r][c] < rows[r] and a[r][c] < cols[c]:\n                  return "NO"\n      return "YES"\n  \n  \n  def parse():\n      N, M = map(int, sys.stdin.readline().strip().split())\n      a = []\n      for i in xrange(N):\n          a.append(map(int, sys.stdin.readline().strip().split()))\n      return N, M, a,\n  \n  \n  if __name__ == "__main__":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      count = 1\n      part = 0\n      if len(sys.argv) == 3:\n          part = int(sys.argv[1])\n          count = int(sys.argv[2])\n      for i in xrange(T):\n          data = parse()\n          if i * count >= part * T and i * count < (part + 1) * T:\n              result = compute(*data)\n              print "Case #%d: %s" % (i + 1, result)\n <CODESPLIT> 9
 \n  MAX_LIMIT = 2000000\n  \n  \n  def get_min_mapped(n):\n      n_min = n\n      x = str(n)\n      for i in xrange(1, len(x)):\n          x = x[1:] + x[0]\n          if x[0] == '0':\n              continue\n          n_min = min(n_min, int(x))\n      return n_min\n  \n  \n  if __name__ == "__main__":\n      T = int(sys.stdin.readline().strip())\n      min_mapped = [0] * (MAX_LIMIT + 1)\n      for i in xrange(1, MAX_LIMIT + 1):\n          min_mapped[i] = get_min_mapped(i)\n  \n      for r in xrange(T):\n          values = map(int, sys.stdin.readline().strip().split(' '))\n          A, B = values\n          cnt_mapped = [0] * (B + 1)\n          for i in xrange(A, B + 1):\n              cnt_mapped[min_mapped[i]] += 1\n          total = 0\n          for i in xrange(B + 1):\n              if cnt_mapped[i] > 1:\n                  total += (cnt_mapped[i] * (cnt_mapped[i] - 1)) / 2\n          print "Case #%d: %s" % (r + 1, total)\n <CODESPLIT> 9
 \n  \n  def won(board, mapping):\n      val = int(board.translate(string.maketrans(mapping, "1100")), 2)\n      for v in [0x000f, 0x00f0, 0x0f00, 0xf000,\n                0x1111, 0x2222, 0x4444, 0x8888,\n                0x1248, 0x8421]:\n          if (val & v) == v:\n              return True\n      return False\n  \n  \n  def finished(board):\n      return '.' not in board\n  \n  \n  def compute(board):\n      if won(board, 'XTO.'):\n          return "X won"\n      if won(board, 'OTX.'):\n          return "O won"\n      if finished(board):\n          return "Draw"\n      return "Game has not completed"\n  \n  \n  def parse():\n      board = []\n      for i in xrange(4):\n          board.append(sys.stdin.readline().strip())\n      sys.stdin.readline()\n      return (''.join(board),)\n  \n  \n  if __name__ == "__main__":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      count = 1\n      part = 0\n      if len(sys.argv) == 3:\n          part = int(sys.argv[1])\n          count = int(sys.argv[2])\n      for i in xrange(T):\n          data = parse()\n          if i * count >= part * T and i * count < (part + 1) * T:\n              result = compute(*data)\n              print "Case #%d: %s" % (i + 1, result)\n <CODESPLIT> 9
 \n  mapping = {}\n  \n  def init_mapping():\n      encoded = ["ejp mysljylc kd kxveddknmc re jsicpdrysi",\n              "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n              "de kr kd eoya kw aej tysr re ujdr lkgc jv",\n              "y qee z"\n              ]\n      decoded = ["our language is impossible to understand",\n              "there are twenty six factorial possibilities",\n              "so it is okay if you want to just give up",\n              "a zoo q"\n              ]\n      for i in xrange(len(encoded)):\n          for j in xrange(len(encoded[i])):\n              if encoded[i][j] in mapping and mapping[encoded[i][j]] != decoded[i][j]:\n                  raise Exception("Multiple mapping for %s" % encoded[i][j])\n              mapping[encoded[i][j]] = decoded[i][j]\n  \n  \n  def decode(sentence):\n      return ''.join(map(lambda x : mapping.get(x, x), sentence))\n  \n  \n  if __name__ == "__main__":\n      init_mapping()\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          result = decode(sys.stdin.readline().strip())\n          print "Case #%d: %s" % (i + 1, result)\n <CODESPLIT> 9
 \n  \n  def dw(a, b):\n      a = sorted(a)\n      b = sorted(b)\n      cnt = 0\n      k = 0\n      for i in a:\n          if b[k] < i:\n              cnt += 1\n              k += 1\n      return cnt\n  \n  \n  def w(a, b):\n      a = sorted(a, reverse=True)\n      b = sorted(b, reverse=True)\n      cnt = 0\n      k = 0\n      for i in a:\n          if i > b[k]:\n              cnt += 1\n          else:\n              k += 1\n      return cnt\n  \n  \n  def compute(a, b):\n      x = dw(a, b)\n      y = w(a, b)\n      return "%s %s" % (x, y)\n  \n  \n  def parse():\n      N = int(sys.stdin.readline().strip())\n      a = map(float, sys.stdin.readline().strip().split())\n      b = map(float, sys.stdin.readline().strip().split())\n      return a, b\n  \n  \n  if __name__ == "__main__":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          data = parse()\n          result = compute(*data)\n          print "Case #%d: %s" % (i + 1, result)\n <CODESPLIT> 9
 \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_float():\n      return float( read_line() )\n  \n  def read_floats():\n      return [ float( x ) for x in read_line().split() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      C, F, X = read_floats()\n      rate = 2\n      cookies = 0\n      s = 0\n      while True:\n          t1 = X/rate\n          t2 = C/rate + X/( rate + F )\n          if t1 < t2:\n              s += t1\n              break\n          s += C/rate\n          rate += F\n      print 'Case #%i: %.7f' % ( t + 1, s )\n <CODESPLIT> 10
 \n  def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      A, B = read_integers()\n      A_root = int( ceil( sqrt( A ) ) )\n      B_root = int( floor( sqrt( B ) ) )\n      count = 0\n      for root in range( A_root, B_root + 1 ):\n          word = str( root )\n          if word == word[ : : -1 ]:\n              word = str( root*root )\n              if word == word[ : : -1 ]:\n                  count += 1\n      print 'Case #%i:' % ( t + 1 ), count\n <CODESPLIT> 10
def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 ),\n      line = iter( read_integers() )\n      N = line.next()\n      S = line.next()\n      p = line.next()\n      t = sorted( line )\n      count = 0\n      while t and ( t[ -1 ] + 2 )/3 >= p:\n          t.pop()\n          count += 1\n      if p > 1:\n          while S and t and ( t[ -1 ] + 4 )/3 >= p:\n              t.pop()\n              S -= 1\n              count += 1\n      print count\n <CODESPLIT> 10
 \n  def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      N, M = read_integers()\n      lawn = array( [ read_integers() for n in range( N ) ] )\n      valid = zeros( lawn.shape, bool )\n      for row in range( N ):\n          valid[ row ][ lawn[ row ] == amax( lawn[ row ] ) ] = True\n      for column in range( M ):\n          valid[ :, column ][ lawn[ :, column ] == amax( lawn[ :, column ] ) ] = 1\n      print 'Case #%i:' % ( t + 1 ), 'YES' if all( valid ) else 'NO'\n <CODESPLIT> 10
def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 ),\n      A, B = read_integers()\n      length = len( str( A ) )\n      pairs = set()\n      for n in range( A, B ):\n          digits = str( n )\n          for start in range( 1, length ):\n              m = int( digits[ start : ] + digits[ : start ] )\n              if n < m <= B:\n                  pairs.add( ( n, m ) )\n      print len( pairs )\n <CODESPLIT> 10
def read_line():\n      return raw_input().strip()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  T = read_integer()\n  for t in range( T ):\n      board = [ read_line() for index in range( 4 ) ]\n      read_line()\n      print 'Case #%i:' % ( t + 1 ),\n      blank_count = 0\n      for row, column, row_increment, column_increment in ( ( 0, 0, 0, 1 ),\n                                                            ( 1, 0, 0, 1 ),\n                                                            ( 2, 0, 0, 1 ),\n                                                            ( 3, 0, 0, 1 ),\n                                                            ( 0, 0, 1, 0 ),\n                                                            ( 0, 1, 1, 0 ),\n                                                            ( 0, 2, 1, 0 ),\n                                                            ( 0, 3, 1, 0 ),\n                                                            ( 0, 0, 1, 1 ),\n                                                            ( 0, 3, 1, -1 ) ):\n          O_count = 0\n          X_count = 0\n          for index in range( 4 ):\n              value = board[ row ][ column ]\n              if value == 'O':\n                  O_count += 1\n              elif value == 'X':\n                  X_count += 1\n              elif value == 'T':\n                  O_count += 1\n                  X_count += 1\n              else:\n                  blank_count += 1\n              row += row_increment\n              column += column_increment\n          result = 'O' if O_count == 4 else 'X' if X_count == 4 else None\n          if result:\n              break\n      else:\n          print 'Game has not completed' if blank_count else 'Draw'\n          continue\n      print result, 'won'\n <CODESPLIT> 10
def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  \n  ciphers = 'y qee', 'ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv'\n  plaintexts = 'a zoo', 'our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up'\n  \n  mapping = {}\n  for cipher, plaintext in zip( ciphers, plaintexts ):\n      for key, value in zip( cipher, plaintext ):\n          mapping[ key.lower() ] = value.lower()\n  mapping[ 'z' ] = 'q'\n  \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 ), ''.join( mapping[ key.lower() ].upper() if key.isupper() else mapping[ key ] for key in read_line() )\n <CODESPLIT> 10
 \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_floats():\n      return [ float( x ) for x in read_line().split() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      N = read_integer()\n      naomi = sorted( read_floats() )\n      ken = sorted( read_floats() )\n      k = len( ken ) - 1\n      h = 0\n      for n in reversed( naomi ):\n          if ken[ k ] > n:\n              k -= 1\n          else:\n              h += 1\n      d = 0\n      n = len( naomi ) - 1\n      for k in reversed( ken ):\n          if naomi[ n ] > k:\n              d += 1\n              n -= 1\n      print 'Case #%i:' % ( t + 1 ), d, h\n <CODESPLIT> 10
T = int(raw_input());\n  for q in range(T):\n      [C,F,X] = map(float, raw_input().split());\n  \n  \n      Time = 0.;\n      Rate = 2.;\n      Fin = False;\n      while (not Fin):\n          t0 = X/Rate;\n          t1 = C/Rate + X/(Rate+F);\n  \n          if t0 <= t1:\n              Time += t0;\n              Fin = True;\n          else:\n              Time += C/Rate;\n              Rate += F;\n  \n      print "Case #%d:" % (q+1),;\n      print "%.7f" % Time;\n      \n          \n <CODESPLIT> 11
def IsPal(n):\n      S = str(n);\n      return S == S[::-1];\n  \n  \n  def Gen():\n      LIM = 10**14;\n      N = 10**7;\n      LIST = [];\n      for i in range(1, N):\n          if IsPal(i):\n              if IsPal(i*i):\n                  LIST.append(i);\n      return LIST\n  \n  PP = Gen();\n  \n  T = int(raw_input());\n  for q in range(1,T+1):\n      [A,B] = map(int, raw_input().split());    \n      ANS = 0;\n      for i in range(len(PP)):\n          if B >= PP[i]**2 >= A:\n              ANS += 1;\n      \n      print "Case #%d: %d" %(q, ANS);\n <CODESPLIT> 11
T = int(raw_input());\n  for i in range(T):\n     Data = map(int, raw_input().split());\n     N = Data.pop(0);\n     S = Data.pop(0);\n     p = Data.pop(0);\n     \n     Good = 0;\n     for score in Data:\n        if score >= 3*p-2:\n           Good += 1;\n        else:\n           if (S > 0) and (score >= 3*p-4) and (score >= p):\n              S -= 1;\n              Good += 1;\n  \n     print "Case #%d:" % (i+1),;\n     print Good;\n     \n  \n <CODESPLIT> 11
T = int(raw_input());\n  for q in range(T):\n      [H,W] = map(int, raw_input().split());\n      Lawn = [];\n      MRow = [0]*H;\n      MCol = [0]*W;\n      for i in range(H):\n          Lawn.append( map(int, raw_input().split()) );\n          MRow[i] = max(Lawn[-1]);\n          for j in range(W):\n              MCol[j] = max(MCol[j], Lawn[-1][j]);\n  \n      Valid = True;\n      for i in range(H):\n          for j in range(W):\n              if Lawn[i][j] not in [MRow[i], MCol[j]]:\n                  Valid = False;\n                  break;\n      \n  \n      if Valid:\n          print "Case #%d: YES" %(q+1);\n      else:\n          print "Case #%d: NO" %(q+1);        \n <CODESPLIT> 11
T = int(raw_input());\n  for case in range(T):\n     [A,B] = map(int, raw_input().split());\n  \n     Big = 10**(len(str(A))-1);\n     Ans = 0;\n  \n     for i in range(A,B+1):\n        j = (i/10)+Big*(i%10);\n        while (j != i):\n           if i < j <= B:\n              Ans += 1;\n           j = (j/10)+Big*(j%10);\n  \n     print "Case #%d:" % (case+1),;\n     print Ans;\n     \n  \n <CODESPLIT> 11
def Winner( M ):\n      for i in range(4):          # Check rows\n          nX = 0;     nO = 0;     \n          for j in range(4):\n              if M[i][j] == 'X':\n                  nX += 1;\n              if M[i][j] == 'O':\n                  nO += 1;\n              if M[i][j] == 'T':\n                  nX += 1;\n                  nO += 1;\n          if nX == 4:\n              return 'X';\n          if nO == 4:\n              return 'O';\n          \n      for j in range(4):          # Check columns\n          nX = 0;     nO = 0;     \n          for i in range(4):\n              if M[i][j] == 'X':\n                  nX += 1;\n              if M[i][j] == 'O':\n                  nO += 1;\n              if M[i][j] == 'T':\n                  nX += 1;\n                  nO += 1;\n          if nX == 4:\n              return 'X';\n          if nO == 4:\n              return 'O';\n  \n      if (M[0][0] in ['X','T']) and (M[1][1] in ['X','T']) and (M[2][2] in ['X','T']) and (M[3][3] in ['X','T']):\n          return 'X';\n      if (M[0][3] in ['X','T']) and (M[1][2] in ['X','T']) and (M[2][1] in ['X','T']) and (M[3][0] in ['X','T']):\n          return 'X';\n      if (M[0][0] in ['O','T']) and (M[1][1] in ['O','T']) and (M[2][2] in ['O','T']) and (M[3][3] in ['O','T']):\n          return 'O';           \n      if (M[0][3] in ['O','T']) and (M[1][2] in ['O','T']) and (M[2][1] in ['O','T']) and (M[3][0] in ['O','T']):\n          return 'O';\n  \n      return 'D';            \n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      if q != 0:\n          raw_input();\n      Map = [];\n      Dot = False;\n      for i in range(4):\n          Map.append( raw_input() );\n          if '.' in Map[-1]:\n              Dot = True;\n  \n      ANS = Winner(Map);\n      if ANS == 'X':\n          print "Case #%d: X won" %(q+1)\n      if ANS == 'O':\n          print "Case #%d: O won" %(q+1)\n      if ANS == 'D':\n          if Dot:\n              print "Case #%d: Game has not completed" %(q+1)\n          else:\n              print "Case #%d: Draw " % (q+1)\n  \n <CODESPLIT> 11
RAW = ['ejp mysljylc kd kxveddknmc re jsicpdrysi',\n         'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',\n         'de kr kd eoya kw aej tysr re ujdr lkgc jv']\n  ENG = ['our language is impossible to understand',\n         'there are twenty six factorial possibilities',\n         'so it is okay if you want to just give up'];\n  \n  New = [32]*128;\n  Left = [];\n  for c in range(97, 123):\n     Left += [chr(c)];\n  \n  for i in range(3):\n     for j in range(len(RAW[i])):\n         x = ord(RAW[i][j]);\n         if (New[x] == 32) and (x != 32):\n            Left.remove(RAW[i][j]);\n         New[x] = ord(ENG[i][j]);\n  \n  New[ord('q')] = ord('z');\n  New[ord('z')] = ord('q');\n  \n  \n  T = int(raw_input());\n  for i in range(T):\n     print "Case #%d:" % (i+1),;\n     S_in = raw_input();\n     S_out = '';\n     for c in S_in:\n        S_out += chr(New[ord(c)])\n     print S_out\n     \n  \n <CODESPLIT> 11
def PlayDevious(list1, list2):\n      Ret = 0;\n      i = 0;\n      j = 0;\n      while (i < len(list1)):\n          if list1[i] > list2[j]:\n              j += 1;\n          i += 1;\n      return j;\n  \n  def PlayWar(list1, list2):\n      j = 0;      Score = 0;\n      for entry in list1:\n          winner = False;\n          while (not winner):\n              if j != len(list2):\n                  if list2[j] > entry:\n                      winner = True;\n                  j += 1;\n              else:\n                  Score += 1;\n                  winner = True;\n  \n      return Score;\n  \n  def PlayWar2(list1, list2):\n      L1 = [];        L2 = [];        Score = 0;\n  \n      for i in range(len(list1)):\n          L1.append(list1[i]);        L2.append(list2[i]);\n      L1.reverse();\n  \n      Score = 0;\n      for play in L1:\n          index =  0;\n          for i in range(1, len(L2)):\n              if L2[i] > play > L2[i-1]:\n                  index = i;\n  \n          if play > L2[index]:\n              Score += 1;\n          L2.pop(index);\n      return Score           \n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      N = int(raw_input());\n      Nlist = map(float, raw_input().split());\n      Klist = map(float, raw_input().split());\n  \n      Nlist.sort();\n      Klist.sort();\n      \n      print "Case #%d:" % (q+1),\n      print PlayDevious(Nlist, Klist), PlayWar(Nlist, Klist)#, PlayWar2(Nlist, Klist);\n <CODESPLIT> 11
 \n  \n  N = int(sys.stdin.readline())\n  \n  for T in range(1, N+1):\n      C, F, X = map(float, sys.stdin.readline().split(' '))\n  \n      N = 0\n      for i in range(int(X)):\n          diff = (2 + F * i) * C - F * X\n          if diff >= 0: break\n          N = i\n  \n      total = 0\n      for i in range(N):\n          val = C / (2 + i * F)\n          total += val\n      val = X / (2.0 + N * F)\n      total += val\n          \n      ans = '%s' % (total)\n      print 'Case #%(T)s: %(ans)s' % locals()\n <CODESPLIT> 12
 \n  \n  def is_palindrome(num):\n      s1 = str(num)\n      s2 = s1[::-1]\n      return s1 == s2\n  \n  fair_numbers = []\n  for i in range(pow(10, 7)+1):\n      if is_palindrome(i):\n          num = i*i\n          if is_palindrome(num):\n              fair_numbers.append(num)\n  \n  N = int(sys.stdin.readline())\n  for T in range(1, N+1):\n      min_val, max_val = map(int, sys.stdin.readline().strip().split())\n  \n      ans = 0\n      for num in fair_numbers:\n          if num < min_val:\n              continue\n          if num > max_val:\n              break\n          ans += 1\n      print 'Case #%(T)s: %(ans)s' % locals()\n <CODESPLIT> 12
 \n  \n  for i, line in enumerate(sys.stdin):\n      if i == 0:\n          continue\n  \n      params = [int(n) for n in line.split(' ')]\n      (N, S, p) = params[:3]\n      scores = params[3:]\n  \n      (clear, possible) = (0, 0)\n      normal_min = max(p * 3 - 2, 0)\n      suprising_min = max(p * 3 - 4, 0)\n      for score in scores:\n          if p > score:\n              continue\n          elif score >= normal_min:\n              clear += 1\n          elif score >= suprising_min:\n              possible += 1\n  \n      ans = clear + min(possible, S)\n      print 'Case #%(i)s: %(ans)s' % locals()\n <CODESPLIT> 12
 \n  \n  def next_pos(grass, goal, elems):\n      while elems:\n          val = elems[0]\n          for n in range(len(goal)):\n              for m in range(len(goal[0])):\n                  if goal[n][m] == val and goal[n][m] < grass[n][m]:\n                      return (n, m)\n          elems.remove(val)\n      return None\n  \n  def check(grass, goal):\n      possible = True\n      completed = True\n      for n in range(len(grass)):\n          for m in range(len(grass[0])):\n              if grass[n][m] > goal[n][m]:\n                  completed = False\n              elif grass[n][m] < goal[n][m]:\n                  possible = False\n  \n      return possible, completed\n  \n  def cut(grass, goal, pos, h, elems):\n      \n      def _cut(grass, goal, pos, h, is_horizontal):\n          if is_horizontal:\n              for m in range(len(grass[0])):\n                  grass[pos[0]][m] = h\n          else:\n              for n in range(len(grass)):\n                  grass[n][pos[1]] = h\n          possible, completed = check(grass, goal)\n          if completed and possible:\n              return 'YES'\n          elif not completed and possible:\n              pos = next_pos(grass, goal, elems)\n              if not pos:\n                  return 'NO'\n              h = goal[pos[0]][pos[1]]\n              return cut(grass, goal, pos, h, elems)\n          elif not possible:\n              return 'NO'\n  \n      ans1 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=True)\n      if ans1 == 'YES':\n          return 'YES'\n      ans2 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=False)\n      if ans2 == 'YES':\n          return 'YES'\n      return 'NO'\n  \n  \n  def calc(grass, goal):\n      def _elems(goal):\n          elems = set()\n          for n in range(len(goal)):\n              for m in range(len(goal[0])):\n                  elems.add(goal[n][m])\n          return sorted(list(elems), reverse=True)\n  \n      elems = _elems(goal)\n      pos = next_pos(grass, goal, elems)\n      h = goal[pos[0]][pos[1]]\n      return cut(grass, goal, pos, h, elems)\n  \n  \n  N = int(sys.stdin.readline())\n  for T in range(1, N+1):\n      N, M = map(int, sys.stdin.readline().strip().split())\n  \n      goal = []\n      for i in range(N):\n          goal.append(map(int, sys.stdin.readline().strip().split()))\n  \n      grass = []\n      for i in range(N):\n          line = [100] * M\n          grass.append(line)\n  \n      ans = calc(grass, goal)\n      print 'Case #%(T)s: %(ans)s' % locals()\n <CODESPLIT> 12
 \n  \n  def recycled_numbers(num):\n      result = []\n      num_text = str(num)\n      for i in range(1, len(num_text)):\n          rotated = int(num_text[i:] + num_text[:i])\n          if num != rotated:\n              result.append(rotated)\n      return result\n  \n  for T, line in enumerate(sys.stdin):\n      if T == 0:\n          continue\n  \n      results = []\n      params = [int(n) for n in line.split(' ')]\n      (A, B) = params\n      for i in range(A, B):\n          candidates = recycled_numbers(i)\n          for c in candidates:\n              pair = (i, c)\n              if pair not in results and A <= c and c <= B and i < c:\n                  results.append(pair)\n      ans = len(results)\n      print 'Case #%(T)s: %(ans)s' % locals()\n <CODESPLIT> 12
 \n  \n  N = int(sys.stdin.readline())\n  \n  for T in range(1, N+1):\n      lines = []\n      completed = True\n      for i in range(4):\n          line = sys.stdin.readline().strip()\n          if '.' in line:\n              completed = False\n          lines.append(line)\n      sys.stdin.readline() # empty line\n  \n      ans = 'Draw' if completed else 'Game has not completed'\n      for row in range(4):\n          X, O = 0, 0\n          for col in range(4):\n              spot = lines[row][col]\n              if spot == 'O':\n                  O += 1\n              elif spot == 'X':\n                  X += 1\n              if spot == 'T':\n                  O += 1\n                  X += 1\n          if X == 4:\n              ans = 'X won'\n          elif O == 4:\n              ans = 'O won'\n  \n      for col in range(4):\n          X, O = 0, 0\n          for row in range(4):\n              spot = lines[row][col]\n              if spot == 'O':\n                  O += 1\n              elif spot == 'X':\n                  X += 1\n              if spot == 'T':\n                  O += 1\n                  X += 1\n          if X == 4:\n              ans = 'X won'\n          elif O == 4:\n              ans = 'O won'\n  \n      X1, X2, O1, O2 = 0, 0, 0, 0\n      for i in range(4):\n          spot1 = lines[i][i]\n          spot2 = lines[4-i-1][i]\n  \n          if spot1 == 'O':\n              O1 += 1\n          elif spot1 == 'X':\n              X1 += 1\n          elif spot1 == 'T':\n              O1 += 1\n              X1 += 1\n  \n          if spot2 == 'O':\n              O2 += 1\n          elif spot2 == 'X':\n              X2 += 1\n          elif spot2 == 'T':\n              O2 += 1\n              X2 += 1\n  \n      if X1 == 4 or X2 == 4:\n          ans = 'X won'\n      elif O1 == 4 or O2 == 4:\n          ans = 'O won'\n      \n      \n      print 'Case #%(T)s: %(ans)s' % locals()\n <CODESPLIT> 12
 \n  \n  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  gog = 'ejp mysljylc kd kxveddknmc re jsicpdrysi' + \\n        'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' + \\n        'de kr kd eoya kw aej tysr re ujdr lkgc jv' + \\n        'y qee'\n  \n  eng = 'our language is impossible to understand' + \\n        'there are twenty six factorial possibilities' + \\n        'so it is okay if you want to just give up' + \\n        'a zoo'\n  \n  rule = {}\n  for i, c in enumerate(gog):\n     rule[c] = eng[i]\n  \n  gog_alphabet = rule.keys()\n  eng_alphabet = rule.values()\n  missing_key = None\n  missing_val = None\n  for c in alphabet:\n      if not c in gog_alphabet:\n          missing_key = c\n      if not c in eng_alphabet:\n          missing_val = c\n  rule[missing_key] = missing_val\n  \n  for i, line in enumerate(sys.stdin):\n      if i == 0:\n          continue\n  \n      orig = line.strip()\n      ans = ''.join([rule[c] for c in orig])\n      print 'Case #%(i)s: %(ans)s' % locals()\n  \n <CODESPLIT> 12
 \n  \n  T = int(sys.stdin.readline())\n  \n  for T in range(1, T+1):\n      N = int(sys.stdin.readline())\n      naomi_blocks = map(float, sys.stdin.readline().split(' '))\n      ken_blocks = map(float, sys.stdin.readline().split(' '))\n  \n      naomi_blocks_w = sorted(copy.deepcopy(naomi_blocks))\n      ken_blocks_w = sorted(copy.deepcopy(ken_blocks))\n      naomi_score_w, ken_score_w = (0, 0)\n      for i in range(N):\n          naomi = naomi_blocks_w.pop()\n  \n          ken = None\n          for k in ken_blocks_w:\n              if k > naomi:\n                  ken = k\n                  break\n          if not ken:\n              ken = ken_blocks_w[0]\n          ken_blocks_w.remove(ken)\n  \n          if naomi > ken:\n              naomi_score_w += 1\n          else:\n              ken_score_w += 1\n      \n      naomi_blocks_dw = sorted(copy.deepcopy(naomi_blocks), reverse=True)\n      ken_blocks_dw = sorted(copy.deepcopy(ken_blocks))\n      naomi_score_dw, ken_score_dw = (0, 0)\n      for i in range(N):\n          naomi = naomi_blocks_dw.pop()\n          ken = min(ken_blocks_dw)\n          if ken > naomi:\n              ken = max(ken_blocks_dw)\n          ken_blocks_dw.remove(ken)            \n          if naomi > ken:\n              naomi_score_dw += 1\n          else:\n              ken_score_dw += 1\n      \n      ans = '%s %s' % (naomi_score_dw, naomi_score_w)\n      print 'Case #%(T)s: %(ans)s' % locals()\n <CODESPLIT> 12
 sys.setrecursionlimit(15000)\n  \n  def solve(C, F, X, rate, time):\n    if (time + (X / rate)) < ((C / rate) + ((X / (rate+F)) + time)):\n      return time + (X / rate)\n    else:\n      return solve(C, F, X, rate+F, time + (C / rate))\n  \n  T = int(raw_input())\n  for t in range(T):\n    C, F, X = map(float, raw_input().split())\n    print 'Case #%i: %.7f' % (t+1, solve(C, F, X, 2, 0))\n <CODESPLIT> 13
 \n  def isPalindrome(s):\n    length = len(s)\n    for i in xrange(length / 2):\n      if s[i] != s[length - 1 - i]: \n        return False\n    return True\n  \n  n = int(raw_input())\n  for i in range(n):\n    a, b = map(int, raw_input().strip().split(' '))\n    count = 0\n    for j in range(a, b+1):\n      if isPalindrome(str(j)):\n        s = math.sqrt(j)\n        if s == int(s) and isPalindrome(str(int(s))):\n          count += 1\n    print 'Case #%i: %i' % (i+1, count)\n <CODESPLIT> 13
 \n  T = int(sys.stdin.readline())\n  for i in range(T):\n      line = sys.stdin.readline().strip()\n      values = map(int, line.split(' '))\n      N = values[0]\n      S = values[1]\n      p = values[2]\n      totals = values[3:]\n      ans = 0\n      for total in totals:\n          base = total / 3\n          remainder = total - (base * 3)\n          scores = [base, base, base]\n          j = 0\n          while remainder > 0:\n              scores[j] += 1\n              remainder -= 1\n              j = (j + 1) % 3\n          if max(scores) >= p:\n              ans += 1\n          else:\n              if S > 0:\n                  remainder = total - (base * 3)\n                  if remainder == 0 and base > 0:\n                      if base + 2 >= p:\n                          ans += 1\n                          S -= 1\n                  elif base + min(remainder, 2) >= p:\n                      ans += 1\n                      S -= 1\n      print 'Case #%s: %s' % (i+1, ans)\n <CODESPLIT> 13
def up_down(board, height, y, x):\n    above = y - 1\n    while above >= 0:\n      if board[above][x] > board[y][x]: \n        return False\n      above -= 1\n    below = y + 1\n    while below < height:\n      if board[below][x] > board[y][x]: \n        return False\n      below += 1\n    return True\n    \n  def left_right(board, width, y, x):\n    before = x - 1\n    while before >= 0:\n      if board[y][before] > board[y][x]: \n        return False\n      before -= 1\n    after = y + 1\n    while after < width:\n      if board[y][after] > board[y][x]: \n        return False\n      after += 1\n    return True\n    \n  def check(board, height, width):\n    if height == 1 or width == 1:\n      return 'YES'\n    for i in range(height):\n      for j in range(width):\n        if (not up_down(board, height, i, j)) and (not left_right(board, width, i, j)):\n          return 'NO'\n    return 'YES'\n  \n  n = int(raw_input().strip())\n  for i in range(n):\n    height, width = map(int,  raw_input().strip().split(' '))\n    board = []\n    for _ in range(height):\n      row = map(int, raw_input().strip().split(' '))\n      board.append(row)\n    print 'Case #%i: %s' % (i+1, check(board, height, width))\n <CODESPLIT> 13
 \n  def isRecycledPair(n, m):\n      m = str(m)\n      for i in range(len(m)):\n          m = m[-1] + m[:-1]\n          if n == int(m):\n              return True\n      return False\n  \n  T = int(sys.stdin.readline())\n  for i in range(T):\n      [A, B] = map(int, sys.stdin.readline().strip().split(' '))\n      count = 0\n      for n in range(A, B+1):\n          for m in range(n, B+1):\n              if n != m and isRecycledPair(n, m):\n                  count += 1\n      print 'Case #%s: %s' % (i + 1, count)\n <CODESPLIT> 13
def check(board):\n    for i in range(4):\n      row = board[i]\n      if set(row) in [set(['X', 'T']), set(['X'])]:\n        return 'X won'\n      if set(row) in [set(['O', 'T']), set(['O'])]:\n        return 'O won'\n    \n    for i in range(4):\n      column = []\n      for j in range(4):\n        column.append(board[j][i])\n      if set(column) in [set(['X', 'T']), set(['X'])]:\n        return 'X won'\n      if set(column) in [set(['O', 'T']), set(['O'])]:\n        return 'O won'\n    \n    diag1 = [board[0][0], board[1][1], board[2][2], board[3][3]]\n    if set(diag1) in [set(['X', 'T']), set(['X'])]:\n        return 'X won'\n    if set(diag1) in [set(['O', 'T']), set(['O'])]:\n      return 'O won'\n    \n    diag2 = [board[3][0], board[2][1], board[1][2], board[0][3]]\n    if set(diag2) in [set(['X', 'T']), set(['X'])]:\n        return 'X won'\n    if set(diag2) in [set(['O', 'T']), set(['O'])]:\n      return 'O won'\n    \n    for i in range(4):\n      for j in range(4):\n        if board[i][j] == '.':\n          return 'Game has not completed'\n    return 'Draw'\n  \n  n = int(raw_input().strip())\n  for i in range(n):\n    board = []\n    for j in range(4):\n      line = raw_input()\n      board.append([c for c in line])\n    raw_input()\n    print 'Case #%i: %s' % (i+1, check(board))\n <CODESPLIT> 13
 \n  data = [\n      ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'],\n      ['rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'],\n      ['de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up']]\n  \n  trans = {'y': 'a', 'e': 'o', 'q': 'z', 'z': 'q'}\n  for row in data:\n      [googlerese, english] = row\n      for i in range(0, len(googlerese)):\n          if not googlerese[i] in trans:\n              trans[googlerese[i]] = english[i]\n  \n  def translate(googlerese):\n      english = ''\n      for c in googlerese:\n          english += trans[c]\n      return english\n  \n  T = int(sys.stdin.readline())\n  for i in range(T):\n      print 'Case #%s: %s' % (i+1, translate(sys.stdin.readline().strip()))\n <CODESPLIT> 13
 \n  def dwar(N, K):\n    N = sorted(N)\n    K = sorted(K)\n    \n    naomi = 0\n    \n    while len(N) > 0:\n      if N[-1] > K[-1]:\n        k = K.pop()\n        for i, n in enumerate(N):\n          if N[i] > k:\n            choosen = i\n            break\n        del(N[choosen])\n        naomi += 1\n      else:\n        N = N[1:]\n        k = K.pop()\n    return naomi\n  \n  def war(N, K):\n    N = sorted(N)\n    K = sorted(K)\n    \n    naomi = 0\n    while len(N) > 0:\n      n = N.pop()\n      chosen = None\n      for i, k in enumerate(K):\n        if k > n:\n          chosen = i\n          break\n      if not chosen == None:\n        del(K[chosen])\n      else:\n        naomi += 1\n    return naomi\n  \n  T = int(raw_input())\n  for t in range(T):\n    _ = raw_input()\n    N = map(float, raw_input().split())\n    K = map(float, raw_input().split())\n    \n    print 'Case #%i: %i %i' % (t+1, dwar(N, K), war(N, K))\n <CODESPLIT> 13
def time_to_get(target, num_factories, factory_cost, factory_increase):\n      rate = 2.0\n      t = 0\n      for i in range(num_factories):\n          t += factory_cost/rate\n          rate += factory_increase\n      return t + target/rate\n      \n  def solve(C,F,X):\n      min_sol = None\n      num_fact = 0\n      while True:\n          t = time_to_get(X, num_fact, C, F)\n          if min_sol is None or t < min_sol:\n              min_sol = t\n              num_fact += 1\n          else:\n              return min_sol\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          C,F,X = map(float, raw_input().split())\n          print "Case #%d: %.07f" % (i, solve(C,F,X))\n <CODESPLIT> 14
 \n  def isqrt(num):\n      return int(sqrt(num))\n  \n  def is_square(num):\n      return isqrt(num)**2 == num\n  \n  def is_palindrome(num):\n      return str(num) == "".join(reversed(str(num)))\n  \n  def is_fair_and_square(num):\n      return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))\n  \n  def solve(A,B):\n      count = 0\n      for i in range(A,B+1):\n          if is_fair_and_square(i):\n              count += 1\n      return count\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          A,B = [int(x) for x in raw_input().split()]\n          print "Case #%d: %d" % (i, solve(A,B))\n          \n <CODESPLIT> 14
def max_of_triplets(n):\n      a = n//3\n      if (n % 3) == 0:\n          if a == 0 : return (0,0)\n          return (a, a+1)\n      if (n % 3) == 1:\n          return (a+1, a+1)\n      if a == 9: return (10, 10)\n      return (a+1, a+2)\n  \n  def solve(scores, S, p):\n      t = 0\n      for s in scores:\n          a,b = max_of_triplets(s)\n          if a >= p:\n              t += 1\n          elif b >= p and S > 0:\n              t += 1\n              S -= 1\n      return t\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          nums = map(int, raw_input().strip().split())\n          N = nums[0]\n          S = nums[1]\n          p = nums[2]\n          scores = nums[3:]\n          if len(scores) != N:\n              print "WTF", i\n          print "Case #%d: %d" % (i, solve(scores, S, p))\n      \n <CODESPLIT> 14
def solve(grid, M, N):\n      row_max = {}\n      column_max = {}\n      for i in range(M):\n          row_max[i] = max(grid[i])\n      for i in range(N):\n          column_max[i] = max([grid[j][i] for j in range(M)])\n      for i in range(M):\n          for j in range(N):\n              v = grid[i][j]\n              if v < row_max[i] and v < column_max[j]:\n                  return "NO"\n      return "YES"\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          M,N = [int(x) for x in raw_input().split()]\n          grid = [[int(x) for x in raw_input().split()] for j in range(M)]\n          print "Case #%d: %s" % (i, solve(grid, M,N))\n <CODESPLIT> 14
def num_rotations(n, A, B):\n      s = str(n)\n      a = set()\n      for i in range(len(s)):\n          rotated = s[i:] + s[:i]\n          r = int(rotated)\n          if rotated[0] != '0' and A <= r <= B:\n              a.add(rotated)\n      return len(a) -1\n  \n  def solve(A,B):\n      t  = 0\n      for i in range(A, B+1):\n          t += num_rotations(i, A, B)\n      if t % 2 != 0:\n          print "WTF", A, B, t\n      return t//2\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          A,B = map(int, raw_input().strip().split())\n          print "Case #%d: %d" % (i, solve(A,B))\n <CODESPLIT> 14
def line_status(line):\n      s = set(line)\n      if '.' in s:\n          return 'I'\n      if len(s) == 1 or (len(s) == 2 and 'T' in s):\n          player = s.pop()\n          while player == "T":\n              player = s.pop()\n          return player\n      return 'D'\n  \n  def grid_status(grid):\n      lines = grid\n      columns = []\n      for i in range(4):\n          columns.append([])\n          for j in range(4):\n              columns[-1].append(grid[j][i])\n      lines.extend(columns)\n      lines.append([grid[i][i] for i in range(4)])\n      lines.append([grid[i][3-i] for i in range(4)])\n      incomplete = False\n      for l in lines:\n          s = line_status(l)\n          if s == 'I':\n              incomplete = True\n          elif s in ('X', 'O'):\n              return s + " won"\n      if incomplete:\n          return "Game has not completed"\n      return "Draw"\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          grid = [raw_input() for j in range(4)]\n          if i < T:\n              raw_input()\n          print "Case #%d: %s" % (i, grid_status(grid))\n      \n <CODESPLIT> 14
mapping = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's',\n             'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u',\n             'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n',\n             'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a',\n             'x': 'm', 'z': 'q', 'q': 'z'}\n  \n  def translate(s):\n      return "".join(map(lambda a: mapping[a], s))\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          s = translate(raw_input().strip())\n          print "Case #%d: %s" %(i, s)\n  \n          \n <CODESPLIT> 14
def solve(naomi, ken):\n      N = list(sorted(naomi))\n      K = list(sorted(ken))\n      pd = 0\n      while len(N) > 0:\n          if N[0] > K[0]:\n              pd += 1\n              N.pop(0)\n              K.pop(0)\n          else:\n              N.pop(0)\n              K.pop(-1)\n      pn = 0\n      N = list(sorted(naomi))\n      K = list(sorted(ken))\n      while len(N) > 0:\n          n = N.pop(0)\n          if n < K[0]:\n              K.pop(0)\n          else:\n              found = None\n              for i,k in enumerate(K):\n                  if k > n:\n                      found = i\n                      break\n              if found is not None:\n                  K.pop(found)\n              else:\n                  K.pop(0)\n                  pn += 1\n      return pd,pn\n  \n  if __name__=="__main__":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          raw_input()\n          naomi = map(float, raw_input().split())\n          ken = map(float, raw_input().split())\n          x,y = solve(naomi,ken)\n          print "Case #%d: %d %d" %(i,x,y)\n <CODESPLIT> 14
 \n  \n  \n  \n  tCase = int(sys.stdin.readline())\n  \n  def calcTemp(taxa, X):\n  	return X/taxa;\n  \n  def main(C, F, X):\n  \n  	taxa = 2.0\n  	resp = 0\n  	\n  	\n  	while True:\n  		if C/taxa + calcTemp(taxa + F, X) < calcTemp(taxa, X):\n  			resp += C/taxa\n  			taxa += F			\n  		else:\n  			resp += calcTemp(taxa, X)\n  			return resp\n  	\n  	\n  	return 0\n  		\n   \n  if __name__ == '__main__':\n  	for i in xrange(tCase):	\n  		\n  		C, F, X = [float(x) for x in sys.stdin.readline().split(' ')]\n  		print "Case #%d: %s" % (i + 1, main(C, F, X))\n <CODESPLIT> 15
 \n  class Test(unittest.TestCase):\n  	def test_1(self):\n  		self.assertEqual(main(1, 4), 2)\n  	def test_2(self):\n  		self.assertEqual(main(10, 120), 0)\n  	def test_3(self):\n  		self.assertEqual(main(100, 100000000000000), 2)\n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def main(M, N):\n  	fns = 0\n  	num = M\n  	maior = math.sqrt(N)\n  	int_maior = 0\n  	\n  	if maior.is_integer():\n  		int_maior = int(maior) - 1\n  		if fair(N):\n  			if fair(int(maior)):\n  				fns += 1\n  	else:\n  		int_maior = int(maior)\n  		\n  	while int_maior >= 1:\n  		if fair(int_maior):\n  			quadrado = int_maior * int_maior\n  			if quadrado >= M:\n  				if fair(quadrado):\n  					fns += 1\n  		int_maior -= 1\n  	return fns\n  \n  def main2(M, N):\n  	fns = 0\n  	num = M\n  	while num <= N:\n  		result = raiz(num)\n  		if result:\n  			if fair(num):\n  			\n  				if fair(result):\n  					fns += 1\n  		num += 1\n  	return fns\n  	\n  def fair(num):\n  	return str(num) == str(num)[::-1]\n  	\n  def raiz(num):\n  	result = math.sqrt(num)\n  	if result.is_integer():\n  		return int(result)\n  	else:\n  		return False\n  	\n  if __name__ == '__main__':\n  	for i in xrange(tCase):	\n  		\n  		N,M = [int(x) for x in sys.stdin.readline().split(' ')]	\n  		print "Case #%d: %d" % (i + 1, main(N,M))\n <CODESPLIT> 15
 \n  tCase = int(sys.stdin.readline())\n  \n  def alien(frases,case):\n  	\n  	case = case.replace('(','[')\n  	case = case.replace(')',']')\n  	\n  	ER1 = re.compile(case, re.I)\n  	count = 0\n  	for frase in frases:\n  		if ER1.search(frase):\n  			count += 1\n  	return count\n  \n  \n  for i in xrange(tCase):	\n  	linha = sys.stdin.readline().split()\n  	P = int(linha[1])\n  	T = int(linha[2])\n  	list = []\n  	for j in range (3,len(linha)):\n  		list.append(int(linha[j]))\n  	list.sort(reverse=True)\n  	realT = T*3 - 2\n  	supT = realT - 2\n  	\n  	count = 0\n  	for item in list:\n  		if item >= realT:\n  			count += 1\n  		elif P > 0 and item >= supT and T >= 2:\n  			count += 1\n  			P -= 1\n  		elif P > 0 and item >= realT and T == 1:\n  			count += 1\n  			P -= 1\n  		elif T == 0:\n  			count += 1\n  		else:\n  			break\n  		\n  	print "Case #%d: %d" % (i+1, count)\n  	\n  	\n  \n <CODESPLIT> 15
 \n  class Test(unittest.TestCase):\n  	def test_1(self):\n  		self.assertEqual(main(1, 4), 2)\n  	def test_2(self):\n  		self.assertEqual(main(10, 120), 0)\n  	def test_3(self):\n  		self.assertEqual(main(100, 100000000000000), 2)\n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def main(matriz, M, N):\n  	\n  	for i in xrange(M):\n  		for j in xrange(N):\n  			ana = matriz[i + 1, j + 1]\n  			maiores_linha = 0\n  			for x in xrange(M + 2):\n  				if matriz[x, j + 1] > ana:\n  					maiores_linha += 1\n  			\n  			if maiores_linha == 0:\n  				continue\n  			\n  			maiores_coluna = 0 \n  			for y in xrange(N + 2):\n  				if matriz[i + 1, y] > ana:\n  					maiores_coluna += 1\n  					\n  			if maiores_linha >= 1 and maiores_coluna >= 1:\n  				return 'NO'\n  				\n  	return 'YES'\n  	\n  \n  \n  	\n  if __name__ == '__main__':\n  	for i in xrange(tCase):	\n  		N,M = [int(x) for x in sys.stdin.readline().split(' ')]\n  		\n  		matriz = zeros((N + 2, M + 2), dtype=int)\n  		\n  		for j in xrange(N + 2):\n  			matriz[j][0] = 0\n  			matriz[j][M + 1] = 0\n  			\n  		for j in xrange(M + 2):\n  			matriz[0][j] = 0\n  			matriz[N + 1][j] = 0\n  		\n  		for k in xrange(N):\n  			j = 1\n  			line = [str(x) for x in sys.stdin.readline().split(' ')]\n  			for n in line:\n  				matriz[k + 1][j] = n		\n  				j += 1\n  		\n  		print "Case #%d: %s" % (i + 1, main(matriz, N, M))\n <CODESPLIT> 15
 \n  tCase = int(sys.stdin.readline())\n  \n  def alien(numbers):\n  	resul = 0\n  	A = int(numbers[0])\n  	B = int(numbers[1])\n  \n  	for n in range(A,B-1):\n  		for m in range(n+1,B+1):\n  			if (len(str(n)) == len(str(m))):\n  				resul += isRecycled(str(n),str(m))\n  	\n  \n  \n  	return resul\n  	\n  def isRecycled(n,m):\n  	if len(n) < 2:\n  		return 0\n  		\n  	for c in m:\n  		if c not in n:\n  			return 0\n  \n  	for i in range (1, len(n)):\n  		mi = m[i:] + m[-len(m):-(len(m)-i)]\n  		if n == mi:\n  			return 1\n  	\n  	return 0\n  \n  \n  lines = []\n  for i in xrange(tCase):\n  	line = sys.stdin.readline().split()\n  	lines.append((line[0],line[1]))\n  	\n  \n  for i in xrange(tCase):	\n  	print "Case #%d: %s" % (i+1, alien(lines[i]))\n  	\n  	\n  \n <CODESPLIT> 15
 \n  class Test(unittest.TestCase):\n  	def test_1(self):\n  		self.assertEqual(main('XXXT', '....', 'OO..', '....'), 'X won')\n  	def test_2(self):\n  		self.assertEqual(main('XOXT', 'XXOO', 'OXOX', 'XXOO'), 'Draw')\n  	def test_3(self):\n  		self.assertEqual(main('XOX.', 'OX..', '....', '....'), 'Game has not completed')\n  	def test_4(self):\n  		self.assertEqual(main('OOXX', 'OXXX', 'OX.T', 'O..O'), 'O won')\n  	def test_5(self):\n  		self.assertEqual(main('XXXO', '..O.', '.O..', 'T...'), 'O won')\n  	def test_6(self):\n  		self.assertEqual(main('OXXX', 'XO..', '..O.', '...O'), 'O won')\n  \n  tCase = int(sys.stdin.readline())\n  \n  def main(l1, l2, l3, l4):\n  	\n  	resul = ganhador(l1[0], l1[1], l1[2], l1[3])\n  	\n  	if resul == 0:\n  		return 'X won'\n  	elif resul == 1:\n  		return 'O won'\n  		\n  	resul = ganhador(l2[0], l2[1], l2[2], l2[3])\n  	\n  	if resul == 0:\n  		return 'X won'\n  	elif resul == 1:\n  		return 'O won'\n  		\n  	resul = ganhador(l3[0], l3[1], l3[2], l3[3])\n  	\n  	if resul == 0:\n  		return 'X won'\n  	elif resul == 1:\n  		return 'O won'\n  		\n  	resul = ganhador(l4[0], l4[1], l4[2], l4[3])\n  	\n  	if resul == 0:\n  		return 'X won'\n  	elif resul == 1:\n  		return 'O won'\n  		\n  	resul = ganhador(l1[0], l2[0], l3[0], l4[0])\n  	\n  	if resul == 0:\n  		return 'X won'\n  	elif resul == 1:\n  		return 'O won'\n  \n  	resul = ganhador(l1[1], l2[1], l3[1], l4[1])\n  	\n  	if resul == 0:\n  		return 'X won'\n  	elif resul == 1:\n  		return 'O won'\n  \n  	resul = ganhador(l1[2], l2[2], l3[2], l4[2])\n  	\n  	if resul == 0:\n  		return 'X won'\n  	elif resul == 1:\n  		return 'O won'\n  \n  	resul = ganhador(l1[3], l2[3], l3[3], l4[3])\n  	\n  	if resul == 0:\n  		return 'X won'\n  	elif resul == 1:\n  		return 'O won'\n  \n  	resul = ganhador(l1[3], l2[2], l3[1], l4[0])\n  	\n  	if resul == 0:\n  		return 'X won'\n  	elif resul == 1:\n  		return 'O won'\n  \n  	resul = ganhador(l1[0], l2[1], l3[2], l4[3])\n  	\n  	if resul == 0:\n  		return 'X won'\n  	elif resul == 1:\n  		return 'O won'\n  	\n  	if '.' in l1 or '.' in l2 or '.' in l3 or '.' in l4:\n  		return 'Game has not completed'\n  	else:\n  		return 'Draw'\n  	\n  	\n  def ganhador(a, b, c, d):\n  	x = 0\n  	o = 0\n  	p = 0\n  	if a == 'X':\n  		x += 1\n  		p += 1\n  	if a == 'O':\n  		o += 1\n  		p += 1\n  	if a == 'T':\n  		x += 1\n  		o += 1\n  		p += 1\n  	if b == 'X':\n  		x += 1\n  		p += 1\n  	if b == 'O':\n  		o += 1\n  		p += 1\n  	if b == 'T':\n  		x += 1\n  		o += 1\n  		p += 1\n  	if c == 'X':\n  		x += 1\n  		p += 1\n  	if c == 'O':\n  		o += 1\n  		p += 1\n  	if c == 'T':\n  		x += 1\n  		o += 1\n  		p += 1\n  	if d == 'X':\n  		x += 1\n  		p += 1\n  	if d == 'O':\n  		o += 1\n  		p += 1\n  	if d == 'T':\n  		x += 1\n  		o += 1\n  		p += 1	\n  	if x == 4:\n  		return 0\n  	elif o == 4:\n  		return 1\n  	elif p == 4:\n  		return 2\n  	else: # incompleto\n  		return 3\n   \n  if __name__ == '__main__':\n  	for i in xrange(tCase):	\n  		l1 = [str(x) for x in sys.stdin.readline().split(' ')]\n  		l2 = [str(x) for x in sys.stdin.readline().split(' ')]	\n  		l3 = [str(x) for x in sys.stdin.readline().split(' ')]	\n  		l4 = [str(x) for x in sys.stdin.readline().split(' ')]\n  		nulo = [str(x) for x in sys.stdin.readline().split(' ')]		\n  		print "Case #%d: %s" % (i + 1, main(l1[0], l2[0], l3[0], l4[0]))\n  		\n <CODESPLIT> 15
 \n  fLine = sys.stdin.readline().split()\n  tCase = int(fLine[0])\n  \n  \n  dic = {		'a':'y',\n  			'b':'h',\n  			'c':'e',\n  			'd':'s',\n  			'e':'o',\n  			'f':'c',\n  			'g':'v',\n  			'h':'x',\n  			'i':'d',\n  			'j':'u',\n  			'k':'i',\n  			'l':'g',\n  			'm':'l',\n  			'n':'b',\n  			'o':'k',\n  			'p':'r',\n  			'q':'z',\n  			'r':'t',\n  			's':'n',\n  			't':'w',\n  			'u':'j',\n  			'v':'p',\n  			'w':'f',\n  			'x':'m',\n  			'y':'a',\n  			'z':'q',\n  			'\n':'',\n  			' ':' '}\n  \n  \n  def alien(frase):\n  	resul = ""\n  	for c in frase:\n  		resul += dic[c]\n  \n  	return resul\n  \n  \n  \n  frases = []\n  for i in xrange(tCase):\n  	frase = sys.stdin.readline().replace("\n","")\n  	frases.append(frase)\n  	\n  \n  for i in xrange(tCase):	\n  	print "Case #%d: %s" % (i+1, alien(frases[i]))\n  	\n  	\n  \n <CODESPLIT> 15
 \n  \n  tCase = int(sys.stdin.readline())\n  \n  def ken(bet, list):\n  	for i in list:\n  		if i >= bet:\n  			list.remove(i)\n  			return i, list\n  	\n  	x = list[0]\n  	list.remove(x)\n  	return x, list\n  	\n  def naomi(YList, ZList):\n  	l1 = list(YList)\n  	l2 = list(ZList)\n  	\n  	while len(l1) > 0:\n  		cy = l1.pop()\n  		cz = l2.pop()\n  \n  		if (cy < cz):\n  				return YList[0], ZList[len(ZList)-1]\n  		\n  	return YList[len(YList)-1], ZList[len(ZList)-1]\n  		\n  def main(YList, ZList):\n  	dnp = 0\n  	np = 0\n  	YList.sort()\n  	ZList.sort()\n  	\n  	YList2 = list(YList)\n  	ZList2 = list(ZList)\n  	\n  	YList.sort()\n  	\n  	while len(YList) > 0:\n  		cy, ty = naomi(YList, ZList)\n  		YList.remove(cy)		\n  		cz, ZList = ken(ty, ZList)\n  		if (cy > cz):\n  			dnp += 1\n  			\n  	while len(YList2) > 0:\n  		cy = YList2.pop()\n  		cz, ZList2 = ken(cy, ZList2)\n  		if (cy > cz):\n  			np += 1\n  			\n  			\n  	\n  \n  	return str(dnp) + " " + str(np)\n  		\n   \n  if __name__ == '__main__':\n  	for i in xrange(tCase):	\n  		\n  		N = [int(x) for x in sys.stdin.readline().split(' ')]\n  		YList = [float(x) for x in sys.stdin.readline().split(' ')]\n  		ZList = [float(x) for x in sys.stdin.readline().split(' ')]\n  		print "Case #%d: %s" % (i + 1, main(YList, ZList))\n <CODESPLIT> 15
 \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = "Case #{}: {}".format(X, ans)\n      f.write(out)\n      f.write("\n")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          C, F, X = readf(inf)\n  \n          power = 2\n          farmtime = round(C / power, 7)\n          keikatime = 0\n          totaltime = round(X / power, 7)\n  \n          while True:\n              keikatime += farmtime\n              power += F\n              farmtime = round(C / power, 7)\n              nokoritime = round(X / power, 7)\n              if keikatime + nokoritime > totaltime:\n                  break\n              totaltime = keikatime + nokoritime\n  \n          answer(outf, casenmbr, totaltime)\n  \n  \n  if __name__=="__main__":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + ".out"\n      with open(infname, "r") as inf:\n          with open(outfname, "w") as outf:\n              main(inf, outf)\n <CODESPLIT> 16
 \n  def read(f):\n      return list( int(v) for v in f.readline().split() )\n  \n  def answer(f, X, ans):\n      out = "Case #{}: {}".format(X, ans)\n      f.write(out)\n      f.write("\n")\n      print(out)\n  \n  def testcases(f):\n      T = int(f.readline())\n      for X in range(1, T + 1):\n          A, B = read(f)\n          yield X, A, B\n  \n  def ispalindrome(v):\n      s = str(v)\n      for i in range(len(s) // 2):\n          if s[i] != s[-i-1]:\n              return False\n      return True\n  \n  def main(inf, outf):\n      MAX = 1000\n      fslst = []\n      for i in itertools.count():\n          if ispalindrome(i):\n              squere = i * i\n              print(MAX, squere, ispalindrome(squere))\n              if squere > MAX:\n                  break\n              if ispalindrome(squere):\n                  fslst.append(squere)\n      for X, A, B in testcases(inf):\n          cnt = 0\n          for fs in fslst:\n              if A <= fs <= B:\n                  cnt += 1\n          answer(outf, X, cnt)\n  \n  if __name__=="__main__":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + ".out"\n      with open(infname, "r") as inf:\n          with open(outfname, "w") as outf:\n              main(inf, outf)\n <CODESPLIT> 16
 \n  def testcases():\n      with open(sys.argv[1], "r") as f:\n          f.readline()  # skip number of testcases\n          for X, T in enumerate(f, 1):\n              yield X, [int(t) for t in T.split()]\n  \n  def main():\n      for X, T in testcases():\n          N = T[0]   # the number of Googlers\n          S = T[1]   # the number of surprising triplets of scores\n          p = T[2]   # best result of at least\n  \n          y = 0\n  \n          for t in T[3:]:\n              d, m = divmod(t, 3)\n              if m == 0:\n                  if p <= d:\n                      y += 1\n                  elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:\n                      y += 1\n                      S -= 1\n              elif m == 1:\n                  if p <= d + 1:\n                      y += 1\n              else:\n                  if p <= d + 1:\n                      y += 1\n                  elif p <= d + 2 and S:\n                      y += 1\n                      S -= 1\n  \n          print("Case #{:d}: {:d}".format(X, y))\n  \n  if __name__=="__main__":\n      main()\n <CODESPLIT> 16
 \n  def read(f):\n      return list( int(v) for v in f.readline().split() )\n  \n  def answer(f, X, ans):\n      out = "Case #{}: {}".format(X, ans)\n      f.write(out)\n      f.write("\n")\n      print(out)\n  \n  def testcases(f):\n      T = int(f.readline())\n      for X in range(1, T + 1):\n          N, M = read(f)\n          GRASS = []\n          for n in range(N):\n              GRASS.append( read(f) )\n          result = yield X, N, M, GRASS\n  \n  def main(inf, outf):\n      for X, N, M, GRASS in testcases(inf):\n          maxN = list( max(gn) for gn in GRASS )\n          maxM = list( max( gn[m] for gn in GRASS ) for m in range(M) )\n  \n          ans = "YES"\n          for n, m in ( (n, m) for m in range(M) for n in range(N) ):\n              if ( GRASS[n][m] < maxN[n] and\n                   GRASS[n][m] < maxM[m] ):\n                  ans = "NO"\n                  break\n          \n          answer(outf, X, ans)\n  \n  if __name__=="__main__":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + ".out"\n      with open(infname, "r") as inf:\n          with open(outfname, "w") as outf:\n              main(inf, outf)\n <CODESPLIT> 16
 \n  def testcases():\n      with open(sys.argv[1], "r") as f:\n          f.readline()  # skip number of testcases\n          for X, T in enumerate(f, 1):\n              yield X, [int(t) for t in T.split()]\n  \n  def main():\n      for X, T in testcases():\n          A = T[0]\n          B = T[1]\n          y = 0\n          strA = str(A)\n          for n in range(B, A - 1, - 1):\n              b = str(n)\n              chk = set()\n              for i in range(1, len(b)):\n                  a = b[i:] + b[:i]\n                  if a not in chk and strA <= a < b:\n                      chk.add(a)\n                      y += 1\n  \n          print("Case #{:d}: {:d}".format(X, y))\n  \n  if __name__=="__main__":\n      main()\n <CODESPLIT> 16
 \n  def testcases():\n      with open(sys.argv[1], "r") as f:\n          T = int(f.readline())\n          for X in range(1, T + 1):\n              BOARD = [\n                  f.readline().strip(),\n                  f.readline().strip(),\n                  f.readline().strip(),\n                  f.readline().strip(),\n              ]\n              f.readline()\n              yield X, BOARD\n  \n  def main():\n      for X, BOARD in testcases():\n          points = [0] * 10\n          for iR, cols in enumerate(BOARD):\n              cols = list( p(c) for c in cols )\n  \n              points[iR] = sum(cols)\n  \n              for iC, c in enumerate(cols):\n                  points[4 + iC] += c  # c\n  \n              points[8] += cols[0 + iR]\n              points[9] += cols[3 - iR]\n  \n          status = "Draw"\n          for pp in points:\n              if pp >= 1000:\n                  status = "Game has not completed"\n              elif pp in (4, 103):\n                  status = "X won"\n                  break\n              elif pp in (40, 130):\n                  status = "O won"\n                  break\n  \n          print("Case #{}: {}".format(X, status))\n  \n  \n  def p(c):\n      if  c == 'X':\n          return 1\n      elif c == 'O':\n          return 10\n      elif c == 'T':\n          return 100\n      else:\n          return 1000\n  \n  if __name__=="__main__":\n      main()\n <CODESPLIT> 16
 \n  def testcases():\n      with open(sys.argv[1], "r") as f:\n          f.readline()  # skip number of testcases\n          for X, T in enumerate(f, 1):\n              yield X, T[:-1]\n  \n  def main():\n      for X, T in testcases():\n          tbl = str.maketrans("abcdefghijklmnopqrstuvwxyz",\n                              "yhesocvxduiglbkrztnwjpfmaq")\n          S = T.translate(tbl)\n          print("Case #{:d}: {}".format(X, S))\n  \n  if __name__=="__main__":\n    main()\n    \n <CODESPLIT> 16
 \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, Y, Z):\n      out = "Case #{}: {} {}".format(X, Y, Z)\n      f.write(out)\n      f.write("\n")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          N = read(inf)\n          naomi_blks = sorted(readf(inf))\n          ken_blks = sorted(readf(inf))\n  \n          y = len([None for naomi in naomi_blks if ken_blks[0] < naomi])\n  \n          z = 0\n          for naomi in naomi_blks:\n              for i in range(len(ken_blks)):\n                  if naomi < ken_blks[i]:\n                      del ken_blks[i]\n                      break\n              else:\n                  z += 1\n                  del ken_blks[0]\n  \n          answer(outf, casenmbr, y, z)\n  \n  \n  if __name__=="__main__":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + ".out"\n      with open(infname, "r") as inf:\n          with open(outfname, "w") as outf:\n              main(inf, outf)\n <CODESPLIT> 16
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n  \n          C, F, X = [float(x) for x in f.readline().split()]\n  \n          base = X / 2.0\n  \n          new_strategy = old_strategy = base\n          time_building = 0\n          farms = 0\n          fastest_speed = 2\n          while new_strategy <= old_strategy:\n              old_strategy = new_strategy\n              time_building += C / fastest_speed\n              farms += 1\n              fastest_speed += F\n              new_strategy = time_building + X / fastest_speed\n              \n          \n          print ("Case #" + str(_t+1) + ": " + str(old_strategy))\n      \n  \n <CODESPLIT> 17
 \n  def is_square(n):\n      if n in square:\n          return True\n      if is_fair(n):\n          root = int(math.sqrt(n))\n          if root**2 != n:\n              return False\n          ss = is_fair(root)\n          if ss: square.add(n)\n          return ss\n      return False\n  \n  def is_fair(n):\n      if n in fair:\n          return True\n      if n in unfair:\n          return False\n      sn = str(n)\n      l = len(sn)\n      mid = math.ceil(n/2)\n      if sn[0:mid] == sn[mid::-1]:\n          fair.add(n)\n          return True\n      else:\n          unfair.add(n)\n          return False\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n              \n      fair = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])\n      unfair = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n      square = set([1, 4])\n  \n      t = int(f.readline())\n      for _t in range(t):\n          s = f.readline()\n          if s:\n              x, y = s.split()\n              Total = sum([is_square(n) for n in range(int(x), int(y)+1)])             \n              print ("Case #" + str(_t+1) + ": " + str(Total))\n      \n  \n <CODESPLIT> 17
 \n  def decode_data(input):\n      output = ""\n      for letter in input:\n          if letter in library:\n              output += library[letter]\n      return output\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())    \n      for _t in range(t):\n          s = f.readline()\n          s = s.split()\n          N = int(s[0])\n          S = int(s[1])\n          p = int(s[2])\n          low_scores = (p - 1) * 2\n          ti = s[3:]\n          ti.sort()\n          r = 0\n          ti = [int(x) for x in ti]\n          for i in ti:\n              score = i - low_scores\n              if p <= i:\n                  if score >= p:\n                      r += 1\n                  elif score >= p - 2 and S > 0:\n                      S -= 1\n                      r +=1\n          print ("Case #" + str(_t+1) + ": " + str(r))\n      \n  \n <CODESPLIT> 17
 \n  def decode_data(input, x, y, z):\n      rotated = zip(*input[::-1])\n      for i in range(x):\n          for j in range(y):\n              if not input[i][j] == "1":\n                  continue            \n              if sum((int(xx) for xx in input[i])) != y and \\n                 sum((int(xx) for xx in rotated[j])) != x:\n                  return "NO"\n      return "YES"\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          x, y = f.readline().split()\n          s = [f.readline().split() for i in range(int(x))]\n          print ("Case #" + str(_t+1) + ": " + decode_data(s, int(x), int(y), 2))\n      \n  \n <CODESPLIT> 17
 \n  def digits(number, base = 10):\n    while number:\n      yield number % base\n      number //= base\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())    \n      for _t in range(t):\n          s = f.readline()\n          s = s.split()\n          A = int(s[0])\n          B = int(s[1])\n          score = 0\n          for i in range(A, B):\n              for j in range(i+1, B+1):\n                  id = [d for d in digits(i)]\n                  jd = [d for d in digits(j)]\n                  if  sorted(id) == sorted(jd):\n                      checklist = [jd[n:] + jd[:n] for n in range(len(id))]\n                      if id in checklist:\n                          score +=1\n          print ("Case #" + str(_t+1) + ": " + str(score))\n      \n  \n <CODESPLIT> 17
 \n  def decode_data(input):\n      output = ""\n      Total = 0\n      for row in input:\n          T = row.count("T")\n          X = row.count("X")\n          O = row.count("O")\n          if X + T == 4:\n              return "X won"\n          elif O + T == 4:\n              return "O won"\n          else:\n              Total += T + X + O\n              \n      rotated = zip(*input[::-1])\n      for row in rotated:\n          T = row.count("T")\n          X = row.count("X")\n          O = row.count("O")\n          if X + T == 4:\n              return "X won"\n          elif O + T == 4:\n              return "O won"\n  \n      row = [input[x][x] for x in range(4)]\n      row.count("T")\n      X = row.count("X")\n      O = row.count("O")\n      if X + T == 4:\n          return "X won"\n      elif O + T == 4:\n          return "O won"\n  \n      row = [input[3-x][x] for x in range(4)]\n      T = row.count("T")\n      X = row.count("X")\n      O = row.count("O")\n      if X + T == 4:\n          return "X won"\n      elif O + T == 4:\n          return "O won"\n  \n      if Total < 16:\n          return "Game has not completed"\n      else:\n          return "Draw"\n      return output\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          s = [f.readline() for i in range(4)]\n          print ("Case #" + str(_t+1) + ": " + decode_data(s))\n          f.readline()\n      \n  \n <CODESPLIT> 17
 \n  library = {'a': 'y', 'o': 'e', 'z': 'q', 'q' : 'z'}\n  \n  def parse_example(input, output):\n      for key, value in zip(input, output):\n          library[key] = value\n  \n  parse_example("ejp mysljylc kd kxveddknmc re jsicpdrysi", "our language is impossible to understand")\n  parse_example("rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd", "there are twenty six factorial possibilities")\n  parse_example("de kr kd eoya kw aej tysr re ujdr lkgc jv", "so it is okay if you want to just give up")\n  \n  def decode_data(input):\n      output = ""\n      for letter in input:\n          if letter in library:\n              output += library[letter]\n      return output\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      d = {'O':0, 'B':1}\n      for _t in range(t):\n          s = f.readline()\n          print ("Case #" + str(_t+1) + ": " + decode_data(s))\n      \n  \n <CODESPLIT> 17
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          N = int(f.readline())\n          Naomi = sorted([float(x) for x in f.readline().split()])\n          Ken = sorted([float(x) for x in f.readline().split()])\n          NMax = max(Naomi)\n          DWScore = 0\n          WScore = 0\n          NaomiW = [x for x in Naomi]\n          KenW = [x for x in Ken]\n          for i in range(N):\n              if(Naomi[-1] > Ken[-1]):\n                  DWScore += 1\n                  Naomi.pop()\n                  Ken.pop()\n              else:\n                  Naomi.pop(0)\n                  Ken.pop()\n          for i in range(N):\n              Na = NaomiW.pop(0)\n              KWinners = [x for x in KenW if x > Na]\n              if len(KWinners) > 0:\n                  KenW.remove(KWinners[0])\n              else:\n                  KenW.pop(0)\n                  WScore += 1\n          print ("Case #" + str(_t+1) + ": " + str(DWScore) + " " + str(WScore))\n      \n  \n <CODESPLIT> 17
 \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T lines follow. \n  Each line contains three space-separated real-valued numbers: C, F and X.\n  \n  Output\n  For each test case, output one line containing "Case #x: y", where x is \n  the test case number (starting from 1) and y is the minimum number of seconds \n  it takes before you can have X delicious cookies.\n  \n  We recommend outputting y to 7 decimal places, but it is not required. \n  y will be considered correct if it is close enough to the correct number: \n  within an absolute or relative error of 10^-6. \n  \n  Limits\n  1 <= T <= 100.\n  \n  Small dataset\n  1 <= C <= 500.\n  1 <= F <= 4.\n  1 <= X <= 2000.\n  \n  Large dataset\n  1 <= C <= 10000.\n  1 <= F <= 100.\n  1 <= X <= 100000.\n  \n  \n  ---Input  \n  4\n  30.0 1.0 2.0\n  30.0 2.0 100.0\n  30.50000 3.14159 1999.19990\n  500.0 4.0 2000.0\n  \n  ---Output \n  Case #1: 1.0000000\n  Case #2: 39.1666667\n  Case #3: 63.9680013\n  Case #4: 526.1904762\n  \n  '''\n  \n  \n  \n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n  def bestTime(C, F, X):\n      v = 2   #speed of production, cookies/sec\n      t = 0   #total time of production, sec\n      while True:\n          tX = X / v          #time to reach goal at current speed\n          tC = C / v          #time to buy farm\n          tXc = X / (v + F)   #time to reach goal after adding farm\n          if tX <= tC + tXc:\n              break\n          t += tC\n          v += F\n      t += tX\n      return t\n  \n  \n  for caseNo in xrange(1, int(input())+1):\n      C, F, X = map(float, input().split())\n      print 'Case #%d: %.7f' % (caseNo, bestTime(C, F, X))\n      \n  \n  \n <CODESPLIT> 18
 \n  '''\n  Limits\n  \n  Small dataset       1 <= T <= 100, 1 <= A <= B <= 1000.\n  First large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.\n  Second large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.\n  \n  Sample\n  *** Input \n  3\n  1 4\n  10 120\n  100 1000\n   	\n  *** Output \n  Case #1: 2\n  Case #2: 0\n  Case #3: 2\n  \n  \n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  pal_sqr_roots = '''1 \n  2 \n  3 \n  11 \n  22 \n  26 \n  101 \n  111 \n  121 \n  202 \n  212 \n  264 \n  307 \n  836 \n  1001 \n  1111 \n  2002 \n  2285 \n  2636 \n  10001 \n  10101 \n  10201 \n  11011 \n  11111 \n  11211 \n  20002 \n  20102 \n  22865 \n  24846 \n  30693 \n  100001 \n  101101 \n  110011 \n  111111 \n  200002 \n  798644 \n  1000001 \n  1001001 \n  1002001 \n  1010101 \n  1011101 \n  1012101 \n  1042151 \n  1100011 \n  1101011 \n  1102011 \n  1109111 \n  1110111 \n  1111111 \n  1270869 \n  2000002 \n  2001002 \n  2012748 \n  2294675 \n  3069307 \n  10000001 \n  10011001 \n  10100101 \n  10111101 \n  11000011 \n  11011011 \n  11100111 \n  11111111 \n  11129361 \n  12028229 \n  12866669 \n  20000002 \n  30001253 \n  64030648 \n  100000001 \n  100010001 \n  100020001 \n  100101001 \n  100111001 \n  100121001 \n  101000101 \n  101010101 \n  101020101 \n  101101101 \n  101111101 \n  110000011 \n  110010011 \n  110020011 \n  110091011 \n  110101011 \n  110111011 \n  111000111 \n  111010111 \n  111091111 \n  111101111 \n  111111111 \n  200000002 \n  200010002 \n  306930693 \n  1000000001 \n  1000110001 \n  1001001001 \n  1001111001 \n  1010000101 \n  1010110101 \n  1011001101 \n  1011111101 \n  1100000011 \n  1100110011 \n  1101001011 \n  1101111011 \n  1110000111 \n  1110110111 \n  1111001111 \n  2000000002 \n  2062386218 \n  2481623254 \n  10000000001 \n  10000100001 \n  10000200001 \n  10001010001 \n  10001110001 \n  10001210001 \n  10010001001 \n  10010101001 \n  10010201001 \n  10011011001 \n  10011111001 \n  10100000101 \n  10100100101 \n  10100200101 \n  10101010101 \n  10101110101 \n  10106064399 \n  10109901101 \n  10110001101 \n  10110101101 \n  10110911101 \n  10111011101 \n  10111111101 \n  10207355549 \n  11000000011 \n  11000100011 \n  11000200011 \n  11000910011 \n  11001010011 \n  11001110011 \n  11010001011 \n  11010101011 \n  11010911011 \n  11011011011 \n  11011111011 \n  11100000111 \n  11100100111 \n  11100910111 \n  11101010111 \n  11101110111 \n  11110001111 \n  11110101111 \n  13579355059 \n  20000000002 \n  20000100002 \n  22865150135 \n  30101273647 \n  30693069307 \n  83163115486 \n  100000000001 \n  100001100001 \n  100010010001 \n  100011110001 \n  100100001001 \n  100101101001 \n  100110011001 \n  100111111001 \n  101000000101 \n  101001100101 \n  101010010101 \n  101011110101 \n  101100001101 \n  101101101101 \n  101110011101 \n  101116809851 \n  110000000011 \n  110001100011 \n  110010010011 \n  110011110011 \n  110100001011 \n  110101101011 \n  110110011011 \n  111000000111 \n  111001100111 \n  111010010111 \n  111100001111 \n  111283619361 \n  112247658961 \n  128817084669 \n  200000000002 \n  1000000000001 \n  1000001000001 \n  1000002000001 \n  1000010100001 \n  1000011100001 \n  1000012100001 \n  1000100010001 \n  1000101010001 \n  1000102010001 \n  1000110110001 \n  1000111110001 \n  1001000001001 \n  1001001001001 \n  1001002001001 \n  1001010101001 \n  1001011101001 \n  1001100011001 \n  1001101011001 \n  1001110111001 \n  1001111111001 \n  1010000000101 \n  1010001000101 \n  1010002000101 \n  1010010100101 \n  1010011100101 \n  1010099010101 \n  1010100010101 \n  1010101010101 \n  1010109110101 \n  1010110110101 \n  1010111110101 \n  1011000001101 \n  1011001001101 \n  1011010101101 \n  1011011101101 \n  1011099011101 \n  1011100011101 \n  1011101011101 \n  1100000000011 \n  1100001000011 \n  1100002000011 \n  1100009100011 \n  1100010100011 \n  1100011100011 \n  1100100010011 \n  1100101010011 \n  1100110110011 \n  1100111110011 \n  1101000001011 \n  1101001001011 \n  1101009101011 \n  1101010101011 \n  1101011101011 \n  1101100011011 \n  1101101011011 \n  1110000000111 \n  1110001000111 \n  1110009100111 \n  1110010100111 \n  1110011100111 \n  1110100010111 \n  1110101010111 \n  1111000001111 \n  1111001001111 \n  1349465117841 \n  2000000000002 \n  2000001000002 \n  2149099165358 \n  2634812417864 \n  3069306930693 \n  6360832925898 \n  10000000000001 \n  10000011000001 \n  10000100100001 \n  10000111100001 \n  10001000010001 \n  10001011010001 \n  10001100110001 \n  10001111110001 \n  10010000001001 \n  10010011001001 \n  10010100101001 \n  10010111101001 \n  10011000011001 \n  10011011011001 \n  10011100111001 \n  10100000000101 \n  10100011000101 \n  10100100100101 \n  10100111100101 \n  10101000010101 \n  10101011010101 \n  10101100110101 \n  10110000001101 \n  10110011001101 \n  10110100101101 \n  10111000011101 \n  11000000000011 \n  11000011000011 \n  11000100100011 \n  11000111100011 \n  11001000010011 \n  11001011010011 \n  11001100110011 \n  11010000001011 \n  11010011001011 \n  11010100101011 \n  11011000011011 \n  11100000000111 \n  11100011000111 \n  11100100100111 \n  11101000010111 \n  11110000001111 \n  20000000000002 \n  30395080190573 \n  69800670077028 \n  98275825201587 \n  100000000000001 \n  100000010000001 \n  100000020000001 \n  100000101000001 \n  100000111000001 \n  100000121000001 \n  100001000100001 \n  100001010100001 \n  100001020100001 \n  100001101100001 \n  100001111100001 \n  100010000010001 \n  100010010010001 \n  100010020010001 \n  100010101010001 \n  100010111010001 \n  100011000110001 \n  100011010110001 \n  100011101110001 \n  100011111110001 \n  100100000001001 \n  100100010001001 \n  100100020001001 \n  100100101001001 \n  100100111001001 \n  100101000101001 \n  100101010101001 \n  100101101101001 \n  100101111101001 \n  100109990011001 \n  100110000011001 \n  100110010011001 \n  100110091011001 \n  100110101011001 \n  100110111011001 \n  100110990111001 \n  100111000111001 \n  100111010111001 \n  101000000000101 \n  101000010000101 \n  101000020000101 \n  101000101000101 \n  101000111000101 \n  101000990100101 \n  101001000100101 \n  101001010100101 \n  101001091100101 \n  101001101100101 \n  101001111100101 \n  101010000010101 \n  101010010010101 \n  101010101010101 \n  101010111010101 \n  101010990110101 \n  101011000110101 \n  101011010110101 \n  101100000001101 \n  101100010001101 \n  101100101001101 \n  101100111001101 \n  101101000101101 \n  101101010101101 \n  101110000011101 \n  101110010011101 \n  110000000000011 \n  110000010000011 \n  110000020000011 \n  110000091000011 \n  110000101000011 \n  110000111000011 \n  110001000100011 \n  110001010100011 \n  110001101100011 \n  110001111100011 \n  110010000010011 \n  110010010010011 \n  110010091010011 \n  110010101010011 \n  110010111010011 \n  110011000110011 \n  110011010110011 \n  110100000001011 \n  110100010001011 \n  110100101001011 \n  110100111001011 \n  110101000101011 \n  110101010101011 \n  110110000011011 \n  110110010011011 \n  111000000000111 \n  111000010000111 \n  111000091000111 \n  111000101000111 \n  111000111000111 \n  111001000100111 \n  111001010100111 \n  111010000010111 \n  111010010010111 \n  111100000001111 \n  111100010001111 \n  129610990752569 \n  200000000000002 \n  200000010000002 \n  210786628549538 \n  314155324482867 \n  1000000000000000 \n  1000000110000000 \n  1000001001000000 \n  1000001111000000 \n  1000010000100000 \n  1000010110100000 \n  1000011001100000 \n  1000011111100000 \n  1000100000010000 \n  1000100110010000 \n  1000101001010000 \n  1000101111010000 \n  1000110000110000 \n  1000110110110000 \n  1000111001110000 \n  1001000000001000 \n  1001000110001000 \n  1001001001001000 \n  1001001111001000 \n  1001010000101000 \n  1001010110101000 \n  1001011001101000 \n  1001100000011000 \n  1001100110011000 \n  1001101001011000 \n  1001110000111000 \n  1010000000000100 \n  1010000110000100 \n  1010001001000100 \n  1010001111000100 \n  1010010000100100 \n  1010010110100100 \n  1010011001100100 \n  1010100000010100 \n  1010100110010100 \n  1010101001010100 \n  1010110000110100 \n  1011000000001100 \n  1011000110001100 \n  1011001001001100 \n  1011010000101100 \n  1011100000011100 \n  1100000000000010 \n  1100000110000010 \n  1100001001000010 \n  1100001111000010 \n  1100010000100010 \n  1100010110100010 \n  1100011001100010 \n  1100100000010010 \n  1100100110010010 \n  1100101001010010 \n  1100110000110010 \n  1101000000001010 \n  1101000110001010 \n  1101001001001010 \n  1101010000101010 \n  1101100000011010 \n  1110000000000110 \n  1110000110000110 \n  1110001001000110 \n  1110010000100110 \n  1110100000010110 \n  1111000000001110 \n  2000000000000000 \n  2201019508986470 \n  2564053868197730 \n  3066446727654240 \n  3107974295870660 \n  3138199296186060'''\n  pal_sqr_roots = map(int, pal_sqr_roots.split())\n  \n  \n  \n  def is_palindrome(n):\n      return str(n)[::-1] == str(n)\n  \n  palindromic_roots = [x for x in pal_sqr_roots if is_palindrome(x)]\n  \n  fair_and_square = [x*x for x in palindromic_roots]\n  \n  \n  def get_num_fair_and_square(a, b):\n      return len([x for x in fair_and_square if a <= x <= b])\n  \n  for caseNo in range(1, int(input())+1):\n      a,b = map(int, input().split())\n      print 'Case #%d:' % caseNo, get_num_fair_and_square(a, b)\n  \n <CODESPLIT> 18
 \n  '''\n  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]\n  At least S of the ti values will be between 2 and 28, inclusive.\n  \n  Small dataset 1 = N = 3.\n  Large dataset 1 = N = 100.\n  \n  Sample Input \n  4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \n  Output \n  Case #1: 3\n  Case #2: 2\n  Case #3: 1\n  Case #4: 3\n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  def maxBestDancers(N, S, p, *Ti):\n      cnt = 0\n      for score in Ti:\n          mx = (score + 2) // 3\n          if mx >= p:\n              cnt += 1\n          elif mx >= p-1 > 0 and S>0:\n              S -= 1\n              cnt += 1\n      return cnt\n  \n  for caseNo in range(1, int(input())+1):\n      print 'Case #%d:' % caseNo,\n      lst = map(int, input().split())\n      print maxBestDancers(*lst)\n  \n <CODESPLIT> 18
 \n  '''\n  Limits\n  \n  1 <= T <= 100.\n  \n  Small dataset   1 <= N, M <= 10. 1 <= a[i,j] <= 2.\n  Large dataset   1 <= N, M <= 100. 1 <= a[i,j] <= 100.\n  \n  Sample\n  \n  *** Input \n  3\n  3 3\n  2 1 2\n  1 1 1\n  2 1 2\n  5 5\n  2 2 2 2 2\n  2 1 1 1 2\n  2 1 2 1 2\n  2 1 1 1 2\n  2 2 2 2 2\n  1 3\n  1 2 1\n  \n  *** Output \n  Case #1: YES\n  Case #2: NO\n  Case #3: YES\n  \n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  \n  def check_lawn(board):\n      n = len(board)\n      m = len(board[0])\n      hmax = map(max, board)\n      vmax = map(max, zip(*board))\n      for i in range(n):\n          for j in range(m):\n              if board[i][j] < min(hmax[i], vmax[j]):\n                  return 'NO'\n      return 'YES'\n  \n  for caseNo in range(1, int(input())+1):\n      n,m = map(int, input().split())\n      board = [map(int, input().split()) for _ in range(n)]\n      print 'Case #%d:' % caseNo, check_lawn(board)\n  \n <CODESPLIT> 18
 \n  '''\n  Limits: 1 <= T <= 50. A and B have the same number of digits.\n  Small dataset: 1 <= A <= B <= 1000.\n  Large dataset: 1 <= A <= B <= 2000000\n  \n  Input \n  4\n  1 9\n  10 40\n  100 500\n  1111 2222\n   	\n  Output \n  Case #1: 0\n  Case #2: 3\n  Case #3: 156\n  Case #4: 287\n  \n  '''\n  \n  psyco.full()\n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  def numRecycled(A,B):\n      ln = len(str(A))\n      rot = 10**(ln-1)\n      cnt = 0\n      for i in range(A,B+1):\n          res = set()\n          j = i\n          for _ in range(ln-1):\n              a,b = divmod(j, 10)\n              j = rot*b + a\n              if i < j <= B:\n                  res.add(j)\n          cnt += len(res)\n      return cnt\n  \n  for caseNo in range(1, int(input())+1):\n      print 'Case #%d:' % caseNo,\n      A,B = map(int, input().split())\n      print numRecycled(A,B)\n  \n <CODESPLIT> 18
 \n  '''\n  Limits\n  The game board provided will represent a valid state that was reached\n  through play of the game Tic-Tac-Toe-Tomek as described above.\n  \n  Small dataset   1 = T = 10.\n  Large dataset   1 = T = 1000.\n  \n  *** Sample Input \n  6\n  XXXT\n  ....\n  OO..\n  ....\n  \n  XOXT\n  XXOO\n  OXOX\n  XXOO\n  \n  XOX.\n  OX..\n  ....\n  ....\n  \n  OOXX\n  OXXX\n  OX.T\n  O..O\n  \n  XXXO\n  ..O.\n  .O..\n  T...\n  \n  OXXX\n  XO..\n  ..O.\n  ...O\n  \n  ***Output \n  Case #1: X won\n  Case #2: Draw\n  Case #3: Game has not completed\n  Case #4: O won\n  Case #5: O won\n  Case #6: O won\n  \n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  \n  x_ptrn = re.compile('X{4}|X(.{4}X){3}|X(.{3}X){3}|X(.{5}X){3}')\n  o_ptrn = re.compile('O{4}|O(.{4}O){3}|O(.{3}O){3}|O(.{5}O){3}')\n  \n  \n  def check_game_status(board):\n      if x_ptrn.search(board.replace('T','X')):\n          return 'X won'\n      elif o_ptrn.search(board.replace('T','O')):\n          return 'O won'\n      elif '.' not in board:\n          return 'Draw'\n      else:\n          return 'Game has not completed'\n  \n  for caseNo in range(1, int(input())+1):\n      board = '|'.join(input() for _ in range(4))\n      input() # skip empty line\n      print 'Case #%d:' % caseNo, check_game_status(board)\n  \n <CODESPLIT> 18
 \n  '''\n  Limits: 1 = T = 30. G contains at most 100 characters.\n  None of the text is guaranteed to be valid English.\n  Sample\n  \n  Input\n  3\n  ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv\n  \n  Output\n  Case #1: our language is impossible to understand\n  Case #2: there are twenty six factorial possibilities\n  Case #3: so it is okay if you want to just give up\n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  knownPairs = [\n      ('zq', 'qz'),\n      ('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'),\n      ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'),\n      ('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')\n  ]\n  \n  xlat = [chr(0) for ch in range(256)]\n  for crypt, plain in knownPairs:\n      for a,b in zip(crypt, plain):\n          xlat[ord(a)] = b\n  for i in range(26):\n      xlat[ord('A')+i] = chr(ord(xlat[ord('a')+i]) - ord('a') + ord('A'))\n  xlat = ''.join(xlat)\n  \n  for caseNo in range(1, int(input())+1):\n      print 'Case #%d:' % caseNo, input().translate(xlat)\n  \n  \n <CODESPLIT> 18
 \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T test cases follow. \n  Each test case starts with a line containing a single integer N, the number of blocks \n  each player has. Next follows a line containing N space-separated real numbers: \n  the masses of Naomi's blocks, in kg. Finally there will be a line containing N \n  space-separated real numbers: the masses of Ken's blocks, in kg.\n  \n  Output\n  For each test case, output one line containing "Case #x: y z", where \n  x is the test case number (starting from 1), \n  y is the number of points Naomi will score if she plays Deceitful War optimally, and \n  z is the number of points Naomi will score if she plays War optimally.\n  \n  Limits\n  1 <= T <= 50.\n  All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.\n  \n  Small dataset\n  1 <= N <= 10.\n  \n  Large dataset\n  1 <= N <= 1000.\n  \n  ---Input \n  4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n  \n  ---Output \n  Case #1: 0 0\n  Case #2: 1 0\n  Case #3: 2 1\n  Case #4: 8 4\n  \n  \n  '''\n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n  \n  \n  def deceitfulWar(Naomi, Ken):\n      Naomi = Naomi[:]\n      Ken = Ken[:]\n      pts = 0\n      while Naomi and Ken and Naomi[-1] > Ken[0]:\n          kn = Ken.pop(0)\n          for i in range(len(Naomi)):\n              if Naomi[i] > kn:\n                  Naomi.pop(i)\n                  break\n          pts += 1        \n  \n      return pts\n  \n  def war(Naomi, Ken):\n      Naomi = Naomi[:]\n      Ken = Ken[:]\n      pts = 0\n      while Naomi and Ken:\n          nm = Naomi.pop(0)\n          if nm > Ken[-1]:\n              Ken.pop(0)\n              pts += 1\n          else:\n              for i in range(len(Ken)):\n                  if Ken[i] > nm:\n                      Ken.pop(i)\n                      break          \n      return pts\n  \n  \n  for caseNo in xrange(1, int(input())+1):\n      _ = input()\n      Naomi = sorted(map(float, input().split()))\n      Ken = sorted(map(float, input().split()))\n      print 'Case #%d:' % caseNo, deceitfulWar(Naomi, Ken), war(Naomi, Ken)\n      \n  \n  \n <CODESPLIT> 18
 \n  \n  data Test = Test {\n        cout     :: Double\n      , bonus    :: Double\n      , objectif :: Double\n      } deriving Show\n  \n  newtype Solution = Solution { temps :: Double }\n  \n  instance Show Solution where\n      show (Solution t) = show t\n  \n  main = do\n      interact (unlines . map showCase . zip [1..] . map resoudre . goTest . tail . lines)\n  \n    where\n      goTest [] = []\n      goTest (l:ls) =\n          let [c, f, x] = map read $ words l\n          in Test c f x : goTest ls\n  \n      showCase :: (Int, Solution) -> String\n      showCase (i, s) = printf "Case #%d: %s" i (show s)\n  \n  resoudre :: Test -> Solution\n  resoudre Test {..} | premierAchat > sansAchat = Solution sansAchat\n                     | otherwise                = go premierAchat 2\n    where\n      go t prod | tempsAvecAchat >= tempsSansAchat = Solution (t + tempsSansAchat)\n                | otherwise                        =\n                    go (t + delaiProchainAchat) prod'\n        where\n          prod' = prod + bonus\n  \n          tempsAvecAchat = objectif / prod'\n          tempsSansAchat = (objectif - cout) / prod\n  \n          delaiProchainAchat = cout / prod'\n  \n      premierAchat = cout / 2\n      sansAchat    = objectif / 2\n <CODESPLIT> 19
 \n  main = do\n      interact (unlines . map showCase . zip [1..] . map (solve . interval) . tail . lines)\n  \n    where\n      interval :: String -> (Int64, Int64)\n      interval l =\n          let [a, b] = map read $ splitOn " " l\n          in (a, b)\n  \n      showCase :: (Int64, Int) -> String\n      showCase (i, r) = printf "Case #%d: %d" i r\n  \n  solve :: (Int64, Int64) -> Int\n  solve (a, b) =\n      length $ takeWhile (<= b) $ dropWhile (< a) [ sq\n          | x <- [0..], palindrome x, let sq = x * x, palindrome sq\n          ]\n    where\n      square x = x * x\n      start = truncate $ sqrt $ double a\n  \n  -- | Returns True if s is a palindrome.\n  palindrome s =\n      let s' = show s\n      in s' == reverse s'\n  \n  double :: Int64 -> Double\n  double = fromIntegral\n <CODESPLIT> 19
 \n  main = interact (unlines . map showCase . zip [1..] . tail . lines)\n    where\n      showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t\n  \n  solve = show . solve' . map read . words\n    where\n      solve' (n:s:p:ts) = \n          let pts = map maxPoints ts\n              directs = filter ((>= p) . fst) pts\n              surps = filter (\(pd, ps) -> pd < p && ps >= p) pts\n          in length directs + min (length surps) s\n          \n  maxPoints :: Int -> (Int, Int)\n  maxPoints tot = \n      (maxScore $ scores normal, maxScore $ scores surprising)\n    where\n      scores cond = [ (x, y, z) |\n          x <- [0..10], y <- [0..10], z <- [0..10]\n          , x + y + z == tot, cond (x, y, z)\n          ]\n      normal t = bestScore t - badScore t <= 1\n      surprising t = bestScore t - badScore t <= 2\n      maxScore = maximum . map bestScore \n  \n  bestScore (x, y, z) = maximum [x, y, z]\n  badScore (x, y, z) = minimum [x, y, z]\n <CODESPLIT> 19
 \n  main = do\n      interact (unlines . map showCase . zip [1..] . go . tail . lines)\n  \n    where\n      go :: [String] -> [Bool]\n      go []     = []\n      go (l:ls) =\n          let [h, w] = map read $ splitOn " " l\n              (ls', ls'') = splitAt h ls\n              table = map (map read . splitOn " ") ls'\n          in solve h w table : go ls''\n  \n      showCase :: (Int, Bool) -> String\n      showCase (i, r) = printf "Case #%d: %s" i (if r then "YES" else "NO")\n  \n  solve :: Int -> Int -> [[Int]] -> Bool\n  solve h w table = and [ cell >= (maxLgn ! y) || cell >= (maxCol ! x)\n      | y <- [0..h-1], x <- [0..w-1], let cell = arr ! (y, x)\n      ]\n    where\n      arr :: Array (Int, Int) Int\n      arr = listArray ((0, 0), (h-1, w-1)) $ concat table\n  \n      maxLgn, maxCol :: Array Int Int\n      maxLgn = listArray (0, h-1) $ [ maximum [ arr ! (y, x) | x <- [0..w-1] ]\n          | y <- [0..h-1]\n          ]\n  \n      maxCol = listArray (0, w-1) $ [ maximum [ arr ! (y, x) | y <- [0..h-1] ]\n          | x <- [0..w-1]\n          ]\n <CODESPLIT> 19
 \n  \n  main = interact (unlines . map showCase . zip [1..] . tail . lines)\n    where\n      showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t\n  \n  solve = show . solve'' . map read . words\n  solve' [a, b] = length [ () | \n          x <- [a..b]\n      , let digits = nDigits x, let lastY = min b (10^digits - 1)\n      , y <- [x+1..lastY]\n      , isRecycled x y digits\n      ]\n      \n  solve'' [a, b] = sum [ nRecycled | \n        x <- [a..b]\n      , let digits = nDigits x\n      , let nRecycled = length [ () |\n                y <- nub $ sort $ moves x digits\n              , y <= b, y > x\n              ]\n      ]\n  \n  isRecycled :: Int -> Int -> Int -> Bool\n  isRecycled n m digits = any (== n) (m : moves m digits)\n  \n  nDigits :: Int -> Int\n  nDigits n = nDigits' n 0\n    where\n      nDigits' 0 acc = acc\n      nDigits' x acc = nDigits' (x `div` 10) (acc+1)\n  \n  moves :: Int -> Int -> [Int]\n  moves n digits = [ dep n d digits | d <- [1..digits-1] ]\n  dep x d digits = x * 10^d `rem` (10^digits) + x `div` 10^(digits - d)\n <CODESPLIT> 19
t = int(input())\n  \n  def win(lines, player):\n      for y in range(0, 4):\n          count = 0\n          for x in range(0, 4):\n              if lines[y][x] in [player, 'T']:\n                  count += 1\n                  if count >= 4:\n                      return True\n              else:\n                  break\n  \n      for x in range(0, 4):\n          count = 0\n          for y in range(0, 4):\n              if lines[y][x] in [player, 'T']:\n                  count += 1\n                  if count >= 4:\n                      return True\n              else:\n                  break\n  \n      count = 0\n      for i in range(0, 4):\n          if lines[i][i] in [player, 'T']:\n              count += 1\n              if count >= 4:\n                  return True\n  \n      count = 0\n      for i in range(0, 4):\n          x = 3 - i\n          if lines[i][x] in [player, 'T']:\n              count += 1\n              if count >= 4:\n                  return True\n  \n      return False\n  \n  for i in range(0, t):\n      lines = []\n      for j in range(0, 4):\n          lines.append(input())\n      input()\n  \n      if win(lines, 'X'):\n          sol = "X won"\n      elif win(lines, 'O'):\n          sol = "O won"\n      else:\n          void = False\n          for y in range(0, 4):\n              if any(c == '.' for c in lines[y]):\n                  void = True\n                  break\n  \n          if void:\n              sol = "Game has not completed"\n          else:\n              sol = "Draw"\n  \n  \n      print ("Case #"+str(i+1)+": "+sol)\n <CODESPLIT> 19
 \n  alphabet = [(' ',' '),('a','y'),('b','h'),('c','e'),('d','s'),('e','o') \n      ,('f','c'),('g','v'),('h','x'),('i','d'),('j','u'),('k','i'),('l','g')\n      ,('m','l'),('n','b'),('o','k'),('p','r'),('q','z'),('r','t'),('s','n')\n      ,('t','w'),('u','j'),('v','p'),('w','f'),('x','m'),('y','a'),('z', 'q')\n      ]\n  \n  main = interact (unlines . map showCase . zip [1..] . tail . lines)\n    where\n      showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t\n  \n  solve = map (fromJust . flip lookup alphabet)\n <CODESPLIT> 19
 \n  \n  data Test = Test {\n        joueur     :: [Double]\n      , adversaire :: [Double]\n      } deriving Show\n  \n  data Solution = Solution Int Int\n  \n  instance Show Solution where\n      show (Solution a b) = show a ++ " " ++ show b\n  \n  main = do\n      interact (unlines . map showCase . zip [1..] . map resoudre . goTest . tail . lines)\n  \n    where\n      goTest [] = []\n      goTest (_:js:as:ls) =\n          Test (map read $ words js) (map read $ words as) : goTest ls\n  \n      showCase :: (Int, Solution) -> String\n      showCase (i, s) = printf "Case #%d: %s" i (show s)\n  \n  resoudre :: Test -> Solution\n  resoudre Test {..} =\n      let jou    = S.fromList joueur\n          adv    = S.fromList adversaire\n          war    = goWar adv (sort joueur)\n          deceit = goDeceit (reverse $ sort adversaire) jou\n      in Solution deceit war\n    where\n      goWar _   []     = 0\n      goWar adv (j:js) =\n          case S.lookupGT j adv of\n              Just e  -> goWar (S.delete e adv)               js     -- Perd ce jeu\n              Nothing -> goWar (S.delete (S.findMin adv) adv) js + 1 -- Gagne ce jeu\n  \n      goDeceit []     _   = 0\n      goDeceit (a:as) jou =\n          -- Premire tape : tente d'liminer le plus gros chiffre restant de\n          -- l'adversaire.\n          case S.lookupGT a jou of\n              Just e  ->\n                  -- Elimine le plus gros pion de l'adversaire et gagne.\n                  goDeceit as (S.delete e jou) + 1\n              Nothing ->\n                  -- Deuxime tape: incapable de l'liminer, sacrifie un\n                  -- point en forcant l'adversaire  jouer ce pion, en\n                  -- utilisant le plus petit point et en mentant sur son\n                  -- poids.\n                  let minJou = S.findMin jou\n                  in goDeceit as (S.delete minJou jou)\n <CODESPLIT> 19
def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def rfs(): return map(float, rstr().split())\n      c, f, x = rfs()\n      b = 2.0\n      if x <= c:\n          return x/b\n      t = 0\n      while True:\n          tf = x/(b+f) + c/b\n          tn = x/b\n          if tn <= tf:\n              return t + tn\n          t += c/b\n          b += f\n  \n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write("Case #%i: %.7f\n" % (i, CASE(IN)))\n  \n  if __name__ == "__main__":\n      RUN(sys.stdin, sys.stdout)\n <CODESPLIT> 20
 \n  def pal(s):\n      for i in xrange(len(s)/2):\n          if s[i] != s[-i-1]:\n              return False\n      return True\n  \n  def pal2(x, s):\n      return pal(s) and pal(str(x*x))\n  \n  def E(k):\n      return 10**k\n  \n  \n  def CREATE_DATABASE(MAX):\n      def init():\n          yield 1\n          yield 2\n          yield 3\n          yield 11\n          yield 22\n          for i in xrange(1, MAX):\n              yield 1*E(2*i) + 1\n              yield 1*E(2*i+1) + 1\n              yield 2*E(2*i) + 2\n              yield 2*E(2*i) + 2 + 1*E(i)\n              yield 2*E(2*i+1) + 2\n              \n              \n      heap = list(sorted(set(init())))\n      for i in heap:\n          print i\n      heapq.heapify(heap)\n      RES = []\n      try:\n          MAX_X = E(MAX)\n          print "MAX_X", MAX_X\n          while True:\n              x = heapq.heappop(heap)\n              RES.append(x)\n              if x == 3:\n                  continue\n              if x > MAX_X:\n                  break\n              s = str(x)\n              j = len(s) / 2\n              shift = 1 if len(s) == 2*j else 0\n              for i in xrange(j+1, MAX):\n                  n = E(2*i-shift) + 1 + E(i-j) * x\n                  if pal2(n,str(n)):\n                      heapq.heappush(heap, n)\n                  \n      except KeyboardInterrupt:\n          print "stopped while x is", x\n      with open("c.database", 'w') as f:\n          for i in sorted(RES + heap):\n              f.write("%i\n"%i)\n  \n  def READ_DATABASE():\n      with open("c.database", 'r') as f:\n          return sorted(map(lambda x: int(x.strip())**2, f))\n  DB = READ_DATABASE()\n  \n  def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def nrints(N): return [rints() for i in xrange(N)]\n      A, B = rints()\n      i = bisect_left(DB, A) \n      j = bisect_right(DB, B)\n      return j-i\n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n  \n  if __name__ == "__main__":\n      RUN(sys.stdin, sys.stdout)\n <CODESPLIT> 20
 \n  \n  \n  D1 = {} # no suprize\n  D2 = {} # surprize\n  for i in xrange(0, 31):\n      D1[i] = D2[i] = -1\n  \n  def precompute():\n      for a in xrange(0, 11):\n          for b in xrange(a, min(a+3,11)):\n              for c in xrange(b, min(a+3,11)):\n                  t = a+b+c\n                  assert a <= b <= c <= a+2 and c <= 11\n                  if c < a+2:\n                      D1[t] = max(D1[t], c)\n                  else: # that is, c == a+2, we have a suprize\n                      D2[t] = max(D2[t], c)\n  \n  \n  precompute()\n  \n  def case(S, P, ts):\n      res_n = 0\n      res_s = 0\n      for t in ts:\n          if D1[t] >= P:\n              res_n+=1\n          elif D2[t]>=P:\n              res_s+=1\n      return (res_n + min(res_s, S))\n  \n  \n  def solve(fin, fout):\n      T = int(fin.readline())\n      for t in xrange(T):\n          nums = map(int, fin.readline().strip().split(" "))\n          N, S, P = nums[:3]\n          ts = nums[3:]\n          assert len(ts) == N    \n          fout.write("Case #%i: %i\n" % (t+1, case(S,P,ts)) )\n      return True\n  \n  if __name__ == "__main__":\n      with open(sys.argv[1],'r') as fin:\n          with open(sys.argv[2], 'w') as fout:\n              solve(fin, fout)\n <CODESPLIT> 20
 \n  def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def nrints(N): return [rints() for i in xrange(N)]\n      N, M = rints()\n      A = nrints(N)\n      R = [max(row) for row in A]\n      C = [max(col) for col in izip(*A)]\n      for i, r in enumerate(R):\n          for j, c in enumerate(C):\n              if A[i][j] != min(r,c):\n                  return "NO"\n      return "YES"\n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n  \n  if __name__ == "__main__":\n      RUN(sys.stdin, sys.stdout)\n <CODESPLIT> 20
 F = {}\n  def f(x, _x, _min, _max):\n      if x < 10: \n          return set()\n      l = len(str(x)) -1\n      k = 10**l\n      res = set()\n      res.add(_x)\n      for i in xrange(l):\n          x = (x % 10) * k + x/10\n          if _min <= x <= _max and _x < x:\n              res.add(x)\n      res.remove(_x)\n      if res:\n          F[_x] = sorted(res)\n      return res\n  \n  def compute_F(B):\n      for i in xrange(0, B+1):\n          f(i,i, 0, B+1)\n      with open("picle",'wb') as _file:\n          cPickle.dump( F, _file)\n  \n  \n  \n  t_start = time.time()\n  print "loading..."\n  with open("picle",'rb') as _file:\n      F = cPickle.load(_file)\n  print "done in %.2fs" % (time.time() - t_start)\n  print "loaded F with %i keys" % len(F)\n  \n  def case(A, B):\n      print "XXXXXXXXX ", A, B\n      res = 0\n      res2 = 0\n      for i in xrange(A, B):\n          l = F.get(i, [])\n  \n          for x in l:\n             if x <= B:\n                 res += 1\n      return res\n  \n  def solve(fin, fout):\n      T = int(fin.readline())\n      for t in xrange(T):\n          A, B = map(int, fin.readline().strip().split(" "))\n          assert A <= B\n          fout.write("Case #%i: %i\n" % (t+1, case(A,B)) )\n      return True\n  \n  if __name__ == "__main__":\n      with open(sys.argv[1],'r') as fin:\n          with open(sys.argv[2], 'w') as fout:\n              solve(fin, fout)\n <CODESPLIT> 20
def test_win(M, c):\n      N = len(M)\n      def yielder():\n          for row in M:\n              yield row, 'row'\n          for i in xrange(N):\n              yield [row[i] for row in M], 'col'\n          yield [M[i][i] for i in xrange(N)], 'd1'\n          yield [M[i][N-i-1] for i in xrange(N)], 'd2'\n      for lst, typ in yielder():\n          if all(l == c or l == 'T' for l in lst):\n              return True\n      return False\n  \n  def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      M = [rstr() for i in xrange(4)]\n      rstr()\n      if test_win(M, 'X'):\n          return 'X won'\n      if test_win(M, 'O'):\n          return 'O won'\n      if any('.' in row for row in M):\n          return 'Game has not completed'\n      return 'Draw'\n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n  \n  if __name__ == "__main__":\n      RUN(sys.stdin, sys.stdout)\n <CODESPLIT> 20
 \n  IN = """\n  ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv"""\n  OUT ="""\n  Case #1: our language is impossible to understand\n  Case #2: there are twenty six factorial possibilities\n  Case #3: so it is okay if you want to just give up"""\n  \n  ins = IN.strip().split("\n")\n  outs = OUT.strip().split("\n")\n  assert len(ins) == len(outs) == 3\n  \n  D = {}\n  D['a'] = 'y'\n  D['o'] = 'e'\n  D['z'] = 'q'\n  \n  for case, s in enumerate(ins):\n      out = outs[case][9:] # skip "Case #?: "\n      assert len(out) == len(s)\n      for i, o in enumerate(out):\n          if o == ' ': continue\n          D[s[i]] = o\n  \n  if len(D) == 25:\n      chars = map(chr, xrange(97, 123))\n      key = set(chars).difference( set(D.keys()) ).pop()\n      value = set(chars).difference( set(D.values()) ).pop()\n      D[key] = value\n  assert len(D) == 26\n  D[' '] = ' '\n  \n  \n  def solve(fin, fout):\n      T = int(fin.readline())\n      for t in xrange(T):\n          fout.write("Case #%i: " % (t+1) )\n          for c in fin.readline().strip():\n              fout.write(D[c])\n          fout.write('\n')\n      return True\n  \n  if __name__ == "__main__":\n      with open(sys.argv[1],'r') as fin:\n          with open(sys.argv[2], 'w') as fout:\n              solve(fin, fout)\n <CODESPLIT> 20
def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rfs(): return map(float, rstr().split())\n      N = rint()\n      A = sorted(rfs())\n      B = sorted(rfs())\n      dwar = solve(N, A, B)\n      war = N - solve(N, B, A)\n      return "%i %i" % (dwar, war)\n  \n  \n  def solve(N, A, B):\n      i, j = 0, 0\n      while True:\n          while j < N and A[j] < B[i]:\n              j += 1\n          if j == N:\n              return i\n          i += 1\n          j += 1\n  \n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n  \n  if __name__ == "__main__":\n      RUN(sys.stdin, sys.stdout)\n <CODESPLIT> 20
 \n  \n  \n  class Cookie_2014_QB(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\n  \n      self.T = None\n  \n    def load(self):\n      """\n        input:\n  \n        T (number of test cases)\n  \n        C F X (real numbers)\n  \n      """\n  \n      self.tests = []\n  \n      with open(self.inputFilename, "rt") as file:\n        self.T = int(file.readline().strip())\n  \n        for i in xrange(self.T):\n          (C,F,X) = [float(x) for x in file.readline().split(' ')]\n  \n          self.tests.append([C,F,X])\n  \n      return True\n  \n    def timeToNextFarm(self, C, rate):\n      """\n        How long in seconds until we get the next farm.\n      """\n  \n      return (C * 1.0) / rate\n  \n    def timeToTarget(self, C, X, rate):\n      """\n        How long in seconds until we hit the target.\n      """\n  \n      return ( X * 1.0) / rate\n  \n    def isFarmWorthIt(self, C, X, F, rate):\n  \n      withoutFarm = self.timeToTarget(C, X, rate)\n      withFarm = self.timeToNextFarm(C, rate) + self.timeToTarget(C, X, rate + F)\n  \n  \n      if (withFarm < withoutFarm):\n        return True\n      else:\n        return False\n  \n    def executeTest(self, test):\n      """\n        Run a test and return output.\n      """\n  \n      (C,F,X) = test\n      rate = 2\n      elapsed = 0.0\n  \n  \n      while True:\n        if self.isFarmWorthIt(C, X, F, rate):\n          elapsed = elapsed + self.timeToNextFarm(C, rate)\n          rate = rate + F\n        else:\n          elapsed = elapsed + self.timeToTarget(C, X, rate)\n          return "%0.7f" % (elapsed, )\n  \n  with Cookie_2014_QB(sys.argv[1]) as problem:\n    problem.load()\n  \n    problem.run()\n <CODESPLIT> 21
 \n  \n  def readfile(file):\n    """\n      input:\n  \n  		T (number of test cases)\n  \n  		A B\n  \n    """\n  \n    tests = []\n  \n    T = int(file.readline().strip())\n  \n    for i in xrange(T):\n  		test = {}\n  \n  		line = file.readline().strip()\n  		parts = line.split(" ")\n  \n  		if len(parts) != 2:\n  			print "HORRIBLE ERROR IN TEST CASE %d" % (i+1,)\n  			return None\n  \n  		test['A'] = int(parts[0])\n  		test['B'] = int(parts[1])\n      \n  		tests.append(test)\n  \n    return tests\n  \n  def isPalindrome(s):\n  	"""\n  		Is s a palindrome.\n  \n  		S must be a string.\n  	"""\n  \n  	l = len(s)\n  \n  	if (l % 2) == 0:\n  		frontHalf = s[0:l/2]\n  		backHalf = s[l/2:]\n  	else:\n  		frontHalf = s[0:(l-1)/2]\n  		backHalf = s[(l+1)/2:]\n  \n  	backHalf = backHalf[::-1]\n  \n  	if frontHalf == backHalf:\n  		return True\n  	else:\n  		return False\n  \n  def isFairAndSquare(n):\n  \n  	sqrtN = int(math.sqrt(n))\n  \n  	if (sqrtN * sqrtN) != n:\n  		return False\n  \n  	if not isPalindrome(str(n)):\n  		return False\n  \n  	if not isPalindrome(str(sqrtN)):\n  		return False\n  \n  	return True\n  \n  def run(test):\n  	"""\n  		Run a test and return output.\n  	"""\n  \n  	count = 0\n  \n  	for i in xrange(test['A'], test['B'] + 1):\n  		if isFairAndSquare(i):\n  			count = count + 1\n  \n  	return count\n  \n  	i = int(math.sqrt(test['A']))\n  \n  	if (i * i) < test['A']:\n  		i = i + 1\n  \n  	while i < test['B']:\n  		if not isPalindrome(str(i)):\n  			i = i + 1\n  			continue\n  \n  		s = i * i\n  \n  		if s <= test['B']:\n  			if isPalindrome(str(s)):\n  				count = count + 1\n  		else:\n  			break\n  \n  		i = i + 1\n  \n  	return "%s" % (count, )\n  \n  file = open(sys.argv[1], "rt")\n  \n  tests = readfile(file)\n  \n  file.close()\n  \n  case = 1\n  \n  for test in tests:\n    result = run(test)\n    print "Case #%d: %s" % (case, result)\n    case = case + 1\n <CODESPLIT> 21
 \n  def readfile(filename):\n  	"""\n  		The first line of the input gives the number of test\n  		cases, T. T test cases follow. Each test case consists of\n  		a single line containing integers separated by single\n  		spaces. The first integer will be N, the number of\n  		Googlers, and the second integer will be S, the number\n  		of surprising triplets of scores. The third integer will\n  		be p, as described above. Next will be N integers ti:\n  		the total points of the Googlers.\n  	"""\n  \n  	file = open(filename, "rt")\n  \n  	retval = {}\n  \n  	T = int(file.readline().strip())\n  	retval['T'] = T\n  \n  	tests = []\n  \n  	for i in xrange(T):\n  		line = file.readline().strip()\n  \n  		parts = line.split(" ")\n  \n  		N = int(parts[0])\n  		S = int(parts[1])\n  		p = int(parts[2])\n  		t = []\n  \n  		for j in xrange(N):\n  			t = t + [int(parts[3 + j]), ]\n  \n  		test = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n  		tests = tests + [test, ]\n  \n  	retval['tests'] = tests\n  	return retval\n  \n  def spread(triplet):\n  	return max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))\n  \n  def bestresult(triplet):\n  	if triplet:\n  		return max(triplet)\n  	return 0\n  \n  def getcombos(points):\n  	"""\n  		Returns ([unsurprising possibilities, ], [surprising possibilities])\n  	"""\n  \n  	unsurps = []\n  	surps = []\n  \n  	avg = points / 3.0\n  \n  	avg = int(avg)\n  \n  	tested = []\n  \n  	for i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  		for j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  			for k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  				if (i + j + k) != points:\n  					continue\n  \n  				scores = (i,j,k)\n  				scores = sorted(scores)\n  \n  				if scores in tested:\n  					continue\n  				tested.append(scores)\n  \n  				s = spread((i,j,k))\n  \n  				if (s < 2):\n  					unsurps.append(scores)\n  				elif (s == 2):\n  					surps.append(scores)\n  				else:\n  					continue\n  \n  	return (unsurps, surps)\n  \n  def getbesttriplet(triplets):\n  	best = None\n  \n  	for i in triplets:\n  		if best:\n  			if (bestresult(i) > bestresult(best)):\n  				best = i\n  		else:\n  			best = i\n  \n  	return best\n  	\n  \n  def getmulticombos(peeps):\n  	"""\n  		Return the best surprising and non-surprising possibility for\n  		each person.\n  	"""\n  \n  	ret = []\n  \n  	for p in peeps:\n  		u,s = getcombos(p)\n  \n  		bestu = getbesttriplet(u)\n  		bests = getbesttriplet(s)\n  \n  		ret.append((bestu, bests))\n  \n  	return ret\n  \n  def getbestresults(scores, best, numsur):\n  	"""\n  		Figure out the maximum number of people that could have gotten\n  		a single score >= best.  Limited to choosing only numsur surprising\n  		triplets.\n  	"""\n  \n  	peeps = getmulticombos(scores)\n  \n  	count = 0\n  	surcount = 0\n  \n  	for p in peeps:\n  		if (bestresult(p[0]) >= best):\n  			count = count + 1\n  		elif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n  			count = count + 1\n  			surcount = surcount + 1\n  \n  	return count\n  \n  def process(test):\n  	N = test['N']\n  	S = test['S']\n  	p = test['p']\n  	t = test['t']\n  \n  	return getbestresults(t, p, S)\n  \n  data = readfile("B-small-attempt0.in")\n  \n  for i in xrange(data['T']):\n  	test = data['tests'][i]\n  \n  	result = process(test)\n  \n  	print "Case #%d: %d" % (i+1, result)\n <CODESPLIT> 21
 \n  \n  def readfile(file):\n    """\n      input:\n  \n  		T (number of test cases)\n  \n  		N M\n  		N lines of M numbers (desired height of grass)\n  \n    """\n  \n    tests = []\n  \n    T = int(file.readline().strip())\n  \n    for i in xrange(T):\n  		test = {}\n  \n  		line = file.readline().strip()\n  		parts = line.split(' ')\n  \n  		if len(parts) != 2:\n  			print "HORRIBLE ERROR in TEST %d!" % (i+1, )\n  			return None\n  \n  		N = int(parts[0])\n  		M = int(parts[1])\n  \n  		test['N'] = N\n  		test['M'] = M\n  		test['desired'] = []\n      \n  		for j in xrange(N):\n  			line = file.readline().strip()\n  			parts = line.split(' ')\n  \n  			if len(parts) != M:\n  				print "TERRIBLE ERROR in TEST %d!" % (i+1, )\n  				return None\n  \n  			for p in parts:\n  				k = int(p)\n  				test['desired'].append(k)\n  \n  		tests.append(test)\n  \n    return tests\n  \n  def run(test):\n  	"""\n  		Run a test and return output.\n  	"""\n  \n  	test['row'] = []\n  	test['col'] = []\n  \n  	for row in xrange(test['N']):\n  		r = []\n  \n  		for col in xrange(test['M']):\n  			i = row * test['M'] + col\n  \n  			r.append(test['desired'][i])\n  \n  		test['row'].append({'min' : min(r), 'max' : max(r)})\n  \n  	for col in xrange(test['M']):\n  		c = []\n  \n  		for row in xrange(test['N']):\n  			i = row * test['M'] + col\n  \n  			c.append(test['desired'][i])\n  \n  		test['col'].append({'min' : min(c), 'max' : max(c)})\n  \n  	for x in xrange(test['M']):\n  		for y in xrange(test['N']):\n  			i = y * test['M'] + x\n  			v = test['desired'][i]\n  \n  			rowmax = test['row'][y]['max']\n  			colmax = test['col'][x]['max']\n  			if (v < rowmax) and (v < colmax):\n  				return "NO"\n  \n  	return "YES"\n  \n  file = open(sys.argv[1], "rt")\n  \n  tests = readfile(file)\n  \n  file.close()\n  \n  case = 1\n  \n  for test in tests:\n    result = run(test)\n    print "Case #%d: %s" % (case, result)\n    case = case + 1\n <CODESPLIT> 21
 \n  def readfile(filename):\n  	"""\n  	The first line of the input gives the number of test cases,\n  	T. T test cases follow. Each test case consists of a single line\n  	containing the integers A and B.\n  	"""\n  \n  	file = open(filename, "rt")\n  \n  	retval = {}\n  \n  	T = int(file.readline().strip())\n  	retval['T'] = T\n  \n  	tests = []\n  \n  	for i in xrange(T):\n  		line = file.readline().strip()\n  \n  		parts = line.split(" ")\n  \n  		A = int(parts[0])\n  		B = int(parts[1])\n  \n  		test = {'A' : A, 'B' : B}\n  \n  		tests = tests + [test, ]\n  \n  	retval['tests'] = tests\n  \n  	return retval\n  \n  def isrecycled(n, m):\n  	if (len(n) != len(m)):\n  		return False\n  \n  	for i in range(len(n)):\n  		left = n[:i]\n  		right = n[i:]\n  \n  		flip = right + left\n  \n  		if (flip == m):\n  			return True\n  \n  	return False\n  \n  def process(test):\n  	count = 0\n  \n  	A = test['A']\n  	B = test['B']\n  \n  	for n in xrange(A, B):\n  		for m in xrange(n + 1, B):\n  			if (isrecycled(str(n), str(m))):\n  				count = count + 1\n  \n  	return count\n  \n  def process2(test):\n  	count = 0\n  \n  	A = test['A']\n  	B = test['B']\n  \n  	for n in xrange(A, B):\n  		v = str(n)\n  \n  		found = set()\n  \n  		for i in xrange(len(v)):\n  			left = v[:i]\n  			right = v[i:]\n  \n  			flip = right + left\n  			iflip = int(flip)\n  \n  			if ((iflip > n) and (iflip <= B)):\n  				if (not iflip in found):\n  					count = count + 1\n  					found.add(iflip)\n  \n  	return count\n  \n  data = readfile("C-small-attempt0.in")\n  \n  for i in xrange(data['T']):\n  	test = data['tests'][i]\n  \n  	result = process2(test)\n  \n  	print "Case #%d: %d" % (i + 1, result)\n <CODESPLIT> 21
 \n  \n  def readfile(file):\n    """\n      input:\n  \n  		T (number of test cases)\n  \n  		xxxx\n  		xxxx\n  		xxxx\n  		xxxx	(T boards, where x in [X,O,T,.]\n  \n    """\n  \n    tests = []\n  \n    T = int(file.readline().strip())\n  \n    for i in xrange(T):\n  		board = ""\n      \n  		for j in xrange(4):\n  			line = file.readline().strip()\n  \n  			board = board + line\n  \n  		file.readline()\n  \n  		tests.append(board)\n  \n    return tests\n  \n  def fourInARow(who, test):\n  	"""\n  		Find four of 'who' in a row (T wild).\n  	"""\n  \n  	target = (who, 'T')\n  \n  	for i in range(4):\n  		horzWin = True\n  		vertWin = True\n  \n  		for j in range(4):\n  			horzIndex = i * 4 + j\n  			vertIndex = j * 4 + i\n  \n  			if not (test[horzIndex] in target):\n  				horzWin = False\n  \n  			if not (test[vertIndex] in target):\n  				vertWin = False\n  \n  		if horzWin or vertWin:\n  			return True\n  \n  	slashWin = True\n  	bslashWin = True\n  \n  	for i in range(4):\n  		x = y = i\n  \n  		slashIndex = y * 4 + x\n  		bslashIndex = y * 4 + (3 - x)\n  \n  \n  		if not (test[slashIndex] in target):\n  			slashWin = False\n  \n  		if not (test[bslashIndex] in target):\n  			bslashWin = False\n  \n  	if slashWin or bslashWin:\n  		return True\n  \n  	return False\n  \n  def run(test):\n  	"""\n  		Run a test and return output.\n  	"""\n  \n  	if fourInARow('X', test):\n  		return "X won"\n  	elif fourInARow('O', test):\n  		return "O won"\n  	elif '.' in test:\n  		return "Game has not completed"\n  	else:\n  		return "Draw"\n  \n  file = open(sys.argv[1], "rt")\n  \n  tests = readfile(file)\n  \n  file.close()\n  \n  case = 1\n  \n  for test in tests:\n    result = run(test)\n    print "Case #%d: %s" % (case, result)\n    case = case + 1\n <CODESPLIT> 21
 \n  \n  input = "aoz"\n  outpt = "yeq"\n  \n  input = input + "our language is impossible to understand"\n  outpt = outpt + "ejp mysljylc kd kxveddknmc re jsicpdrysi"\n  \n  input = input + "there are twenty six factorial possibilities"\n  outpt = outpt + "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"\n  \n  input = input + "so it is okay if you want to just give up"\n  outpt = outpt + "de kr kd eoya kw aej tysr re ujdr lkgc jv"\n  \n  input = input + "q"\n  outpt = outpt + "z"\n  \n  togoog = maketrans(input, outpt)\n  ungoog = maketrans(outpt, input)\n  \n  filename = "A-small-attempt1.in"\n  \n  file = open(filename, "rt")\n  \n  T = int(file.readline().strip())\n  \n  for i in xrange(T):\n  	line = file.readline().strip()\n  \n  	print "Case #%d: %s" % (i + 1, line.translate(ungoog))\n <CODESPLIT> 21
 \n  \n  \n  class War_2014_QD(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\n  \n      self.T = None\n  \n    def load(self):\n      """\n        input:\n  \n        T (number of test cases)\n  \n        N (number of blocks)\n        N1 N2 N3 ... (mass of Naomi's blocks, real)\n        K1 K2 K3 ... (mass of Ken's blocks, real)\n  \n      """\n  \n      self.tests = []\n  \n      with open(self.inputFilename, "rt") as file:\n        self.T = int(file.readline().strip())\n  \n        for i in xrange(self.T):\n          N = int(file.readline().strip())\n          naomi = [float(x) for x in file.readline().split(' ')]\n          ken = [float(x) for x in file.readline().split(' ')]\n  \n          test = {'N': N, 'Naomi': naomi, 'Ken': ken}\n  \n          self.tests.append(test)\n  \n      return True\n  \n    def playWar(self, naomi, ken):\n      """\n        How many points does naomi get when playing standard War?\n      """\n  \n      if (len(naomi) <= 0):\n        return 0\n  \n      maxN = max(naomi)\n  \n      maxK = max(ken)\n  \n      if maxK > maxN:\n        k = min([x for x in ken if x > maxN])\n  \n  \n        naomi.remove(maxN)\n        ken.remove(k)\n  \n        return 0 + self.playWar(naomi, ken)\n      else:\n        k = min(ken)\n  \n  \n        naomi.remove(maxN)\n        ken.remove(k)\n  \n        return 1 + self.playWar(naomi, ken)\n  \n    def playDWar(self, naomi, ken):\n      """\n        How many points does naomi get when playing decietful war?\n      """\n  \n      if (len(naomi) <= 0):\n        return 0\n  \n      minN = min(naomi)\n      minK = min(ken)\n      maxK = max(ken)\n  \n      if (minN < minK):\n        naomi.remove(minN)\n        ken.remove(maxK)\n        return 0 + self.playDWar(naomi, ken)\n  \n      naomi.remove(minN)\n      ken.remove(minK)\n      return 1 + self.playDWar(naomi, ken)\n  \n    def executeTest(self, test):\n      """\n        Run a test and return output.\n      """\n  \n      dwar = self.playDWar(list(test['Naomi']), list(test['Ken']))\n      war = self.playWar(list(test['Naomi']), list(test['Ken']))\n      return "%d %d" % (dwar, war)\n  \n  with War_2014_QD(sys.argv[1]) as problem:\n    problem.load()\n  \n    problem.run()\n <CODESPLIT> 21
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      data = f.readline().split()\n      C = Decimal(data[0])\n      F = Decimal(data[1])\n      X = Decimal(data[2])\n      curr_rate = Decimal(2)\n      best_time = Decimal(10**100)\n      curr_time = Decimal(0)\n      while curr_time < best_time:\n          poss_finish_time = curr_time + X / curr_rate\n          if poss_finish_time < best_time:\n              best_time = poss_finish_time\n  \n          curr_time += C / curr_rate\n          curr_rate += F\n  \n      print "Case #%d: %.7f" % (test + 1, best_time)\n <CODESPLIT> 22
 \n  def get_generators_up_to_length_n(n):\n      generators = []\n      for ii in range(1, n + 1):\n          generators += get_generators_length_n(ii)\n      return generators        \n  \n  def get_generators_length_n(length):\n      if length % 2 == 0: return get_even_generators_length_n(length)\n      else: return get_odd_generators_length_n(length)\n  \n  def get_odd_generators_length_n(length):\n      if length == 1: return [1, 2, 3]\n      else: \n          n = length / 2\n          generators = []\n          for ii in range(min(n, 4)):\n              for comb in itertools.combinations(range(1, n), ii):\n                  first_half = ["1"] + ["0"] * (n-1)\n                  for jj in comb:\n                      first_half[jj] = "1"\n                  second_half = list(first_half)\n                  second_half.reverse()\n                  palin = first_half + ["0"] + second_half\n                  generators.append(int("".join([elem for elem in palin])))\n                  palin[n] = "1"\n                  generators.append(int("".join([elem for elem in palin])))\n                  if ii <= 1:\n                      palin[n] = "2"\n                      generators.append(int("".join([elem for elem in palin])))\n          generators.append(int("".join([elem for elem in (["2"] + ["0"] * (n - 1) + ["0"] + ["0"] * (n - 1) + ["2"])])))\n          generators.append(int("".join([elem for elem in (["2"] + ["0"] * (n - 1) + ["1"] + ["0"] * (n - 1) + ["2"])])))\n          generators.sort()\n          return generators\n  \n  def get_even_generators_length_n(length):\n      if length == 2: return [11, 22]\n      n = length / 2\n      generators = []\n      for ii in range(min(n, 4)):\n          for comb in itertools.combinations(range(1, n), ii):\n              first_half = ["1"] + ["0"] * (n-1)\n              for jj in comb:\n                  first_half[jj] = "1"\n              second_half = list(first_half)\n              second_half.reverse()\n              palin = first_half + second_half\n              generators.append(int("".join([elem for elem in palin])))\n      generators.append(int("".join([elem for elem in (["2"] + ["0"] * (length - 2) + ["2"])])))\n      generators.sort()\n      return generators\n  \n  def is_palin(num):\n      string = str(num)\n      length = len(string)\n      ii = 0\n      while ii < length/2:\n          if string[ii] != string[-(1+ii)]:\n              return False\n          ii += 1\n      return True\n  \n  def gen_fair_and_squares(upper_limit):\n      fair_and_squares = []\n      for ii in range(1, upper_limit + 1):\n          if (is_palin(ii) and is_palin(ii*ii)):\n              fair_and_squares.append(ii)\n      return fair_and_squares\n  \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  gens = get_generators_up_to_length_n(60)\n  squares = map(lambda x: x*x, gens)\n  \n  for t in range(T):\n      A, B = map(int, f.readline().strip().split())\n      total = 0\n      for elem in squares:\n          assert(is_palin(elem))\n          if elem >= A and elem <= B: total += 1\n          if elem > B:\n              break\n  \n      print "Case #%d:" % (t + 1), total\n <CODESPLIT> 22
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      temp = map(int, f.readline().split())\n      N = temp[0]\n      S = temp[1]\n      p = temp[2]\n      scores = temp[3:]\n      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))\n      if (p<=1):\n          surprising_scores = 0\n      else:\n          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))\n      num_scores = non_surprising_scores + min(surprising_scores, S)   \n      print "Case #%d:" % (t + 1), num_scores\n <CODESPLIT> 22
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      N, M = map(int, f.readline().strip().split())\n      grass_lengths = []\n      for nn in range(N):\n          grass_lengths.append(map(int, f.readline().strip().split())) # Read in all grass heights\n  \n      x_max = [0] * M\n      y_max = [0] * N\n      for xx in range(M):\n          for yy in range(N):\n              height = grass_lengths[yy][xx]\n              x_max[xx] = max(x_max[xx], height)  # Update the max required height for column x\n              y_max[yy] = max(y_max[yy], height)  # Update the max required height for row y\n  \n      impossible = False\n      for xx in range(M):\n          for yy in range(N):\n              height = grass_lengths[yy][xx]\n              if (x_max[xx] > height and y_max[yy] > height): # Can we cut this row down to this level?\n                  impossible = True\n  \n      print "Case #%d:" % (t + 1), "NO" if impossible else "YES"\n <CODESPLIT> 22
 \n  def recycle(num):\n      x = str(num)\n      recycles = []\n      for ii in range(1, len(x)):\n          recycles.append(x[ii:] + x[:ii])    \n      return recycles\n  \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      A, B = map(int, f.readline().split())\n      total = 0\n      debugs = []\n      for ii in range(A,B):\n          recycles_ii = recycle(ii)\n          recycles_ii = (filter(lambda x: int(x) > ii and int(x) <= B, recycles_ii))\n          total += len(recycles_ii)\n          for elem in recycles_ii:\n              debugs.append((ii, int(elem)))   \n      print "Case #%d:" % (t + 1), len(set(debugs))\n <CODESPLIT> 22
 \n  def hasWon(game, player):\n      for ii in range(4):\n          success = True\n          for jj in range(4): # Has the player won in row ii\n              if game[4*ii + jj] != player and game[4*ii + jj] != "T":\n                  success = False\n          if success: return True\n          success = True\n          for jj in range(4): # Has the player won in column ii\n              if game[4*jj + ii] != player and game[4*jj + ii] != "T":\n                  success = False\n          if success: return True\n      \n      success = True\n      for ii in range(4):\n          if game[ii*5] != player and game[ii*5] != "T":\n              success = False\n      if success: return True\n      success = True\n      for ii in range(4):\n          if game[3+ii*3] != player and game[3+ii*3] != "T":\n              success = False\n      if success: return True\n      return False\n  \n  def gameOver(game):\n      ret_val = True\n      for ii in range(16):\n          if game[ii] == ".":\n              ret_val = False\n      return ret_val\n  \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      game = []\n      for ii in range(4):\n          for elem in f.readline().strip():\n              game.append(elem)\n  \n      if hasWon(game, "O"):\n          print "Case #%d:" % (t + 1), "O won"\n      elif hasWon(game, "X"):\n          print "Case #%d:" % (t + 1), "X won"\n      elif gameOver(game):\n          print "Case #%d:" % (t + 1), "Draw"\n      else:\n          print "Case #%d:" % (t + 1), "Game has not completed"\n  \n      f.readline()\n <CODESPLIT> 22
 \n  def translate(letter):\n      input =  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n      output = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']\n      index = input.index(letter)\n      return output[index]\n  \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      string = []\n      A = f.readline().split()\n      for elem in A:\n          for ii in range(len(elem)):\n              string.append(translate(elem[ii]))\n          string.append(' ')           \n      print "Case #%d:" % (t + 1), ''.join(elem for elem in string)\n <CODESPLIT> 22
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      N = int(f.readline())\n      naomi_blocks = map(float, f.readline().strip().split(" "))\n      ken_blocks = map(float, f.readline().strip().split(" "))\n      naomi_blocks.sort()\n      ken_blocks.sort()\n      naomi_clone = list(naomi_blocks)\n      ken_clone = list(ken_blocks)\n  \n      naomi_standard_score = 0\n      while naomi_blocks != []:\n          naomi_new_val = naomi_blocks.pop()\n          if naomi_new_val > ken_blocks[-1]:\n              naomi_standard_score += 1\n              ken_blocks.pop(0)\n          else:\n              ii = 0\n              while ken_blocks[ii] < naomi_new_val:\n                  ii += 1\n              ken_blocks.pop(ii)\n  \n      assert(ken_blocks == [])\n  \n      naomi_blocks = naomi_clone\n      ken_blocks = ken_clone\n      naomi_blocks.sort(reverse=True)\n      ken_blocks.sort(reverse=True)\n      deceiving_strat_score = 0\n      while naomi_blocks != []:\n          naomi_new_val = naomi_blocks.pop()\n          if naomi_new_val > ken_blocks[-1]:\n              ken_blocks.pop()\n              deceiving_strat_score += 1\n  \n      print "Case #%d: " % (test + 1), deceiving_strat_score, naomi_standard_score\n  \n  \n  \n <CODESPLIT> 22
"""\n  Google Code Jam 2014 Qualification Problem B\n  Usage:\n      python b.py < input.txt > output.txt\n  """\n  \n  \n  def solve_problem(farm_cost, farm_rate, target):\n      rate = 2.0\n      farms = 0.0\n  \n      while (farms + target / rate) > (farms + farm_cost / rate + target / (rate + farm_rate)):\n          farms = farms + farm_cost / rate\n          rate = rate + farm_rate\n  \n      return farms + target / rate\n  \n  \n  if __name__ == "__main__":\n      num_of_cases = int(sys.stdin.readline().strip())\n      for i in xrange(1, num_of_cases + 1):\n          farm_cost, farm_rate, target = map(float, sys.stdin.readline().strip().split())\n          print "Case #{0}: {1:9.7f}".format(i, solve_problem(farm_cost, farm_rate, target))\n <CODESPLIT> 23
 \n  \n  def is_palindrome(a):\n      return str(a) == ''.join(reversed(str(a)))\n  \n  \n  def solve_problem(min_num, max_num):\n      count = 0\n      for i in xrange(min_num, max_num + 1):\n          if is_palindrome(i):\n              sqrt = math.sqrt(i)\n              if int(sqrt) == sqrt and is_palindrome(int(sqrt)):\n                  count += 1\n      return count\n  \n  \n  if __name__ == '__main__':\n      num_of_cases = int(sys.stdin.readline())\n      for i in xrange(1, num_of_cases + 1):\n          min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))\n          print 'Case #{0}: {1}'.format(i, solve_problem(min_num, max_num))\n <CODESPLIT> 23
"""\n  Google Code Jam 2012 Problem B\n  Usage:\n      python problem_b.py < input.txt > output.txt\n  """\n  \n  \n  def calc_possible(n):\n      combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores\n      return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)\n  \n  \n  def calc_surprising(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def calc_normal(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def solve_problem():\n      number_of_cases = int(sys.stdin.readline())\n  \n      for i in xrange(1, number_of_cases + 1):\n  \n          case = sys.stdin.readline().strip()\n          result = 0\n          num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)\n          num_of_googlers = int(num_of_googlers)\n          num_of_surprising = int(num_of_surprising)\n          desired_score = int(desired_score)\n          scores = map(int, scores.split())\n  \n          possible_scores = []\n  \n          for k in xrange(num_of_googlers):\n  \n              normal = calc_normal(scores[k])\n              surprising = calc_surprising(scores[k])\n  \n              possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))\n  \n          possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))\n          result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))\n  \n          sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n  \n  \n  if __name__ == '__main__':\n      solve_problem()\n <CODESPLIT> 23
 \n  \n  def solve_problem(lawn, size_x, size_y):\n      for i in xrange(size_x):\n          for k in xrange(size_y):\n              elem = lawn[i][k]\n              if max(lawn[i]) > elem and max([lawn[j][k] for j in xrange(size_x)]) > elem:\n                  return 'NO'\n  \n      return 'YES'\n  \n  def read_lawn(stdin, size_x, size_y):\n      lawn = []\n      for i in xrange(size_x):\n          line = map(int, sys.stdin.readline().strip().split(' '))\n          lawn.append(line)\n      return lawn\n  \n  \n  if __name__ == '__main__':\n      num_of_cases = int(sys.stdin.readline())\n      for i in xrange(1, num_of_cases + 1):\n          size_x, size_y = map(int, sys.stdin.readline().strip().split(' '))\n          lawn = read_lawn(sys.stdin, size_x, size_y)\n          print 'Case #{0}: {1}'.format(i, solve_problem(lawn, size_x, size_y))\n <CODESPLIT> 23
"""\n  Google Code Jam 2012 Problem C\n  Usage:\n      python problem_c.py < input.txt > output.txt\n  """\n  \n  \n  def is_recycled(n, m, _cache={}, _cache_sorted={}, _cache_length={}):\n      if not n in _cache:\n          _cache[n] = str(n)\n  \n      if not m in _cache:\n          _cache[m] = str(m)\n  \n      str_n = _cache[n]\n      str_m = _cache[m]\n  \n      if not n in _cache_sorted:\n          _cache_sorted[n] = sorted(str_n)\n  \n      if not m in _cache_sorted:\n          _cache_sorted[m] = sorted(str_m)\n  \n      if _cache_sorted[n] != _cache_sorted[m]:\n          return False\n  \n      if not n in _cache_length:\n          _cache_length[n] = len(str_n)\n  \n      for i in xrange(_cache_length[n] + 1):\n          if str_m == str_n[i:] + str_n[:i]:\n              return True\n  \n      return False\n  \n  \n  def solve_problem():\n      number_of_cases = int(sys.stdin.readline())\n  \n      for i in xrange(1, number_of_cases + 1):\n          case = sys.stdin.readline().strip()\n          A, B = map(int, case.split())\n          result = sum(itertools.imap(lambda (n, m): is_recycled(n, m),\n                                      itertools.combinations(xrange(A, B + 1), 2)))\n  \n          sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n  \n  if __name__ == '__main__':\n      solve_problem()\n <CODESPLIT> 23
 \n  \n  WINNING = (\n      set(['X']),\n      set(['O']),\n      set(['X', 'T']),\n      set(['O', 'T']),\n  )\n  \n  \n  def solve_problem(matrix):\n      game_completed = True\n  \n      lines_combo = (matrix[i] for i in xrange(4))\n      rows_combo = ((matrix[k][i] for k in xrange(4)) for i in xrange(4))\n      diagonals = ((matrix[i][i] for i in xrange(4)),\n                   (matrix[i][3 - i] for i in xrange(4)))\n  \n      for combo in itertools.chain(lines_combo, rows_combo, diagonals):\n          combo_set = set(combo)\n          if combo_set in WINNING:\n              if 'X' in combo_set:\n                  return 'X won'\n              if 'O' in combo_set:\n                  return 'O won'\n          if '.' in combo_set:\n              game_completed = False\n  \n  \n      if game_completed:\n          return 'Draw'\n      else:\n          return 'Game has not completed'\n  \n      return 0\n  \n  def read_matrix(stdin):\n      matrix = [[], [], [], []]\n      for i in xrange(4):\n          line = stdin.readline().strip()\n          for k in line:\n              matrix[i].append(k)\n      return matrix\n  \n  \n  if __name__ == '__main__':\n      num_of_cases = int(sys.stdin.readline())\n      for i in xrange(1, num_of_cases + 1):\n          matrix = read_matrix(sys.stdin)\n          print 'Case #{0}: {1}'.format(i, solve_problem(matrix))\n          sys.stdin.readline() # separator\n <CODESPLIT> 23
"""\n  Google Code Jam 2012 Problem A\n  Usage:\n      python problem_a.py < input.txt > output.txt\n  """\n  \n  hints = {\n      'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',\n      'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',\n      'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up',\n  }\n  \n  mapping = {'q': 'z', 'z': 'q'}\n  \n  for k, v in hints.items():\n      for from_char, to_char in zip(k, v):\n          mapping[from_char] = to_char\n  \n  def solve_problem():\n      number_of_cases = int(sys.stdin.readline())\n      for i in xrange(1, number_of_cases + 1):\n          case = sys.stdin.readline().strip()\n          translated = ''.join(map(lambda c: mapping.get(c, c), case))\n          sys.stdout.write('Case #{0}: {1}\n'.format(i, translated))\n  \n  if __name__ == '__main__':\n      solve_problem()\n <CODESPLIT> 23
"""\n  Google Code Jam 2014 Qualification Problem D\n  Usage:\n      python d.py < input.txt > output.txt\n  """\n  \n  \n  def memoized(func):\n      cache = {}\n      def wrapped(*args):\n          if not args in cache:\n              cache[args] = func(*args)\n          return cache[args]\n      return wrapped\n  \n  \n  @memoized\n  def play_dwar(naomi_blocks, ken_blocks):\n      if not naomi_blocks:\n          return 0\n  \n      max_score = 0\n  \n      for naomi_choice in naomi_blocks:\n          naomi_remaining = tuple(b for b in naomi_blocks if b != naomi_choice)\n  \n          ken_better = tuple(b for b in ken_blocks if b > naomi_choice)\n          ken_worse = tuple(b for b in ken_blocks if b < naomi_choice)\n  \n          if ken_better and not ken_worse:\n              ken_choice = max(ken_better)\n              ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)\n              score = 0 + play_dwar(naomi_remaining, ken_remaining)\n          else:\n              ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))\n              score = 1 + play_dwar(naomi_remaining, ken_remaining)\n  \n          max_score = max(max_score, score)\n  \n      return max_score\n  \n  \n  @memoized\n  def play_war(naomi_blocks, ken_blocks):\n      if not naomi_blocks:\n          return 0\n  \n      max_score = 0\n  \n      for naomi_choice in naomi_blocks:\n          naomi_remaining = tuple(b for b in naomi_blocks if b != naomi_choice)\n  \n          ken_better = tuple(b for b in ken_blocks if b > naomi_choice)\n  \n          if ken_better:\n              ken_choice = min(ken_better)\n              ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)\n              score = 0 + play_war(naomi_remaining, ken_remaining)\n          else:\n              ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))\n              score = 1 + play_war(naomi_remaining, ken_remaining)\n  \n          max_score = max(max_score, score)\n  \n      return max_score\n  \n  \n  def solve_problem(naomi_blocks, ken_blocks):\n      return play_dwar(naomi_blocks, ken_blocks), play_war(naomi_blocks, ken_blocks)\n  \n  \n  if __name__ == "__main__":\n      num_of_cases = int(sys.stdin.readline().strip())\n      for i in xrange(1, num_of_cases + 1):\n  \n          num_of_blocks = int(sys.stdin.readline().strip())\n  \n          naomi_blocks = tuple(map(float, sys.stdin.readline().strip().split()))\n          ken_blocks = tuple(map(float, sys.stdin.readline().strip().split()))\n  \n          print "Case #{0}: {1} {2}".format(i, *solve_problem(naomi_blocks, ken_blocks))\n <CODESPLIT> 23
 if len(sys.argv) == 1:\n      sys.stdin = open("B.in")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_floats(s):\n      return map(float, s.split())\n  \n  def get_floats():\n      return to_floats(raw_input())\n  \n  n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      farm_cost, farm_increase, goal = get_floats()\n  \n      best_time = float('inf')\n      time = 0.0\n      rate = 2.0\n      while time < best_time:\n          best_time = min(best_time, time + goal / rate)\n          time += farm_cost / rate\n          rate += farm_increase\n  \n      print "Case #%d: %.7f" % (case, best_time)\n <CODESPLIT> 24
 \n  n_cases = input()\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  for case in xrange(1, n_cases + 1):\n      a, b = to_ints(raw_input())\n  \n      nums = range(int(b ** .5) + 2)\n      palins = filter(is_palindrome, nums)\n      squares = [x**2 for x in palins]\n      palin_squares = filter(is_palindrome, squares)\n      range_squares = [x for x in palin_squares if a <= x <= b]\n  \n      print "Case #%d: %s" % (case, len(range_squares))\n <CODESPLIT> 24
n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      ins = map(int, raw_input().strip().split())\n      n = ins[0]\n      s = ins[1]\n      p = ins[2]\n      t = ins[3:]\n  \n      out = 0\n      for x in t:\n          if (x + 2) / 3 >= p:\n              out += 1\n          elif s and x > p and p - ((x - p) / 2) <= 2:\n              out += 1\n              s -= 1\n              \n      print "Case #%d: %s" % (case, out)\n <CODESPLIT> 24
 \n  n_cases = input()\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  for case in xrange(1, n_cases + 1):\n      ydim, xdim = to_ints(raw_input())\n      heights = [to_ints(raw_input()) for _ in xrange(ydim)]\n  \n      ymaxes = [max(row) for row in heights]\n      xmaxes = [max(col) for col in zip(*heights)]\n  \n  \n      poss = True\n  \n      for y in range(ydim):\n          for x in range(xdim):\n              height = heights[y][x]\n              if not (height == xmaxes[x] or height == ymaxes[y]):\n                  poss = False\n  \n  \n      print "Case #%d: %s" % (case, 'YES' if poss else 'NO')\n <CODESPLIT> 24
n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      a, b = map(int, raw_input().split())\n  \n      out = 0\n      e = 10 ** (len(str(a)) - 1)\n      for n in xrange(a, b):\n          s = str(n)\n          m = n\n          while True:\n              m = (m / 10) + (m % 10 * e)\n              if n < m <= b:\n                  out += 1\n              if m == n:\n                  break\n  \n      print "Case #%d: %s" % (case, out)\n <CODESPLIT> 24
 \n  n_cases = input()\n  \n  def xwin(s):\n      return all(c in 'XT' for c in s)\n  \n  def owin(s):\n      return all(c in 'OT' for c in s)\n  \n  for case in xrange(1, n_cases + 1):\n      board = [raw_input().strip() for _ in xrange(4)]\n      raw_input()\n  \n      board_t = zip(*board)\n  \n  \n      x_win = False\n      o_win = False\n      full = not any('.' in line for line in board)\n  \n      diag_nw = [board[x][x] for x in range(4)]\n      diag_ne = [board[x][3-x] for x in range(4)]\n  \n  \n      if xwin(diag_nw) or xwin(diag_ne):\n          x_win = True\n      if owin(diag_nw) or owin(diag_ne):\n          o_win = True\n  \n      for line, line_t in zip(board, board_t):\n          if xwin(line) or xwin(line_t):\n              x_win = True\n          if owin(line) or owin(line_t):\n              o_win = True\n  \n      out = 'Game has not completed'\n      if x_win:\n          out = 'X won'\n      elif o_win:\n          out = 'O won'\n      elif full:\n          out = 'Draw'\n  \n      print "Case #%d: %s" % (case, out)\n <CODESPLIT> 24
mapping = {'y':'a', 'e':'o', 'q':'z', 'z':'q'}\n  \n  for src, dst in [("ejp mysljylc kd kxveddknmc re jsicpdrysi", "our language is impossible to understand"),\n      ("rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd","there are twenty six factorial possibilities"),\n      ("de kr kd eoya kw aej tysr re ujdr lkgc jv","so it is okay if you want to just give up")]:\n      for a, b in zip(src,dst):\n          mapping[a] = b\n  \n  n_cases = input()\n  \n  \n  for case in xrange(1, n_cases + 1):\n      string = raw_input()\n  \n      out = ''.join(mapping.get(c, c) for c in string)\n              \n      print "Case #%d: %s" % (case, out)\n <CODESPLIT> 24
 if len(sys.argv) == 1:\n      sys.stdin = open("D.in")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_floats(s):\n      return map(float, s.split())\n  \n  def get_floats():\n      return to_floats(raw_input())\n  \n  n_cases = input()\n  \n  \n  def cheat(our_blocks, opp_blocks):\n      n_blocks = len(our_blocks)\n      burned = 0\n      while any(our_blocks[x+burned] < opp_blocks[x] for x in xrange(0, n_blocks - burned)):\n          burned += 1\n      return n_blocks - burned\n  \n  def fair(our_blocks, opp_blocks):\n      score = 0\n      opp_left, opp_right = 0, len(opp_blocks)-1\n      for our in our_blocks:\n          for n, opp in enumerate(opp_blocks):\n              if opp > our:\n                  opp_blocks.pop(n)\n                  break\n          else:\n              score += 1\n              opp_blocks.pop(0)\n      return score\n  \n  for case in xrange(1, n_cases + 1):\n      n_blocks, = get_floats()\n      our_blocks = sorted(get_floats())\n      opp_blocks = sorted(get_floats())\n  \n      deceitful_score = cheat(our_blocks, opp_blocks)\n      fair_score = fair(our_blocks, opp_blocks)\n  \n      print "Case #%d: %d %d" % (case, deceitful_score, fair_score)\n <CODESPLIT> 24
 \n  \n  def click(C, F, X):\n      states = Queue.PriorityQueue()\n  \n      states.put((0.0, 2.0, False))\n      while not states.empty():\n          time, rate, is_done = states.get()\n  \n          if is_done:\n              return time\n  \n          states.put((\n              time + X / rate,\n              rate,\n              True\n          ))\n  \n          states.put((\n              time + C / rate,\n              rate + F,\n              False\n          ))\n  \n      return None\n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          C, F, X = map(float, sys.stdin.readline().split())\n          print 'Case #%d: %.7f' % (case + 1, click(C, F, X))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 25
 \n  def is_fair(n):\n      n = str(n)\n      for i in range(long(len(n) / 2)):\n          if n[i] != n[len(n) - i - 1]:\n              return False\n      return True\n  \n  def is_square_and_fair(n):\n      if not is_fair(n): return False\n      root = math.sqrt(n)\n      if root != math.floor(root): return False\n      if not is_fair(long(root)): return False\n      return True\n  \n  def process():\n      a, b = sys.stdin.readline().split()\n      a = long(a)\n      b = long(b)\n      \n      count = 0\n      for i in range(a, b + 1):\n          if is_square_and_fair(i): count = count + 1\n  \n      return count\n  \n  def main():\n  \n      count = int(sys.stdin.readline())\n      for index in range(count):\n          result = process()\n          print "Case #%d: %s" % (index + 1, result)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 25
 \n  \n  def calculate_max_score(scores_sum):\n      if scores_sum % 3 == 1:\n          max_score = (scores_sum + 2) / 3\n          return (max_score, max_score)\n      if scores_sum % 3 == 2:\n          max_score = (scores_sum + 1) / 3\n          return (max_score, max_score + 1)\n      max_score = scores_sum / 3\n      if max_score == 0:\n          return (0, 0)\n      return (max_score, max_score + 1)\n  \n  def find_max_dancers(s, p, *scores_sums):\n      dancers_count = 0\n      for scores_sum in scores_sums:\n          (normal_max, surprise_max) = calculate_max_score(scores_sum)\n          if normal_max >= p:\n              dancers_count = dancers_count + 1\n              continue\n          if surprise_max >= p and s > 0:\n              s = s - 1\n              dancers_count = dancers_count + 1\n              continue\n      return dancers_count\n  \n  def main():\n  \n      case_count = int(sys.stdin.readline())\n  \n      for case_index in range(1, case_count + 1):\n          line = sys.stdin.readline().strip().split(' ')\n          s = int(line[1])\n          p = int(line[2])\n          scores_sums = [int(scores_sum) for scores_sum in line[3:]]\n          print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 25
 \n  def process():\n      height, width = sys.stdin.readline().split()\n      width = int(width)\n      height = int(height)\n  \n      lawn = [[0 for c in range(width)] for r in range(height)]\n      mark = [[0 for c in range(width)] for r in range(height)]\n      settings = []\n  \n      for r in range(height):\n          row = sys.stdin.readline().split()\n          for c in range(width):\n              h = int(row[c])\n              lawn[r][c] = h\n              if h not in settings: settings.append(h)\n  \n      settings = sorted(settings)\n  \n      for i in range(len(settings)):\n          h = settings[i]\n          h_next = 0\n          if i < len(settings) - 1:\n              h_next = settings[i + 1]\n  \n          for r in range(height):\n              count = 0\n              for c in range(width):\n                  if lawn[r][c] == h: count = count + 1\n              if count == width:\n                  for c in range(width): mark[r][c] = h\n  \n          for c in range(width):\n              count = 0\n              for r in range(height):\n                  if lawn[r][c] == h: count = count + 1\n              if count == height:\n                  for r in range(height): mark[r][c] = h\n  \n          for c in range(width):\n              for r in range(height):\n                  if lawn[r][c] == h:\n                      if mark[r][c] != h: return "NO"\n                      lawn[r][c] = h_next\n  \n      return "YES"\n  \n          \n  \n  def main():\n  \n      count = int(sys.stdin.readline())\n      for index in range(count):\n          result = process()\n          print "Case #%d: %s" % (index + 1, result)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 25
 \n  def find_recycled_pairs(A, B):\n      count = 0\n      l = len(str(A))\n      for i in range(A, B + 1):\n          variants = []\n          for d in range(1, l):\n              fixed = str(i)[:d]\n              moving = str(i)[-(l - d):]\n              j = int(moving + fixed)\n              if j != i and len(str(i)) == len(str(j)) and j in range(A, B + 1) and j not in variants:\n                  variants.append(j)\n                  count = count + 1\n      return count / 2\n  \n  \n  def find_recycled_pairs_efficient(A, B):\n      count = 0\n      sa = str(A)\n      sb = str(B)\n      l = len(sa)\n      for fixed in range(1, l):\n          moving = l - fixed\n          x = int(sa[:fixed])\n          y = int(sb[:fixed])\n          m = int(sa[-fixed:])\n          n = int(sb[-fixed:])\n          j = int(sa[:moving])\n          k = int(sb[:moving])\n          print '%i fixed: x = %i, m = %i, n = %i, y = %i, j = %i, k = %i' % (fixed, x, m, n, y, j, k)\n  \n          if int(str(y) + str(k)) >= B:\n              k1 = int(sb[-moving:])\n              print 'k1 - j = %i - %i' % (k1, j)\n              if k1 > j:\n                  count = count + (k1 - j)\n          if int(str(x) + str(j)) <= A:\n              j1 = int(sa[-moving:])\n              print 'k - j1 = %i - %i' % (k, j1)\n              if k > j1:\n                  count = count + (k - j1)\n  \n          if len(str(k)) >= len(str(x)):\n              count = count + (y - x) * (k - j)\n          else:\n              count = count + (y - x - 1) * (k - j + 1)\n  \n          if x < m:\n              count = count - (m - x - 1)\n          if y > n:\n              count = count - (y - n - 1)\n  \n      return count / 2\n  \n  def main():\n  \n      case_count = int(sys.stdin.readline())\n  \n      for case_index in range(1, case_count + 1):\n          (A, B) = sys.stdin.readline().strip().split(' ')\n          A = int(A)\n          B = int(B)\n          assert len(str(A)) == len(str(B))\n          print 'Case #%i: %s' % (case_index, find_recycled_pairs(A, B))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 25
 \n  def process():\n      empty = 0\n      board = [['.', '.', '.', '.'] for i in range(4)]\n      for r in range(4):\n          row = sys.stdin.readline()\n          for c in range(4):\n              board[r][c] = row[c]\n              if row[c] == '.': empty = empty + 1\n      sys.stdin.readline()\n  \n  \n      for r in range(4):\n          x = 0\n          o = 0\n          for c in range(4):\n              if board[r][c] == 'X':\n                  x = x + 1\n              if board[r][c] == 'O':\n                  o = o + 1\n              if board[r][c] == 'T':\n                  x = x + 1\n                  o = o + 1\n          if x == 4: return "X won"\n          if o == 4: return "O won"\n  \n      for c in range(4):\n          x = 0\n          o = 0\n          for r in range(4):\n              if board[r][c] == 'X':\n                  x = x + 1\n              if board[r][c] == 'O':\n                  o = o + 1\n              if board[r][c] == 'T':\n                  x = x + 1\n                  o = o + 1\n          if x == 4: return "X won"\n          if o == 4: return "O won"\n  \n      x = 0\n      o = 0\n      for c in range(4):\n          r = c\n          if board[r][c] == 'X':\n              x = x + 1\n          if board[r][c] == 'O':\n              o = o + 1\n          if board[r][c] == 'T':\n              x = x + 1\n              o = o + 1\n  \n      if x == 4: return "X won"\n      if o == 4: return "O won"\n  \n      x = 0\n      o = 0\n      for c in range(4):\n          r = 3 - c\n          if board[r][c] == 'X':\n              x = x + 1\n          if board[r][c] == 'O':\n              o = o + 1\n          if board[r][c] == 'T':\n              x = x + 1\n              o = o + 1\n  \n      if x == 4: return "X won"\n      if o == 4: return "O won"\n  \n      if empty == 0: return "Draw"\n  \n      return "Game has not completed"\n  \n          \n  \n  def main():\n  \n      count = int(sys.stdin.readline())\n      for index in range(count):\n          result = process()\n          print "Case #%d: %s" % (index + 1, result)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 25
 \n  cipher = dict()\n  \n  def learn(encrypted_text, clear_text):\n      for encrypted_letter, clear_letter in zip(encrypted_text, clear_text):\n          if encrypted_letter in cipher:\n              assert cipher[encrypted_letter] == clear_letter\n          cipher[encrypted_letter] = clear_letter\n  \n  def test():\n      alphabet = 'abcdefghijklmnopqrstuvwxyz '\n      for letter in alphabet:\n          if letter not in cipher.keys():\n              print 'Googlerese letter %s does not have corresponding English letter.' % letter\n          if letter not in cipher.values():\n              print 'English letter %s not found in cipher dictionary values.' % letter\n      if len(cipher.keys()) != len(alphabet):\n          print 'Size of cipher dictionary and alphabet mismatch.'\n  \n  def decrypt(text):\n      decrypted_text = ''\n      for letter in text:\n          assert letter in cipher\n          decrypted_text += cipher[letter]\n      return decrypted_text\n  \n  def main():\n      learn(' yeqz', ' aozq')\n      learn('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand')\n      learn('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities')\n      learn('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')\n      test()\n  \n      case_count = int(sys.stdin.readline())\n  \n      for case_index in range(1, case_count + 1):\n          print 'Case #%i: %s' % (case_index, decrypt(sys.stdin.readline().strip()))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 25
 \n  def ken(ken_blocks, naomi_block):\n      """\n      Since ken do not know Naomi's blocks weights\n      Best strategy will be spent the smallest block to beat Naomi\n      """\n  \n      for block in ken_blocks:\n          if block > naomi_block:\n              ken_blocks = ken_blocks[:]\n              ken_blocks.remove(block)\n              return True, ken_blocks\n  \n      ken_blocks = ken_blocks[1:]\n      return False, ken_blocks\n  \n  def naomi(naomi_blocks):\n      naomi_block = naomi_blocks[0]\n      naomi_blocks = naomi_blocks[1:]\n      return naomi_block, naomi_blocks\n  \n  def play(naomi_blocks, ken_blocks):\n      naomi_points = 0\n      ken_points = 0\n  \n      naomi_blocks.sort()\n      ken_blocks.sort()\n  \n      while naomi_blocks and ken_blocks:\n          naomi_block, naomi_blocks = naomi(naomi_blocks)\n          ken_wins, ken_blocks = ken(ken_blocks, naomi_block)\n          if ken_wins:\n              ken_points += 1\n          else:\n              naomi_points += 1\n  \n      return naomi_points\n  \n  def naomi2(naomi_blocks, ken_blocks):\n      target = ken_blocks[0]\n      for block in naomi_blocks:\n          if block > target:\n              naomi_blocks = naomi_blocks[:]\n              naomi_blocks.remove(block)\n              return ken_blocks[-1] + 0.0000001, naomi_blocks\n      return naomi_blocks[0], naomi_blocks[1:]\n  \n  def cheat(naomi_blocks, ken_blocks):\n      naomi_points = 0\n      ken_points = 0\n  \n      naomi_blocks.sort()\n      ken_blocks.sort()\n  \n      while naomi_blocks and ken_blocks:\n          naomi_block, naomi_blocks = naomi2(naomi_blocks, ken_blocks)\n          ken_wins, ken_blocks = ken(ken_blocks, naomi_block)\n          if ken_wins:\n              ken_points += 1\n          else:\n              naomi_points += 1\n      return naomi_points\n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          N = int(sys.stdin.readline())\n          naomi_blocks = map(float, sys.stdin.readline().split())\n          ken_blocks = map(float, sys.stdin.readline().split())\n          assert len(naomi_blocks) is N\n          assert len(ken_blocks) is N\n  \n          normal_war = play(naomi_blocks, ken_blocks)\n          cheat_war = cheat(naomi_blocks, ken_blocks)\n          print 'Case #%d: %d %d' % (case + 1, cheat_war, normal_war)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 25
T = int(raw_input())\n  \n  def solve(C, F, X):\n      best = x/2\n      buildTime, speed = 0, 2\n      while True:\n          buildTime += C/speed\n          if buildTime > best:\n              break\n          speed += F\n          best = min(best, buildTime + X/speed)\n      return best\n  \n  for z in xrange(T):\n      c, f, x = map(float, raw_input().split())\n      print "Case #%d: %.7f" % (z+1, solve(c, f, x))\n <CODESPLIT> 26
 \n  def generateTable(N):\n      msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]\n      nums = revnums = [1, 2]\n  \n      digsums = [1, 4]\n  \n      for i in xrange(2, N+1):\n          a, b, d = [], [], []\n          p = 10**(i-1)\n          for j in xrange(len(nums)):\n              for k in xrange(3):\n                  n, rn, ds = 10*nums[j] + k, revnums[j] + k*p, digsums[j] + k*k\n                  if ds < 5:\n                      a.append(n)\n                      b.append(rn)\n                      d.append(ds)\n                      msq.append(10*p*n + rn) # even length\n                      if i == N:\n                          continue\n                      for l in xrange(3): # odd length\n                          if 2*ds + l*l < 10:\n                              msq.append(100*p*n + 10*p*l + rn)\n          nums, revnums, digsums = a, b, d\n  \n      msq.sort()\n      return msq\n  \n  def getNum(A, B):\n      return bisect_right(tab2, B) - bisect_right(tab2, A-1)\n  \n  N = 10\n  tab = generateTable(N)\n  tab2 = map(lambda n: n**2, tab)\n  \n  T = int(raw_input())\n  for z in xrange(T):\n      A, B = map(int, raw_input().split())\n      print "Case #%d: %d" % (z+1, getNum(A, B))\n <CODESPLIT> 26
T = int(raw_input())\n  \n  for z in xrange(1, T+1):\n      a = map(int, raw_input().split())\n      s, p = a[1:3]\n      a = a[3:]\n      A = 0 if p == 0 else 3*p - 2\n      B = 0 if p == 0 else 1 if p == 1 else 3*p-4\n      x = len(filter(lambda x: x >= A, a))\n      y = len(filter(lambda x: x >= B, a)) - x\n      res = x + min(s, y)\n      print "Case #%d:" % z, res\n <CODESPLIT> 26
T = int(raw_input())\n  \n  def readMatrix(nlines):\n      return [map(int, raw_input().split(' ')) for i in xrange(nlines)]\n  \n  def transpose(A):\n      return map(lambda i: map(lambda line: line[i], A), xrange(len(A[0])))\n  \n  for z in xrange(T):\n      M, N = map(int, raw_input().split(' '))\n      A = readMatrix(M)\n      b = map(max, A)\n      c = map(max, transpose(A))\n      fl = True\n      for i in xrange(M):\n          for j in xrange(N):\n              if A[i][j] != min(b[i], c[j]):\n                  fl = False\n      print "Case #%d: %s" % (z+1, "YES" if fl else "NO")\n <CODESPLIT> 26
T = int(raw_input())\n  \n  def isRecycle(x, y, d):\n      k = 10**(d-1)\n      for i in xrange(ndigits):\n          y = k*(y%10) + y/10\n          if x == y:\n              return True\n      return False\n  \n  for z in xrange(1, T+1):\n      res = 0\n      A, B = map(int, raw_input().split())\n      ndigits = len(str(A))\n      for i in xrange(A, B):\n          for j in xrange(i+1, B+1):\n             if isRecycle(i, j, ndigits):\n                 res += 1\n      print "Case #%d:" % z, res\n <CODESPLIT> 26
n = int(raw_input())\n  \n  d = {'X':2, 'O': 0, 'T':1, '.':-10}\n  \n  def readGame():\n      return [map(lambda c:d[c], raw_input().strip()) for i in xrange(4)]\n  \n  def check(game):\n      s = []\n      for i in xrange(4): # horizontal\n          s.append(sum(game[i]))\n      for i in xrange(4): # vertical\n          s.append(sum(map(lambda li: li[i], game)))\n      d1 = d2 = 0 # diagonal\n      for i in xrange(4):\n          d1 += game[i][i]\n          d2 += game[i][3-i]\n      s.append(d1)\n      s.append(d2)\n      if max(s) >= 7:\n          return "X won";\n      gr0 = filter(lambda n: n >= 0, s)\n      if len(gr0) > 0 and min(gr0) <= 1:\n          return "O won"\n      if min(s) < 0:\n          return "Game has not completed"\n      return "Draw"\n  \n  for i in xrange(n):\n      game = readGame()\n      if i + 1 < n:\n          raw_input()\n  \n      print "Case #%d: %s" % (i+1, check(game))\n <CODESPLIT> 26
inps = ["ejp mysljylc kd kxveddknmc re jsicpdrysi", "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd", "de kr kd eoya kw aej tysr re ujdr lkgc jv"]\n  outs = ["our language is impossible to understand","there are twenty six factorial possibilities", "so it is okay if you want to just give up"]\n  \n  d = {'z':'q', 'q':'z'}\n  \n  for i in xrange(3):\n      inp, out = inps[i], outs[i]\n      for j in xrange(len(inp)):\n          d[inp[j]] = out[j]\n  \n  n = int(raw_input())\n  for i in xrange(n):\n      s = raw_input()\n      print "Case #%d:" % (i+1), "".join(map(lambda c: d[c], s))\n <CODESPLIT> 26
T = int(raw_input())\n  \n  def solve(a, b):\n      n = len(a)\n      a.sort()\n      b.sort()\n      i = j = m = M = 0\n      while i < n:\n          if a[i] > b[j]:\n              M += 1\n              i += 1\n              j += 1\n          else:\n              i += 1\n      i = j = 0\n      while j < n:\n          if b[j] > a[i]:\n              m += 1\n              i += 1\n              j += 1\n          else:\n              j += 1\n      return str(M) + " " + str(n-m)\n  \n  for z in xrange(T):\n      n = int(raw_input())\n      a = map(float, raw_input().split())\n      b = map(float, raw_input().split())\n      print "Case #%d: %s" % (z+1, solve(a, b))\n <CODESPLIT> 26
 \n  T = int(input())\n  \n  for x in range(1, T+1):\n      (C, F, X) = [float(y) for y in input().split()]\n      totalsecs = 0\n      cur_speed = 2\n      while True:\n          cur_time = X/cur_speed\n          new_speed = cur_speed + F\n          new_time = C/cur_speed + X/new_speed\n          if new_time < cur_time:\n              totalsecs += C/cur_speed\n              cur_speed = new_speed\n          else:\n              totalsecs += cur_time\n              break\n      \n      print("Case #%d: %.7f" % (x, totalsecs))\n <CODESPLIT> 27
 \n  T = input()\n  \n  for n in range(1, T+1):\n  \n      A, B = raw_input().split()\n      A, B = int(A), int(B)\n  \n      j = 0\n      for i in range(A, B+1):\n          s = str(i)\n          m = int(i**.5)\n          if s[-1] in ["1", "4", "5", "6", "9"] and \\n                  (s == "".join(reversed(s))) and \\n                  m**2 == i:\n              s = str(m)\n              if s == "".join(reversed(s)):\n                  j += 1\n  \n  \n      print "Case #%d: %d" % (n, j)\n <CODESPLIT> 27
 \n  T=0 #no. of Test cases\n  for line in fileinput.input():\n      if fileinput.isfirstline():\n          T=int(line)\n          print "no. of test cases:", T\n          continue\n      \n      nums=[int(x) for x in line.split()]\n      N=nums[0] #no. of googlers\n      S=nums[1] #no. of surprising triplets\n      p=nums[2] #max value\n      \n      del nums[:3]\n      count=0\n      for num in nums:\n          quo=num//3\n          rem=num%3\n          if quo >= p:\n              count += 1\n              continue\n          elif quo+1 == p and rem > 0:\n              count += 1\n              continue\n          elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:\n              count += 1\n              S -= 1\n              continue\n          elif quo+2 >= p and rem == 2 and S > 0:\n              count += 1\n              S -= 1\n      \n      print "Case #%(k)i: %(count)i" % {"k":fileinput.lineno()-1,"count":count}\n <CODESPLIT> 27
 \n  T=input()\n  \n  for i in range(1, T+1):\n      N, M = raw_input().split()\n      N, M = int(N), int(M)\n      matrix = []\n      for j in range(N):\n          row = raw_input().split()\n          assert len(row) == M\n          row = [int(x) for x in row]\n          matrix.append(row)\n      rmax = [max(x) for x in matrix]\n      matrix_t = [list(x) for x in zip(*matrix)]\n      cmax = [max(x) for x in matrix_t]\n      feasible = True\n      for r, k in zip(matrix, range(N)):\n          for c, l in zip(r, range(M)):\n              if c == rmax[k]:\n                  continue\n              elif c == cmax[l]:\n                  continue\n              else:\n                  break\n          else:\n              continue\n          break\n      else:\n          print "Case #%d: %s" % (i, "YES")\n          continue\n      print "Case #%d: %s" % (i, "NO")\n <CODESPLIT> 27
 \n  \n  def checkIndex(index,num,numB):\n  	n=int(str(num)[index:]+str(num)[:index])\n  	if n > num and n <= numB:\n  		return n\n  	else: return False\n  \n  \n  for line in fileinput.input():\n  	if fileinput.isfirstline():\n  		T=int(line) # no. of test cases\n  		continue\n  	numStrs=line.split()\n  	numSize=len(numStrs[0])\n  	numA=int(numStrs[0])\n  	numB=int(numStrs[1])\n  	count=0\n  	for num in xrange(numA, numB+1):\n  		pairs=set()\n  		for i in range(numSize):\n  			n=checkIndex(i,num, numB)\n  			if n:\n  				pairs.add(n)\n  		count +=len(pairs)\n  				\n  	print "Case #%(k)i: %(count)i" % {"k":fileinput.lineno()-1,"count":count}\n  	\n <CODESPLIT> 27
 \n  T=input()\n  for i in range(1, T+1):\n      game = []\n      res = ""\n      unfinished = False\n      for j in range(4):\n          game.append(raw_input())\n      diag1=""\n      diag2=""\n      for (j, line) in zip(range(4), game):\n          if re.match("(X|T){4}|(O|T){4}", line):\n              res = line[0] if line[0] != 'T' else line[1]\n              break\n          else:\n              if "." in line:\n                  unfinished = True\n              diag1 += line[j]\n              diag2 += line[3-j]\n      if not res:\n          game = ["".join(x) for x in zip(*game)]\n          game.append(diag1)\n          game.append(diag2)\n          for line in game:\n              grp = re.match("(X|T){4}|(O|T){4}", line)\n              if grp:\n                  res = line[0] if line[0] != 'T' else line[1]\n                  break\n  \n      if res:\n          print "Case #%d: %s won" % (i, res)\n      elif unfinished:\n          print "Case #%d: Game has not completed" % i\n      else:\n          print "Case #%d: Draw" % i\n      raw_input() #empty line after each test case\n <CODESPLIT> 27
 \n  str1="""ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv"""\n  \n  strlist=str1.split()\n  \n  str2="""our language is impossible to understand\n  there are twenty six factorial possibilities\n  so it is okay if you want to just give up"""\n  \n  strlist2=str2.split()\n  \n  mapLang={"y":"a","e":"o","q":"z"}\n  for x,y in zip(strlist,strlist2):\n      for xi,yj in zip(x,y):\n          if xi not in mapLang:\n              mapLang[xi]=yj\n              \n  alphabet= ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n  for letter in  alphabet:\n      if letter not in mapLang.keys():\n          for lv in alphabet:\n              if lv not in mapLang.values():\n                  mapLang[letter]=lv\n                  break\n      \n  ncases=0\n  sp=" "\n  for txt in fileinput.input():\n      if fileinput.isfirstline():\n          ncases=int(txt)\n          continue\n      txtList=txt.split()\n      outList=[]\n      for word in txtList:\n          outword=""\n          for letter in word:\n              outword += mapLang[letter]\n          outList.append(outword)\n      outstr=sp.join(outList)\n      print "Case #%(k)i: %(str)s" % {"k":fileinput.lineno()-1,"str":outstr}\n <CODESPLIT> 27
 \n  T = int(input())\n  \n  for n in range(1, T+1):\n      blocks = int(input())\n      naomi = [ int(float(a)*(10**5)) for a in input().split() ]\n      ken = [ int(float(a)*(10**5)) for a in input().split() ]\n  \n      naomi.sort()\n      ken.sort()\n      dcwar = blocks\n      war = 0\n      i = 0\n      j = 0\n      while i<blocks and j<blocks:\n          if ken[i] > naomi[j]:\n              dcwar -= 1\n          else:\n              i += 1\n          j += 1\n      i = 0\n      j = 0\n      while i<blocks and j<blocks:\n          if ken[i] < naomi[j]:\n              war += 1\n          else:\n              j += 1\n          i += 1\n  \n      print("Case #%d: %d %d" % (n, dcwar, war))\n          \n  \n <CODESPLIT> 27
 \n  \n  def solve(c, f, x):\n      time = 0\n      cps = 2.0\n      while True:\n          time_to_farm = c / cps\n          time_to_end = x / cps\n          buy_a_farm = (time_to_farm + x / (cps + f)) < time_to_end\n          if buy_a_farm:\n              time += time_to_farm\n              cps += f\n          else:\n              time += time_to_end\n              return time\n  \n  if __name__ == '__main__':\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with fin, fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              c, f, x = map(float, fin.readline().split())\n              soln = solve(c, f, x)\n              print >> fout, "Case #{0}: {1:.7f}".format(case, soln)\n  \n <CODESPLIT> 28
 \n  \n  def palindromes():\n      for digits in count(1):\n          for n in xrange(10**(digits-1), 10**digits):\n              n = str(n)\n              yield int(n + n[-2::-1])\n          for n in xrange(10**(digits-1), 10**digits):\n              n = str(n)\n              yield int(n + n[::-1])\n  \n  def is_palindrome(n):\n      n = str(n)\n      return n == n[::-1]\n  \n  def solve(A, B):\n      count = 0\n      for n in palindromes():\n          square = n**2\n          if square > B:\n              break\n          if square >= A and is_palindrome(square):\n              count += 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n  \n              A, B = map(int,fin.readline().split())\n              soln = solve(A, B)\n  \n              print >> fout, "Case #{0}: {1}".format(case, soln)\n <CODESPLIT> 28
 \n  def solve(n, s, p, scores):\n      count = 0\n      for t in scores:\n          if ceil(t/3) >= p:\n              count += 1\n          elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:\n              count += 1\n              s -= 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in range(1, T+1):\n              line = map(int, fin.readline().split())\n              n, s, p, *scores = line\n              result = solve(n, s, p, scores)\n              print("Case #{0}: {1}".format(case, result), file=fout)\n <CODESPLIT> 28
 \n  def solve(N, M, grid):\n      possible = [[False for _ in xrange(M)] for _ in xrange(N)]\n      for i in xrange(N):\n          m = max(grid[i])\n          for j in xrange(M):\n              possible[i][j] = possible[i][j] or grid[i][j] == m\n  \n      for j in xrange(M):\n          m = max(grid[_][j] for _ in xrange(N))\n          for i in xrange(N):\n              possible[i][j] = possible[i][j] or grid[i][j] == m\n  \n      if all(all(row) for row in possible):\n          return "YES"\n      else:\n          return "NO"\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              print "Case #{0}:".format(case)\n  \n              N, M = map(int, fin.readline().split())\n              grid = [map(int, fin.readline().split()) for _ in xrange(N)]\n  \n              soln = solve(N, M, grid)\n              print soln\n              print >> fout, "Case #{0}: {1}".format(case, soln)\n <CODESPLIT> 28
 \n  def solve(a, b):\n      count = 0\n      for n in xrange(a, b):\n          s = str(n)\n          for i in xrange(len(s)):\n              m = int(s[i:] + s[:i])\n              if n < m <= b:\n                  count += 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              a, b = map(int, fin.readline().split())\n              print >> fout, "Case #{0}: {1}".format(case, solve(a, b))\n <CODESPLIT> 28
 \n  def fours(grid):\n      for i in xrange(4):\n          yield list(grid[i]) # row i\n          yield [grid[x][i] for x in xrange(4)] # column i\n      yield [grid[x][x] for x in xrange(4)] # major diagonal\n      yield [grid[x][3-x] for x in xrange(4)] # minor diagonal\n  \n  def solve(grid):\n      for x in fours(grid):\n          if set(x) in ({'X', 'T'}, {'X'}):\n              return "X won"\n          elif set(x) in ({'O', 'T'}, {'O'}):\n              return "O won"\n      if any('.' in x for x in grid):\n          return "Game has not completed"\n      else:\n          return "Draw"\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n  \n              grid = [fin.readline().strip() for _ in xrange(4)]\n              assert fin.readline().strip() == ''\n  \n              soln = solve(grid)\n              print >> fout, "Case #{0}: {1}".format(case, soln)\n <CODESPLIT> 28
 \n  \n  code = maketrans("y qee"\n                   "ejp mysljylc kd kxveddknmc re jsicpdrysi"\n                   "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"\n                   "de kr kd eoya kw aej tysr re ujdr lkgc jv"\n                   "z",\n                   "a zoo"\n                   "our language is impossible to understand"\n                   "there are twenty six factorial possibilities"\n                   "so it is okay if you want to just give up"\n                   "q")\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              line = fin.readline().strip('\n')\n              decrypted = translate(line, code)\n              print >> fout, "Case #{0}: {1}".format(case, decrypted)\n <CODESPLIT> 28
 \n  \n  def war(N, ns, ks):\n      """Return Naomi's score in regular War\n  \n      Strategy: Naomi and Ken both play their smallest possible block. When Ken\n      runs out of winning blocks, Naomi's score is the number of remaining blocks.\n  \n      Ken's strategy is to select the smallest block which will beat Naomi's\n      choice, or if there is none, then his smallest block.\n      """\n      i = 0   # position through naomi's blocks\n      j = 0   # position through ken's blocks\n  \n      while i < N:\n          while j < N and ks[j] < ns[i]:\n              j += 1\n  \n          if j == N:\n              break\n  \n          i += 1\n          j += 1\n  \n      return N - i\n  \n  def deceit(N, ns, ks):\n      """Return Naomi's score in Deceitful War\n  \n      Strategy: Naomi selects the smallest block with size > min(ks), and sets\n      Told_N > max(ks). Ken will choose to play min(ks), and lose the round.\n      If all of Naomi's blocks are smaller than all of Ken's, she cannot win any\n      more rounds, and her score is the number of blocks used (which is also equal\n      to N - the number of remaining blocks).\n  \n      This happens to be the same strategy as regular war, with ks and ns swapped,\n      and the final score subtracted from N. (At least, I'm pretty sure it'll work).\n      """\n      return N - war(N, ks, ns)\n  \n  \n  def solve(N, ns, ks):\n      ns.sort()\n      ks.sort()\n      return "{} {}".format(deceit(N, ns, ks), war(N, ns, ks))\n  \n  if __name__ == '__main__':\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with fin, fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              n = int(fin.readline())\n              ns = map(float, fin.readline().split())\n              ks = map(float, fin.readline().split())\n              soln = solve(n, ns, ks)\n              print >> fout, "Case #{0}: {1}".format(case, soln)\n  \n <CODESPLIT> 28
 \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      C, F, X = map(float, fin.readline().split())\n  \n  \n      rate = 2\n      time = 0\n  \n      best = 10**20\n  \n      while time < best:\n          result = X / rate + time\n          if result < best:\n              best = result\n          time += C / rate\n          rate += F\n  \n  \n  \n      print("Case #%d: %.7f" % (case, best))\n  \n <CODESPLIT> 29
 \n  N = 10**4\n  \n  def isp(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  fs = []\n  for i in range(N):\n      s = str(i)\n      n1 = int(s + s[::-1])**2\n      n2 = int(s[:-1] + s[::-1])**2\n  \n      if isp(n1):\n          fs.append(n1)\n      if isp(n2):\n          fs.append(n2)\n  \n  fs.sort()\n  \n  print(fs, file=sys.stderr)\n  \n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      board = []\n      A, B = map(int, fin.readline().split())\n  \n      i = bisect.bisect_left(fs, A)\n      j = bisect.bisect_right(fs, B)\n  \n      print("Case #%d: %s" % (case, j-i))\n  \n  \n <CODESPLIT> 29
 fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      numbers = map(int, fin.readline().split())\n      N, S, p = numbers[:3]\n      T = numbers[3:]\n      normal_limit = p + 2*max(0, (p-1))\n      surpising_limit = p + 2*max(0, (p-2))\n  \n      normal_count = 0\n      surprising_count = 0\n  \n      for t in T:\n          if t >= normal_limit:\n              normal_count += 1\n          elif t >= surpising_limit:\n              surprising_count += 1\n  \n      result = normal_count + min(surprising_count, S)\n  \n      print "Case #%d: %s" % (case, result)\n  \n <CODESPLIT> 29
 fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      board = []\n      N, M = map(int, fin.readline().split())\n      for i in range(N):\n          board.append(list(map(int, fin.readline().split())))\n      \n      row_min = [100]*N\n      row_max = [0]*N\n      col_min = [100]*M\n      col_max = [0]*M\n  \n      for i in range(N):\n          for j in range(M):\n              v = board[i][j]\n              row_min[i] = min(v, row_min[i])\n              row_max[i] = max(v, row_max[i])\n              col_min[j] = min(v, col_min[j])\n              col_max[j] = max(v, col_max[j])\n  \n  \n      possible = True\n      for i in range(N):\n          for j in range(M):\n              v = board[i][j]\n              if v != row_max[i] and v != col_max[j]:\n                  possible = False\n                  break\n  \n  \n      print("Case #%d: %s" % (case, possible and "YES" or "NO"))\n  \n  \n  \n <CODESPLIT> 29
 fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      A, B = map(int, fin.readline().split())\n  \n      total = 0\n  \n      for i in range(A, B+1):\n          n = str(i)\n          pairs = set()\n          for shift in range(1, len(n)):\n              m = n[shift:] + n[:shift]\n              j = int(m)\n              if j > i and j <= B:\n                  pairs.add(m)\n          total += len(pairs)\n  \n  \n      print "Case #%d: %s" % (case, total)\n  \n <CODESPLIT> 29
 fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      board = []\n      for i in range(4):\n          row = list(fin.readline().strip())\n          board.append(row)\n  \n      fin.readline()\n  \n      rows = [[], [], [], []]\n      cols = [[], [], [], []]\n      diags = [[], []]\n  \n      for i in range(4):\n          for j in range(4):\n              v = board[i][j]\n              rows[i].append(v)\n              cols[j].append(v)\n              if i == j:\n                  diags[0].append(v)\n              if i + j == 3:\n                  diags[1].append(v)\n  \n      buckets = rows + cols + diags\n      result = 'Draw'\n      filled = True\n      for bucket in buckets:\n          d = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n          for v in bucket:\n              d[v] += 1\n          if d['T'] + d['X'] == 4:\n              result = 'X won'\n              break\n          if d['T'] + d['O'] == 4:\n              result = 'O won'\n              break\n          if d['.'] > 0:\n              result = 'Game has not completed'\n  \n      print("Case #%d: %s" % (case, result))\n  \n  \n  \n <CODESPLIT> 29
 \n  input = """ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv"""\n  \n  output = """our language is impossible to understand\n  there are twenty six factorial possibilities\n  so it is okay if you want to just give up"""\n  \n  mapping = {'a': 'y', 'o': 'e', 'z': 'q', 'q': 'z'}\n  \n  for i, c in enumerate(input):\n      mapping[c] = output[i]\n  \n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      line = fin.readline().strip()\n  \n      result = ""\n      for c in line:\n          result += mapping[c]\n  \n      print "Case #%d: %s" % (case, result)\n  \n <CODESPLIT> 29
 \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      N = int(fin.readline())\n      numbers1 = list(map(float, fin.readline().split()))\n      numbers2 = list(map(float, fin.readline().split()))\n  \n      numbers1.sort(reverse=True)\n      numbers2.sort()\n  \n      naomi = 0\n      remaining = numbers2[:]\n      for n in numbers1:\n          lost = False\n          for i, r in enumerate(remaining):\n              if r > n:\n                  del remaining[i]\n                  lost = True\n                  break\n          if not lost:\n              naomi += 1\n  \n      cheat = 0\n      remaining = numbers2[:]\n      numbers1.sort()\n      while numbers1:\n          n = numbers1[0]\n          if n > remaining[0]:\n              cheat += 1\n              del remaining[0]\n              del numbers1[0]\n          else:\n              del remaining[-1]\n              del numbers1[0]\n  \n      print("Case #%d: %d %d" % (case, cheat, naomi))\n  \n <CODESPLIT> 29
 \n  def calculate_time(c, f, x, num_farms):\n  	t = 0.0\n  	rate = 2.0\n  	for i in range(num_farms):\n  		t += c / rate\n  		rate += f\n  		\n  	t += x / rate\n  	return t	\n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  	print "Case #" + str(i + 1) + ":",\n  \n  	(c, f, x) = [float(i) for i in sys.stdin.readline().strip().split()]\n  	\n  	if x <= c:\n  		t = calculate_time(c, f, x, 0)\n  	else:\n  		opt_rate = f * (x - c) / c\n  		num_farms = (opt_rate - 2) / f\n  		t1 = calculate_time(c, f, x, int(math.floor(num_farms)))\n  		t2 = calculate_time(c, f, x, int(math.ceil(num_farms)))\n  \n  		t = min(t1, t2)\n  		\n  	print "%.7f" % t\n <CODESPLIT> 30
def is_palindrome(s):\n  	if s == '':\n  		return True\n  	else:\n  		if (ord(s[0]) - ord(s[len(s)-1])) == 0:\n  			return is_palindrome(s[1 : len(s) - 1])\n  		else:\n  			return False\n  \n  all_fair_and_square = set()\n  for i in range(10000):\n  	orig = str(i)\n  	rev = orig[::-1]\n  \n  	palin = orig + rev\n  	intpalin = int(palin)\n  	if is_palindrome(str(intpalin * intpalin)):\n  		all_fair_and_square.add(intpalin * intpalin)\n  \n  	palin = orig[:-1] + rev\n  	intpalin = int(palin)\n  	if is_palindrome(str(intpalin * intpalin)):\n  		all_fair_and_square.add(intpalin * intpalin)\n  	\n  \n  \n  t = int(sys.stdin.readline().strip())\n  for ii in range(t):\n  	line = sys.stdin.readline().strip().split()\n  	a = int(line[0])\n  	b = int(line[1])\n  	count = 0\n  	for num in all_fair_and_square:\n  		if (num >= a) and (num <= b):\n  			count += 1\n  	print "Case #" + str(ii + 1) + ": " + str(count)\n  \n <CODESPLIT> 30
 \n  t = int(sys.stdin.readline())\n  for i in range(t):\n  	inputline = sys.stdin.readline().strip()\n  	inputparams = inputline.split()\n  \n  	n = int(inputparams[0])\n  	s = int(inputparams[1])\n  	p = int(inputparams[2])\n  	validcount = 0\n  	surprisingcount = 0\n  	for j in range(n):\n  		score = int(inputparams[3 + j])\n  		if (p + (p - 1) * 2) <= score:\n  			validcount += 1\n  		elif ((p + (p - 2) * 2) <= score) and (p <= score):\n  			surprisingcount += 1\n  \n  	print "Case #%d: %d" % (i + 1, validcount + min(surprisingcount, s))\n <CODESPLIT> 30
 \n  direction = [[0, 1], [1, 0]]\n  \n  t = int(sys.stdin.readline())\n  for i in range(t):\n  	line = sys.stdin.readline().strip().split()\n  	n = int(line[0])\n  	m = int(line[1])\n  	field = []\n  	for j in range(n):\n  		line = [int(x) for x in sys.stdin.readline().strip().split()]\n  		field.append(line)\n  \n  	possibleLawn = True\n  	for j in range(n):\n  		for k in range(m):\n  			for direct in range(2):\n  				coords = [j if (direct == 0) else 0, 0 if (direct == 0) else k]\n  				possibleField = True\n  				while (coords[0] < n) and (coords[1] < m):\n  					if field[j][k] < field[coords[0]][coords[1]]:\n  						possibleField = False\n  					coords[0] += direction[direct][0]\n  					coords[1] += direction[direct][1]\n  \n  				if possibleField:\n  					break\n  			else:\n  				possibleLawn = False\n  \n  	print "Case #" + str(i + 1) + ": " + ('YES' if possibleLawn else 'NO')\n  \n <CODESPLIT> 30
 \n  n = int(sys.stdin.readline())\n  for i in range(n):\n  	inputline = sys.stdin.readline().strip()\n  	inputparams = inputline.split()\n  \n  	a = int(inputparams[0])\n  	b = int(inputparams[1])\n  \n  	k = a\n  	ndigits = 0\n  	while k > 0:\n  		k /= 10\n  		ndigits += 1\n  \n  	cnt = 0\n  \n  	dic = {}\n  \n  	for n1digits in range(1, ndigits / 2 + 1):\n  		n2digits = ndigits - n1digits\n  \n  		for n1 in range(a / (10 ** n2digits), b / (10 ** n2digits) + 1):\n  			for n2 in range(a / (10 ** n1digits), b / (10 ** n1digits) + 1):\n  \n  				k1 = n1 * 10 ** n2digits + n2\n  				k2 = n2 * 10 ** n1digits + n1\n  \n  				if (n1digits == n2digits) and (n1 >= n2):\n  					continue\n  \n  				if (k1 != k2) and (k1 >=a) and (k2 >= a) and (k1 <= b) and (k2 <= b):\n  \n  					if min(k1, k2) not in dic:\n  						dic[min(k1, k2)] = set()\n  \n  					if max(k1, k2) not in dic[min(k1, k2)]:\n  						dic[min(k1, k2)].add(max(k1, k2))\n  						cnt += 1\n  \n  	print "Case #%d: %d" % (i + 1, cnt)	\n  \n <CODESPLIT> 30
 \n  t = int(sys.stdin.readline())\n  for i in range(t):\n  	board = []\n  	for j in range(4):\n  		board.append(sys.stdin.readline().strip())\n  \n  	sys.stdin.readline()\n  \n  	winX = False\n  	winO = False\n  	gameEnded = True\n  \n  	for j in range(4):\n  		xCount = 0\n  		oCount = 0\n  		tCount = 0\n  		for k in range(4):\n  			if board[j][k] == 'X':\n  				xCount += 1\n  			if board[j][k] == 'O':\n  				oCount += 1\n  			if board[j][k] == 'T':\n  				tCount += 1\n  \n  		if xCount + tCount == 4:\n  			winX = True\n  		\n  		if oCount + tCount == 4:\n  			winO = True\n  \n  		if xCount + oCount + tCount < 4:\n  			gameEnded = False\n  \n  	for k in range(4):\n  		xCount = 0\n  		oCount = 0\n  		tCount = 0\n  		for j in range(4):\n  			if board[j][k] == 'X':\n  				xCount += 1\n  			if board[j][k] == 'O':\n  				oCount += 1\n  			if board[j][k] == 'T':\n  				tCount += 1\n  \n  		if xCount + tCount == 4:\n  			winX = True\n  		\n  		if oCount + tCount == 4:\n  			winO = True\n  \n  		if xCount + oCount + tCount < 4:\n  			gameEnded = False\n  \n  	xCount = 0\n  	oCount = 0\n  	tCount = 0\n  	for j in range(4):\n  		if board[j][j] == 'X':\n  			xCount += 1\n  		if board[j][j] == 'O':\n  			oCount += 1\n  		if board[j][j] == 'T':\n  			tCount += 1\n  \n  	if xCount + tCount == 4:\n  		winX = True\n  	\n  	if oCount + tCount == 4:\n  		winO = True\n  \n  	if xCount + oCount + tCount < 4:\n  		gameEnded = False\n  \n  \n  	xCount = 0\n  	oCount = 0\n  	tCount = 0\n  	for j in range(4):\n  		if board[3 - j][j] == 'X':\n  			xCount += 1\n  		if board[3 - j][j] == 'O':\n  			oCount += 1\n  		if board[3 - j][j] == 'T':\n  			tCount += 1\n  \n  	if xCount + tCount == 4:\n  		winX = True\n  	\n  	if oCount + tCount == 4:\n  		winO = True\n  \n  	if xCount + oCount + tCount < 4:\n  		gameEnded = False\n  \n  	print "Case #" + str(i + 1) + ": ",\n  	if winX:\n  		print "X won"\n  	elif winO:\n  		print "O won"\n  	elif gameEnded:\n  		print "Draw"\n  	else:\n  		print "Game has not completed"\n <CODESPLIT> 30
 \n  inputmapping  = "abcdefghijklmnopqrstuvwxyz "\n  outputmapping = "ynficwlbkuomxsevzpdrjgthaq "\n  \n  n = int(sys.stdin.readline())\n  for i in range(n):\n  	outputstring = sys.stdin.readline().strip()\n  	inputstring = ""\n  	for j in range(len(outputstring)):\n  		outputletter = outputstring[j]\n  		k = 0\n  		while outputmapping[k] != outputletter:\n  			k += 1\n  \n  		inputstring += inputmapping[k]\n  \n  	print "Case #%d: %s" % (i + 1, inputstring)	\n  \n  		\n <CODESPLIT> 30
 \n  def play_war(b1, b2):\n  	if 0 == len(b1):\n  		return 0\n  		\n  	if b1[0] > b2[0]:\n  		b1.pop(0)\n  		b2.pop()\n  		return 1 + play_war(b1, b2)\n  	else:\n  		b1.pop(0)\n  		b2.pop(0)\n  		return play_war(b1, b2)\n  		\n  def play_deceitful_war(b1, b2):\n  	if 0 == len(b1):\n  		return 0\n  		\n  	i = len(b1) - 1\n  	while (i >= 0) and (b1[i] < b2[len(b2) - 1]):\n  		i -= 1\n  		\n  	if i < 0:\n  		return 0\n  	\n  	\n  	b1.pop(i)\n  	b2.pop()\n  \n  	return 1 + play_deceitful_war(b1, b2)\n  \n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  	print "Case #" + str(i + 1) + ":",\n  \n  	n = int(sys.stdin.readline().strip())\n  	\n  	blocks1 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n  	blocks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n  \n  	print play_deceitful_war(list(blocks1), list(blocks2)), play_war(blocks1, blocks2)\n  	\n <CODESPLIT> 30
directory = 'C:/users/me/desktop/google code jam/2014/qualification/B/'\n  \n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          line = f_in.readline()\n          C,F,X = [float(q) for q in line.split()]\n          result = compute (C,F,X)\n          f_out.write('Case #' + str(testcase) + ': ' + str(result) + '\n')\n  \n  \n  def compute(C,F,X):\n      cps = 2\n      farms = 0\n      timespent = 0\n      while X / cps > C/cps + X/(cps+F):\n          farms += 1\n          timespent += C/cps\n          cps += F\n  \n      return timespent + X/cps\n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n <CODESPLIT> 31
directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'\n  \n  \n  def is_palindrome (n):\n      l = list(str(n))\n      return list(reversed(l)) == l\n  \n  def prepare ():\n      global fair_and_squares\n      fair_and_squares = []\n      \n      for i in range(1,10**7):\n          if is_palindrome(i):\n              sqr = i**2\n              if is_palindrome(sqr):\n                  fair_and_squares.append(sqr)\n      return\n  \n          \n  def solve (f_in, f_out):\n      prepare()\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          A,B = [int(x) for x in f_in.readline().split()]\n          count = len([x for x in fair_and_squares if (x>=A and x<=B)])\n          f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\n')\n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n <CODESPLIT> 31
directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'\n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      print ('Test cases : ',T)\n      for i in range(1,T+1):\n          line = f_in.readline()\n          nnn = [int(x) for x in line.split()]\n          S = nnn[1]\n          p = nnn[2]\n          t = nnn[3:]\n          if p > 1:\n              A = 0\n              B = 0\n              for t_i in t:\n                  if t_i >=3*p-2:\n                      A += 1\n                  elif t_i >= 3*p-4:\n                      B += 1\n              result = A + min(B,S)\n          if p == 1:\n              result = len([x for x in t if x>=1])\n          if p == 0:\n              result=  len(t)\n          f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n  \n  \n  \n  main_run()\n <CODESPLIT> 31
directory = 'C:/users/hai/my projects/google code jam/2013/qualification/B/'\n  \n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          print (testcase)\n          N,M = [int(x) for x in f_in.readline().split()]\n          sqr = []\n          for i in range(N):\n              sqr.append([int(x) for x in f_in.readline().split()])\n          res = get_result(sqr)\n          f_out.write('Case #' + str(testcase) + ': ' + res + '\n')\n  \n  \n  def get_result (sqr):\n      while len(sqr) > 1 and len(sqr[0]) > 1:\n          print (sqr)\n          r,c = 0,0\n          for row in range(len(sqr)):\n              for col in range(len(sqr[0])):\n                  if sqr[row][col] < sqr[r][c]:\n                      r,c = row, col\n          min_val = sqr[r][c]\n          whole_row = list(sqr[r])\n          whole_col = []\n          for row in range(len(sqr)):\n              whole_col.append(sqr[row][c])\n          assert min(whole_row) == min_val\n          assert min(whole_col) == min_val\n          if max(whole_row) == min_val:\n              sqr = remove_row(sqr,r)\n          elif max(whole_col) == min_val:\n              sqr = remove_col(sqr,c)\n          else:\n              return 'NO'\n  \n      return 'YES'\n      \n  \n  \n  \n  \n  \n  def remove_row (sqr, row):\n      cpy = deepcopy(sqr)\n      del cpy[row]\n      return cpy\n  \n  def remove_col (sqr,col):\n      cpy = deepcopy(sqr)\n      for row in cpy:\n          del row[col]\n      return cpy\n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n <CODESPLIT> 31
directory = 'C:/users/hai/my projects/google code jam/2012/qualification/C/'\n  \n  \n  def solve (f_in, f_out):\n      pre_calc = prepare()\n      T = int(f_in.readline())\n      for i in range(1,T+1):\n          A,B = [int(x) for x in f_in.readline().split()]\n          c = 0\n          for m in range(A,B+1):\n              c += len ([n for n in pre_calc[m] if n >=A])\n          f_out.write('Case #' + str(i) + ': ' + str(c) + '\n')\n  \n  \n  \n  \n  \n  \n  def prepare ():\n      l = [None]* 2000001\n      for n in range(1,2000001):\n          recycled = []\n          s = str(n)\n          for c in range(1, len(s)):\n              s2 = s[c:] + s[:c]\n              if s2[0] != '0':\n                  n2 = int(s2)\n                  if n2 < n and n2 not in recycled:\n                      recycled.append(n2)\n          l [n] = recycled\n      return l\n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n <CODESPLIT> 31
directory = 'C:/users/hai/my projects/google code jam/2013/qualification/A/'\n  \n  \n  def solve (f_in, f_out):\n      N = int(f_in.readline())\n      for testcase in range(1,N+1):\n          sqr = []\n          for i in range(4):\n              sqr.append(list(f_in.readline().split()[0]))\n          assert len(f_in.readline().split()) == 0\n  \n          f_out.write('Case #' + str(testcase) + ': ' + get_square_winner(sqr) +'\n')\n      \n  \n  def get_all_lines(sqr):\n      lines = []\n      for line in sqr:\n          lines.append(list(line))\n      for column in range(4):\n          line = []\n          for row in range(4):\n              line.append(sqr[row][column])\n          lines.append(list(line))\n  \n      diag1 = []\n      diag2 = []\n      for  i in range(4):\n          diag1.append(sqr[i][i])\n          diag2.append(sqr[i][3-i])\n      lines.append(diag1)\n      lines.append(diag2)\n  \n      return lines\n      \n  def get_square_winner (sqr):\n      for line in get_all_lines(sqr):\n          if get_line_winner (line):\n              return get_line_winner (line)\n  \n      for row in sqr:\n          if '.' in row:\n              return "Game has not completed"\n      return "Draw"\n  \n  \n  \n  \n  def get_line_winner (line):\n      if line.count('X') == 4:\n          return "X won"\n      if line.count('X') == 3 and 'T' in line:\n          return "X won"\n      \n      if line.count('O') == 4:\n          return "O won"\n      if line.count('O') == 3 and 'T' in line:\n          return "O won"\n  \n  \n      return None\n  \n  \n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n <CODESPLIT> 31
directory = 'C:/users/hai/my projects/google code jam/2012/qualification/A/'\n  \n  \n  t= '''ay\n  bh\n  ce\n  ds\n  eo\n  fc\n  gv\n  hx\n  id\n  ju\n  ki\n  lg\n  ml\n  nb\n  ok\n  pr\n  qz\n  rt\n  sn\n  tw\n  uj\n  vp\n  wf\n  xm\n  ya\n  zq'''\n  \n  table = {}\n  for line in t.split():\n      table[line[0]] = line[1]\n  \n  def translate (line):\n      l = list(line)\n      for i in range(len(l)):\n          if l[i] in table:\n              l[i] = table[l[i]]\n      return ''.join(l)\n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for i in range(1,T+1):\n          line = f_in.readline()\n          out_line = translate(line)\n          f_out.write('Case #' + str(i) + ': ' + out_line)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n  \n  \n  \n  main_run()\n <CODESPLIT> 31
directory = 'C:/users/me/desktop/google code jam/2014/qualification/D/'\n  \n  \n  \n  \n  INCREASING = 501\n  DECREASING = 502\n  NO_ORDER = 503\n  \n  def play_war (l_n, l_k, inc_val):\n      assert inc_val in [INCREASING, DECREASING, NO_ORDER]\n      assert len(l_n) == len(l_k)\n      if inc_val == INCREASING:\n          l_n = list(sorted(l_n))\n      if inc_val == DECREASING:\n          l_n = list(reversed(sorted(l_n)))\n      l_k = list(sorted(l_k))\n      naomi_wins = 0\n      for i in range(len(l_n)):\n          val = l_n[0]\n          l_n = l_n[1:]\n          if l_k[-1] < val:\n              l_k = l_k[1:]\n              naomi_wins += 1\n          else:\n              for j in range(len(l_k)):\n                  if l_k[j] > val:\n                      del l_k[j]\n                      break\n  \n      return naomi_wins\n  \n  \n  def play_deceitful (l_n, l_k):\n      l_n = list(sorted(l_n))\n      l_k = list(sorted(l_k))\n      naomi_wins = 0\n      assert len(l_n) == len(l_k)\n      while len(l_n):\n          if l_n[-1] < l_k[-1]:\n              l_n = l_n[1:]\n              l_k = l_k[:-1]\n          else:\n              l_n = l_n[:-1]\n              l_k = l_k[:-1]\n              naomi_wins += 1\n      return naomi_wins\n              \n              \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          N = int(f_in.readline())\n          l_n = [float(x) for x in f_in.readline().split()]\n          l_k = [float(x) for x in f_in.readline().split()]\n  \n          a1 = play_war (l_n, l_k, INCREASING)\n          a2 = play_war (l_n, l_k, DECREASING)\n          a3 = play_war (l_n, l_k, NO_ORDER)\n          assert a1 == a2\n          assert a2 == a3\n          b = play_deceitful (l_n, l_k)\n  \n          f_out.write('Case #' + str(testcase) + ': ' + str(b) + ' ' + str(a1) + '\n')\n  \n  \n          \n          \n  \n      \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n  \n  def randomize_arrs (n):\n      l = []\n      for i in range(2*n):\n          r = choice(range(2**30))\n          while r in l:\n              r = choice(range(2**30))\n          l.append(r)\n      return l[:n], l[n:]\n  \n <CODESPLIT> 31
 \n  \n  def read_case(f):\n  	return map(float, f.readline().split())\n  \n  \n  def solve(C, F, X, rate=2.0):\n  	accum = 0\n  	while 1:\n  		goal1 = X / rate\n  	\n  		farm = C / rate\n  		goal2 = farm + (X / (rate + F))\n  \n  		if goal1 <= goal2:\n  			return accum + goal1\n  		else:\n  			accum += farm\n  			rate += F\n  \n  			\n  def trunc(x, p=7):\n  	m = 10 ** p\n  	return round(x * m) / m\n  \n  \n  def main():\n  	fn = sys.argv[1]\n  	with open(fn, encoding='utf-8') as f:\n  		ncases = int(f.readline())\n  		for case in range(1, ncases + 1):\n  			C, F, X = read_case(f)\n  			solution = solve(C, F, X)\n  			print('Case #{}: {}'.format(case, trunc(solution)))\n  \n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 32
 \n  \n  \n  def next_range(stream):\n      line = stream.readline()\n      if not line:\n          return None\n      return [int(x) for x in line.split()]\n  \n  \n  def is_palindrome(n):\n      n = str(n)\n      return all(n[i] == n[len(n)-1-i] for i in range(len(n) // 2))\n  \n  def mysqrt(n):\n      """Return -1 if not an integer"""\n      rt = int(sqrt(n))\n      return rt if rt * rt == n else -1\n  \n  \n  def is_fas(n):\n      rt = mysqrt(n)\n      return rt != -1 and is_palindrome(n) and is_palindrome(rt)\n  \n  \n  def main():\n      with open('C-small-attempt0.in', encoding='utf-8') as f:\n          f.readline()\n  \n          for case in count(1):\n              r = next_range(f)\n              if r is None:\n                  break\n  \n              cnt = 0\n              for n in range(r[0], r[1] + 1):\n                  if is_fas(n):\n                      cnt += 1\n  \n              print('Case #{}: {}'.format(case, cnt))\n  \n  \n  main()\n <CODESPLIT> 32
 \n  \n  def best(total):\n      """Return the best possible score for the given `total`.  Assume\n      the total is computed by summing exactly three scores (each in the\n      interval of 0 to 10 inclusive) and no score can be 2 points apart\n      \n      Arguments:\n      - `total`:\n      """\n      m = total % 3\n      if m == 2:\n          b = total // 3 + 2\n      else:\n          b = total // 3 + 1\n      if b > 10:\n          b = 10\n      return b\n  \n  def best_non_surprising(total):\n      """Return the best possible score for the given `total`, but\n      assume that there should be no more than 1 point difference\n      between the scores.\n  \n      Arguments:\n      - `total`:\n      """\n      if total % 3 == 0:\n          return total // 3\n      else:\n          return total // 3 + 1\n  \n  def max_num_gte_p(totals, S, p):\n      """Return the maximum number of Googlers that could have had a\n      best result of at least p.\n      \n      Arguments:\n      - `totals`:\n      - `S`: number of surprising triplets of scores\n      - `p`:\n      """\n      res = 0\n      for total in totals:\n          if total == 0:\n              if p == 0:\n                  res += 1\n              continue\n  \n          if best_non_surprising(total) >= p:\n              res += 1\n          elif S > 0 and best(total) >= p:\n              res += 1\n              S -= 1\n  \n      return res\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()            # skip T\n  \n          n = 0\n          for line in f:\n              n += 1\n  \n              line = [int(s) for s in line.split()]\n              N = line[0]\n              S = line[1]\n              p = line[2]\n              totals = line[3:]\n  \n              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 32
 \n  \n  \n  def next_lawn(stream):\n      init = stream.readline()\n      if not init:\n          return None\n  \n      N, _ = map(int, init.split())\n      lawn = []\n      for i in range(N):\n          line = stream.readline()\n          lawn.append([int(x) for x in line.split()])\n      return lawn\n  \n  \n  def test_hor(lawn, i, j):\n      me = lawn[i][j]\n      return all(lawn[i][col] <= me for col in range(len(lawn[i])))\n  \n  \n  def test_ver(lawn, i, j):\n      me = lawn[i][j]\n      return all(lawn[row][j] <= me for row in range(len(lawn)))\n  \n  \n  def test_square(lawn, i, j):\n      return test_hor(lawn, i, j) or test_ver(lawn, i, j)\n  \n  \n  def is_possible(lawn):\n      return all(test_square(lawn, i, j) for i in range(len(lawn))\n                 for j in range(len(lawn[i])))\n  \n  \n  def main():\n      with open('B-small-attempt0.in', encoding='utf-8') as f:\n          f.readline()            # Skip the first line\n  \n          for i in count(1):\n              lawn = next_lawn(f)\n              if lawn is None:\n                  break\n              ans = is_possible(lawn)\n              print('Case #{}: {}'.format(i, 'YES' if ans else 'NO'))\n          \n  \n  main()\n <CODESPLIT> 32
 \n  \n  def rotate(i, ndigits):\n      s = str(i)\n      s = s[-ndigits:] + s[:-ndigits]\n      return int(s)\n  \n  def pairs(A, B):\n      for n in range(A, B + 1):\n          for i in range(1, len(str(n))):\n              m = rotate(n, i)\n              if n >= m or m > B: continue\n              yield n, m\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()\n          n = 0\n          for line in f:\n              n += 1\n  \n              A, B = [int(x) for x in line.split(' ')]\n              unique = set()\n              for pair in pairs(A, B):\n                  unique.add(pair)\n              print 'Case #%d: %d' % (n, len(unique))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 32
 \n  \n  \n  def next_board(stream=None):\n      """"""\n      if stream is None:\n          stream = sys.stdin\n      board = []\n      for line in filter(lambda line: len(line) and line[0] in '.OTX', stream):\n          board.append([c for c in line.rstrip()])\n          if len(board) == 4:\n              break\n      return board if len(board) else None\n  \n  \n  def scan_not_completed(board):\n      if any(board[i][j] == '.'\n             for j in range(len(board))\n             for i in range(len(board))):\n          return '.'\n  \n  \n  def check_set(s):\n      s.discard('T')\n      return s.pop() if len(s) == 1 and '.' not in s else None\n  \n  \n  scan_diagonal1 = lambda board: check_set({board[i][i]\n          for i in range(len(board))})\n  \n  scan_diagonal2 = lambda board: check_set({board[i][len(board)-1-i]\n          for i in range(len(board))})\n  \n  scan_col = lambda board, col: check_set({board[i][col]\n      for i in range(len(board))})\n  \n  scan_row = lambda board, row: check_set(set(board[row]))\n  \n  \n  def determine_state(board):\n      """"""\n      for i in range(4):\n          for s in (scan_col, scan_row):\n              ret = s(board, i)\n              if ret:\n                  return ret\n      for s in (scan_diagonal1, scan_diagonal2, scan_not_completed):\n          ret = s(board)\n          if ret:\n              return ret\n      return 'draw'\n  \n  \n  def main():\n      """"""\n      with open('A-small-attempt0.in', encoding='utf-8') as f:\n          for i in itertools.count(1):\n              board = next_board(f)\n              if board is None:\n                  break\n              state = determine_state(board)\n              if state == 'X':\n                  line = 'X won'\n              elif state == 'O':\n                  line = 'O won'\n              elif state == 'draw':\n                  line = 'Draw'\n              elif state == '.':\n                  line = 'Game has not completed'\n              print('Case #{}: {}'.format(i, line))\n  \n  \n  main()\n <CODESPLIT> 32
 \n  \n  _inp = (\n      'ejp mysljylc kd kxveddknmc re jsicpdrysi',\n      'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',\n      'de kr kd eoya kw aej tysr re ujdr lkgc jv',\n  )\n  \n  _out = (\n      'our language is impossible to understand',\n      'there are twenty six factorial possibilities',\n      'so it is okay if you want to just give up',\n  )\n  \n  def compute_lang_map(inp, out):\n      lang_map = {}\n      for gs, ss in zip(inp, out):\n          for gl, sl in zip(gs, ss):\n              lang_map[gl] = sl\n      lang_map['q'] = 'z'\n      lang_map['z'] = 'q'\n      return lang_map\n  \n  _lang_map = compute_lang_map(_inp, _out)\n  def conv(s):\n      out = ''\n      for l in s:\n          out += _lang_map[l]\n      return out\n  \n  def main():\n      with open('input-file', 'r') as f:\n          f.readline()            # skip T\n          n = 0\n          for line in f:\n              n += 1\n              print 'Case #%d: %s' % (n, conv(line.strip()))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 32
 \n  \n  def ken(naomi_told, kens_blocks):\n  	heavier = list(filter(lambda b: b > naomi_told, kens_blocks))\n  	if heavier:\n  		chosen = min(heavier)\n  	else:\n  		chosen = min(kens_blocks)\n  	kens_blocks.remove(chosen)\n  	return chosen\n  \n  \n  def remove_lightest(blocks):\n  	lightest = sorted(blocks)[0]\n  	blocks.remove(lightest)\n  	return lightest\n  \n  \n  def remove_heaviest(blocks):\n  	heaviest = sorted(blocks)[-1]\n  	blocks.remove(heaviest)\n  	return heaviest\n  \n  \n  def dwar(naomis_blocks, kens_blocks):\n  	wins = 0\n  	kens_blocks = copy.copy(kens_blocks)\n  	for block in sorted(naomis_blocks):\n  		if any(map(lambda x: x < block, kens_blocks)):\n  			wins += 1\n  			remove_lightest(kens_blocks)\n  \n  		elif any(map(lambda x: x > block, kens_blocks)):\n  			remove_heaviest(kens_blocks)\n  	return wins\n  \n  \n  def war(naomis_blocks, kens_blocks):\n  	wins = 0\n  	kens_blocks = copy.copy(kens_blocks)\n  	for block in naomis_blocks:\n  		k = ken(block, kens_blocks)\n  		if block > k:\n  			wins += 1\n  	return wins\n  \n  \n  def read_case(f):\n  	N = int(f.readline())\n  	naomis_blocks = list(map(float, f.readline().split()))\n  	kens_blocks = list(map(float, f.readline().split()))\n  	return N, naomis_blocks, kens_blocks\n  \n  \n  def solve(n, k):\n  	return '{} {}'.format(dwar(n, k), war(n, k))\n  \n  \n  def main():\n  	fn = sys.argv[1]\n  	with open(fn, encoding='utf-8') as f:\n  		ncases = int(f.readline())\n  		for case in range(1, ncases + 1):\n  			N, naomi, ken = read_case(f)\n  			solution = solve(naomi, ken)\n  			print('Case #{}: {}'.format(case, solution))\n  \n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 32
 \n  lines = [line.strip() for line in open(sys.argv[1])]\n  count = int(lines[0])\n  \n  for i in xrange(count):\n      farm_cost,farm_production,target = map(float, lines[i+1].split())\n      seconds = 0\n      production = 2\n      best = float("inf")\n      while True:\n          best = min(best, seconds + target / production)\n          seconds += farm_cost / production\n          if seconds >= best: break\n          production += farm_production\n  \n      print "Case #%s: %.7f" % (i+1, best)\n <CODESPLIT> 33
 \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1] \n  \n  palindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]\n  all_palindromes = palindromes[1] + palindromes[2]\n  limit = [100]\n  \n  palindromic_squares = []\n  psqtop = 0\n  psqix = 0\n  \n  stdin = sys.stdin\n  for c in xrange(int(stdin.readline())):\n      a,b = map(int, stdin.readline().split())\n  \n      while psqtop < b:\n          while psqix >= len(all_palindromes):\n              ps = []\n              pp = 10 ** (len(palindromes)-1) + 1\n              for i in range(1,10):\n                  for p in palindromes[-2]:\n                      ps.append(i * pp + 10 * p) \n              palindromes.append(ps)\n              all_palindromes.extend(ps)\n  \n          sq = all_palindromes[psqix] * all_palindromes[psqix]\n          if is_palindrome(sq):\n              palindromic_squares.append(sq)\n          psqix  += 1\n          psqtop = sq\n  \n      aix = bisect.bisect_left(palindromic_squares, a)\n      bix = bisect.bisect_right(palindromic_squares, b)\n  \n      print "Case #%i: %i" % (c+1, bix-aix) \n <CODESPLIT> 33
 \n  T = int(stdin.readline())\n  for i in xrange(1,T+1):\n  	ns = map(int, stdin.readline().split())\n  	N,S,p = ns[0:3]\n  	\n  	h = 0\n  	z = 0\n  \n  	for n in ns[3:]:\n  		if n <= 1:\n  			if n >= p: h += 1	\n  		elif (n+2) // 3 >= p:\n  			h += 1\n  		elif (n+4) // 3 >= p:\n  			z += 1\n  \n  	print "Case #%d: %d" % (i, h + min(S,z))\n  \n  \n <CODESPLIT> 33
 \n  stdin = sys.stdin\n  for c in xrange(int(stdin.readline())):\n      n,m = map(int, stdin.readline().split())\n      rows = [map(int, stdin.readline().split()) for i in xrange(n)]\n      cols = [[row[i] for row in rows] for i in xrange(m)]\n  \n      rowmaxs = [max(x) for x in rows]\n      colmaxs = [max(x) for x in cols]\n  \n      verdict = "YES"\n      for i in xrange(n):\n          for k in xrange(m):\n              if min(rowmaxs[i], colmaxs[k]) > rows[i][k]:\n                  verdict = "NO"\n                  break\n  \n          if verdict == "NO": break\n  \n      print "Case #%i: %s" % (c+1, verdict)\n <CODESPLIT> 33
 \n  pots = [int(10**k) for k in xrange(0,16)]\n  \n  T = int(stdin.readline())\n  \n  for i in xrange(1,T+1):\n  	a,b = map(int, stdin.readline().split())\n  	t = 0\n  	m = len(str(a))\n  \n  	pp = int(10**m)\n  \n  	for n in xrange(a,b):\n  		ss = []\n  		q = 1\n  		p = pp\n  		for j in xrange(1,m):\n  			q *= 10\n  			p /= 10\n  			r = (n % p) * q + (n /p)\n  			if n < r and r <= b and not r in ss: \n  				ss.append(r)\n  				t += 1\n  \n  \n  	print "Case #%d: %d" % (i,t)\n  \n <CODESPLIT> 33
 \n  stdin = sys.stdin\n  ixs = range(4)\n  for i in xrange(int(stdin.readline())):\n      print "Case #%i: " % (i+1),\n      rows = [stdin.readline()[:4] for i in ixs]\n  \n      cols = [[row[i] for row in rows] for i in ixs]\n      diags = [\n          [rows[i][i] for i in ixs],\n          [rows[i][3-i] for i in ixs]\n      ]\n      notdone = False\n      for row in rows + cols + diags:\n          x = None\n          for t in row:\n              if t == '.':\n                  notdone = True\n                  break\n              elif t == 'T':\n                  continue\n              elif x is not None and x != t:\n                  break\n              else:\n                  x = t\n          else:\n              print x, "won"\n              break\n      else:\n          if notdone: print "Game has not completed"\n          else:       print "Draw"\n  \n      stdin.readline()\n <CODESPLIT> 33
 \n  googlerese = """\n  y qee\n  ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv\n  z\n  """\n  \n  plain = """\n  a zoo\n  our language is impossible to understand\n  there are twenty six factorial possibilities\n  so it is okay if you want to just give up\n  q\n  """\n  \n  gtos = {}\n  stog = {}\n  \n  for s,g in zip(plain, googlerese):\n  	gtos[g] = s\n  	stog[s] = g\n  \n  \n  f = sys.stdin\n  \n  t = int(f.readline())\n  \n  for i in xrange(0,t):\n  	line = f.readline().strip()\n  	print "Case #%d: %s" % (i+1, "".join([gtos.get(c,c) for c in line]))\n  \n <CODESPLIT> 33
 \n  f = open(sys.argv[1])\n  count = int(f.readline())\n  \n  for i in xrange(0, count):\n      n = int(f.readline())\n      naomis = sorted(map(float, f.readline().split()))\n      kens = sorted(map(float, f.readline().split()))\n      assert len(naomis) == n and len(kens) == n\n  \n      naomis_w = set(naomis)\n      kens_w = set(kens)\n      naomi_war_wins = 0\n      while naomis_w:\n          nao = max(naomis_w)\n          try:\n              ken = min(w for w in kens_w if w > nao)\n          except ValueError:\n              ken = min(kens_w)\n              naomi_war_wins += 1\n          naomis_w.remove(nao)\n          kens_w.remove(ken)\n  \n      naomi_deceit_wins = 0\n      naomis_w = set(naomis)\n      kens_w = set(kens)\n      while naomis_w:\n          ken = min(kens_w)\n          try:\n              nao = min(w for w in naomis_w if w > ken)\n              naomi_deceit_wins += 1\n          except ValueError:\n              nao = min(naomis_w)\n          naomis_w.remove(nao)\n          kens_w.remove(ken)\n  \n      print "Case #%s: %s %s" % (i+1, naomi_deceit_wins, naomi_war_wins)\n <CODESPLIT> 33
 \n  \n  \n  sys.setrecursionlimit(5000)\n  \n  INPUT = "tiny"\n  INPUT = "B-large.in"\n  INPUT = "B-small-attempt0.in"\n  \n  def debug(*args):\n      return\n      sys.stderr.write(str(args) + "\n")\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  def do_trial(C, F, X, rate=2.0):\n      win_time_wait = X / rate\n      buy_time = C / rate\n      win_time_buy_1 = buy_time + X / (rate+F)\n      if win_time_wait < win_time_buy_1:\n          return win_time_wait\n      return buy_time + do_trial(C, F, X, rate+F)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      C, F, X = [float(x) for x in f.readline().split()]\n      v = do_trial(C, F, X)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 34
 \n  \n  \n  INPUT = "tiny"\n  if 1:\n      INPUT = "C-small-attempt0.in"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args\n  \n  def is_palindrome(N):\n      s = str(N)\n      return s == ''.join(reversed(s))\n  \n  def fair_and_square_set(max_N):\n      p = "squareset_%d" % max_N\n      try:\n          s = pickle.load(file(p))\n          return s\n      except:\n          pass\n      s = set()\n      for i in range(1,max_N+1):\n          if is_palindrome(i) and is_palindrome(i*i):\n              s.add(i*i)\n      pickle.dump(s, file(p, "wb"))\n      return s\n  \n  MAX_N = int(1e7)\n  SQUARE_SET = fair_and_square_set(MAX_N)\n  \n  def do_trial(A, B):\n      count = 0\n      for ss in SQUARE_SET:\n          if A <= ss <= B:\n              count += 1\n      return count\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      A, B = [int(x) for x in f.readline().split()]\n      v = do_trial(A, B)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 34
 \n  \n  INPUT = "tiny"\n  \n  INPUT = "B-small-attempt0.in.txt"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  def zdebug(*args):\n      print ''.join(str(s) for s in args)\n  \n  def can_score_p(N, p):\n      low_p = max(p-1, 0)\n      if low_p + low_p + p <= N:\n          return "Y"\n      low_p = max(p-2, 0)\n      if low_p + low_p + p <= N:\n          return "S"\n      return "N"\n  \n  def do_trial(N, S, p, *scores):\n      d = { "Y" : 0, "N" : 0, "S" : 0 }\n      for s in scores:\n          v = can_score_p(s, p)\n          debug("score %s p=%s : %s" % (s, p, v))\n          d[v] = d[v] + 1\n      return d["Y"] + min(d["S"], S)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      l = [int(x) for x in f.readline()[:-1].split()]\n      v = do_trial(*l)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 34
 \n  \n  \n  INPUT = "tiny"\n  if 1:\n      INPUT = "B-small-attempt0.in"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args\n  \n  def do_trial(lawn):\n      w = len(lawn[0])\n      h = len(lawn)\n      x_maxes = [max(lawn_row) for lawn_row in lawn]\n      y_maxes = [max(lawn[y][x] for y in range(h)) for x in range(w)]\n      def lawn_row(y):\n          x_max = x_maxes[y]\n          return tuple([min(y_maxes[x], x_max) for x in range(w)])\n      new_lawn = tuple([lawn_row(y) for y in range(h)])\n      if new_lawn == lawn:\n          return "YES"\n      return "NO"\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      w, h = [int(x) for x in f.readline().split()]\n      lawn = []\n      for k in range(w):\n          lawn.append(tuple([int(x) for x in f.readline().split()]))\n      lawn = tuple(lawn)\n      v = do_trial(lawn)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 34
 \n  \n  INPUT = "tiny"\n  \n  INPUT = "C-small-attempt0.in.txt"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  if 0:\n      def debug(*args):\n          sys.stderr(''.join(str(s) for s in args) + "\n")\n  \n  def recycleables(N, A, B):\n      t = set()\n      s = str(N)\n      for i in range(len(s)):\n          s1 = int(s[i:] + s[:i])\n          if A <= s1 <= B:\n              t.add(s1)\n      return t\n  \n  def do_trial(A, B):\n      total = 0\n      seen = set()\n      for i in xrange(A, B+1):\n          if i not in seen:\n              t = recycleables(i, A, B)\n              z = len(t)\n              total += z * (z-1) / 2\n              seen.update(t)\n      return total\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      A, B = [int(x) for x in f.readline()[:-1].split()]\n      v = do_trial(A, B)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 34
 \n  \n  \n  INPUT = "tiny"\n  if 1:\n      INPUT = "A-small-attempt0.in"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  def check(board, x, y, dx, dy):\n      c = collections.Counter((board[x+dx*i][y+dy*i] for i in range(4)))\n      if c.get("X", 0) + c.get("T", 0) == 4: return "X won"\n      if c.get("O", 0) + c.get("T", 0) == 4: return "O won"\n  \n  def do_trial(board):\n      for x in range(4):\n          v = check(board, x, 0, 0, 1)\n          if v: return v\n          v = check(board, 0, x, 1, 0)\n          if v: return v\n      v = check(board, 0, 0, 1, 1)\n      if v: return v\n      v = check(board, 3, 0, -1, 1)\n      if v: return v\n      if '.' in ''.join(board):\n          return "Game has not completed"\n      return "Draw"\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      lines = [f.readline()[:-1] for j in range(4)]\n      f.readline()\n      v = do_trial(lines)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 34
 \n  \n  INPUT = "tiny"\n  if 1:\n      INPUT = "A-small-attempt2.in.txt"\n  \n  I=re.sub(" ", "", "ejp mysljylc kd kxveddknmc re jsicpdrysirbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jv")\n  O=re.sub(" ", "", "our language is impossible to understandthere are twenty six factorial possibilitiesso it is okay if you want to just give up")\n  \n  \n  MAP={ 'z' : 'q', 'q' : 'z' }\n  for i,o in zip(I,O):\n      MAP[i] = o\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  def debug(*args):\n      print str(args)\n  \n  def do_trial(l):\n      t = list(l)\n      t1 = [MAP.get(x, x) for x in t]\n      return ''.join(t1)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      l = f.readline()[:-1]\n      v = do_trial(l)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 34
 \n  \n  \n  \n  INPUT = "tiny"\n  INPUT = "D-small-attempt0.in"\n  \n  def debug(*args):\n      return\n      sys.stderr.write(str(args) + "\n")\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  def war_wins(N, K):\n      wins = 0\n      debug(N, K)\n      while 1:\n          if len(N) == 0:\n              return wins\n          N,n = N[:-1], N[-1]\n          if n > K[-1]:\n              wins += 1\n              K = K[1:]\n              continue\n          for idx, v in enumerate(K):\n              if v > n:\n                  break\n          K = K[:idx] + K[idx+1:]\n  \n  def dwar_wins(N, K):\n      wins = 0\n      while 1:\n          if len(N) == 0:\n              return wins\n          n, N = N[0], N[1:]\n          if n > K[0]:\n              wins += 1\n              K = K[1:]\n          else:\n              K = K[:-1]\n  \n  \n  def do_trial(N, K):\n      N.sort()\n      K.sort()\n      dww = dwar_wins(N, K)\n      ww = war_wins(N, K)\n      return "%d %d" % (dww, ww)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      f.readline()\n      N = [float(x) for x in f.readline().split()]\n      K = [float(x) for x in f.readline().split()]\n      v = do_trial(N, K)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 34
 \n  \n  lines = iter('''\n  5\n  30.0 1.0 2.0\n  30.0 2.0 100.0\n  30.50000 3.14159 1999.19990\n  500.0 4.0 2000.0\n  100.0 1.0 100000.0\n  '''.splitlines(False)[1:])\n  \n  lines = iter(open(r'B-small-attempt0.in').readlines(False))\n  \n  caseCnt = int(next(lines))\n  \n  for case in range(1, caseCnt+1):\n  	C, F, X = map(float, next(lines).split())\n  	\n  	v = 2.0\n  	total = 0.0\n  	goal = X/v\n  	while 1:\n  		farm = C/v + total\n  		if farm >= goal:\n  			answer = goal\n  			break\n  		v += F\n  		total = farm\n  		if goal > X/v + total:\n  			goal = X/v + total	\n  	print('Case #%d: %0.6lf'%(case, answer))\n  	\n  \n <CODESPLIT> 35
 f   = file(sys.argv[1])\n  out = file(sys.argv[2], 'w')\n  \n  caseCnt = int(f.readline())\n  \n  Num = [\n  	0,\n  	1,\n  	4,\n  	9,\n  	121,\n  	484,\n  	10201,\n  	12321,\n  	14641,\n  	40804,\n  	44944,\n  	1002001,\n  	1234321,\n  	4008004,\n  	100020001,\n  	102030201,\n  	104060401,\n  	121242121,\n  	123454321,\n  	125686521,\n  	400080004,\n  	404090404,\n  	10000200001,\n  	10221412201,\n  	12102420121,\n  	12345654321,\n  	40000800004,\n  	1000002000001,\n  	1002003002001,\n  	1004006004001,\n  	1020304030201,\n  	1022325232201,\n  	1024348434201,\n  	1210024200121,\n  	1212225222121,\n  	1214428244121,\n  	1232346432321,\n  	1234567654321,\n  	4000008000004,\n  	4004009004004,\n  ]\n  \n  for case in range(1, caseCnt+1):\n  	L, H = f.readline().split()\n  	L = int(L); H = int(H)\n  	assert L <= H\n  	\n  	for i in range(len(Num)):\n  		if L <= Num[i]:\n  			break\n  	else:\n  		print>>out, 'Case #%d:'%case, 0\n  		continue\n  \n  	lb = i - 1\n  \n  	for i in range(1, len(Num)+1):\n  		if H >= Num[len(Num)-i]:\n  			break\n  	else:\n  		print>>out, 'Case #%d:'%case, 0\n  		continue\n  	ub = len(Num)-i\n  		\n  	print>>out, 'Case #%d:'%case, ub - lb\n  \n  out.close()\n <CODESPLIT> 35
 \n  f = file("B-small-attempt0.in")\n  w = file("answer.txt", "w")\n  cnt = int(f.readline()[:-1])\n  for no in range(cnt):\n  	l = f.readline()[:-1].split()\n  	T, s, p = map(int, l[:3])\n  	ts = map(int, l[3:])\n  	ns = p*3-2 if p*3-2 > 0 else 0\n  	ss = p*3-4 if p*3-4 > 0 else 31\n  	l = filter(lambda x: x<ns, ts)\n  	c = min([len(filter(lambda x: x>=ss, l)), s])\n  	\n  	print>>w, "Case #%d:"%(no+1), T-len(l)+c\n  \n  \n <CODESPLIT> 35
 f   = file(sys.argv[1])\n  out = file(sys.argv[2], 'w')\n  \n  caseCnt = int(f.readline())\n  \n  for case in range(1, caseCnt+1):\n  	V, H = f.readline().split()\n  	V = int(V); H = int(H)\n  	\n  	field = [map(int, list(f.readline().split())) for _ in range(V)]\n  	\n  	rowMax = [max(row) for row in field]\n  	colMax = [max([row[i] for row in field]) for i in range(H)]\n  		\n  	result = 'YES'\n  	for row in range(V):\n  		for col in range(H):\n  			if field[row][col] < rowMax[row] and field[row][col] < colMax[col]:\n  				result = 'NO'\n  				break\n  		else:\n  			continue\n  		break\n  	print>>out, 'Case #%d:'%case, result\n  \n  out.close()\n <CODESPLIT> 35
 \n  f = file("C-small-attempt0.in")\n  w = file("answer.txt", "w")\n  cnt = int(f.readline()[:-1])\n  for no in range(cnt):\n  	A, B = map(int, f.readline()[:-1].split())\n  	\n  	count = 0\n  	for n in range(A, B):\n  		d = int(log(n, 10))+1\n  		s = set()\n  		for e in range(1, d):\n  			c = 10**e\n  			r = (n % c)*10**(d-e)\n  			b = n / c\n  			if r+b>n and r+b<=B and (n, r+b) not in s:\n  				s.add((n, r+b))\n  				count += 1\n  				\n  	print>>w, "Case #%d:"%(no+1), count\n  \n  \n <CODESPLIT> 35
 f   = file(sys.argv[1])\n  out = file(sys.argv[2], 'w')\n  \n  caseCnt = int(f.readline())\n  \n  for case in range(1, caseCnt+1):\n  	board = [\n  		f.readline()[:4],\n  		f.readline()[:4],\n  		f.readline()[:4],\n  		f.readline()[:4],\n  	]\n  	f.readline()\n  	xwin = False\n  	owin = False\n  	rest = False\n  	for row in board:\n  		if row.replace('T', 'X') == 'XXXX':\n  			xwin = True\n  		elif row.replace('T', 'O') == 'OOOO':\n  			owin = True\n  		if '.' in row: rest = True\n  	for i in range(4):\n  		col = ''.join([row[i] for row in board])\n  		if col.replace('T', 'X') == 'XXXX':\n  			xwin = True\n  		elif col.replace('T', 'O') == 'OOOO':\n  			owin = True\n  	up = ''.join([row[i] for i, row in enumerate(board)])\n  	if up.replace('T', 'X') == 'XXXX':\n  		xwin = True\n  	elif up.replace('T', 'O') == 'OOOO':\n  		owin = True\n  	down = ''.join([row[3-i] for i, row in enumerate(board)])\n  	if down.replace('T', 'X') == 'XXXX':\n  		xwin = True\n  	elif down.replace('T', 'O') == 'OOOO':\n  		owin = True\n  	\n  	assert not (xwin==owin==True)\n  	\n  	if xwin:\n  		result = 'X won'\n  	elif owin:\n  		result = 'O won'\n  	elif rest:\n  		result = 'Game has not completed'\n  	else:\n  		result = 'Draw'\n  		\n  	print>>out, 'Case #%d:'%case, result\n  \n  out.close()\n <CODESPLIT> 35
 \n  a = "abcdefghijklmnopqrstuvwxyz"\n  d = {}\n  for c in a:\n  	d[c] = "*"\n  \n  i = "ejp mysljylc kd kxveddknmc re jsicpdrysi"\n  o = "our language is impossible to understand"\n  for k, v in zip(i, o):\n  	d[k] = v\n  i = "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"\n  o = "there are twenty six factorial possibilities"\n  for k, v in zip(i, o):\n  	d[k] = v\n  i = "de kr kd eoya kw aej tysr re ujdr lkgc jv"\n  o = "so it is okay if you want to just give up"\n  for k, v in zip(i, o):\n  	d[k] = v\n  \n  \n  i = "y qee"\n  o = "a zoo"\n  for k, v in zip(i, o):\n  	d[k] = v\n  d['z'] = 'q'\n  f = file("A-small-attempt1.in")\n  w = file("answer.txt", "w")\n  cnt = int(f.readline()[:-1])\n  for no in range(cnt):\n  	i = f.readline()[:-1]\n  	o = ""\n  	for k in i:\n  		o += d[k]\n  	print>>w, "Case #%d:"%(no+1), o\n  \n  \n <CODESPLIT> 35
 \n  \n  lines = iter('''\n  4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n  '''.splitlines(False)[1:])\n  out = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  lines = iter(open(r'D-small-attempt2.in').readlines(False))\n  out = open('d-small.answer', 'w')\n  \n  \n  caseCnt = int(next(lines))\n  \n  def solve(N, K):\n  	if N == [] and K == []:\n  		return 0\n  	if K[-1] > N[-1]:\n  		return solve(N[:-1], K[1:])\n  	else:\n  		return solve(N[:-1], K[:-1])+1\n  \n  for case in range(1, caseCnt+1):\n  	C = int(next(lines))\n  	N = sorted(map(float, next(lines).split()), reverse=True)\n  	K = sorted(map(float, next(lines).split()), reverse=True)\n  	\n  	\n  	W=0\n  	k = 0\n  	for i, n in enumerate(N):\n  		if n < K[k]:\n  			k += 1\n  		else:\n  			W += 1\n  	\n  	D = solve(N, K)\n  	print('Case #%d: %d %d'%(case, D, W), file=out)\n  	\n <CODESPLIT> 35
 \n  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n  	with file(filepath, 'rb') as f_in:\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			yield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 1\n  		case = []\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			case.append(line.strip().split(' '))\n  			if not line_index % n:\n  				yield case_counter, case\n  				case_counter += 1\n  				case = []\n  \n  def iterate_cases_glpc(filepath):		#glpc - given lines per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 0\n  		new_case = True\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			if new_case:\n  				new_case = False\n  				case_counter += 1\n  				case = []\n  				assert len(line.strip().split(' ')) == 1\n  				lines_left = int(line.strip())\n  				if not lines_left:\n  					new_case = True\n  					yield case_counter, case\n  				continue\n  			if lines_left:\n  				lines_left -= 1\n  				case.append(line.strip().split(' '))\n  			if not lines_left:\n  				new_case = True\n  				yield case_counter, case\n  			\n  def part_of_list_to_int(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(int(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_int(array):\n  	return part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(float(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_float(array):\n  	return part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  	elem_len = len(array[0])\n  	assert index < elem_len\n  	for elem in array:\n  		assert elem_len == len(elem)\n  	max_sub = array[0][index]\n  	max_elem = array[0]\n  	for elem in array:\n  		if elem[index] > max_sub:\n  			max_sub = elem[index]\n  			max_elem = elem\n  	return max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  	list_len = len(a_list)\n  	if list_len == 1:\n  		if a_list[0] == value:\n  			return pos\n  		return -1\n  	if a_list[list_len/2] > value:\n  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  	else:\n  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  	\n  def list_index_in_sorted_list(a_list, value):\n  	return list_index_in_sorted_with_position(a_list, value, 0)\n  \n  def copy_list(list):\n  	res = []\n  	for elem in list:\n  		res.append(elem)\n  	return res	\n  \n  \n  def solve(C, F, X):\n  	farms_num = 0\n  	waiting_for_farms = 0\n  	production_rate = 2\n  	final_run_time = X / production_rate\n  	result = final_run_time + waiting_for_farms\n  	\n  	print "%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f" % (farms_num,\n  																				production_rate,\n  																				final_run_time,\n  																				waiting_for_farms,\n  																				result)\n  		\n  \n  	\n  	while True:\n  		farms_num += 1\n  		waiting_for_farms += C / production_rate\n  		production_rate += F\n  		final_run_time = X / production_rate\n  		new_result = final_run_time + waiting_for_farms\n  		print "%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f" % (farms_num,\n  																					production_rate,\n  																					final_run_time,\n  																					waiting_for_farms,\n  																					new_result)\n  		if new_result > result:\n  			return result\n  		result = new_result\n  	\n  def calc_result(case):\n  	result = None\n  	\n  	C = float(case[0])\n  	F = float(case[1])\n  	X = float(case[2])\n  	print C, F, X\n  	\n  	result = solve(C, F, X)\n  	print result\n  	\n  	return result\n  \n  def main(filepath):\n  	start_time = time.time()\n  	with file('output.txt', 'wb') as f_out:\n  		\n  		for case_index, case in iterate_cases_1lpc(filepath):\n  			\n  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n  			result = calc_result(case)\n  			\n  			f_out.write("Case #%d: %.07f\n" % (case_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 36
 \n  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n  	with file(filepath, 'rb') as f_in:\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			yield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 1\n  		case = []\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			case.append(line.strip().split(' '))\n  			if not line_index % n:\n  				yield case_counter, case\n  				case_counter += 1\n  				case = []\n  \n  def iterate_cases_glpc(filepath):		#glpc - given lines per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 0\n  		new_case = True\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			if new_case:\n  				new_case = False\n  				case_counter += 1\n  				case = []\n  				assert len(line.strip().split(' ')) == 1\n  				lines_left = int(line.strip())\n  				if not lines_left:\n  					new_case = True\n  					yield case_counter, case\n  				continue\n  			if lines_left:\n  				lines_left -= 1\n  				case.append(line.strip().split(' '))\n  			if not lines_left:\n  				new_case = True\n  				yield case_counter, case\n  			\n  def part_of_list_to_int(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(int(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_int(array):\n  	return part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(float(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_float(array):\n  	return part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  	elem_len = len(array[0])\n  	assert index < elem_len\n  	for elem in array:\n  		assert elem_len == len(elem)\n  	max_sub = array[0][index]\n  	max_elem = array[0]\n  	for elem in array:\n  		if elem[index] > max_sub:\n  			max_sub = elem[index]\n  			max_elem = elem\n  	return max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  	list_len = len(a_list)\n  	if list_len == 1:\n  		if a_list[0] == value:\n  			return pos\n  		return -1\n  	if a_list[list_len/2] > value:\n  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  	else:\n  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  	\n  def list_index_in_sorted_list(a_list, value):\n  	return list_index_in_sorted_with_position(a_list, value, 0)\n  	\n  def check_palindrome(value):\n  	val_str = str(value)\n  	length = len(val_str)\n  	for i in xrange(length):\n  		if val_str[i] != val_str[length - 1 - i]:\n  			return False\n  	return True\n  \n  def calc_result(case):\n  	A = int(case[0])\n  	B = int(case[1])\n  	\n  	A_sqrt = int(math.ceil(math.sqrt(A)))\n  	B_sqrt = int(math.floor(math.sqrt(B)))\n  	\n  	print "\tinterval: %s" % [A, B]\n  	print "\tsqrt_int: %s" % [A_sqrt, B_sqrt]\n  	\n  	count = 0\n  	for i in xrange(A_sqrt, B_sqrt + 1):\n  		if check_palindrome(i):\n  			if check_palindrome(i * i):\n  				count += 1\n  				print "\tfound: %d, %d" % (i, i * i)\n  	\n  	print "\ttot: %d" % count\n  	print \n  	result = "%s" % count\n  	return result\n  \n  def main(filepath):\n  	start_time = time.time()\n  	with file('output.txt', 'wb') as f_out:\n  		\n  		for case_index, case in iterate_cases_1lpc(filepath):\n  			\n  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n  			result = calc_result(case)\n  			\n  			f_out.write("Case #%d: %s\n" % (case_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 36
 \n  class Triplet(object):\n  	def __init__(self, i, j, k):\n  		self.i = i\n  		self.j = j\n  		self.k = k\n  		self.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))\n  		self.valid = self.max_diff <= 2\n  		self.surprise = self.max_diff == 2\n  	\n  	def get_tuple(self):\n  		return (self.i, self.j, self.k)\n  	\n  	def get_redundancies(self):\n  		return [(self.i, self.j, self.k),\n  				(self.i, self.k, self.j),\n  				(self.j, self.i, self.k),\n  				(self.j, self.k, self.i),\n  				(self.k, self.i, self.j),\n  				(self.k, self.j, self.i)]\n  \n  class Googler(object):\n  	def __init__(self, total_points):\n  		self.total_points = total_points\n  		self.regular_triplets = []\n  		self.surprise_triplets = []\n  		\n  		for i in xrange(0, 11):\n  			if i > total_points:\n  				break\n  			for j in xrange(i, 11):\n  				if i + j > total_points:\n  					break\n  				k = total_points - i - j\n  				if k > 10:\n  					break\n  				triplet = Triplet(i, j, k)\n  				self.add(triplet)\n  		\n  		self.can_surprise = len(self.surprise_triplets) > 0\n  		self.actual_triplet = None\n  		self.best_result = -1\n  		\n  	def add(self, triplet):\n  		if not triplet.valid:\n  			return\n  		if triplet.surprise:\n  			self.add_uniquely(triplet, is_surprise=True)\n  		else:\n  			self.add_uniquely(triplet, is_surprise=False)\n  			\n  	def add_uniquely(self, triplet, is_surprise):\n  		if is_surprise:\n  			input_list = self.surprise_triplets\n  		else:\n  			input_list = self.regular_triplets\n  		for triplet_redundancy in triplet.get_redundancies():\n  			if triplet_redundancy in input_list:\n  				return\n  		input_list.append(triplet.get_tuple())\n  	\n  	def __str__(self):\n  		return "regular: %s\nsurprise: %s" % (self.regular_triplets,\n  											  self.surprise_triplets)\n  	\n  	def set_googler(self, is_surprise=False):\n  		if not is_surprise:\n  			self.actual_triplet = self.regular_triplets[0]\n  		else:\n  			self.actual_triplet = self.surprise_triplets[0]\n  		self.calc_best_result()\n  	\n  	def calc_best_result(self):\n  		self.best_result = max(self.actual_triplet)\n  \n  		\n  class Contest(object):\n  	def __init__(self, num_of_googlers, results):\n  		self.num = num_of_googlers\n  		self.googlers = []\n  		for i in xrange(self.num):\n  			self.googlers.append(Googler(results[i]))\n  	\n  	def calc(self, num_of_surprises, p):\n  		max_googlers_over_p = 0\n  		for surprise_perm in self.get_permutations(num_of_surprises):\n  			if not self.validate_permutation(surprise_perm):\n  				continue\n  			count = 0\n  			for index, googler in enumerate(self.googlers):\n  				googler.set_googler(index in surprise_perm)\n  				if googler.best_result >= p:\n  					count += 1\n  			if count >= max_googlers_over_p:\n  				max_googlers_over_p = count\n  		return max_googlers_over_p\n  	\n  	def get_permutations(self, num_of_surprises):\n  		results = get_perms(0, self.num, num_of_surprises)\n  		if not results:\n  			return [[]]\n  		return results\n  	\n  	def validate_permutation(self, perm):\n  		for googler_index in perm:\n  			if not self.googlers[googler_index].can_surprise:\n  				return False\n  		return True\n  \n  def get_perms(start_index, finish_index, amount):\n  	if amount == 0:\n  		return []\n  	result_list = []\n  	for i in xrange(start_index, finish_index):\n  		if amount == 1:\n  			result_list.append([i])\n  			continue\n  		for result in get_perms(i + 1, finish_index, amount - 1):\n  			new_result = [i]\n  			new_result.extend(result)\n  			result_list.append(new_result)\n  	return result_list\n  		\n  def main(filepath):\n  	with file('dancing_output.txt', 'wb') as f_out:\n  		with file(filepath, 'rb') as f_in:\n  			for line_index, line in enumerate(f_in):\n  				if line_index == 0: #T\n  					continue\n  				input_list = line.strip().split(' ')\n  				num_of_googlers = int(input_list[0])\n  				num_of_surprises = int(input_list[1])\n  				p = int(input_list[2])\n  				results = []\n  				for res in input_list[3:]:\n  					results.append(int(res))\n  				contest = Contest(num_of_googlers, results)\n  				result = contest.calc(num_of_surprises, p)\n  				\n  				print\n  				print line.strip()\n  				print result\n  				\n  				f_out.write("Case #%d: %d\n" % (line_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 36
 \n  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n  	with file(filepath, 'rb') as f_in:\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			yield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 1\n  		case = []\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			case.append(line.strip().split(' '))\n  			if not line_index % n:\n  				yield case_counter, case\n  				case_counter += 1\n  				case = []\n  \n  def iterate_cases_glpc(filepath):		#glpc - given lines per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 0\n  		new_case = True\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			if new_case:\n  				new_case = False\n  				case_counter += 1\n  				case = []\n  				assert len(line.strip().split(' ')) == 2\n  				N = int(line.strip().split(' ')[0])\n  				M = int(line.strip().split(' ')[1])\n  				lines_left = N\n  				case.append(N)\n  				case.append(M)\n  				if not lines_left:\n  					new_case = True\n  					yield case_counter, case\n  				continue\n  			if lines_left:\n  				lines_left -= 1\n  				case.append(line.strip().split(' '))\n  			if not lines_left:\n  				new_case = True\n  				yield case_counter, case\n  			\n  def part_of_list_to_int(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(int(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_int(array):\n  	return part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(float(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_float(array):\n  	return part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  	elem_len = len(array[0])\n  	assert index < elem_len\n  	for elem in array:\n  		assert elem_len == len(elem)\n  	max_sub = array[0][index]\n  	max_elem = array[0]\n  	for elem in array:\n  		if elem[index] > max_sub:\n  			max_sub = elem[index]\n  			max_elem = elem\n  	return max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  	list_len = len(a_list)\n  	if list_len == 1:\n  		if a_list[0] == value:\n  			return pos\n  		return -1\n  	if a_list[list_len/2] > value:\n  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  	else:\n  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  	\n  def list_index_in_sorted_list(a_list, value):\n  	return list_index_in_sorted_with_position(a_list, value, 0)\n  	\n  def test_row(row, value):\n  	for elem in row:\n  		if elem > value:\n  			return False\n  	return True\n  \n  def calc_result(case):\n  	N = case[0]\n  	M = case[1]\n  	rows = []\n  	for str_row in case[2:]:\n  		rows.append(list_to_int(str_row))\n  	columns = []\n  	for i in xrange(M):\n  		column = []\n  		for j in xrange(N):\n  			column.append(rows[j][i])\n  		columns.append(column)\n  	\n  	for i in xrange(N):\n  		for j in xrange(M):\n  			if not (test_row(rows[i], rows[i][j]) or test_row(columns[j], rows[i][j])):\n  				print "i,j: %d,%d" % (i, j)\n  				result = "NO"\n  				print "\t%s" % result\n  				return result\n  	\n  	result = "YES"\n  	print "\t%s" % result\n  	return result\n  \n  def main(filepath):\n  	start_time = time.time()\n  	with file('output.txt', 'wb') as f_out:\n  		\n  		for case_index, case in iterate_cases_glpc(filepath):\n  			\n  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n  			result = calc_result(case)\n  			\n  			f_out.write("Case #%d: %s\n" % (case_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 36
 \n  def cycle_shift(in_str):\n  	return "%s%s" % (in_str[-1], in_str[:-1])\n  \n  def get_cyclic_shifts(num):\n  	results = []\n  	str_num = str(num)\n  	for _ in xrange(len(str_num) - 1):\n  		str_num = cycle_shift(str_num)\n  		if str_num[0] == '0':\n  			continue\n  		number = int(str_num)\n  		if not number in results:\n  			results.append(number)\n  	return results\n  	\n  def get_rec_pairs(A, B):\n  	rec_pairs = []\n  	for i in xrange(A, B + 1):\n  		shifts = get_cyclic_shifts(i)\n  		for shift in shifts:\n  			if (shift > i and\n  				shift <= B):\n  				rec_pairs.append((i, shift))\n  	return rec_pairs\n  	\n  def main(filepath):\n  	with file('numbers_output.txt', 'wb') as f_out:\n  		with file(filepath, 'rb') as f_in:\n  			for line_index, line in enumerate(f_in):\n  				if line_index == 0: #T\n  					continue\n  				input_list = line.strip().split(' ')\n  				A = int(input_list[0])\n  				B = int(input_list[1])\n  				\n  				rec_pairs = get_rec_pairs(A, B)\n  				result = len(rec_pairs)\n  							\n  				print\n  				print line.strip()\n  				print result\n  				\n  				f_out.write("Case #%d: %d\n" % (line_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 36
 \n  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n  	with file(filepath, 'rb') as f_in:\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			yield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 1\n  		case = []\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			case.append(line.strip().split(' '))\n  			if not line_index % n:\n  				yield case_counter, case\n  				case_counter += 1\n  				case = []\n  \n  def iterate_cases_glpc(filepath):		#glpc - given lines per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 0\n  		new_case = True\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			if new_case:\n  				new_case = False\n  				case_counter += 1\n  				case = []\n  				assert len(line.strip().split(' ')) == 1\n  				lines_left = int(line.strip())\n  				if not lines_left:\n  					new_case = True\n  					yield case_counter, case\n  				continue\n  			if lines_left:\n  				lines_left -= 1\n  				case.append(line.strip().split(' '))\n  			if not lines_left:\n  				new_case = True\n  				yield case_counter, case\n  			\n  def part_of_list_to_int(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(int(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_int(array):\n  	return part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(float(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_float(array):\n  	return part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  	elem_len = len(array[0])\n  	assert index < elem_len\n  	for elem in array:\n  		assert elem_len == len(elem)\n  	max_sub = array[0][index]\n  	max_elem = array[0]\n  	for elem in array:\n  		if elem[index] > max_sub:\n  			max_sub = elem[index]\n  			max_elem = elem\n  	return max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  	list_len = len(a_list)\n  	if list_len == 1:\n  		if a_list[0] == value:\n  			return pos\n  		return -1\n  	if a_list[list_len/2] > value:\n  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  	else:\n  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  	\n  def list_index_in_sorted_list(a_list, value):\n  	return list_index_in_sorted_with_position(a_list, value, 0)\n  	\n  \n  def check_row(row):\n  	if row.count('X') == 4:\n  		return 'X'\n  	if row.count('O') == 4:\n  		return 'O'\n  	if row.count('X') == 3 and row.count('T') == 1:\n  		return 'X'\n  	if row.count('O') == 3 and row.count('T') == 1:\n  		return 'O'\n  	if row.count('.') > 0:\n  		return '.'\n  	return 'F'\n  		\n  \n  def calc_result(case):\n  	case = case[:-1]\n  	print "\t%s" % case\n  	\n  	rows = []\n  	for row in case:\n  		rows.append(row[0])\n  	\n  	for i in xrange(4):\n  		column = ""\n  		for j in xrange(4):\n  			column += case[j][0][i]\n  		rows.append(column)\n  	\n  	diag1 = ""\n  	diag2 = ""\n  	for i in xrange(4):\n  		diag1 += case[i][0][i]\n  		diag2 += case[3-i][0][i]\n  	rows.append(diag1)\n  	rows.append(diag2)\n  	\n  	res = []\n  	for row in rows:\n  		res.append(check_row(row))\n  	\n  	if res.count('X'):\n  		if res.count('O'):\n  			raise IOError('both X and O won')\n  		else:\n  			result = "X won"\n  	else:\n  		if res.count('O'):\n  			result = "O won"\n  		else:\n  			if res.count('.'):\n  				result = "Game has not completed"\n  			else:\n  				result = "Draw"\n  	\n  	print "\t%s" % res\n  	print "\t%s" % result\n  	\n  	return result\n  \n  def main(filepath):\n  	start_time = time.time()\n  	with file('output.txt', 'wb') as f_out:\n  		\n  		for case_index, case in iterate_cases_nlpc(filepath, 5):\n  			\n  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n  			result = calc_result(case)\n  			\n  			f_out.write("Case #%d: %s\n" % (case_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 36
 \n  class Translation(object):\n  	def __init__(self):\n  		self.letters = {}\n  		self.letters['z'] = 'q'	# from text under 'Problem'\n  		self.letters['q'] = 'z'\n  		self.letters[' '] = ' '\n  		self.count = 0\n  	\n  	def update_letter(self, source, image):\n  		if source in self.letters.keys():\n  			if self.letters[source] != image:\n  				raise Exception('old: %s-->%s. new: %s-->%s' % (source, \n  																self.letters[source],\n  																source,\n  																image))\n  		else:\n  			self.letters[source] = image\n  	\n  	def update_word(self, source, image):\n  		for char_index, _ in enumerate(source):\n  			self.update_letter(source[char_index], image[char_index])\n  	\n  	def update_line(self, source, image):\n  		for word_index, _ in enumerate(source.strip().split(' ')):\n  			self.update_word(source.strip().split(' ')[word_index],\n  							 image.strip().split(' ')[word_index])\n  	\n  	def print_dict(self):\n  		for i in xrange(ord('a'), ord('z') + 1):\n  			print "%s-->%s" % (chr(i), self.letters.get(chr(i), 'None'))\n  	\n  	def translate_line(self, line):\n  		out = ""\n  		for char in line:\n  			out += self.letters[char]\n  		return out\n  		\n  def main(filepath):\n  	translation = Translation()\n  	before = []\n  	after = []\n  	with file('tounges_before.txt', 'rb') as f_before:\n  		for line in f_before:\n  			before.append(line)\n  		\n  	with file('tounges_after.txt', 'rb') as f_after:\n  		for line in f_after:\n  			after.append(line)\n  	\n  	if len(before) != len(after):\n  		raise Exception('the before and after files are not of the same size')\n  	\n  	for line_index in xrange(len(before)):\n  		translation.update_line(before[line_index], after[line_index])\n  	\n  	translation.print_dict()\n  	\n  	with file('tounges_output.txt', 'wb') as f_out:\n  		with file(filepath, 'rb') as f_in:\n  			for line_index, line in enumerate(f_in):\n  				if line_index == 0: #T\n  					continue\n  				result = translation.translate_line(line.strip())\n  				print\n  				print line.strip()\n  				print result\n  				f_out.write("Case #%d: %s\n" % (line_index, result))\n  			\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 36
 \n  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n  	with file(filepath, 'rb') as f_in:\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			yield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 1\n  		case = []\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			case.append(line.strip().split(' '))\n  			if not line_index % n:\n  				yield case_counter, case\n  				case_counter += 1\n  				case = []\n  \n  def iterate_cases_glpc(filepath):		#glpc - given lines per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 0\n  		new_case = True\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			if new_case:\n  				new_case = False\n  				case_counter += 1\n  				case = []\n  				assert len(line.strip().split(' ')) == 1\n  				lines_left = int(line.strip())\n  				if not lines_left:\n  					new_case = True\n  					yield case_counter, case\n  				continue\n  			if lines_left:\n  				lines_left -= 1\n  				case.append(line.strip().split(' '))\n  			if not lines_left:\n  				new_case = True\n  				yield case_counter, case\n  			\n  def part_of_list_to_int(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(int(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_int(array):\n  	return part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(float(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_float(array):\n  	return part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  	elem_len = len(array[0])\n  	assert index < elem_len\n  	for elem in array:\n  		assert elem_len == len(elem)\n  	max_sub = array[0][index]\n  	max_elem = array[0]\n  	for elem in array:\n  		if elem[index] > max_sub:\n  			max_sub = elem[index]\n  			max_elem = elem\n  	return max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  	list_len = len(a_list)\n  	if list_len == 1:\n  		if a_list[0] == value:\n  			return pos\n  		return -1\n  	if a_list[list_len/2] > value:\n  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  	else:\n  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  	\n  def list_index_in_sorted_list(a_list, value):\n  	return list_index_in_sorted_with_position(a_list, value, 0)\n  \n  def copy_list(list):\n  	res = []\n  	for elem in list:\n  		res.append(elem)\n  	return res	\n  \n  \n  def war_answer_simulator(blocks, choice):\n  	over_arr = []\n  	for elem in blocks:\n  		if elem > choice:\n  			over_arr.append(elem)\n  	if not over_arr:\n  		return min(blocks)\n  	return min(over_arr)\n  \n  def war_counter(a, b):\n  	count = 0\n  	while len(a) and len(b):\n  		if a[0] > b[0]:\n  			count += 1\n  		else:\n  			b.pop(0)\n  		a.pop(0)\n  	return count\n  \n  def dec_counter(a, b):\n  	count = 0\n  	while len(a) and len(b):\n  		if a[0] < b[0]:\n  			pass\n  		else:\n  			b.pop(0)\n  			count += 1\n  		a.pop(0)\n  	return count	\n  	\n  def solve(N, N_blocks, K_blocks):\n  	res = None\n  	\n  	N_blocks.sort()\n  	K_blocks.sort()\n  	N_blocks_copy = copy_list(N_blocks)\n  	K_blocks_copy = copy_list(K_blocks)\n  	\n  	N_blocks_copy.reverse()\n  	K_blocks_copy.reverse()\n  	\n  	war_count = war_counter(N_blocks_copy, K_blocks_copy)\n  	print 'war', war_count\n  	\n  	dec_count = dec_counter(N_blocks, K_blocks)\n  	print 'dec', dec_count\n  	\n  	return '%d %d' % (dec_count, war_count)\n  	\n  	\n  def calc_result(case):\n  	result = None\n  	\n  	N = int(case[0][0])\n  	N_blocks = list_to_float(case[1])\n  	K_blocks = list_to_float(case[2])\n  	print N\n  	print N_blocks\n  	print K_blocks\n  	\n  	result = solve(N, N_blocks, K_blocks)\n  	print result\n  	\n  	return result\n  \n  def main(filepath):\n  	start_time = time.time()\n  	with file('output.txt', 'wb') as f_out:\n  		\n  		for case_index, case in iterate_cases_nlpc(filepath, 3):\n  			\n  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n  			result = calc_result(case)\n  			\n  			f_out.write("Case #%d: %s\n" % (case_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 36
 \n  BIG_NUM=100000\n  def Solve(C,F,X):\n      best_time=float('inf')\n      for n in xrange(0,BIG_NUM):\n          if n==0:\n              farm_time=0\n          else:\n              farm_time += C/(2+(n-1)*F)\n          if best_time<=farm_time: break\n          cookie_time=X/(2+n*F)\n  \n          if farm_time+cookie_time<best_time:\n              best_time=farm_time+cookie_time\n  \n      return '%.9f'%best_time\n  \n  \n  \n  def parse(infile):\n      C,F,X=map(float, infile.readline().split() )\n      return C,F,X\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n <CODESPLIT> 37
 \n  def isPalindrome(n):\n      cn=str(n)\n      return (cn==cn[::-1])\n  \n  palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]\n  \n  \n  \n              \n          \n          \n  \n  \n  \n  def Solve(a,b):\n      num=0\n      for p in palinSqrt:\n          if a<= p**2 <=b: num+=1\n      return num\n  \n  \n  \n  def parse(infile):\n      a,b=map(int, infile.readline().split() )\n      return a,b\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  class Categorizer(dict):\n      def __init__(self,thelist,transform,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.AddList(thelist)\n          self.trunc=trunc\n      def AddList(self,thelist):\n          for item in thelist: self.Add( item )\n      def Add(self,object):\n          cat=self.transform( object )\n          if type(cat) is float:\n              cat=round(cat,trunc)\n          if self.has_key(cat):\n              self[cat].append( object )\n          else:\n              self[cat]=[object]\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-len(x[1]))\n          total=0\n          for i in items: total+=len(i[1])\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(len(val))) for val in self.itervalues() )\n          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n          for key,count in items[0:n]:\n              print formatter.format(key,len(count),\n                                     ("%.2f"%(len(count)*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=[]\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=len(self[key])\n              avg+=len(self[key])*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=len(self[key])\n              stddev += len(self[key]) * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n          tot=0\n          for value in self.itervalues(): tot+=len(value)\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += len(self[key])\n             if nCount>tot/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n  \n  \n  \n  \n  class Counter(dict):\n      def __init__(self,thelist,transform=None,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.trunc=trunc\n          self.AddList(thelist)\n      def AddList(self,thelist):\n          if self.transform is not None:\n              for item in thelist: self.Add( self.transform(item) )\n          else:\n              for item in thelist: self.Add( item )            \n      def Add(self,object):\n          if type(object) is float:\n              object=round(object,self.trunc)\n          if self.has_key(object):\n              self[object]+=1\n          else:\n              self[object]=1\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-x[1])\n          total=0\n          for i in items: total+=i[1]\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(val)) for val in self.itervalues() )\n          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n          for key,count in items[0:n]:\n              print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=0\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=self[key]\n              avg+=self[key]*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=self[key]\n              stddev += self[key] * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n   	total=sum(self.values())\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += self[key]\n             if nCount>total/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: x[1])[0]\n  \n  \n  def gen_primes():\n      """ Generate an infinite sequence of prime numbers.\n      """\n      D = {}  \n      q = 2  \n  \n      while True:\n          if q not in D:\n              yield q        \n              D[q * q] = [q]\n          else:\n              for p in D[q]:\n                  D.setdefault(p + q, []).append(p)\n              del D[q]\n  \n          q += 1\n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n <CODESPLIT> 37
 \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  for iCase in xrange(NumCases):\n      line=[ int(i) for i in infile.readline().split() ]\n  \n      n=line.pop(0)\n      s=line.pop(0)\n      p=line.pop(0)\n  \n      scores=line\n      assert(len(scores))==n\n  \n      imax=0\n      isurprise=0\n  \n      for score in scores:\n          if score<p: continue\n          if score<3*p-4:\n              pass\n          elif 3*p-2>score>=3*p-4:\n              isurprise+=1\n          else:\n              imax+=1\n  \n      print 'Case #'+str(iCase+1)+':',imax+min(isurprise,s)\n  \n <CODESPLIT> 37
 \n  \n  def Solve(n,m,heights):\n      for i,j in ( (i,j) for i in xrange(n) for j in xrange(m) ):\n          if (heights[i,:]<= heights[i,j]).all(): continue\n  \n          if (heights[:,j]>heights[i,j]).any(): return "NO"\n  \n  \n      return 'YES'\n  \n  \n  \n  def parse(infile):\n      n,m=map(int, infile.readline().split() )\n      heights=np.zeros( (n,m) )\n      for i in xrange(n):\n          heights[i,:]=np.array( map(int, infile.readline().split() ) )\n      return n,m,heights\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  class Categorizer(dict):\n      def __init__(self,thelist,transform,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.AddList(thelist)\n          self.trunc=trunc\n      def AddList(self,thelist):\n          for item in thelist: self.Add( item )\n      def Add(self,object):\n          cat=self.transform( object )\n          if type(cat) is float:\n              cat=round(cat,trunc)\n          if self.has_key(cat):\n              self[cat].append( object )\n          else:\n              self[cat]=[object]\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-len(x[1]))\n          total=0\n          for i in items: total+=len(i[1])\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(len(val))) for val in self.itervalues() )\n          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n          for key,count in items[0:n]:\n              print formatter.format(key,len(count),\n                                     ("%.2f"%(len(count)*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=[]\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=len(self[key])\n              avg+=len(self[key])*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=len(self[key])\n              stddev += len(self[key]) * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n          tot=0\n          for value in self.itervalues(): tot+=len(value)\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += len(self[key])\n             if nCount>tot/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n  \n  \n  \n  \n  class Counter(dict):\n      def __init__(self,thelist,transform=None,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.trunc=trunc\n          self.AddList(thelist)\n      def AddList(self,thelist):\n          if self.transform is not None:\n              for item in thelist: self.Add( self.transform(item) )\n          else:\n              for item in thelist: self.Add( item )            \n      def Add(self,object):\n          if type(object) is float:\n              object=round(object,self.trunc)\n          if self.has_key(object):\n              self[object]+=1\n          else:\n              self[object]=1\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-x[1])\n          total=0\n          for i in items: total+=i[1]\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(val)) for val in self.itervalues() )\n          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n          for key,count in items[0:n]:\n              print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=0\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=self[key]\n              avg+=self[key]*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=self[key]\n              stddev += self[key] * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n   	total=sum(self.values())\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += self[key]\n             if nCount>total/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: x[1])[0]\n  \n  \n  def gen_primes():\n      """ Generate an infinite sequence of prime numbers.\n      """\n      D = {}  \n      q = 2  \n  \n      while True:\n          if q not in D:\n              yield q        \n              D[q * q] = [q]\n          else:\n              for p in D[q]:\n                  D.setdefault(p + q, []).append(p)\n              del D[q]\n  \n          q += 1\n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n <CODESPLIT> 37
 \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  for iCase in xrange(NumCases):\n  \n      a,b=[int(i) for i in infile.readline().split()]\n  \n  \n      a_digits=[int(i) for i in str(a) ]\n      b_digits=[int(i) for i in str(b) ]\n  \n      ld=len(a_digits)\n  \n  \n      result=0\n  \n      for iNum in xrange(a,b+1):\n          mystr=str(iNum)\n          myset=set()\n          for i in xrange(1,ld):\n              mystr=mystr[1:]+mystr[0]\n              iii=int(mystr)\n              if iii>iNum and iii<=b and iii not in myset:\n                  result+=1\n  \n              myset.add(iii)\n              \n          \n  \n  \n      print 'Case #'+str(iCase+1)+':',result\n  \n <CODESPLIT> 37
 \n  \n  def Solve(lines):\n      hasEmpty=False\n  \n      rows=[ lines[0][i]+lines[1][i]+lines[2][i]+lines[3][i] \n             for i in xrange(4) ]\n  \n      diags=[ lines[0][0]+lines[1][1]+lines[2][2]+lines[3][3] ,\n              lines[0][3]+lines[1][2]+lines[2][1]+lines[3][0] ]\n  \n  \n      for il in lines + rows + diags:\n          if il.replace('T','X')=='XXXX': return "X won"\n          elif il.replace('T','O')=='OOOO': return "O won"\n          elif il.find('.')>=0: hasEmpty=True\n  \n      \n      if hasEmpty: return "Game has not completed"\n      else: return "Draw"\n  \n  \n  \n  def parse(infile):\n      lines=[]\n      for i in xrange(4):\n          lines.append(infile.readline().strip())\n      infile.readline()\n      return (lines,)\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  class Categorizer(dict):\n      def __init__(self,thelist,transform,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.AddList(thelist)\n          self.trunc=trunc\n      def AddList(self,thelist):\n          for item in thelist: self.Add( item )\n      def Add(self,object):\n          cat=self.transform( object )\n          if type(cat) is float:\n              cat=round(cat,trunc)\n          if self.has_key(cat):\n              self[cat].append( object )\n          else:\n              self[cat]=[object]\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-len(x[1]))\n          total=0\n          for i in items: total+=len(i[1])\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(len(val))) for val in self.itervalues() )\n          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n          for key,count in items[0:n]:\n              print formatter.format(key,len(count),\n                                     ("%.2f"%(len(count)*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=[]\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=len(self[key])\n              avg+=len(self[key])*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=len(self[key])\n              stddev += len(self[key]) * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n          tot=0\n          for value in self.itervalues(): tot+=len(value)\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += len(self[key])\n             if nCount>tot/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n  \n  \n  \n  \n  class Counter(dict):\n      def __init__(self,thelist,transform=None,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.trunc=trunc\n          self.AddList(thelist)\n      def AddList(self,thelist):\n          if self.transform is not None:\n              for item in thelist: self.Add( self.transform(item) )\n          else:\n              for item in thelist: self.Add( item )            \n      def Add(self,object):\n          if type(object) is float:\n              object=round(object,self.trunc)\n          if self.has_key(object):\n              self[object]+=1\n          else:\n              self[object]=1\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-x[1])\n          total=0\n          for i in items: total+=i[1]\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(val)) for val in self.itervalues() )\n          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n          for key,count in items[0:n]:\n              print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=0\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=self[key]\n              avg+=self[key]*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=self[key]\n              stddev += self[key] * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n   	total=sum(self.values())\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += self[key]\n             if nCount>total/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: x[1])[0]\n  \n  \n  def gen_primes():\n      """ Generate an infinite sequence of prime numbers.\n      """\n      D = {}  \n      q = 2  \n  \n      while True:\n          if q not in D:\n              yield q        \n              D[q * q] = [q]\n          else:\n              for p in D[q]:\n                  D.setdefault(p + q, []).append(p)\n              del D[q]\n  \n          q += 1\n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n <CODESPLIT> 37
 \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  myinput="""ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv"""\n  \n  myoutput=\\n  """our language is impossible to understand\n  there are twenty six factorial possibilities\n  so it is okay if you want to just give up"""\n  \n  mapping={}\n  mapping['q']='z'\n  mapping['z']='q'\n  \n  \n  for char,mapto in zip(myinput,myoutput):\n      if mapping.has_key(char):\n          assert mapping[char]==mapto\n      else:\n          mapping[char]=mapto\n  \n  \n  \n  \n  for iCase in xrange(NumCases):\n      thestring=infile.readline().strip()\n  \n      newstring=''\n      for char in thestring: newstring+=mapping[char]\n  \n  \n      print 'Case #'+str(iCase+1)+': '+newstring\n  \n <CODESPLIT> 37
 \n  \n  def Solve(N,n,k):\n      n.sort(reverse=True)\n      k.sort(reverse=True)\n      nDW=0\n      i_n,i_k=0,0\n      while i_n<N and i_k<N:\n          if n[i_n]>k[i_k]:\n              nDW+=1\n              i_n+=1\n              i_k+=1\n          else:\n              i_k+=1\n  \n      nW=0\n      i_n,i_k=0,0\n      while i_n<N and i_k<N:\n          if n[i_n]<k[i_k]:\n              nW+=1\n              i_n+=1\n              i_k+=1\n          else:\n              i_n+=1\n  \n      nW=N-nW\n      return '%d %d'%(nDW,nW)\n  \n  \n  \n  def parse(infile):\n      N=int(infile.readline().strip())\n      n=map(float, infile.readline().split() )\n      k=map(float, infile.readline().split() )\n      return N,n,k\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n <CODESPLIT> 37
f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  def tot(n) :\n      if n == 0 : return X / 2\n      else :\n          s = 0\n          for i in range(0, n) : s += C / (2 + i*F)\n          return s + X / (2 + n*F)\n  \n  for case in xrange(T) :\n      C, F, X = map(float, f.readline()[:-1].split())\n      N =  int(X/C) + 1\n      s, e = 0, N\n      if tot(0) >= tot(1) : \n          while True :\n              m = (s+e)/2\n              if tot(m) <= tot(m-1) and tot(m) <= tot(m+1) : break\n              elif tot(m-1) <= tot(m) <= tot(m+1) : e = m\n              elif tot(m-1) >= tot(m) >= tot(m+1) : s = m\n              else : 1/0\n      else : m = 0\n      output = 'Case #' + str(case + 1) + ': ' + str(tot(m))\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n <CODESPLIT> 38
 \n  def isPalindrome(n) :\n      return str(n) == str(n)[::-1]\n  \n  def findPalindrome(n) :\n      if n % 2 == 0 : return [start*(10**(n/2)) + int(str(start)[::-1]) for start in range(10**(n/2-1),10**(n/2))]\n      if n == 1 : return range(1,10)\n      return [start*(10**(n/2)) + int(str(start)[:-1][::-1]) for start in range(10**(n/2),10**((n+1)/2))]\n  \n  def findPalindromeInRange(a, b) :\n      num = range(len(str(a)), len(str(b)) + 1)\n      allPalindrome = []\n      for n in num : allPalindrome += findPalindrome(n)\n      return filter(lambda x : a <= x <= b, allPalindrome)\n  \n  f = open('C-small-attempt0.in', 'r')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in range(T) :\n      A, B = map(int, f.readline()[:-1].split())\n      a = int(math.ceil(A**0.5))\n      b = int(B**0.5)\n      res = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(a, b)))\n      outString = 'Case #' + str(case+1) + ': ' + str(res) + '\n'\n      print outString[:-1]\n      g.write(outString)\n  \n  f.close()\n  g.close()\n <CODESPLIT> 38
fin = open('B-small-attempt0.in', 'r')\n  fout = open('B-output.txt', 'w')\n  \n  cases = int(fin.readline()[:-1])\n  \n  for case in range(cases) :\n      line = map(int, fin.readline()[:-1].split(' '))\n      N, S, p = line[:3]\n      T = line[3:]\n      okLimit = p + 2*max(p-1,0)\n      okIfSLimit = p + 2*max(p-2,0)\n      ok = len(filter(lambda x : x >= okLimit, T))\n      okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))\n      res = ok + min(okIfS, S)\n      fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n      \n  fin.close()\n  fout.close()\n <CODESPLIT> 38
f = open('B-small-attempt0.in', 'r')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in range(T) :\n      A = []\n      N, M = map(int, f.readline()[:-1].split())\n      for i in range(N) : A.append(map(int, f.readline()[:-1].split()))\n      for line in A : print line\n      maxPerRow = map(max, A)\n      maxPerColumn = map(max, zip(*A))\n      res = all(A[i][j] in (maxPerRow[i], maxPerColumn[j]) for i in range(N) for j in range(M))\n      outString = 'Case #' + str(case+1) + ': ' + ('YES' if res else 'NO') + '\n'\n      print outString[:-1]\n      g.write(outString)\n  \n  f.close()\n  g.close()\n <CODESPLIT> 38
fin = open('C-small-attempt0.in', 'r')\n  fout = open('C-output.txt', 'w')\n  \n  cases = int(fin.readline()[:-1])\n  \n  for case in range(cases) :\n      A, B = map(int, fin.readline()[:-1].split(' '))\n      digits = len(str(A))\n      couples = set()\n      for n in range(A,B+1) :\n          for t in range(1,digits) :\n              m = [str(n)[(i+t)%digits] for i in range(digits)]\n              m = int(''.join(m))\n              if A <= n < m <= B :\n                  couples.add(str([n,m]))\n      res = len(couples)\n      print 'Case #' + str(case+1) + ': ' + str(res)\n      fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n      \n  fin.close()\n  fout.close()\n <CODESPLIT> 38
def detectResults() :\n      for sym in ('X', 'O') :\n          for line in board :\n              if all(elem in (sym, 'T') for elem in line) :\n                  return sym + ' won'\n          for column in range(4) :\n              if all(board[i][column] in (sym, 'T') for i in range(4)) :\n                  return sym + ' won'\n          if all(board[i][i] in (sym, 'T') for i in range(4)) or all(board[3-i][i] in (sym, 'T') for i in range(4)) :\n              return sym + ' won'\n      for sym in ('X', 'O') :\n          for line in board :\n              if all(elem in (sym, 'T', '.') for elem in line) :\n                  return 'Game has not completed'\n          for column in range(4) :\n              if all(board[i][column] in (sym, 'T', '.') for i in range(4)) :\n                  return 'Game has not completed'\n          if all(board[i][i] in (sym, 'T', '.') for i in range(4)) or all(board[3-i][i] in (sym, 'T', '.') for i in range(4)) :\n              return 'Game has not completed'\n      return 'Draw'\n  \n  f = open('A-small-attempt0.in', 'r')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in range(T) :\n      board = []\n      for i in range(4) : board.append([i for i in f.readline()[:-1]])\n      outString = 'Case #' + str(case+1) + ': ' + detectResults() + '\n'\n      print outString[:-1]\n      g.write(outString)\n      useless = f.readline()[:-1]\n  \n  f.close()\n  g.close()\n <CODESPLIT> 38
fin = open('A-small-attempt0.in', 'r')\n  fout = open('A-output.txt', 'w')\n  \n  translation = {'y': 'a', 'e': 'o', 'q': 'z'}\n  \n  knownresults = {\n      'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',\n      'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',\n      'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up'\n      }\n  \n  for key in knownresults :\n      for letter in range(len(key)) :\n          translation[key[letter]] = knownresults[key][letter]\n  \n  missingkey = [i for i in translation.values() if i not in translation.keys()][0]\n  missingvalue = [i for i in translation.keys() if i not in translation.values()][0]\n  \n  translation[missingkey] = missingvalue\n  \n  cases = int(fin.readline()[:-1])\n  \n  for case in range(cases) :\n      line = fin.readline()[:-1]\n      res = [translation[line[i]] for i in range(len(line))]\n      res = ''.join(res)\n      fout.write('Case #' + str(case+1) + ': ' + res + '\n')\n      \n  fin.close()\n  fout.close()\n <CODESPLIT> 38
f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      N = int(f.readline()[:-1])\n      Naomi = sorted(map(float, f.readline()[:-1].split()))\n      Ken = sorted(map(float, f.readline()[:-1].split()))\n      Ken2 = Ken[:]\n      War, DWar = 0, 0\n      for n in Naomi :\n          if n > max(Ken) :\n              Ken.pop(0)\n              War += 1\n          else :\n              for i, k in enumerate(Ken) :\n                  if k > n : break\n              Ken.pop(i)\n      Ken = Ken2\n      for n in Naomi :\n          if n < min(Ken) :\n              Ken.pop(-1)\n          else :\n              Ken.pop(0)\n              DWar += 1\n      output = 'Case #' + str(case + 1) + ': ' + str(DWar) + ' ' + str(War)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n <CODESPLIT> 38
for i in range(int(input())):\n  \n      c, f, x = tuple(map(float, str.split(input())))\n  \n      base_time = 0.0\n      base_rate = 2.0\n      farms_count = 0\n      best_time = None\n  \n      current_time = base_time + x / (base_rate + farms_count * f)\n  \n      while best_time is None or best_time > current_time:\n  \n          best_time = current_time\n          base_time += c / (base_rate + farms_count * f)\n          farms_count += 1\n  \n          current_time = base_time + x / (base_rate + farms_count * f)\n  \n      print(str.format("Case #{}: {}", i + 1, best_time))\n <CODESPLIT> 39
def sqrt(x, ge):\n      if x == 1:\n          return 1\n      sx = x >> 1\n      step = sx >> 1\n  \n      while step:\n          if sx ** 2 >= x:\n              sx = sx - step\n          else:\n              sx = sx + step\n          step = step >> 1\n  \n      if ge:\n          while not sx ** 2 < x:\n              sx = sx - 1\n          while not sx ** 2 >= x:\n              sx = sx + 1\n      else:\n          while not sx ** 2 > x:\n              sx = sx + 1\n          while not sx ** 2 <= x:\n              sx = sx - 1\n  \n      return sx\n  \n  \n  def get_start_pali(a):\n      s = str(a)\n      ls = len(s)\n      if ls == 1:\n          return s, True\n      elif ls & 1:\n          return s[:ls >> 1 + 1], True\n      else:\n          return s[:ls >> 1], False\n  \n  \n  def get_next_pali(p, m):\n      if len(p) == p.count("9"):\n          if m:\n              return "1" + "0" * (len(p) - 1), False\n          else:\n              return "1" + "0" * len(p), True\n      else:\n          return str(int(p) + 1), m\n  \n  \n  def pali_to_num(p, m):\n      if m:\n          return int(p + p[-2::-1])\n      else:\n          return int(p + p[::-1])\n  \n  \n  def is_pali(a):\n      s = str(a)\n      hls = len(s) >> 1\n      return s[:hls] == s[:-hls - 1:-1]\n  \n  for i in range(int(input())):\n      a, b = tuple(map(int, input().split()))\n      sqa, sqb = sqrt(a, True), sqrt(b, False)\n  \n      p, m = get_start_pali(sqa)\n      while pali_to_num(p, m) < sqa:\n          p, m = get_next_pali(p, m)\n  \n      count = 0\n  \n      while True:\n          curr = pali_to_num(p, m)\n          if curr > sqb:\n              break\n          if is_pali(curr ** 2):\n              count = count + 1\n          p, m = get_next_pali(p, m)\n  \n      print("Case #{}: {}".format(i + 1, count))\n <CODESPLIT> 39
def passes(p, t): #normal, surprising\n      q, r = divmod(t, 3)\n      if r == 0:\n          return q >= p, q + 1 >= p and q\n      elif r == 1:\n          return q + 1 >= p, q + 1 >= p and q\n      elif r == 2:\n          return q + 1 >= p, q + 2 >= p\n  \n  for case in range(int(input())):\n      st = input().strip().split()\n      n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))\n      result = 0\n      for i in t:\n          normal, surprising = passes(p, i)\n          if normal:\n              result += 1\n          elif surprising and s != 0:\n              result += 1\n              s -= 1\n      print("Case #{}: {}".format(case + 1, result))\n <CODESPLIT> 39
 \n  \n  for i in range(int(input())):\n      n, m = tuple(map(int, input().split()))\n      l = dict(chain.from_iterable(map(lambda j: zip(zip([j] * m, range(m)), map(int, input().split())), range(n))))\n      ans = "YES"\n  \n      while len(l):\n          ly, lx = min(l, key=l.get)\n          lowest = l[(ly, lx)]\n  \n          if all(map(lambda j: l.get((ly, j), lowest) == lowest, range(m))):\n              for j in range(m):\n                  l.pop((ly, j), None)\n  \n          elif all(map(lambda j: l.get((j, lx), lowest) == lowest, range(n))):\n              for j in range(n):\n                  l.pop((j, lx), None)\n  \n          else:\n              ans = "NO"\n              break\n  \n      print("Case #{}: {}".format(i + 1, ans))\n <CODESPLIT> 39
for case in range(int(input())):\n      a, b = tuple(map(int, input().split()))\n      result = 0\n      ast, bst = str(a), str(b)\n      for x in range(a, b + 1):\n          xst = str(x)\n          added = list()\n          for j in range(len(xst)):\n              xstr = xst[j:] + xst[:j]\n              if xstr < ast or xstr > bst:\n                  continue\n              elif xst < xstr and xstr not in added:\n                  added.append(xstr)\n                  result += 1\n      print("Case #{}: {}".format(case + 1, result))\n <CODESPLIT> 39
def yoba(s, ch):\n      lines = [True] * 10\n      for i in range(4):\n          for j in range(4):\n              lines[j] = lines[j] and (s[i][j] in (ch, "T"))\n              lines[j + 4] = lines[j + 4] and (s[j][i] in (ch, "T"))\n          lines[8] = lines[8] and (s[i][i] in (ch, "T"))\n          lines[9] = lines[9] and (s[3 - i][i] in (ch, "T"))\n      return any(lines)\n  \n  for i in range(int(input())):\n      s = tuple(map(lambda _: input(), range(4)))\n  \n      if yoba(s, "X"):\n          ans = "X won"\n      elif yoba(s, "O"):\n          ans = "O won"\n      elif "." not in "".join(s):\n          ans = "Draw"\n      else:\n          ans = "Game has not completed"\n  \n      input()\n      print("Case #{}: {}".format(i + 1, ans))\n <CODESPLIT> 39
for case in range(int(input())):\n      a, b = tuple(map(int, input().split()))\n      result = 0\n      ast, bst = str(a), str(b)\n      for x in range(a, b + 1):\n          xst = str(x)\n          added = list()\n          for j in range(len(xst)):\n              xstr = xst[j:] + xst[:j]\n              if xstr < ast or xstr > bst:\n                  continue\n              elif xst < xstr and xstr not in added:\n                  added.append(xstr)\n                  result += 1\n      print("Case #{}: {}".format(case + 1, result))\n <CODESPLIT> 39
 \n  \n  def optimal_war_step(blocks, value):\n  \n      win_blocks = set(filter(lambda block: block > value, blocks))\n      blocks.discard(min(win_blocks if win_blocks else blocks))\n      return bool(win_blocks)\n  \n  \n  def deceitful_war(ken, naomi, epsilon = 10 ** (-6)):\n  \n      while ken:\n  \n          min_ken = min(ken)\n          max_ken = max(ken)\n          min_naomi = min(naomi)\n  \n          if min_ken > min_naomi and any(map(lambda bs: operator.lt(*bs), zip(sorted(naomi), sorted(ken)))):\n  \n              yield max_ken - epsilon\n  \n          else:\n  \n              yield 1.0 - epsilon\n  \n          naomi.discard(min_naomi)\n  \n  \n  for i in range(int(input())):\n  \n      input()\n      naomi = set(map(float, str.split(input())))\n      ken = set(map(float, str.split(input())))\n  \n      dwar_ken = ken.copy()\n      dwar_naomi = naomi.copy()\n      dwar = collections.Counter(map(functools.partial(optimal_war_step, dwar_ken), deceitful_war(dwar_ken, dwar_naomi)))\n      war = collections.Counter(map(functools.partial(optimal_war_step, ken), naomi))\n      print(str.format("Case #{}: {} {}", i + 1, dwar[False], war[False]))\n <CODESPLIT> 39
 \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          c, f, x = [float(t) for t in inputs[0].split()]\n          if x <= c:\n              return '%.7f'%(x/2)\n          ii = int(math.ceil((f*x-2*c)/(f*c)-1))\n          if ii <= 0:\n              return '%.7f'%(x/2)\n          t = 0\n          for i in range(ii):\n              t += c/(2+i*f)\n          t += x/(2+ii*f)\n          return '%.7f'%t\n          pass\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 1\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              outputs.append(self.solve(case_inputs))\n          return outputs\n  \n  if __name__ == '__main__':\n      iname = 'B-small-attempt0.in'\n      sample_in = '''\n      4\n  30.0 1.0 2.0\n  30.0 2.0 100.0\n  30.50000 3.14159 1999.19990\n  500.0 4.0 2000.0\n      '''\n      sample_out = '''\n  Case #1: 1.0000000\n  Case #2: 39.1666667\n  Case #3: 63.9680013\n  Case #4: 526.1904762\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n          for i, v in enumerate(outputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n <CODESPLIT> 40
 \n  def ss(t, amap, bmap):\n      s = 0\n      for m in amap:\n          if len(m) == 1 and t == m.keys()[0]:\n              s += m[t]\n              for b in bmap:\n                  if t in b:\n                      b[t] -= 1\n                      if b[t] == 0:\n                          b.pop(t)\n              m.clear()\n      return s           \n  \n  \n  def solve(case, in_lines):\n      out = 'Case #%d: '%case\n   \n      rn, cn = [int(x) for x in in_lines[0].split()]\n      mtx = []\n      for i in xrange(rn):\n          mtx.append([int(x) for x in in_lines[i+1].split()])\n      rmap = [{} for x in xrange(rn)]\n      cmap = [{} for x in xrange(cn)]\n      td = {}\n      \n      for i in xrange(rn):\n          for j in range(cn):\n              k = mtx[i][j]\n              if k in rmap[i]:\n                  rmap[i][k] += 1\n              else:\n                  rmap[i][k] = 1\n              if k in cmap[j]:\n                  cmap[j][k] += 1\n              else:\n                  cmap[j][k] = 1\n              if k in td:\n                  td[k] += 1\n              else:\n                  td[k] = 1\n                  \n      while len(td):\n          k = min(td.keys())\n          sb = ss(k, rmap, cmap)\n          sb += ss(k, cmap, rmap)\n          if sb == 0:\n              break;\n          td[k] -= sb\n          if td[k] == 0:\n              td.pop(k)\n  \n      return out + ('YES' if sb else 'NO')\n  \n  \n  def main(raw):\n      lines = raw.split('\n')\n      n = int(lines[0])\n      ln = 1\n      outs = []\n      for case in xrange(1, n+1):\n          buff = []\n          cl = int(lines[ln].split()[0]) + ln + 1\n          while ln < cl and lines[ln]:\n              buff.append(lines[ln])\n              ln += 1\n          s = solve(case, buff)\n          print s\n          outs.append(s)\n      return '\n'.join(outs)\n      pass\n  \n  if __name__ == '__main__':\n      test_input = """4\n  4 3\n  2 5 2\n  1 1 1\n  2 4 2\n  2 3 2\n  3 3\n  2 1 2\n  1 1 1\n  2 1 2\n  5 5\n  2 2 2 2 2\n  2 1 1 1 2\n  2 1 2 1 2\n  2 1 1 1 2\n  2 2 2 2 2\n  1 3\n  1 2 1"""\n      force_no_file = False\n      in_file_name = '' if force_no_file else 'B-large.in'\n      base_path = 'G:/workspace/py/codejam2013/RQ/'\n      if in_file_name:\n          with open(base_path + in_file_name) as f:\n              raw = f.read()\n      else:\n          raw = test_input\n      out = main(raw)\n      if in_file_name:\n          with open(base_path + in_file_name + '.out', 'w') as f:\n              f.write(out)\n      pass\n <CODESPLIT> 40
 \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = 0\n      raw = [int(x) for x in case_input[0].split()]\n      ts = raw[3:]\n      ct = raw[1]\n      n = raw[2]\n      cc = 0\n      for i in ts:\n          if i > 3*n-3:\n              result += 1\n          elif i > max(3*n-5, 0):\n              cc += 1\n      result += min(cc, ct)\n  \n      case_output += '%d'%result\n      \n      return case_output\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = """4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  """\n      use_test_data = False\n      \n      test_file = 'B-small-attempt0.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n <CODESPLIT> 40
 \n  def ss(t, amap, bmap):\n      s = 0\n      for m in amap:\n          if len(m) == 1 and t == m.keys()[0]:\n              s += m[t]\n              for b in bmap:\n                  if t in b:\n                      b[t] -= 1\n                      if b[t] == 0:\n                          b.pop(t)\n              m.clear()\n      return s           \n  \n  \n  def solve(case, in_lines):\n      out = 'Case #%d: '%case\n   \n      rn, cn = [int(x) for x in in_lines[0].split()]\n      mtx = []\n      for i in xrange(rn):\n          mtx.append([int(x) for x in in_lines[i+1].split()])\n      rmap = [{} for x in xrange(rn)]\n      cmap = [{} for x in xrange(cn)]\n      td = {}\n      \n      for i in xrange(rn):\n          for j in range(cn):\n              k = mtx[i][j]\n              if k in rmap[i]:\n                  rmap[i][k] += 1\n              else:\n                  rmap[i][k] = 1\n              if k in cmap[j]:\n                  cmap[j][k] += 1\n              else:\n                  cmap[j][k] = 1\n              if k in td:\n                  td[k] += 1\n              else:\n                  td[k] = 1\n                  \n      while len(td):\n          k = min(td.keys())\n          sb = ss(k, rmap, cmap)\n          sb += ss(k, cmap, rmap)\n          if sb == 0:\n              break;\n          td[k] -= sb\n          if td[k] == 0:\n              td.pop(k)\n  \n      return out + ('YES' if sb else 'NO')\n  \n  \n  def main(raw):\n      lines = raw.split('\n')\n      n = int(lines[0])\n      ln = 1\n      outs = []\n      for case in xrange(1, n+1):\n          buff = []\n          cl = int(lines[ln].split()[0]) + ln + 1\n          while ln < cl and lines[ln]:\n              buff.append(lines[ln])\n              ln += 1\n          s = solve(case, buff)\n          print s\n          outs.append(s)\n      return '\n'.join(outs)\n      pass\n  \n  if __name__ == '__main__':\n      test_input = """4\n  4 3\n  2 5 2\n  1 1 1\n  2 4 2\n  2 3 2\n  3 3\n  2 1 2\n  1 1 1\n  2 1 2\n  5 5\n  2 2 2 2 2\n  2 1 1 1 2\n  2 1 2 1 2\n  2 1 1 1 2\n  2 2 2 2 2\n  1 3\n  1 2 1"""\n      force_no_file = False\n      in_file_name = '' if force_no_file else 'B-small-attempt0.in'\n      base_path = 'G:/workspace/py/codejam2013/RQ/'\n      if in_file_name:\n          with open(base_path + in_file_name) as f:\n              raw = f.read()\n      else:\n          raw = test_input\n      out = main(raw)\n      if in_file_name:\n          with open(base_path + in_file_name + '.out', 'w') as f:\n              f.write(out)\n      pass\n <CODESPLIT> 40
 \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = 0\n      raw = case_input[0].split()\n      n = len(raw[0])\n      a = int(raw[0])\n      b = int(raw[1])\n      \n      for i in xrange(a, b):\n          rslt = set()\n          for t in xrange(1, n):\n              tt = 10**t\n              tn = 10**(n-t)\n              ia, ib = divmod(i, tt)\n              ii = ib*tn + ia\n              if ii > i and ii <= b:\n                  rslt.add(ii)\n          result += len(rslt)\n          \n  \n      case_output += '%d'%result\n      \n      return case_output\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = """5\n  1 9\n  10 40\n  100 500\n  1111 2222\n  1000000 2000000\n  """\n      use_test_data = False\n      \n      test_file = 'C-small-attempt0.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n <CODESPLIT> 40
 \n  mm = [0xf, 0xf0, 0xf00, 0xf000, 0x8888, 0x4444, 0x2222, 0x1111, 0x8421, 0x1248]\n  \n  def solve(case, in_lines):\n      out = 'Case #%d: '%case\n      s = ''.join(in_lines)\n      x = 0\n      o = 0\n      nc = False\n      for i in xrange(16):\n          m = 1 << i\n          c = s[i]\n          if c == 'X':\n              x |= m\n          elif c == 'O':\n              o |= m\n          elif c == 'T':\n              x |= m\n              o |= m\n          else:\n              nc = True\n      r = ''\n      for m in mm:\n          if m & x == m:\n              r = 'X won'\n              break\n          if m & o == m:\n              r = 'O won'\n              break\n      if not r:\n          if nc:\n              r = 'Game has not completed'\n          else:\n              r = 'Draw'\n      \n      return out + r\n  \n  \n  def main(raw):\n      lines = raw.split('\n')\n      n = int(lines[0])\n      ln = 0\n      outs = []\n      for case in xrange(1, n+1):\n          buff = []\n          ln += 1\n          while ln < len(lines) and lines[ln]:\n              buff.append(lines[ln])\n              ln += 1\n          s = solve(case, buff)\n          print s\n          outs.append(s)\n      return '\n'.join(outs)\n      pass\n  \n  if __name__ == '__main__':\n      test_input = """6\n  XXXT\n  ....\n  OO..\n  ....\n  \n  XOXT\n  XXOO\n  OXOX\n  XXOO\n  \n  XOX.\n  OX..\n  ....\n  ....\n  \n  OOXX\n  OXXX\n  OX.T\n  O..O\n  \n  XXXO\n  ..O.\n  .O..\n  T...\n  \n  OXXX\n  XO..\n  ..O.\n  ...O"""\n      force_no_file = False\n      in_file_name = '' if force_no_file else 'A-small-attempt0.in'\n      base_path = 'G:/workspace/py/codejam2013/RQ/'\n      if in_file_name:\n          with open(base_path + in_file_name) as f:\n              raw = f.read()\n      else:\n          raw = test_input\n      out = main(raw)\n      if in_file_name:\n          with open(base_path + in_file_name + '.out', 'w') as f:\n              f.write(out)\n      pass\n <CODESPLIT> 40
 \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = ""\n      for c in case_input[0]:\n          if c in map:\n              result += map[c]\n          else:\n              result += c\n  \n      case_output += '%s'%result\n      \n      return case_output\n  \n  \n  def getmap():\n      inputs = ["ejp mysljylc kd kxveddknmc re jsicpdrysi",\n                "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n                "de kr kd eoya kw aej tysr re ujdr lkgc jv"]\n      outputs = ["our language is impossible to understand",\n                 "there are twenty six factorial possibilities",\n                 "so it is okay if you want to just give up"]\n      map = {}\n      for case in xrange(3):\n          for i, c in enumerate(inputs[case]):\n              map[c] = outputs[case][i]\n      \n      map['q'] = 'z'\n      map['z'] = 'q'\n      \n      print map\n      print len(map)\n      for c in "abcdefghijklmnopqrstuvwxyz":\n          if c not in map:\n              print c\n      return map\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = """3\n  ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv\n      """\n      use_test_data = False\n      \n      map = getmap()\n      \n      test_file = 'A-small-attempt2.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n <CODESPLIT> 40
 \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          nn = [float(x) for x in inputs[1].split()]\n          nn.sort()\n          kk = [float(x) for x in inputs[2].split()]\n          kk.sort()\n          dw = self.dwar(nn[:], kk[:])\n          w = self.war(nn[:], kk[:])\n          return '%d %d'%(dw, w)\n          pass\n      \n      def dwar(self, nn, kk):\n          turn = len(nn)\n          cnt = 0\n          for i in range(turn):\n              i = i\n              if nn[-1] < kk[-1]:\n                  nn.pop(0)\n                  kk.pop(-1)\n              elif nn[0] < kk[0]:\n                  nn.pop(0)\n                  kk.pop(-1)\n              else:\n                  cnt += 1\n                  nn.pop(0)\n                  kk.pop(0)\n          return cnt\n      \n      def war(self, nn, kk):\n          turn = len(nn)\n          cnt = 0\n          for i in range(turn):\n              i = i\n              j = bisect.bisect_left(kk, nn[0])\n              if j == len(kk):\n                  cnt += 1\n                  kk.pop(0)\n              else:\n                  kk.pop(j)\n              nn.pop(0)\n          return cnt\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 3\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              outputs.append(self.solve(case_inputs))\n          return outputs\n  \n  if __name__ == '__main__':\n      iname = 'D-small-attempt0.in'\n      sample_in = '''\n  4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n      '''\n      sample_out = '''\n  Case #1: 0 0\n  Case #2: 1 0\n  Case #3: 2 1\n  Case #4: 8 4\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n          for i, v in enumerate(outputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n <CODESPLIT> 40
'''\n  Created on Apr 11, 2014\n  \n  @author: mostasem\n  '''\n  \n  \n  def getSeconds(C,F,X):\n      seconds = 0.0\n      cookie_rate = 2\n      solved =False\n      while (not solved):\n          choice1 = X/cookie_rate\n          choice2 = C/cookie_rate + X/(cookie_rate + F)\n          if(choice1 < choice2):\n              seconds += choice1\n              solved = True\n          else :\n              seconds += C/cookie_rate\n              cookie_rate += F\n      \n      return seconds\n  \n  f_r = open('B.in',"r")\n  n_test=int(f_r.readline().strip()) \n  f_w = open("B.out", "w")\n  result = ""\n  for i in range(n_test):\n      C,F,X = map(float,f_r.readline().split())\n      seconds = getSeconds(C,F,X)\n      result = str(seconds)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      \n  f_r.close()\n  f_w.close()\n  \n <CODESPLIT> 41
'''\n  Created on Apr 12, 2013\n  \n  @author: Moatasem\n  '''\n  \n  \n  \n  def isPalindrome(word):\n      isPalin=False\n      if(len(word)%2==0):\n          f_half=word[0:len(word)/2];\n          s_half=word[len(word)/2:len(word)][::-1]\n          if( f_half==s_half):\n              isPalin= True\n      else:\n          f_half=word[0:len(word)/2]\n          s_half=word[(len(word)/2)+1:len(word)][::-1]\n          if( f_half==s_half):\n              isPalin= True\n      return isPalin\n      \n  def getNumberOfFairAndSquare(range_):\n      start=range_[0]\n      end=range_[1]\n      count_=0\n      for i in range(start,end+1):\n          root=math.sqrt(i);\n          if(root.is_integer() and isPalindrome(str(int(root))) and isPalindrome(str(i))):\n              count_+=1\n      return count_\n          \n          \n      \n  \n  f_r = open('C.in',"r")\n  n_test=int(f_r.readline().strip()) \n  f_w = open("C.out", "w")\n  for i in range(n_test):\n      range_ =map(int,f_r.readline().split())\n      result=getNumberOfFairAndSquare(range_)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n  f_r.close()\n  f_w.close()\n <CODESPLIT> 41
'''\n  Created on Apr 14, 2012\n  \n  @author: moatasem\n  '''\n  \n  \n  def isSurprising(t):\n      if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):\n          return True\n      else:\n          return False\n  \n  \n  def getAllTriplets(n):\n      h=[]\n      for i in xrange(11):\n          for j in xrange(i,11):\n              for  k in xrange(j,11):\n                  if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):\n                      h.append((i,j,k))\n              \n      return  h\n  \n  def getInfo(p,total,S):\n      g= getAllTriplets(total)\n      if(S):\n          s_=len(g)\n          indcies=[]\n          for i in xrange (s_):\n              if(isSurprising(g[i])):\n                  indcies.append(i)\n          for i in xrange (len(indcies)):  \n              g.remove(g[indcies[i]])\n      equ=False\n      sur=False\n      sur_equ=False\n      for i in xrange(len(g)):\n          if(max(g[i])>=p):\n              if(isSurprising(g[i])):\n                  sur_equ=True\n              else:\n                  equ=True\n          elif(isSurprising(g[i])):\n                  sur=True\n      return sur_equ,equ,sur\n             \n  f = open("b_.in", "r")\n  n=int(f.readline().strip())\n  for k  in xrange(n):\n      d=f.readline().strip()\n      googlers=[]\n      g=[int(i) for i in d.split(" ")]\n      N=g[0]\n      S=g[1]\n      noSu=False\n      if(S==0):\n          noSu=True\n      p=g[2]\n      count=0\n      equ_count=0;\n      both_count=0;\n      sur_count=0;\n      first_count=0;\n      googlers=g[3:len(g)]\n      for o in xrange(N):\n          info=getInfo(p,googlers[o],noSu)\n          if(info[0]==True and info[1]==False and S<>0): #101 /100\n              count+=1\n              S-=1\n          elif(info[0]==True and info[1]==True):#110 / 111\n              first_count+=1\n          elif(info[1]==True and info[2]==True):#011\n              both_count+=1\n          elif(info[1]==True):#010\n              count+=1\n          elif(info[2]==True):#001\n              sur_count+=1\n      count+=first_count\n      if(S>0):\n          if(first_count>S):\n              S=0\n          elif(first_count <=S) :\n              S-=first_count\n              if(S>0):\n                   if(both_count>S):\n                      both_count-=S\n                      S=0\n                   else:\n                      both_count=0\n      count+=both_count\n      \n      print 'Case #'+str((k+1))+": "+str(count)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n      \n  \n <CODESPLIT> 41
'''\n  Created on Apr 12, 2013\n  \n  @author: Moatasem\n  '''\n  \n  \n  \n  \n  \n  def markMax(max_,start,end,marked,isRow,lawn):\n      for i in range(end):\n              if(isRow):\n                  if( lawn[start][i]==max_):\n                      marked[start][i]=-1\n              else: \n                  if( lawn[i][start]==max_):\n                      marked[i][start]=-1\n                      \n                  \n      \n      \n  def mowerLawn(lawn,m,n,marked):\n      for i in range(m):\n          max_=max(lawn[i])\n          markMax(max_,i,n,marked,True,lawn) \n      \n      for i in range(n):\n          colList=[]\n          for j in range(m):\n              colList.append(lawn[j][i])\n          max_=max(colList)\n          markMax(max_,i,m,marked,False,lawn) \n             \n      done=True\n      for i in range(m):\n          for j in range(n):\n              if(marked[i][j]!=-1):\n                  done=False\n                  break\n          if(not done):\n              break\n      if(done):\n          return 'YES'\n      else:\n          return 'NO'\n      \n          \n      \n  \n  f_r = open('B.in',"r")\n  n_test=int(f_r.readline().strip()) \n  f_w = open("B.out", "w")\n  for i in range(n_test):\n      lawn=[]\n      \n      range_ =map(int,f_r.readline().split())\n      marked=[[0]*range_[1] for x in xrange(range_[0])]\n      for j in range(range_[0]):\n          temp=[map(int,f_r.readline().split())]\n          lawn.extend(temp)\n      result=mowerLawn(lawn,range_[0],range_[1],marked)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n  f_r.close()\n  f_w.close()\n <CODESPLIT> 41
'''\n  Created on Apr 14, 2012\n  \n  @author: moatasem\n  '''\n  \n  def getNumRecycle(n,A,B,h):\n          c=0\n          x=list(str(n))\n          for i in xrange(1,len(x)):\n              t1="".join(x[0:i])\n              t2="".join(x[i:len(x)])\n              num=int(t2+t1)\n              if((num>=A and num<=B) and num<>n and h.get((num,n))==None and h.get((n,num))==None):\n                  h[(num,n)]=0;\n                  c+=1\n          return c\n      \n      \n  f = open("C-small-attempt0.in", "r")\n  n=int(f.readline().strip())\n  for k  in xrange(n):\n      d=f.readline().strip()\n      A,B=[int(i) for i in d.split(" ")]\n      count=0\n      h={}\n      for j in range(A,B+1):\n          count+= getNumRecycle(j,A,B,h)\n      print 'Case #'+str((k+1))+": "+str(count)\n <CODESPLIT> 41
'''\n  Created on Apr 12, 2013\n  \n  @author: Moatasem\n  '''\n  \n  def getStatus(board):\n      status="" \n      solved=False\n      n_dotted=0\n      for i in range(4):\n          result= checkBoard(board[i])\n          if(result!="None"):\n              status=result\n              solved=True\n          else:\n              columnlist=[]\n              for j in range(4):\n                  if(board[i][j]=='.'):\n                      n_dotted+=1\n                  columnlist.append(board[j][i])\n              result= checkBoard(columnlist)\n              if(result!="None"): \n                  solved=True\n                  status=result\n                  break\n          if(solved):\n              break\n          \n      result_l=checkBoard([board[x][x] for x in range(4)]) #leftDiagonal\n      result_r=checkBoard([board[0][3],board[1][2],board[2][1],board[3][0]]) #rightDiagonal\n      if(result_l!="None"): \n              solved=True\n              status=result_l\n      if(result_r!="None"): \n              solved=True\n              status=result_r\n                  \n      if(solved==False):\n          if(n_dotted==0):\n              status="Draw"\n          else: \n              status="Game has not completed"   \n  \n      return status\n  \n  \n  def checkBoard(board):\n          status="None"\n          x_count=board.count('X')\n          o_count=board.count('O')\n          t_count=board.count('T')\n          if(x_count==4 or (x_count==3 and t_count==1)):\n              status="X won"\n          elif(o_count==4 or (o_count==3 and t_count==1)):\n              status="O won"\n          return status\n  \n  \n  f_r = open('A.in',"r")\n  n_test=int(f_r.readline().strip()) \n  \n  f_w = open("A.out", "w")\n  for i in range(n_test):\n      board=[]\n      for j in range(4):\n          board.append(f_r.readline().strip())\n      result= getStatus(board)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      f_r.readline()\n  f_r.close()\n  f_w.close()\n <CODESPLIT> 41
'''\n  Created on Apr 14, 2012\n  \n  @author: moatasem\n  '''\n  lan={'z':'q','q':'z',' ':' '}\n  \n  s1=list("ejp mysljylc kd kxveddknmc re jsicpdrysi")\n  e1=list ("our language is impossible to understand")\n  s2=list("rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd")\n  e2=list ("there are twenty six factorial possibilities")\n  s3=list("de kr kd eoya kw aej tysr re ujdr lkgc jv")\n  e3=list ("so it is okay if you want to just give up")\n  for i in xrange(len(s1)):\n      if(lan.get(s1[i])==None and s1[i]!=" "):\n          lan[s1[i]]=e1[i]\n      if(lan.get(s2[i])==None and s2[i]!=" "):\n          lan[s2[i]]=e2[i]\n      if(lan.get(s3[i])==None and s3[i]!=" "):\n          lan[s3[i]]=e3[i]\n          \n  f = open("A-small-attempt0.in", "r")\n  n=int(f.readline().strip())\n  for i  in xrange(n):\n      line=f.readline().strip()\n      res='Case #'+str((i+1))+": "\n      for j in xrange(len(line)):\n          res+=str(lan.get(line[j]))\n      print res\n          \n      \n  \n <CODESPLIT> 41
'''\n  Created on Apr 11, 2014\n  \n  @author: mostasem\n  '''\n  def solveWar(Naomi, Ken):\n      NPoints = 0\n      while(len(Naomi) <> 0):\n          Nmax = max(Naomi)\n          Kmax = max(Ken)\n          Kmin = min(Ken)\n          if(Nmax > Kmax):\n              NPoints += 1\n              Naomi.remove(Nmax)\n              Ken.remove(Kmin)\n          else:\n              Naomi.remove(Nmax)\n              Ken.remove(Kmax)\n      return NPoints\n  \n  \n  def getKeyWithMaxValue(dict_):\n   \n      keys = dict_.keys()\n      currentKey = 0.0\n      min_val = 10000000000000000\n      for i in range(len(keys)): \n          if(min_val > dict_.get(keys[i])):\n              min_val = dict_.get(keys[i])\n              currentKey = keys[i]\n          elif(min_val == dict_.get(keys[i])):\n              if(currentKey > keys [i]):\n                  currentKey = keys[i]\n              \n      return currentKey\n  \n          \n  def updateWeights(Naomi, Ken):  \n      NaomiHash = {}     \n      for i in range(len(Naomi)):\n          if(NaomiHash.get(Naomi[i]) == None):\n                  NaomiHash[Naomi[i]] = 0\n          for j in range(len(Ken)):\n              if(Naomi[i] > Ken [j]):\n                      NaomiHash[Naomi[i]] += 1\n      return NaomiHash\n  \n  \n  def checkIFAllBigger(NaomiHash,Ken):\n      k = len(Ken)\n      allBigger = True\n      values = list(NaomiHash.values());\n      for i in range(k):\n          found = False\n          for j in range(len(values)):\n              if(values [j] >= k - i):\n                  values.remove(values[j])\n                  found = True\n                  break\n          if(not found):\n              allBigger = False\n              break\n      return allBigger\n  \n  def solveDecitfulWar(Naomi, Ken):\n      NPoints = 0\n      NaomiHash = updateWeights(Naomi, Ken)\n      while(len(Naomi) <> 0):\n          if(checkIFAllBigger(NaomiHash,Ken)):\n              NPoints += len(Ken)\n              break\n          NChoice = getKeyWithMaxValue(NaomiHash)\n          print NChoice\n          Kmax = max(Ken)\n          Kmin = min(Ken)\n          if(NChoice > Kmax):\n              NPoints += 1\n              Naomi.remove(NChoice)\n              NaomiHash[NChoice] = 10000000000000000\n              Ken.remove(Kmin)\n          else:\n              Naomi.remove(NChoice)\n              NaomiHash[NChoice] = 10000000000000000\n              Ken.remove(Kmax)\n          NaomiHash = updateWeights(Naomi, Ken)\n          \n      return NPoints\n  \n  \n   \n  f_r = open('D.in',"r")\n  n_test=int(f_r.readline().strip()) \n  f_w = open("D.out", "w")\n  result = ""\n  for i in range(n_test):\n      list_len = int(f_r.readline().strip()) \n      Naomi = map(float,f_r.readline().split())\n      Ken = map(float,f_r.readline().split())\n      \n      Naomi2 = list(Naomi)\n      Ken2 = list(Ken)\n      p1 =  solveWar(Naomi, Ken)\n      p2 =  solveDecitfulWar(Naomi2, Ken2)\n      result = str(p2)+" "+str(p1)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      \n  f_r.close()\n <CODESPLIT> 41
 \n  FILE_NAME_BASE = 'B-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  	cost, prod, goal = (float(x) for x in inp.readline().split())\n  	return cost, prod, goal\n  \n  def solve(cost, prod, goal):\n  	rate = 2\n  	now = 0\n  	while True:\n  		nobuyEnd = goal / rate\n  		buyEnd = cost / rate + goal / (rate + prod)\n  		if buyEnd < nobuyEnd:\n  			now += cost / rate\n  			rate += prod\n  		else:\n  			return '%0.7f' % (now + nobuyEnd)\n  \n  def main():\n  	sys.setrecursionlimit(RECURSION_LIMIT)\n  \n  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  	inp = open(FILE_NAME_BASE + '.in', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 42
 \n  \n  FILE_NAME_BASE = 'C-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  	a, b = (int(x) for x in inp.readline().split())\n  	return a, b\n  \n  def isFair(x):\n  	l1 = list(str(x))\n  	l2 = list(l1)\n  	l2.reverse()\n  	return l1 == l2\n  \n  def solve(a, b):\n  	c = 0\n  	for i in xrange(a, b + 1):\n  		r = int(sqrt(i))\n  		if r * r == i and isFair(i) and isFair(r):\n  			c += 1\n  \n  	return str(c)\n  \n  def main():\n  	sys.setrecursionlimit(RECURSION_LIMIT)\n  \n  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  	inp = open(FILE_NAME_BASE + '.in', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 42
 \n  FILE_NAME_BASE = 'B-small-attempt0'\n  NUM_PROCESSES = 0\n  \n  def parse(inp):\n  	data = tuple(int(x) for x in inp.readline().split())\n  	dancers, surprises, points = data[ : 3]\n  	totals = data[3 : ]\n  	assert len(totals) == dancers\n  	return totals, surprises, points\n  \n  def totalAtDist():\n  	'''\n  	If a dancer's best result is b, the total can be:\n  	  distance 0: 3b\n  	  distance 1: [3b-2..3b-1]\n  	  distance 2: [3b-4..3b-2]\n  	Note: distance d is only possible if d <= b.\n  \n  	total 15:\n  	b = 0..4:  impossible\n  	b = 5:     dist = 0\n  	b = 6:     dist = 2\n  	b = 7..10: impossible\n  \n  	For every total we have a number of explanations, which are\n  	(b, d) pairs where b is the best result and d is the distance.\n  \n  	The output of this function shows:\n  \n  	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:\n  	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)\n  	In other words, always one surprise option and one normal option.\n  	The surprise option can have a result one higher than the normal one or\n  	equal to it.\n  	'''\n  \n  	print '  ',\n  	for b in xrange(0, 11):\n  		print 'b=%d' % b,\n  	print\n  	for total in xrange(0, 31):\n  		print '%2d' % total,\n  		for b in xrange(0, 11):\n  			s = '0' if total == b * 3 else '.'\n  			s += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'\n  			s += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'\n  			print s,\n  		print\n  \n  \n  def solve(totals, surprises, points):\n  	countCertain = 0\n  	countSurprise = 0\n  	for total in totals:\n  		if (total + 2) / 3 >= points:\n  			countCertain += 1\n  		elif 2 <= total <= 28 and (total + 4) / 3 >= points:\n  			countSurprise += 1\n  		else:\n  			pass\n  \n  \n  	return countCertain + min(countSurprise, surprises)\n  \n  if __name__ == '__main__':\n  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out.txt', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n <CODESPLIT> 42
 \n  FILE_NAME_BASE = 'B-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  	rows, cols = (int(x) for x in inp.readline().split())\n  	return tuple(\n  		tuple(int(x) for x in inp.readline().split())\n  		for row in xrange(rows)\n  		),\n  \n  def solve(lawn):\n  \n  	rowMax = tuple(max(row) for row in lawn)\n  	colMax = tuple(max(row[i] for row in lawn) for i in xrange(len(lawn[0])))\n  \n  	def possible():\n  		for y, row in enumerate(lawn):\n  			for x, cell in enumerate(row):\n  				h = min(rowMax[y], colMax[x])\n  				if cell != h:\n  					return False\n  		return True\n  \n  	return 'YES' if possible() else 'NO'\n  \n  def main():\n  	sys.setrecursionlimit(RECURSION_LIMIT)\n  \n  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  	inp = open(FILE_NAME_BASE + '.in', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 42
 \n  FILE_NAME_BASE = 'C-small-attempt0'\n  NUM_PROCESSES = 0\n  \n  def parse(inp):\n  	a, b = (int(x) for x in inp.readline().split())\n  	return a, b\n  \n  def solve(a, b):\n  	count = 0\n  	for i in xrange(a, b):\n  		s = str(i)\n  		recycled = set()\n  		for d in xrange(1, len(s)):\n  			r = s[d : ] + s[ : d]\n  			if i < int(r) <= b:\n  				recycled.add(r)\n  		count += len(recycled)\n  	return count\n  \n  if __name__ == '__main__':\n  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out.txt', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n <CODESPLIT> 42
 \n  FILE_NAME_BASE = 'A-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  	board = tuple( inp.readline().rstrip() for _ in xrange(4) )\n  	empty = inp.readline().rstrip()\n  	assert empty == '', empty\n  	return board,\n  \n  def solve(board):\n  \n  	def scan(start, delta):\n  		x, y = start\n  		dx, dy = delta\n  		for _ in xrange(4):\n  			yield board[y][x]\n  			x += dx\n  			y += dy\n  \n  	for start, delta in (\n  		((0, 0), (1, 0)),\n  		((0, 1), (1, 0)),\n  		((0, 2), (1, 0)),\n  		((0, 3), (1, 0)),\n  		((0, 0), (0, 1)),\n  		((1, 0), (0, 1)),\n  		((2, 0), (0, 1)),\n  		((3, 0), (0, 1)),\n  		((0, 0), (1, 1)),\n  		((3, 0), (-1, 1)),\n  		):\n  		chars = set(scan(start, delta))\n  		if chars == set(['X']) or chars == set(['X', 'T']):\n  			return 'X won'\n  		elif chars == set(['O']) or chars == set(['O', 'T']):\n  			return 'O won'\n  \n  	if any('.' in row for row in board):\n  		return 'Game has not completed'\n  	else:\n  		return 'Draw'\n  \n  def main():\n  	sys.setrecursionlimit(RECURSION_LIMIT)\n  \n  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  	inp = open(FILE_NAME_BASE + '.in', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 42
 \n  FILE_NAME_BASE = 'A-small'\n  NUM_PROCESSES = 0\n  \n  def findMapping(knowledge):\n  	mapping = {}\n  	for english, googlerese in knowledge:\n  		assert len(english) == len(googlerese)\n  		for engChar, gooChar in zip(english, googlerese):\n  			if ord('a') <= ord(engChar) <= ord('z'):\n  				assert ord('a') <= ord(gooChar) <= ord('z')\n  				if gooChar in mapping:\n  					assert mapping[gooChar] == engChar\n  				else:\n  					mapping[gooChar] = engChar\n  			else:\n  				assert engChar == gooChar\n  \n  	alphabet = set(chr(i) for i in xrange(ord('a'), ord('z') + 1))\n  	gooMissing = alphabet - set(mapping.iterkeys())\n  	engMissing = alphabet - set(mapping.itervalues())\n  	assert len(gooMissing) == len(engMissing)\n  	if len(gooMissing) == 1:\n  		gooChar, = gooMissing\n  		engChar, = engMissing\n  		mapping[gooChar] = engChar\n  	else:\n  		assert len(gooMissing) == 0\n  \n  	assert len(mapping) == 26, mapping\n  	return ''.join(mapping.get(chr(i), chr(i)) for i in xrange(256))\n  \n  def parse(inp):\n  	return inp.readline().rstrip('\n'),\n  \n  def solve(line):\n  	return line.translate(mapping)\n  \n  knowledge = (\n  	( 'our language is impossible to understand',\n  	  'ejp mysljylc kd kxveddknmc re jsicpdrysi' ),\n  	( 'there are twenty six factorial possibilities',\n  	  'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' ),\n  	( 'so it is okay if you want to just give up',\n  	  'de kr kd eoya kw aej tysr re ujdr lkgc jv' ),\n  	( 'a zoo',\n  	  'y qee' ),\n  	)\n  \n  mapping = findMapping(knowledge)\n  \n  if __name__ == '__main__':\n  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out.txt', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n <CODESPLIT> 42
 \n  FILE_NAME_BASE = 'D-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  \n  def parse(inp):\n  	numBlocks, = (int(x) for x in inp.readline().split())\n  	naomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n  	kenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n  	assert len(naomiBlocks) == numBlocks\n  	assert len(kenBlocks) == numBlocks\n  	return naomiBlocks, kenBlocks\n  \n  def solve(naomiBlocks, kenBlocks):\n  	numBlocks = len(naomiBlocks)\n  \n  	kenPointsHonest = 0\n  	naomiLowerBlocks = 0\n  	for _, owner in sorted(chain(\n  			((b, 'n') for b in naomiBlocks),\n  			((b, 'k') for b in kenBlocks)\n  			)):\n  		if owner == 'n':\n  			naomiLowerBlocks += 1\n  		elif naomiLowerBlocks != 0:\n  			naomiLowerBlocks -= 1\n  			kenPointsHonest += 1\n  	naomiPointsHonest = numBlocks - kenPointsHonest\n  \n  	naomiLoIdx = 0\n  	naomiHiIdx = numBlocks - 1\n  	kenLoIdx = 0\n  	kenHiIdx = numBlocks - 1\n  	naomiPointsDeceit = 0\n  	while naomiLoIdx <= naomiHiIdx:\n  		assert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx\n  		naomiLo = naomiBlocks[naomiLoIdx]\n  		kenLo = kenBlocks[kenLoIdx]\n  		if naomiLo > kenLo:\n  			naomiPointsDeceit += 1\n  			kenLoIdx += 1\n  		else:\n  			kenHiIdx -= 1\n  		naomiLoIdx += 1\n  \n  \n  	return '%d %d' % (naomiPointsDeceit, naomiPointsHonest)\n  \n  def main():\n  	sys.setrecursionlimit(RECURSION_LIMIT)\n  \n  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  	inp = open(FILE_NAME_BASE + '.in', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 42
T = int(raw_input().strip())\n  \n  for i in xrange(T):\n  	C, F, X = map(float, raw_input().strip().split(' '))\n  	best = X / 2.0\n  	c_sum = 0\n  	factories = 1\n  	n_sum = c_sum + C / (2.0 + (factories - 1) * F)\n  	while n_sum + X / (2.0 + factories * F) < best:\n  		best = n_sum + X / (2.0 + factories * F)\n  		c_sum = n_sum\n  		factories += 1\n  		n_sum = c_sum + C / (2.0 + (factories - 1) * F)\n  \n  	print "Case #%s: %s" % (i + 1, best)\n <CODESPLIT> 43
 \n  \n  LIMIT = 10\n  \n  def check_palindrome(number):\n      rev = 0\n      runner = number\n      while runner > 0:\n          rev = rev * 10 + (runner % 10)\n          runner /= 10\n      if rev == number:\n          return True\n      else:\n          return False\n  \n  def list_to_number(number_list):\n      l = len(number_list)\n      res = 0; rres = 0\n      multi = 1\n      for i in xrange(1, l + 1):\n          res += number_list[l - i] * multi\n          rres += number_list[i - 1] * multi\n          multi *= 10\n      return (res, rres)\n  \n  def gen_one_side(side_length):\n      state = [0 for _ in xrange(side_length)]\n      done = False\n  \n      while not done:\n          if state[-1] != 0:\n              yield state\n          state[-1] += 1\n          curr = side_length - 1\n          while state[curr] == LIMIT:\n              if curr == 0:\n                  done = True\n                  break\n              state[curr] = 0\n              curr -= 1\n              state[curr] += 1\n  \n  def gen_odd_palindrome(side_length):\n      if side_length == 0:\n          for i in xrange(1, 10):\n              yield i\n      else:\n          multi = 10**side_length\n          for one_side in gen_one_side(side_length):\n              number, rnumber = list_to_number(one_side)\n              for i in xrange(LIMIT):\n                  yield number + i * multi + rnumber * multi * 10\n  \n  def gen_even_palindrome(side_length):\n      multi = 10**side_length\n      for one_side in gen_one_side(side_length):\n          number, rnumber = list_to_number(one_side)\n          yield number + rnumber * multi\n  \n  \n  def gen_palindrome():\n      l = 1\n  \n      while True:\n          if l % 2 == 1:\n              for odd_pal in gen_odd_palindrome((l - 1) / 2):\n                  yield odd_pal\n          else:\n              for even_pal in gen_even_palindrome(l / 2):\n                  yield even_pal\n          l += 1\n  \n  \n  cache = []\n  upper = 10**14\n  for pal in gen_palindrome():\n      pal2 = pal**2\n      if pal2 > upper:\n          break\n      if check_palindrome(pal2):\n          cache.append(pal2)\n  \n  cl = len(cache)\n  T = int(raw_input().strip())\n  for i in xrange(T):\n      low_ind = 0\n      high_ind = cl - 1\n      A, B = map(int, raw_input().strip().split(' '))\n  \n      while cache[low_ind] < A:\n          low_ind += 1\n      while cache[high_ind] > B:\n          high_ind -= 1\n  \n  \n      if low_ind <= high_ind:\n          print "Case #%s: %s" % (i + 1, high_ind - low_ind + 1)\n      else:\n          print "Case #%s: 0" % (i + 1)\n <CODESPLIT> 43
 \n  surprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]\n  regular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]\n  \n  f = open(argv[1], 'r')\n  T = int(f.readline().strip('\n'))\n  for i in range(T):\n  	both = 0\n  	surp_only = 0\n  	line = f.readline().strip('\n').split(' ')\n  	N = int(line[0]) # What for?\n  	S = int(line[1])\n  	p = int(line[2])\n  	ts = map(int, line[3:])\n  	for t in ts:\n  		if reduce(max, map(max, regular[t])) >= p:\n  			both += 1\n  		elif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:\n  			surp_only += 1\n  \n  	print "Case #%s: %s" % (i + 1, both + min(surp_only, S))\n <CODESPLIT> 43
YES = 0\n  NO = 1\n  \n  messages = [\n      "YES",\n      "NO"\n  ]\n  \n  \n  \n  \n  \n  \n  \n  \n  def check_lawn(lawn, N, M):\n      row_maxs = [0 for _ in xrange(N)]\n      col_maxs = [0 for _ in xrange(M)]\n  \n      for i in xrange(N):\n          cmax = -1\n          for j in xrange(M):\n              if lawn[i][j] > cmax:\n                  cmax = lawn[i][j]\n          row_maxs[i] = cmax\n  \n      for j in xrange(M):\n          cmax = -1\n          for i in xrange(N):\n              if lawn[i][j] > cmax:\n                  cmax = lawn[i][j]\n          col_maxs[j] = cmax\n  \n      for i in xrange(N):\n          for j in xrange(M):\n              if row_maxs[i] > lawn[i][j] and col_maxs[j] > lawn[i][j]:\n                  return NO\n  \n      return YES\n  \n  \n  T = int(raw_input().strip())\n  for i in xrange(T):\n      N, M = map(int, raw_input().strip().split(' '))\n      lawn = [[] for j in xrange(N)]\n      for j in xrange(N):\n          lawn[j] = map(int, raw_input().strip().split(' '))\n      print "Case #%s: %s" % (i + 1, messages[check_lawn(lawn, N, M)])\n <CODESPLIT> 43
 \n  def grab2(x):\n  	if x < 2:\n  		return 0\n  	return x * (x - 1) / 2\n  \n  def solve(low, high):\n  	was = [0 for i in range(low, high + 1)]\n  	total = 0\n  \n  	for i in xrange(low, high + 1):\n  		if was[i - low] == 0:\n  			was[i - low] = 1\n  			variations = set([i])\n  			\n  			if global_variations[i] != []:\n  				for j in global_variations[i]:\n  					if j >= low and j <= high:\n  						was[j - low] = 1\n  						variations.add(j)\n  			else:\n  				curr = i\n  				clen = int(floor(log10(i)))\n  				pow10 = pow(10, clen)\n  				cgvariations = set(list(variations))\n  				for i in range(clen):\n  					pre = curr % 10\n  					curr = pow10 * pre + (curr - (curr % 10)) / 10\n  					if pre != 0 and curr not in variations and curr >= low and curr <= high:\n  						variations.add(curr)\n  						was[curr - low] = 1\n  					if pre != 0 and curr < ma and curr not in cgvariations:\n  						cgvariations.add(curr)\n  \n  				for cg in cgvariations:\n  					global_variations[cg] = list(cgvariations)\n  \n  			total += grab2(len(variations))\n  \n  \n  	return total\n  \n  f = open(argv[1], 'r')\n  T = int(f.readline().strip('\n'))\n  mi = 2000000\n  ma = 1\n  ab = []\n  for i in range(T):\n  	ab.append(map(int, f.readline().strip('\n').split(' ')))\n  	if ab[-1][1] > ma:\n  		ma = ab[-1][1]\n  \n  global_variations = [[] for i in range(ma + 2)]\n  \n  i = 1\n  for x in ab:\n  	print "Case #%s: %s" % (i, solve(x[0],x[1]))\n  	i += 1\n <CODESPLIT> 43
X_WON = 0\n  O_WON = 1\n  DRAW = 2\n  NEITHER = 3\n  \n  messages = [\n      "X won",\n      "O won",\n      "Draw",\n      "Game has not completed"\n  ]\n  \n  \n  def check_win(state):\n      if state['X'] == 4 or state['X'] == 3 and state['T'] == 1:\n          return X_WON\n      elif state['O'] == 4 or state['O'] == 3 and state['T'] == 1:\n          return O_WON\n      else:\n          return -1\n  \n  def check_state(table):\n  \n      for i in xrange(4):\n          state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n          for j in xrange(4):\n              state[table[i][j]] += 1\n          res = check_win(state)\n          if res != -1:\n              return res\n  \n      for i in xrange(4):\n          state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n          for j in xrange(4):\n              state[table[j][i]] += 1\n          res = check_win(state)\n          if res != -1:\n              return res\n  \n      state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n      for i in xrange(4):\n          state[table[i][i]] +=  1\n      res = check_win(state)\n      if res != -1:\n          return res\n  \n      state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\n      for i in xrange(4):\n          state[table[i][3 - i]] +=  1\n      res = check_win(state)\n      if res != -1:\n          return res\n  \n      for i in xrange(4):\n          for j in xrange(4):\n              if table[i][j] == '.':\n                  return NEITHER\n  \n      return DRAW\n  \n  T = int(raw_input().strip())\n  for i in xrange(T):\n      table = [[] for _ in xrange(4)]\n      for j in xrange(4):\n          table[j] = list(raw_input().strip())\n      if i != T - 1:\n          raw_input()\n      print "Case #%s: %s" % (i + 1, messages[check_state(table)])\n <CODESPLIT> 43
 \n  mapping = { "a": "y", "c": "e", "b": "h", "e": "o", "d": "s", "g": "v", "f": "c", "i": "d", "h": "x", "k": "i", "j": "u", "m": "l", "l": "g", "o": "k", "n": "b", "p": "r", "s": "n", "r": "t", "u": "j", "t": "w", "w": "f", "v": "p", "y": "a", "x": "m", "q": "z", "z": "q"}\n  \n  def translator(s):\n  	ret = []\n  	for c in s:\n  		if ord(c) > 96 and ord(c) < 123:\n  			ret.append(mapping[c])\n  		else:\n  			ret.append(c)\n  \n  	return ''.join(ret)\n  \n  f = open(argv[1], 'r')\n  T = int(f.readline().strip('\n'))\n  for i in range(T):\n  	line = f.readline().strip('\n')\n  	print "Case #%s: %s" % (i + 1, translator(line))\n <CODESPLIT> 43
T = int(raw_input().strip())\n  \n  for i in xrange(T):\n  	N = int(raw_input().strip())\n  	naomi = sorted(map(float, raw_input().strip().split(' ')))\n  	ken = sorted(map(float, raw_input().strip().split(' ')))\n  \n  	war_score = N\n  	np = 0\n  	kp = 0\n  	while np < N and kp < N:\n  		while kp < N and naomi[np] >= ken[kp]:\n  			kp += 1\n  		if kp < N:\n  			kp += 1\n  			np += 1\n  			war_score -= 1\n  \n  	d_war_score = N\n  	best = None\n  	for start_from in xrange(N):\n  		j = 0\n  		good = True\n  		while start_from + j < N:\n  			if ken[j] >= naomi[start_from + j]:\n  				good = False\n  				break\n  			j += 1\n  		if good:\n  			best = N - start_from\n  			break\n  	if best is not None:\n  		d_war_score = best\n  	else:\n  		d_war_score = 0\n  \n  	print "Case #%s: %s %s" % (i + 1, d_war_score, war_score)\n <CODESPLIT> 43
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      c, e, x = [float(x) for x in f.readline().split()]\n      n = int((x*e-2*c)/(c*e))\n      if n < 0:\n          n = 0\n      t = 0\n      for j in range(n):\n          t += c/(2+j*e)\n      t += x/(2+n*e)\n      print 'Case #{}: {}'.format(i+1, t)\n <CODESPLIT> 44
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def pal(x):\n      l = list(str(x))\n      l2 = copy.copy(l)\n      l2.reverse()\n      return l == l2\n  \n  for i in range(num):\n      count = 0\n      line = f.readline()\n      a,b = line.split()\n      a = int(a)\n      b = int(b)\n      ma = int(math.sqrt(a))\n      mb = int(math.sqrt(b))+1\n      for j in range(ma,mb+1):\n          q = j*j\n          if q < a or q > b:\n              continue\n          if pal(j) and pal(q):\n              count += 1\n      print 'Case #{}:'.format(i+1), count\n <CODESPLIT> 44
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      res = [int(x) for x in f.readline().split()]\n      nrg, nrsup, score = res[0:3]\n      del res[0:3]\n      nrpass = 0\n      nrsuppass = 0\n      for x in res:\n          if score > 1:\n              if x >= 3*score-2:\n                  nrpass += 1\n              elif x >= 3*score-4:\n                  nrsuppass += 1\n          elif score == 1:\n              if x > 0:\n                  nrpass += 1\n          else:\n              nrpass +=1\n      print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)\n <CODESPLIT> 44
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      l = f.readline()\n      n,m = l.split()\n      n = int(n)\n      m = int(m)\n      lawn = []\n      seen = []\n      for j in range(n):\n          l = f.readline()\n          lawn.append([int(x) for x in l.split()])\n          seen.append([False]*m)\n      l = []\n      for j in range(n):\n          for k in range(m):\n              l.append((lawn[j][k], (j,k)))\n      l.sort(key=operator.itemgetter(0))\n      ok = True\n      for x in l:\n          if seen[x[1][0]][x[1][1]]:\n              continue\n          row = True\n          for j in range(n):\n              if not (seen[j][x[1][1]] or lawn[j][x[1][1]] <= lawn[x[1][0]][x[1][1]]):\n                  row = False\n                  break\n          if(row):\n              for j in range(n):\n                  seen[j][x[1][1]] = True\n              continue\n          col = True\n          for j in range(m):\n              if not (seen[x[1][0]][j] or lawn[x[1][0]][j] <= lawn[x[1][0]][x[1][1]]):\n                  col = False\n                  break\n          if(col):\n              for j in range(m):\n                  seen[x[1][0]][j] = True\n              continue\n          ok = False\n          break\n      if ok:\n          print 'Case #{}: YES'.format(i+1)\n      else:\n          print 'Case #{}: NO'.format(i+1)\n <CODESPLIT> 44
 \n  \n  def permute(x, d):\n      perm = []\n      for i in range(1,d):\n          n = x / 10**i\n          r = x % 10**i\n          if r >= 10**(i-1):\n              perm.append(r * 10**(d-i) + n)\n      perm = list(set(perm))\n      while x in perm:\n          perm.remove(x)\n      return perm\n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      n1, n2 = [int(x) for x in f.readline().split()]\n      d = int(math.floor(math.log10(n1))) + 1\n      rec = 0\n      for j in range(n1,n2+1):\n          p = permute(j, d)\n          rec += sum([1 for x in p if x >= n1 and x <= n2])\n      print 'Case #{}:'.format(i+1), rec/2\n <CODESPLIT> 44
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def check(x, mat):\n      for i in range(4):\n          row = True\n          col = True\n          for j in range(4):\n              if not (mat[i][j] == x or mat[i][j] == 'T'):\n                  row = False\n              if not (mat[j][i] == x or mat[j][i] == 'T'):\n                  col = False\n          if row or col:\n              return True\n      diag1 = True\n      diag2 = True\n      for i in range(4):\n          if not (mat[i][i] == x or mat[i][i] == 'T'):\n              diag1 = False\n          if not (mat[3-i][i] == x or mat[3-i][i] == 'T'):\n              diag2 = False\n      if diag1 or diag2:\n          return True\n      return False\n  \n  def fin(mat):\n      for i in range(4):\n          for j in range(4):\n              if mat[i][j] == '.':\n                  return False\n      return True\n  \n  for i in range(num):\n      mat = []\n      for j in range(4):\n          mat.append(list(f.readline().strip()))\n      f.readline()\n      if check('X', mat):\n          print 'Case #{}: X won'.format(i+1)\n      elif check('O', mat):\n          print 'Case #{}: O won'.format(i+1)\n      elif fin(mat):\n          print 'Case #{}: Draw'.format(i+1)\n      else:\n          print 'Case #{}: Game has not completed'.format(i+1)\n <CODESPLIT> 44
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      s = f.readline().strip()\n      t = s.translate(string.maketrans("yeqjpmslckdxvnribtahwfougz",\n          "aozurlngeismpbtdhwyxfckjvq"))\n      print 'Case #{}:'.format(i+1), t\n <CODESPLIT> 44
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      f.readline()\n      na = [float(x) for x in f.readline().split()]\n      ke = [float(x) for x in f.readline().split()]\n      na.sort()\n      ke.sort()\n      dw = 0\n      index = 0\n      for x in ke:\n          while index < len(na) and na[index] <= x:\n              index += 1\n          if index == len(na):\n              break\n          dw += 1\n          index += 1\n      w = 0\n      index = 0\n      na.reverse()\n      ke.reverse()\n      for x in na:\n          if ke[index] > x:\n              index += 1\n          else:\n              w += 1\n      print 'Case #{}: {} {}'.format(i+1, dw, w)\n <CODESPLIT> 44
 \n  \n  filename = "B-small-attempt0.in"\n  \n  inp = open(filename, "rU")\n  \n  n = int(inp.readline().strip())\n  \n  for case in range(1, n + 1):\n      cost, freq, goal = map(float, inp.readline().strip().split(" "))\n      fac = 0.0\n      time = 0.0\n      test = lambda x: (goal/(2+(freq * (x + 1)))) + (cost /(2+(freq * x)))\n      test2 = lambda x: (goal/(2+(freq * x)))\n      while(test2(fac) > test(fac)):\n          time += cost/(2 + (freq *  fac))\n          fac += 1\n      time += goal/(2+(freq*fac))\n      print("Case #{}: {}".format(case, time))\n <CODESPLIT> 45
 def ispal(num):\n      num = str(num)\n      if num == num[::-1]:\n          return True\n      else:\n          return False\n  \n  def test(bot, top):\n      count = []\n      for i in range(bot,top+1):\n          if not ((int(i**0.5)**2) == i):\n              continue\n          if ispal(i) and ispal(int(i**0.5)):\n              count.append(i)\n      return len(count)\n  \n  case = 1\n  for line in open('C-small-attempt2.in', 'Ur'):\n      if ' ' in line:\n          a,b = line.split()\n          res = test(int(a),int(b))\n          print("Case #{0}: {1}".format(case, res))\n          case += 1\n  \n  \n <CODESPLIT> 45
 data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]\n  count = 0\n  for line in data[1:]:\n  	count += 1\n  	supps = line[1]\n  	score = line[2]\n  	maxes = 0\n  	nonsuptot = (score*3)-2\n  	suptot = (score*3)-4\n  	if suptot < 0:\n  		suptot = 1\n  	for i in range(3,(len(line))):\n  		if line[i] >= nonsuptot:\n  			maxes += 1\n  			continue\n  		if (line[i] >= suptot) and (supps > 0):\n  			maxes += 1\n  			supps -= 1\n  	if score == 0:\n  		maxes = line[0]\n  	print ("Case #"+str(count)+":", maxes)\n  		\n  			\n  \n  \n  \n  \n <CODESPLIT> 45
 def check(grid):\n      if len(grid) <= 1 or len(grid[0]) <= 1:\n          return True\n      for r in range(len(grid)-1):\n          for c in range(len(grid[r])-1):\n              e1 = grid[r][c]\n              e2 = grid[r][c+1]\n              e3 = grid[r+1][c]\n              e4 = grid[r+1][c+1]\n              if (e1 > e2 and e4 > e2) or (e1 > e3 and e4 > e3):\n                  return False\n              if (e2 > e1 and e3 > e1) or (e2 > e4 and e3 > e4):\n                  return False\n      return True\n  \n  def removeG(grid):\n      for i in range(len(grid)):\n          if len(set(grid[i])) == 1 and grid[i][0] == 1 :\n              del grid[i]\n              return True\n      return False\n  \n  infile = open('B-small-attempt5.in', 'Ur')\n  \n  tests = int(infile.readline().strip())\n  \n  for t in range(tests):\n      grid = []\n      h, w = [int(x) for x in infile.readline().strip().split()]\n      for i in range(h):\n          row =[int(x) for x in infile.readline().strip().split()]\n          grid.append(row)\n  \n      pass1 = check(grid)\n      print("------")\n      for r in grid:\n          print(" ".join([str(x) for x in r]))\n      while len(grid) >= 3:\n          if not removeG(grid):\n              break\n  \n      pass2 = check(grid)\n      grid = [x for x in zip(*grid[::-1])]\n      while len(grid) >= 3:\n          if not removeG(grid):\n              break\n      print("------")\n      for r in grid:\n          print(" ".join([str(x) for x in r]))\n      pass3 = check(grid)\n  \n  \n  \n      if pass1 and pass2 and pass3:\n          res = 'YES'\n      else:\n          res = 'NO'\n  \n      print("Case #{0}: {1}".format(t+1,res))\n  \n  \n <CODESPLIT> 45
data = [ [int(a) for a in i.split(" ")] for i in open("C-small-attempt0.in","rU").read()[:-1].split("\n")]\n  \n  def recycle(number, mini, maxi):\n  	number2 = str(number)\n  	count = 0\n  	for i in range(len(number2)):\n  		number2 = number2[-1:] + number2[:-1]\n  		numtemp = int(number2)\n  		if (number == numtemp) or (number > numtemp):\n  			continue\n  		if ((numtemp <= maxi) and (numtemp > mini)):\n  			numlist.append((number,numtemp))\n  			count += 1\n  	return count\n  \n  \n  \n  count = 0\n  for line in data[1:]:\n  	count += 1\n  	total = 0\n  	numlist = []\n  	for a in range(line[0],(line[1])):\n  		total += recycle(a,line[0], line[1])\n  	print ("Case #"+str(count)+":", len(set(numlist)))\n <CODESPLIT> 45
 \n  infile = open('A-small-attempt0.in', 'Ur').read()[1:].split('\n\n')\n  \n  case = 1\n  for test in infile:\n      test = test.replace('\n','')\n      sets = []\n      if not test:\n          break\n  \n      r = 0\n      for i in range(4):\n          sets.append(test[i::4])\n          sets.append(test[r:r+4])\n          r = r+4\n      sets.append(test[0] + test[5] + test[10] + test[15])\n      sets.append(test[3] + test[6] + test[9] + test[12])\n  \n      sets = [set(x) for x in sets]\n      winner = ''\n      for i in sets:\n          if i.issubset({'X', 'T'}):\n              winner = 'X'\n              break\n          if i.issubset({'O', 'T'}):\n              winner = 'O'\n              break\n  \n      if winner:\n          print("Case #{0}: {1} won".format(case, winner))\n      else:\n          if '.' in test:\n              print("Case #{0}: Game has not completed".format(case))\n          else:\n              print("Case #{0}: Draw".format(case))\n      case += 1\n  \n <CODESPLIT> 45
mapp = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm','q':'z','z':'q'}\n  input = open("A-small-attempt0.in", "rU").readlines()\n  counter = 0\n  for a in input[1:]:\n  	counter += 1\n  	outline = a.replace("\n",'')\n  	outline2 = []\n  	for i in outline:\n  		outline2.append(mapp[i])\n  	print ("Case #"+str(counter)+":",''.join(outline2))\n  \n <CODESPLIT> 45
 \n  \n  def normal(ken, nao):\n      total = 0\n      k = ken[:]\n      for i in nao[::-1]:\n          if i > ken[-1]:\n              k = k[1:]\n          else:\n              for e in range(len(k)):\n                  if k[e] > i:\n                      del k[e]\n                      total += 1\n                      break\n      return total\n  \n  def deceit(ken, nao):\n      k = ken[:]\n      n = nao[:]\n      while(len(n) > 0 and len(n) > 0 and (n[0] < k[0] or n[-1] < k[-1])):\n              n = n[1:]\n              k = k[:-1]\n      return len(n)\n  \n  \n      \n  \n  \n  \n  def main():\n      filename = "D-small-attempt1.in"\n  \n      inp = open(filename, "rU")\n  \n      n = int(inp.readline().strip())\n  \n      for case in range(1, n + 1):\n          count = int(inp.readline().strip())\n          nao = sorted(map(float, inp.readline().strip().split()))\n          ken = sorted(map(float, inp.readline().strip().split()))\n  \n          war = count - normal(ken, nao)\n          dwar = normal(nao, ken)\n  \n          print("Case #{}: {} {}".format(case, dwar, war))\n  \n  main()\n <CODESPLIT> 45
 \n  def oneMoreFarm(C, F, nFarms):\n  	return C/(2.0 + nFarms*F)\n  	\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file("output.txt", "w")\n  \n  T = int(f.readline().strip())\n  \n  for case in xrange(T):\n  \n  	data = f.readline().split()\n  	C = eval(data[0])\n  	F = eval(data[1])\n  	X = eval(data[2])\n  \n  	tmin = X/2.0\n  	foundMin = False\n  \n  	S = 0\n  	nFarms = 0\n  \n  	while not foundMin:\n  		nFarms += 1\n  		S += oneMoreFarm(C, F, nFarms - 1)\n  		t = S + X/(2.0 + nFarms*F)\n  		if t < tmin:\n  			tmin = t\n  		else:\n  			foundMin = True\n  \n  	fout.write("Case #%d: %.7f\n" %(case + 1, tmin))\n <CODESPLIT> 46
 \n  def isPalindrome(n):\n  	n = str(n)	\n  	for i in xrange(len(n)/2):\n  		if n[i] != n[(-i-1)]:\n  			return False\n  	return True\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file("output.txt", "w")\n  \n  T = eval(f.readline())\n  \n  for case in xrange(T):\n  	data = f.readline().split()\n  	A = eval(data[0])\n  	B = eval(data[1])\n  \n  	i = A\n  	found = []\n  	while i <= B:\n  		if isPalindrome(i):\n  			sqrtI = math.sqrt(i)\n  			if sqrtI == int(sqrtI):\n  				if isPalindrome(int(sqrtI)):\n  					found.append(i)\n  		i += 1\n  \n  	fout.write("Case #%d: %d\n" %(case + 1, len(found)))\n <CODESPLIT> 46
arq = file("input.in")\n  n_cases = eval(arq.readline())\n  out = file("output.txt", "w")\n  \n  for case in xrange(n_cases):\n  \n  	data = arq.readline()\n  	data = data.strip()\n  	data = data.split(" ")\n  \n  	n = eval(data[0])\n  	s = eval(data[1])\n  	p = eval(data[2])\n  \n  	scores = []\n  	n_googlers_with_best_result = 0\n  	candidates = 0\n  \n  	for j in data[3:]:\n  		i = eval(j)\n  		if i%3 == 0:\n  			score = i/3\n  			scores.append([score, score, score])\n  		elif (i+1)%3 == 0:\n  			score = (i+1)/3\n  			scores.append([score-1, score, score])\n  		else: #(i+2)%3 == 0\n  			score = (i+2)/3\n  			scores.append([score-1, score-1, score])\n  \n  	for score in scores:\n  		if score[2] >= p:\n  			n_googlers_with_best_result +=1\n  		elif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n  			candidates += 1\n  \n  	n_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)\n  \n  	out.write("Case #%d: %d\n" % (case+1, n_googlers_with_best_result))\n <CODESPLIT> 46
 \n  def testLine(i, lawn):\n  	return (2 not in lawn[i])\n  \n  def testColumn(j, lawn):\n  	possible = True\n  	for line in lawn:\n  		if line[j] == 2:\n  			possible = False\n  			break\n  	return possible\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file("output.txt", "w")\n  \n  T = eval(f.readline())\n  \n  for case in xrange(T):\n  	data = f.readline().split()\n  	N = eval(data[0])\n  	M = eval(data[1])\n  	possible = True\n  	if N == 1 or M == 1:\n  		for i in xrange(N):\n  			f.readline()\n  	else:\n  		lawn = []\n  		for i in xrange(N):\n  			line = f.readline().strip().split()\n  			for j in xrange(M):\n  				line[j] = eval(line[j])\n  			lawn.append(line)\n  		i = 0\n  		while i < N and possible:\n  			for j in xrange(M):\n  				if lawn[i][j] == 1:\n  					if not testLine(i, lawn):\n  						if not testColumn(j, lawn):\n  							possible = False\n  			i += 1\n  \n  	fout.write("Case #%d: " %(case + 1))\n  	if possible:\n  		fout.write("YES\n")\n  	else:\n  		fout.write("NO\n")\n <CODESPLIT> 46
def find_recycled(n, b):\n  	ns = str(n)\n  	reclist = []\n  	for i in xrange(1, len(ns), 1):\n  		nrec = ns[i:len(ns)] + ns[0:i]\n  		if nrec[0] != "0":\n  			nrec = eval(nrec)\n  			if nrec <= b and nrec > n and (n, nrec) not in reclist:\n  				reclist.append((n,nrec))\n  	return len(reclist)\n  \n  inp = file("input.in")\n  T = eval(inp.readline())\n  out = file("output.txt", "w")\n  \n  for i in xrange(T):\n  	a, b = inp.readline().strip().split()\n  	a = eval(a)\n  	b = eval(b)\n  	nrec = 0\n  	reclist = []\n  	for n in xrange(a, b):\n  		if n > 11:\n  			nrec += find_recycled(n, b)\n  	out.write("Case #%d: %d\n" %(i + 1, nrec))\n  			\n <CODESPLIT> 46
 \n  def testSymbol(symbol, game):\n  	if testLines(symbol, game):\n  		return True\n  	elif testColumns(symbol, game):\n  		return True\n  	elif testDiagonals(symbol, game):\n  		return True\n  	else:\n  		return False\n  \n  def testLines(symbol, game):\n  	i = 0\n  	won = False\n  	while (i < 4 and not won):\n  		line = game[i]\n  		c = line.count(symbol)\n  		if c == 4 or (c == 3 and "T" in line):\n  			won = True\n  		i += 1\n  	return won\n  \n  def transpose(game):\n  	for i in xrange(3):\n  		for j in xrange(i + 1, 4):\n  			aux = game[i][j]\n  			game[i][j] = game[j][i]\n  			game[j][i] = aux\n  	return game\n  \n  def testColumns(symbol, game):\n  	game = transpose(game)\n  	return testLines(symbol, game)\n  \n  def testDiagonals(symbol, game):\n  	won1 = True\n  	won2 = True\n  	i = 0\n  	while i < 4 and (won1 or won2):\n  		if game[i][i] not in [symbol, "T"]:\n  			won1 = False\n  		if game[i][3 - i] not in [symbol, "T"]:\n  			won2 = False\n  		i += 1\n  	return (won1 or won2)		\n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file("output.txt", "w")\n  \n  T = eval(f.readline())\n  \n  for i in xrange(T):\n  	game = []\n  	for j in xrange(4):\n  		line = f.readline().strip()\n  		gameLine = 4*[None]\n  		for k in xrange(4):\n  			gameLine[k] = line[k]\n  		game.append(gameLine)\n  	f.readline()\n  	if testSymbol("X", game):\n  		gameResult = "X"\n  	elif testSymbol("O", game):\n  		gameResult = "O"\n  	elif "." not in game[0] and "." not in game[1] and "." not in game[2] and "." not in game[3]:\n  		gameResult = "Draw\n"\n  	else:\n  		gameResult = "Game has not completed\n"\n  \n  	fout.write("Case #%d: " %(i + 1))\n  	if gameResult in ["X", "O"]:\n  		fout.write("%s won\n" %(gameResult))\n  	else:\n  		fout.write(gameResult)\n <CODESPLIT> 46
 googlerese = "ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv"\n  english = "our language is impossible to understand there are twenty six factorial possibilities so it is okay if you want to just give up"\n  d = {"y":"a", "e":"o", "q":"z"}\n  \n  for i in xrange(len(googlerese)):\n  	d[googlerese[i]] = english[i]\n  \n  d["z"] = "q"\n  \n  inp = file("input.in")\n  n = eval(inp.readline())\n  out = file("output.txt", "w")\n  \n  for i in xrange(n):\n  	G = inp.readline().strip()\n  	S = ""\n  	for letter in G:\n  		S += d[letter]\n  	out.write("Case #%d: " %(i + 1) + S + "\n")\n <CODESPLIT> 46
 \n  def pointsWar(naomi, ken, N):\n  	points = 0\n  	iNaomi = 0\n  	iKen = 0\n  	while iNaomi < N and iKen < N:\n  		if naomi[iNaomi] > ken[iKen]:\n  			points += 1\n  		else:\n  			iNaomi += 1\n  		iKen += 1\n  	return points\n  \n  def pointsDeceitfulWar(naomi, ken, N):\n  	points = N\n  	iNaomi = 0\n  	iKen = 0\n  	while iNaomi < N and iKen < N:\n  		if naomi[iNaomi] > ken[iKen]:\n  			iKen += 1\n  		else:\n  			points -= 1\n  		iNaomi += 1\n  	return points\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file("output.txt", "w")\n  \n  T = int(f.readline())\n  \n  for case in xrange(T):\n  	N = int(f.readline().strip())\n  	naomi = f.readline().strip().split()\n  	ken = f.readline().strip().split()\n  \n  	for i in xrange(N):\n  		naomi[i] = (float(naomi[i]),"N")\n  		ken[i] = (float(ken[i]),"K")\n  \n  	naomi.sort()\n  	ken.sort()\n  \n  	fout.write("Case #%d: %d %d\n" %(case + 1, pointsDeceitfulWar(naomi, ken, N), pointsWar(naomi, ken, N)))\n <CODESPLIT> 46
 \n  \n  EOL = "\n"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      """Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      """\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      """Read a line of whitespace separated symbols."""\n      return fd.readline().strip().split()\n  \n  def read_ints(fd):\n      """Read a line of whitespace separated integers."""\n      return [int(p) for p in read_syms(fd)]\n  \n  def read_floats(fd):\n      """Read a line of whitespace separated floats."""\n      return [float(p) for p in read_syms(fd)]\n  \n  \n  class Mtrx(object):\n      """A matrix object."""\n      \n      def __init__(self, rows, cols, data):\n          assert len(data) == rows * cols\n          self.rows = rows\n          self.cols = cols\n          self.data = data\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in xrange(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in xrange(self.rows)]\n      \n      @classmethod\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n          """Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          """\n          data = []\n          if rows is None:\n              assert cols is None\n              rows, cols = read_ints(fd)\n          else:\n              assert cols is not None\n          for _ in range(rows):\n              line = readfunc(fd)\n              assert len(line) == cols\n              data.extend(line)\n          return Mtrx(rows, cols, data)\n              \n      @classmethod\n      def read_int_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_ints, rows, cols)\n              \n      @classmethod\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_syms, rows, cols)\n              \n      def __str__(self):\n          res = ""\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + EOL\n          return res\n      \n      def __repr__(self):\n          return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,\n                                         self.cols, self.data)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      """Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      """\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          """Support instance methods."""\n          return functools.partial(self.__call__, obj)\n  \n  \n  class timeit(object):\n      """Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      """\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\n              cachetotals else 0\n          print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case["C"], case["F"], case["X"] = read_floats(f)\n              data.append(case)\n      return data\n  \n  def make_output(fname, output):\n      CASE_PRFX = "Case #%s: "\n      fname = fname + time.strftime("%H%M%S") + ".out"\n      with open(fname, "w") as f:\n          restext = []\n          print "Output content ==============="\n          for i, outdata in enumerate(output):\n              line = CASE_PRFX % (i + 1,) + str(outdata) + EOL\n              print line,\n              restext.append(line)\n          print "=" * 30\n          f.writelines(restext)\n  \n  \n  @memoizeit\n  def will_a_farm_help(target, current_rate, farm_cost, farm_rate):\n      no_farm = target / current_rate\n      with_farm = farm_cost / current_rate + target / (farm_rate + current_rate)\n      if no_farm > with_farm:\n          return True, farm_cost / current_rate\n      else:\n          return False, no_farm\n  \n  @timeit\n  def solveit(case):\n      C = case["C"]\n      F = case["F"]\n      X = case["X"]\n      \n      t = 0\n      current_rate = 2.0 # default rate of 2 cookies per seconds\n      \n      while True:\n          new_farm, add_time = will_a_farm_help(X, current_rate, C, F)\n          if new_farm:\n              t += add_time\n              current_rate += F\n          else:\n              t += add_time\n              return t\n  \n  \n  @timeit\n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          statreset() # reset cache stats\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main("B-small-attempt0.in")\n <CODESPLIT> 47
 \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      """ Returns True iff y is within relative or absolute 'epsilon' of x.\n          By default, 'epsilon' is 1e-6.\n      """\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      return [c for c in fd.readline().strip()]\n  \n  def read_ints(fd):\n      return [int(p) for p in fd.readline().strip().split()]\n  \n  def read_floats(fd):\n      return [float(p) for p in fd.readline().strip().split()]\n  \n  class Mtrx(object):\n      \n      def __init__(self, readfunc):\n          self.readfunc = readfunc\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in range(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in range(self.rows)]\n      \n      def readfromfile(self, fd):\n          self.data = []\n          self.rows, self.cols = read_ints(fd)\n          for _ in range(self.rows):\n              line = self.readfunc(fd)\n              assert len(line) == self.cols\n              self.data.extend(line)\n              \n      def __str__(self):\n          res = ""\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + "\n"\n          return res\n               \n  class IntMatrix(Mtrx):\n      def __init__(self):\n          super(IntMatrix, self).__init__(read_ints)\n  \n  class SymMatrix(Mtrx):\n      def __init__(self):\n          super(IntMatrix, self).__init__(read_syms)\n  \n  class memoizeit(object):\n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          try:\n              return self.cache[args]\n          except KeyError:\n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  class timeit(object):\n      def __init__(self, func):\n          self.func = func\n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          print self.func.__name__, "{:7.3f}s, (res: {})".format(delta, value)\n          return value\n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n <CODESPLIT> 47
 \n  OEXT = ".out"\n  IN_S = "small.in"\n  IN_L = "large.in"\n  CASE_PRFX = "Case #%s: "\n  \n  \n  def avg(L):\n      return 1.0*sum(L)/len(L)\n  \n  triplets = [[0,0,0], [0,0,1], [0,1,1], \n              [0,0,2], [0,2,2], [0,1,2],\n              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],\n              ]\n  \n  def analyze_sum(sm, tgt):\n      av = 1.0 * sm / 3\n      av_cls = av % 1\n  \n      if av_cls > 0.1:\n          ns_max_val = math.ceil(av)\n      else:\n          ns_max_val = av \n      \n      s_max_val = 0 \n      if sm >= 2 and sm <= 28:\n          if av_cls > 0.5:\n              s_max_val = math.ceil(av) + 1\n          elif av_cls > 0.1:\n              s_max_val = math.ceil(av) \n          else:\n              s_max_val = av + 1\n      \n      if ns_max_val >= tgt:\n          res = [ns_max_val, None]\n          kind = 1\n      elif s_max_val < tgt:\n          res = [None, None]\n          kind = 0\n      else:\n          res = [None, s_max_val]\n          kind = 2\n          \n      print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind\n      return res, kind\n  \n  def analyze_triplet(trip, tgt):\n      sm = sum(trip)\n      analyze_triplet(sm, tgt)\n      \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              case = f.readline().strip().split()\n              case = [int(c) for c in case]\n              data.append({"ngoog": case[0], "ssurp": case[1], "ptgt": case[2],\n                           "trips": case[3:]})\n      return data\n  \n  def make_output(fname, output):\n      fname = fname + OEXT\n      with open(fname, "w") as f:\n          restext = []\n          for i, v in enumerate(output):\n              restext.append(CASE_PRFX % (i+1,) + str(v) + "\n")\n          f.writelines(restext)\n      \n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          ansys = [analyze_sum(c, case["ptgt"]) for c in case["trips"]]\n          non_surp_is_enough = len([k for _, k in ansys if k == 1])\n          surp_needed = len([k for _, k in ansys if k == 2])\n          if surp_needed >= case["ssurp"]:\n              res = non_surp_is_enough + case["ssurp"]\n          else:\n              res = non_surp_is_enough + surp_needed\n          output.append(res)\n      print "output:", output\n      make_output(fname, output)\n       \n  \n  main("examples.in")\n  main("small.in")\n <CODESPLIT> 47
 \n  NO = "NO"\n  YES = "YES"\n  \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              field = IntMatrix()\n              field.readfromfile(f)\n              data.append(field)\n      return data\n  \n  def make_output(fname, output):\n      CASE_PRFX = "Case #%s: "\n      fname = fname + time.strftime("%H%M%S") + ".out"\n      with open(fname, "w") as f:\n          restext = []\n          print "Output content ==============="\n          for i, v in enumerate(output):\n              line = CASE_PRFX % (i+1,) + str(v) + "\n"\n              print line[:-1]\n              restext.append(line)\n          print "=" * 30\n          f.writelines(restext)\n  \n  \n  @timeit\n  def solveit(case):\n      print case\n      for row in range(case.rows):\n          for col in range(case.cols):\n              cell = case.cell(row, col)\n              if (any([c > cell for c in case.getrow(row)]) and\n                  any([c > cell for c in case.getcol(col)])):\n                  return NO\n      return YES\n          \n  @timeit\n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for i, case in enumerate(data):\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main("small.in")\n <CODESPLIT> 47
 \n  OEXT = ".out"\n  CASE_PRFX = "Case #%s: "\n  \n  MAXB = 2000000\n  \n  \n  \n  def circlify(num, cutoff=MAXB):\n      numstr = str(num) + str(num)\n      max_opt = len(numstr) / 2\n      opts = [int(numstr[i:i+max_opt]) for i in xrange(max_opt)]\n      \n      opts = [o for o in opts if o > num and o <= cutoff]\n      \n      return len(set(opts))\n  \n  def check(A, B):\n      res2 = 0\n      start = time.time()\n      for t in xrange(A, B):\n          res2 += circlify(t, B)\n      print res2, time.time()-start  \n  \n      return res2\n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              case = f.readline().strip().split()\n              data.append((int(case[0]), int(case[1])))\n      return data\n  \n  def make_output(fname, output):\n      fname = fname + OEXT\n      with open(fname, "w") as f:\n          restext = []\n          for i, v in enumerate(output):\n              restext.append(CASE_PRFX % (i+1,) + str(v) + "\n")\n          f.writelines(restext)\n      \n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          output.append(check(case[0], case[1]))\n      print "output:", output\n      make_output(fname, output)\n  \n  main("small.in")\n <CODESPLIT> 47
 \n  XWON = "X won"\n  OWON = "O won"\n  DRAW = "Draw" \n  NOTOVER = "Game has not completed"\n  \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              board = []\n              for _ in xrange(4):\n                  board.extend(read_syms(f))\n              read_syms(f)\n              data.append(board)\n      return data\n  \n  def make_output(fname, output):\n      CASE_PRFX = "Case #%s: "\n      fname = fname + time.strftime("%H%M%S") + ".out"\n      with open(fname, "w") as f:\n          restext = []\n          for i, v in enumerate(output):\n              line = CASE_PRFX % (i+1,) + str(v) + "\n"\n              print line\n              restext.append(line)\n          f.writelines(restext)\n  \n  \n  def getrow(board, i):\n      return board[i*4:4*i+4]\n  \n  def getcol(board, i):\n      return [c for j, c in enumerate(board) if j % 4 == i ]\n  \n  def getdiag(board, i):\n      if i == 0:\n          return board[0], board[5], board[10], board[15]\n      return board[3], board[6], board[9], board[12]\n  \n  @timeit\n  def solveit(case):\n      print case\n      xcase = [(c if c != 'T' else 'X') for c in case]\n      ocase = [(c if c != 'T' else 'O') for c in case]\n      \n      for i in range(4):\n          if all([x == 'X' for x in getrow(xcase, i)]):\n              return XWON\n          if all([x == 'O' for x in getrow(ocase, i)]):\n              return OWON\n          \n      for i in range(4):\n          if all([x == 'X' for x in getcol(xcase, i)]):\n              return XWON\n          if all([x == 'O' for x in getcol(ocase, i)]):\n              return OWON\n          \n      for i in range(2):\n          if all([x == 'X' for x in getdiag(xcase, i)]):\n              return XWON\n          if all([x == 'O' for x in getdiag(ocase, i)]):\n              return OWON\n          \n      if any([x == '.' for x in case]):\n          return NOTOVER\n      return DRAW\n          \n  @timeit\n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for i, case in enumerate(data):\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main("small.in")\n <CODESPLIT> 47
 \n  OEXT = ".out"\n  IN_S = "small.in"\n  IN_L = "large.in"\n  CASE_PRFX = "Case #%s: "\n  \n  ddd = {}\n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              code = f.readline()\n              data.append(code)\n      return data\n  \n  def make_output(fname, output):\n      fname = fname + OEXT\n      with open(fname, "w") as f:\n          restext = []\n          for i, v in enumerate(output):\n              restext.append(CASE_PRFX % (i+1,) + v)\n          f.writelines(restext)\n      \n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for code in data:\n          output.append("".join([ddd[k] for k in code]))\n      print output\n      make_output(fname, output)\n      \n  def mainex(fname):\n      with open(fname, "r") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              code = f.readline()\n              trans = f.readline()\n              for i, c in enumerate(code):\n                  ddd.setdefault(c, trans[i])\n      \n      abc = string.ascii_lowercase + " \n"\n      for c in abc:\n          if c not in ddd.values():\n              print "not in trans:", c\n              missingt = c\n          if c not in ddd.keys():\n              print "not in code:", c\n              missingc = c\n      ddd.setdefault(missingc, missingt)\n      print ddd\n      print len(ddd)\n      return ddd\n      \n      \n      \n  mainex("examples.in")\n  main("examples_raw.in")\n  main("small.in")\n <CODESPLIT> 47
 \n  \n  EOL = "\n"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      """Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      """\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      """Read a line of whitespace separated symbols."""\n      return fd.readline().strip().split()\n  \n  def read_ints(fd):\n      """Read a line of whitespace separated integers."""\n      return [int(p) for p in read_syms(fd)]\n  \n  def read_floats(fd):\n      """Read a line of whitespace separated floats."""\n      return [float(p) for p in read_syms(fd)]\n  \n  \n  class Mtrx(object):\n      """A matrix object."""\n      \n      def __init__(self, rows, cols, data):\n          assert len(data) == rows * cols\n          self.rows = rows\n          self.cols = cols\n          self.data = data\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in xrange(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in xrange(self.rows)]\n      \n      @classmethod\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n          """Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          """\n          data = []\n          if rows is None:\n              assert cols is None\n              rows, cols = read_ints(fd)\n          else:\n              assert cols is not None\n          for _ in range(rows):\n              line = readfunc(fd)\n              assert len(line) == cols\n              data.extend(line)\n          return Mtrx(rows, cols, data)\n              \n      @classmethod\n      def read_int_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_ints, rows, cols)\n              \n      @classmethod\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_syms, rows, cols)\n              \n      def __str__(self):\n          res = ""\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + EOL\n          return res\n      \n      def __repr__(self):\n          return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,\n                                         self.cols, self.data)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      """Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      """\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          """Support instance methods."""\n          return functools.partial(self.__call__, obj)\n  \n  \n  class timeit(object):\n      """Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      """\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\n              cachetotals else 0\n          print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case["N"] = read_ints(f)\n              case["Naomi"] = sorted(read_floats(f))\n              case["Ken"] = sorted(read_floats(f))\n              data.append(case)\n      return data\n  \n  def make_output(fname, output):\n      CASE_PRFX = "Case #%s: "\n      fname = fname + time.strftime("%H%M%S") + ".out"\n      with open(fname, "w") as f:\n          restext = []\n          print "Output content ==============="\n          for i, outdata in enumerate(output):\n              line = CASE_PRFX % (i + 1,) + str(outdata) + EOL\n              print line,\n              restext.append(line)\n          print "=" * 30\n          f.writelines(restext)\n  \n  \n  @timeit\n  def solveit(case):\n      ns = case["Naomi"]\n      ks = case["Ken"]\n      \n      nsmin = 0\n      ksmin = 0\n      \n      dwpoints = 0\n      while nsmin < len(ns):\n          if ns[nsmin] > ks[ksmin]:\n              ksmin += 1\n              dwpoints += 1 \n          nsmin += 1\n      \n      nsmax = len(ns) - 1\n      ksmin = 0\n      \n      wpoints = 0\n      while len(ks) >= ksmin + 1:\n          print ns, ks, nsmax, ksmin\n          if ns[nsmax] > ks[-1]:\n              ksmin += 1\n              wpoints += 1\n          else:\n              m = ksmin\n              for i in xrange(len(ks)-1, ksmin-1, -1):\n                  if ks[i] < ns[nsmax]:\n                      m = i + 1\n                      break\n              del ks[m]\n          nsmax -= 1\n      \n      return str(dwpoints) + " " + str(wpoints) \n  \n  \n  \n  @timeit\n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          statreset() # reset cache stats\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main("D-small-attempt0.in")\n <CODESPLIT> 47
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readfloatarray():\n      return map(float, sys.stdin.readline().strip().split())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 48
 \n  possibles = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]\n  \n  for case in xrange(codejam.readint()):\n      A, B = map(int, codejam.readstring().split())\n      count = 0\n      for possible in possibles:\n          if A > possible:\n              continue\n  \n          if B < possible:\n              break\n  \n          count += 1\n  \n      print "Case #%d: %d" % (case + 1, count)\n <CODESPLIT> 48
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 48
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 48
 \n  for case in xrange(readint()):\n      A, B = readintarray()\n      res = 0\n      for i in xrange(A, B + 1):\n          for j in xrange(i + 1, B + 1):\n              ist = str(i)\n              jst = str(j)\n              if len(ist) != len(jst):\n                  continue\n  \n              if ist in (jst + jst):\n                  res += 1\n  \n      print "Case #%d: %d" % (case + 1, res)\n <CODESPLIT> 48
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 48
 \n  inp = "ejp mysljylc kd kxveddknmc re jsicpdrysi"\\n        "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"\\n        "de kr kd eoya kw aej tysr re ujdr lkgc jv zq"\n  out = "our language is impossible to understand"\\n      "there are twenty six factorial possibilities"\\n      "so it is okay if you want to just give up qz"\n  \n  for case in xrange(readint()):\n      trantab = maketrans(inp, out)\n      line = readstring()\n      print "Case #%d: %s" % (case + 1, line.translate(trantab))\n <CODESPLIT> 48
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readfloatarray():\n      return map(float, sys.stdin.readline().strip().split())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 48
 \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  for t in range(1, ncases+1):\n      values = sys.stdin.readline().split()\n      c = float(values[0])\n      f = float(values[1])\n      x = float(values[2])\n      r = 2\n  \n      time = 0\n  \n      while True:\n          tdirect = x/r\n          tfactory = c/r + x/(r+f)\n  \n          if tdirect<tfactory:\n              time += tdirect\n              break\n          else:\n              time += c/r\n              r += f\n  \n      print("Case #{0}: {1:.7f}".format(t, time))\n <CODESPLIT> 49
 \n  \n  \n  def calculatepalindromes(ndigits):\n      if ndigits == 1:\n          return 3\n  \n      result = 0\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)/2)\n  \n      if isEven:\n          result += 1\n      else:\n          result += 3\n  \n      for numones in range(0, min(6, fillingdigits) + 1):\n          combinations = int(math.factorial(fillingdigits) / (math.factorial(fillingdigits-numones) * math.factorial(numones)))\n          result += combinations\n          if not isEven:\n              result += combinations\n  \n      return result\n  \n  \n  def findpalindromes(ndigits):\n      if ndigits == 1:\n          return [1, 2, 3]\n  \n      result = []\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)/2)\n  \n      if isEven:\n          result.append(int("2" + "0"*(fillingdigits*2) + "2"))\n      else:\n          result.append(int("2" + "0"*fillingdigits + "0" + "0"*fillingdigits + "2"))\n          result.append(int("2" + "0"*fillingdigits + "1" + "0"*fillingdigits + "2"))\n          result.append(int("1" + "0"*fillingdigits + "2" + "0"*fillingdigits + "1"))\n  \n      for numones in range(0, min(6, fillingdigits)+1):\n          ones = fillOnes([], fillingdigits, numones)\n          for o in ones:\n              if isEven:\n                  result.append(int("1" + "".join(o) + "".join(list(reversed(o))) + "1"))\n              else:\n                  result.append(int("1" + "".join(o) + "0" + "".join(list(reversed(o))) + "1"))\n                  result.append(int("1" + "".join(o) + "1" + "".join(list(reversed(o))) + "1"))\n  \n      return result\n  \n  def fillOnes(combination, size, remainingOnes):\n      if len(combination) == size:\n          return [combination]\n      result = []\n      if remainingOnes > 0:\n          c = combination + ["1"]\n          result += fillOnes(c, size, remainingOnes - 1)\n      if remainingOnes < size - len(combination):\n          c = combination + ["0"]\n          result += fillOnes(c, size, remainingOnes)\n      return result\n  \n  \n  \n  ncases = int(sys.stdin.readline())\n  \n  for t in range(1, ncases+1):\n      fairsquare = 0\n      (a, b) = sys.stdin.readline().strip().split(" ")\n      intA = int(a)\n      intB = int(b)\n      ndigitsA = len(a)\n      ndigitsB = len(b)\n      ndigitsARooted = math.ceil(ndigitsA/2)\n      ndigitsBRooted = math.ceil(ndigitsB/2)\n  \n      if ndigitsBRooted == ndigitsARooted:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA and p ** 2 <= intB:\n                  fairsquare +=1\n      else:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA:\n                  fairsquare +=1\n  \n          for i in range(ndigitsARooted + 1, ndigitsBRooted):\n              fairsquare += calculatepalindromes(i)\n  \n          palindromes = findpalindromes(ndigitsBRooted)\n          for p in palindromes:\n              if p ** 2 <= intB:\n                  fairsquare +=1\n  \n      print("Case #%d: %d" % (t, fairsquare))\n <CODESPLIT> 49
 \n  \n  def findbest(score):\n  	if score == 0: return (0, 0)\n  \n  	best = math.ceil(score / 3)\n  	bestsurp = round(score / 3) + 1\n  \n  	return (best, bestsurp)\n  	\n  sys.stdin.readline()\n  \n  casenum = 0\n  for line in sys.stdin:\n  	casenum += 1\n  \n  	data = line.strip().split(' ')\n  	maxsurprising = int(data[1])\n  	p = int(data[2])\n  	scores = data[3:]\n  	maxgooglers = 0\n  \n  	for s in scores:\n  		(best, bestsurp) = findbest(int(s))\n  		if best >= p:\n  			maxgooglers += 1\n  		else:\n  			if bestsurp >= p and maxsurprising > 0:\n  				maxgooglers += 1\n  				maxsurprising -= 1\n  \n  	print("Case #%d: %d" % (casenum, maxgooglers))\n <CODESPLIT> 49
 \n  \n  ncases = int(sys.stdin.readline())\n  \n  for t in range(1, ncases+1):\n      (n, m) = [int(x) for x in sys.stdin.readline().strip().split(" ")]\n      lawn = []\n      cuttable = []\n      for row in range(0, n):\n          lawn.append([int(x) for x in sys.stdin.readline().strip().split(" ")])\n          cuttable.append([False for x in range(0, m)])\n  \n      for row in range(0, n):\n          rowdata = lawn[row]\n          maxheight = max(rowdata)\n          for col in range(0, m):\n              if lawn[row][col] == maxheight:\n                  cuttable[row][col] = True\n  \n      for col in range(0, m):\n          coldata = [x[col] for x in lawn]\n          maxheight = max(coldata)\n          for row in range(0, n):\n              if lawn[row][col] == maxheight:\n                  cuttable[row][col] = True\n  \n      result = True\n      for row in range(0, n):\n          for col in range(0, m):\n              if not cuttable[row][col]:\n                  result = False\n                  break\n          if result == False:\n              break\n  \n      if result == False:\n          print("Case #%d: NO" % t)\n      else:\n          print("Case #%d: YES" % t)\n <CODESPLIT> 49
 \n  \n  def findrecycled(num, A, B):\n  	strnum = str(num)\n  	results = {}\n  	for i in range(1, len(strnum)):\n  		strrecycled = strnum[i:] + strnum[0:i]\n  		recycled = int(strrecycled)\n  		if recycled > num and recycled >= A and recycled <= B:\n  			results["%d_%d" % (num, recycled)] = 1\n  	return len(results)\n  \n  sys.stdin.readline()\n  \n  casenum = 0\n  for line in sys.stdin:\n  	casenum += 1\n  \n  	data = line.strip().split(' ')\n  	A = int(data[0])\n  	B = int(data[1])\n  \n  	count = 0\n  	for num in range(A, B):\n  		count += findrecycled(num, A, B)\n  \n  	print("Case #%d: %d" % (casenum, count))\n <CODESPLIT> 49
 \n  \n  ncases = int(sys.stdin.readline())\n  \n  for t in range(1, ncases+1):\n      board = []\n      winner = False\n      numDots = 0\n  \n      for row in range(0, 4):\n          rowdata = sys.stdin.readline().strip()\n          board.append([])\n          numX = 0\n          numO = 0\n          for col in range(0, 4):\n              value = rowdata[col]\n              if value == ".":\n                  numDots += 1\n              if value == "X":\n                  numX += 1\n              if value == "O":\n                  numO += 1\n              if value == "T":\n                  numX += 1\n                  numO += 1\n              board[row].append(value)\n          if numX == 4:\n              winner = True\n              print("Case #%d: X won" % t)\n              break\n          if numO == 4:\n              winner = True\n              print("Case #%d: O won" % t)\n              break\n      while sys.stdin.readline().strip() != "": pass\n  \n      if winner == True: continue\n  \n      for col in range(0, 4):\n          numX = 0\n          numO = 0\n          for row in range(0, 4):\n              value = board[row][col]\n              if value == "X":\n                  numX += 1\n              if value == "O":\n                  numO += 1\n              if value == "T":\n                  numX += 1\n                  numO += 1\n          if numX == 4:\n              winner = True\n              print("Case #%d: X won" % t)\n              break\n          if numO == 4:\n              winner = True\n              print("Case #%d: O won" % t)\n              break\n  \n      if winner == True: continue\n  \n      numX = 0\n      numO = 0\n      for rowcol in range(0, 4):\n          value = board[rowcol][rowcol]\n          if value == "X":\n              numX += 1\n          if value == "O":\n              numO += 1\n          if value == "T":\n              numX += 1\n              numO += 1\n      if numX == 4:\n          print("Case #%d: X won" % t)\n          continue\n      if numO == 4:\n          print("Case #%d: O won" % t)\n          continue\n  \n      numX = 0\n      numO = 0\n      for rowcol in range(0, 4):\n          value = board[rowcol][3-rowcol]\n          if value == "X":\n              numX += 1\n          if value == "O":\n              numO += 1\n          if value == "T":\n              numX += 1\n              numO += 1\n      if numX == 4:\n          print("Case #%d: X won" % t)\n          continue\n      if numO == 4:\n          print("Case #%d: O won" % t)\n          continue\n  \n      if numDots == 0:\n          print("Case #%d: Draw" % t)\n      else:\n          print("Case #%d: Game has not completed" % t)\n  \n <CODESPLIT> 49
 \n  \n  reverseMappings = {\n  'a': 'y',\n  'b': 'h',\n  'c': 'e',\n  'd': 's',\n  'e': 'o',\n  'f': 'c',\n  'g': 'v',\n  'h': 'x',\n  'i': 'd',\n  'j': 'u',\n  'k': 'i',\n  'l': 'g',\n  'm': 'l',\n  'n': 'b',\n  'o': 'k',\n  'p': 'r',\n  'q': 'z',\n  'r': 't',\n  's': 'n',\n  't': 'w',\n  'u': 'j',\n  'v': 'p',\n  'w': 'f',\n  'x': 'm',\n  'y': 'a',\n  'z': 'q',\n  ' ': ' '\n  }\n  \n  def reverse(string):\n  	return ''.join([reverseMappings[c] for c in string])\n  \n  sys.stdin.readline()\n  \n  casenum=0\n  for line in sys.stdin:\n  	casenum += 1\n  	reversed = reverse(line.strip())\n  	print("Case #%d: %s" % (casenum, reversed))\n <CODESPLIT> 49
 \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  for t in range(1, ncases+1):\n      nblocks = int(sys.stdin.readline().strip())\n      naomi_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n      ken_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n  \n      naomi_blocks.sort()\n      ken_blocks.sort()\n  \n      ken_lightest = 0\n      ken_heaviest = nblocks-1\n      points_deceitful = 0\n  \n      for i in range(0, nblocks):\n          if naomi_blocks[i] > ken_blocks[ken_lightest]:\n              points_deceitful += 1\n              ken_lightest += 1\n          else:\n              ken_heaviest -= 1\n  \n      ken_lightest = 0\n      ken_heaviest = nblocks-1\n      points_standard = 0\n  \n      for i in range(nblocks-1, -1, -1):\n          if naomi_blocks[i] > ken_blocks[ken_heaviest]:\n              points_standard += 1\n              ken_lightest += 1\n          else:\n              ken_heaviest -= 1\n  \n      print("Case #{0}: {1} {2}".format(t, points_deceitful, points_standard))\n <CODESPLIT> 49
 \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      return read_floats(f)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%s'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (C, F, X) = case\n      res = 0\n      i = 0\n      while X/(2 + i*F) > C/(2 + i*F) + X/(2 + (i+1)*F):\n          res += C/(2 + i*F)\n          i += 1\n      return res + X/(2 + i*F)\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n <CODESPLIT> 50
 \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(reader(f, *args, **kwargs))\n      return res\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      return read_ints(f)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%d'%res)\n      f.write('\n')\n  \n  \n  def aux(A, B, x, s):\n      res = 0\n      n = int(''.join(x[::-1]+x))\n      nn = n*n\n      if nn > B:\n          return res\n      if nn >= A:\n          res += 1\n      for c in [0, 1, 2]:\n          if s + c*c < 10:\n              n = int(''.join(x[::-1]+[str(c)]+x))\n              nn = n*n\n              if nn >= A and nn <= B:\n                  res += 1\n          if s + 2*c*c < 10:\n              res += aux(A, B, [str(c)]+x, s + 2*c*c)\n      return res\n  \n  def solve_small(case):\n      [A, B] = case\n      res = 0\n      for n in [1, 4, 9]:\n          if n >= A and n <= B:\n              res += 1\n      for c in [1, 2]:\n          res += aux(A, B, [str(c)], 2*c*c)\n      return res\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n <CODESPLIT> 50
 \n  __file__ = sys.argv[0]\n  __path__ = os.path.dirname(__file__)\n  __prob__ = os.path.basename(__path__)\n  \n  def pout(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n  \n  def perr(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n  \n  def argmin(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best > y:\n              best = y\n              res = x\n      return res\n  \n  def argmax(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best < y:\n              best = y\n              res = x\n      return res\n  \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_word_arr(f, R):\n      res = []\n      for i in range(R):\n          res.append(read_word(f))\n      return res\n  \n  def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(read_ints(f, *args, **kwargs))\n      return numpy.array(res, dtype)\n  \n  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n      global ERR_FILE\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      err_fn = fn + '.err'\n      if start_case == 0:\n          append = True\n          if os.path.exists(out_fn):\n              with open(out_fn, 'r') as f:\n                  for l in f:\n                      if l[:6] == 'Case #':\n                          start_case = int(l[6:l.index(':')])+1\n      else:\n          append = False\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'a' if append else 'w') as fo:\n              with open(err_fn, 'w') as ERR_FILE:\n                  T = read_int(fi)\n                  for i in range(T):\n                      case = read_case(fi)\n                      if i+1 < start_case:\n                          continue\n                      print('Case #%d of %d'%(i+1, T))\n                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                      perr('case')\n                      res = solver(case)\n                      perr('res')\n                      write_case(fo, i, res)\n                      fo.flush()\n                      if end_case is not None and i+1 == end_case:\n                          break\n  \n  def test(start_case=1, end_case=None):\n      fn = os.path.join(__path__, 'test')\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small2(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case, fn + '2.out')\n  \n  def large(start_case=0, end_case=None):\n      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case)\n  \n  \n  def read_case(f):\n      Z = read_ints(f)\n      (N, S, p) = Z[:3]\n      t = Z[3:]\n      return (N, S, p, t)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%(i+1))\n      f.write('%s'%res)\n      f.write('\n')\n  \n  FAIL = 'NO SOLUTION'\n  \n  def solve_small(case):\n      (N, S, p, t) = case\n      res = 0\n      for i in range(N):\n          if p >= 2:\n              if t[i] >= 3*p-2:\n                  res += 1\n              elif S > 0 and t[i] >= 3*p-4:\n                  res += 1\n                  S -= 1\n          elif p == 1:\n              if t[i] >= 3*p-2:\n                  res += 1\n          elif p == 0:\n              res += 1\n      return res\n  \n  solve_large = solve_small\n  \n  pout = perr\n <CODESPLIT> 50
 \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(reader(f, *args, **kwargs))\n      return res\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      [N, M] = read_ints(f)\n      A = read_arr(f, N)\n      return (N, M, A)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%s'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (N, M, A) = case\n      rows = [max(row) for row in A]\n      cols = [max(row[j] for row in A) for j in range(M)]\n      for i in range(N):\n          for j in range(M):\n              if A[i][j] < min(rows[i], cols[j]):\n                  return 'NO'\n      return 'YES'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n <CODESPLIT> 50
 \n  __file__ = sys.argv[0]\n  __path__ = os.path.dirname(__file__)\n  __prob__ = os.path.basename(__path__)\n  \n  def pout(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n  \n  def perr(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n  \n  def argmin(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best > y:\n              best = y\n              res = x\n      return res\n  \n  def argmax(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best < y:\n              best = y\n              res = x\n      return res\n  \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_word_arr(f, R):\n      res = []\n      for i in range(R):\n          res.append(read_word(f))\n      return res\n  \n  def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(read_ints(f, *args, **kwargs))\n      return numpy.array(res, dtype)\n  \n  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n      global ERR_FILE\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      err_fn = fn + '.err'\n      if start_case == 0:\n          append = True\n          if os.path.exists(out_fn):\n              with open(out_fn, 'r') as f:\n                  for l in f:\n                      if l[:6] == 'Case #':\n                          start_case = int(l[6:l.index(':')])+1\n      else:\n          append = False\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'a' if append else 'w') as fo:\n              with open(err_fn, 'w') as ERR_FILE:\n                  T = read_int(fi)\n                  for i in range(T):\n                      case = read_case(fi)\n                      if i+1 < start_case:\n                          continue\n                      print('Case #%d of %d'%(i+1, T))\n                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                      perr('case')\n                      res = solver(case)\n                      perr('res')\n                      write_case(fo, i, res)\n                      fo.flush()\n                      if end_case is not None and i+1 == end_case:\n                          break\n  \n  def test(start_case=1, end_case=None):\n      fn = os.path.join(__path__, 'test')\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small2(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case, fn + '2.out')\n  \n  def large(start_case=0, end_case=None):\n      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case)\n  \n  \n  def read_case(f):\n      (A, B) = read_ints(f)\n      return (A, B)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%(i+1))\n      f.write('%s'%res)\n      f.write('\n')\n  \n  FAIL = 'NO SOLUTION'\n  \n  def aux(n, a, b):\n      res = 0\n      s = set()\n      for i in range(1, len(n)):\n          m = n[i:]+n[:i]\n          if m > n and m >= a and m <= b and m not in s:\n              res += 1\n              s.add(m)\n      return res\n  \n  def solve_small(case):\n      (A, B) = case\n      a = str(A)\n      b = str(B)\n      res = 0\n      for n in range(A, B+1):\n          res += aux(str(n), a, b)\n      return res\n  \n  solve_large = solve_small\n  \n  pout = perr\n <CODESPLIT> 50
 \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(reader(f, *args, **kwargs))\n      return res\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      B = read_arr(f, 4, read_letters)\n      read_word(f)\n      return B\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%s'%res)\n      f.write('\n')\n  \n  \n  def test(a):\n      if '.' not in a and 'O' not in a:\n          return 'X won'\n      if '.' not in a and 'X' not in a:\n          return 'O won'\n  \n  def solve_small(case):\n      draw = True\n      for row in case:\n          if '.' in row:\n              draw = False\n          res = test(row)\n          if res:\n              return res\n      for i in range(len(case[0])):\n          col = [row[i] for row in case]\n          res = test(col)\n          if res:\n              return res\n      diag = [case[i][i] for i in range(len(case))]\n      res = test(diag)\n      if res:\n          return res\n      diag = [case[i][-i-1] for i in range(len(case))]\n      res = test(diag)\n      if res:\n          return res\n      if draw:\n          return 'Draw'\n      return 'Game has not completed'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n <CODESPLIT> 50
 \n  __file__ = sys.argv[0]\n  __path__ = os.path.dirname(__file__)\n  __prob__ = os.path.basename(__path__)\n  \n  def pout(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n  \n  def perr(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n  \n  def argmin(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best > y:\n              best = y\n              res = x\n      return res\n  \n  def argmax(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best < y:\n              best = y\n              res = x\n      return res\n  \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_word_arr(f, R):\n      res = []\n      for i in range(R):\n          res.append(read_word(f))\n      return res\n  \n  def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(read_ints(f, *args, **kwargs))\n      return numpy.array(res, dtype)\n  \n  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n      global ERR_FILE\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      err_fn = fn + '.err'\n      if start_case == 0:\n          append = True\n          if os.path.exists(out_fn):\n              with open(out_fn, 'r') as f:\n                  for l in f:\n                      if l[:6] == 'Case #':\n                          start_case = int(l[6:l.index(':')])+1\n      else:\n          append = False\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'a' if append else 'w') as fo:\n              with open(err_fn, 'w') as ERR_FILE:\n                  T = read_int(fi)\n                  for i in range(T):\n                      case = read_case(fi)\n                      if i+1 < start_case:\n                          continue\n                      print('Case #%d of %d'%(i+1, T))\n                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                      perr('case')\n                      res = solver(case)\n                      perr('res')\n                      write_case(fo, i, res)\n                      fo.flush()\n                      if end_case is not None and i+1 == end_case:\n                          break\n  \n  def test(start_case=1, end_case=None):\n      fn = os.path.join(__path__, 'test')\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-practice'%__prob__)\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small2(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-practice'%__prob__)\n      solve(solve_large, fn, start_case, end_case, fn + '2.out')\n  \n  def large(start_case=0, end_case=None):\n      fn = os.path.join(__path__, '%s-large-practice'%__prob__)\n      solve(solve_large, fn, start_case, end_case)\n  \n  \n  def read_case(f):\n      G = read_word(f)\n      return G\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%(i+1))\n      f.write('%s'%res)\n      f.write('\n')\n  \n  FAIL = 'NO SOLUTION'\n  \n  TRANS = {'z': 'q', 'q': 'z', '\n': '\n', ' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm'}\n  \n  def solve_small(case):\n      G = case\n      return ''.join(TRANS[x] for x in G)\n  \n  solve_large = solve_small\n  \n  pout = perr\n <CODESPLIT> 50
 \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      N = read_int(f)\n      MN = read_floats(f)\n      MK = read_floats(f)\n      return (N, MN, MK)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%d %d'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (N, MN, MK) = case\n      MN = sorted(MN)\n      MK = sorted(MK)\n      y = 0\n      i = 0\n      for j in range(N):\n          while i < N and MN[i] < MK[j]:\n              i += 1\n          if i < N:\n              y += 1\n              i += 1\n      z = N\n      j = 0\n      for i in range(N):\n          while j < N and MN[i] > MK[j]:\n              j += 1\n          if j < N:\n              z -= 1\n              j += 1\n      return (y, z)\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n <CODESPLIT> 50
__author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(" "))\n  LA = lambda: map(long, RL().split(" "))\n  FA = lambda: map(float, RL().split(" "))\n  \n  T = int(sys.stdin.readline())\n  \n  for CASE in range(T):\n      C,F,X = FA()\n      tick = 2.\n      answer = X/tick\n  \n      game = 0\n      while True:\n          span = C / tick\n          tick += F\n          test = game + span + X/tick\n          game = game + span\n  \n          if test < answer:\n              answer = test\n          else:\n              if tick > X:\n                  break\n  \n      print "Case #%d: %s" % (CASE+1, answer)\n  \n <CODESPLIT> 51
 \n  lines = sys.stdin.readlines()\n  def parseCase(lines):\n      dims = map(int,lines[0].split(" "))\n      return 1, dims\n  \n  def getCases(lines):\n      i =0\n      while i < len(lines):\n          lines_used, case = parseCase(lines[i:])\n          i += lines_used\n          yield case\n  \n  \n  fands = []\n  phash = {1:True}\n  def isPalindrome(p):\n      return p in phash\n  \n  def test(p):\n      square = p**.5\n      return square == int(square) and isPalindrome(int(square))\n  \n  for i in range(1,10**5):\n      if i > 9:\n          small_p = int(i * 10 ** int(math.log(i,10)) + int("".join(reversed(str(i)[:-1]))))\n      else: small_p = i\n      phash[small_p]= test(small_p)\n      if phash[small_p]: fands.append(small_p)\n      big_p = int(i * 10 ** int(math.log(i,10)+1) + int("".join(reversed(str(i)))))\n      phash[big_p] = test(big_p)\n      if phash[big_p]: fands.append(big_p)\n  cNum =0\n  \n  for c in getCases(lines[1:]):\n      cNum += 1\n      answer = []\n      for i in fands:\n          if i < c[0]: continue\n          if i > c[1]: break\n          if phash[i]: answer.append(i)\n      answer = str(len(answer))\n      print "Case #%d: %s" % ( cNum, answer)\n  \n  \n      \n  \n  \n <CODESPLIT> 51
 """\n  GCJ framework (gcj.fw.framework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing case input\n   - executing problem code against cases\n   - testing framework\n  """\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, caseNumber, caseData=None):\n              self.number = caseNumber\n              self.data = caseData\n              self.result = None\n      \n          @classmethod\n          def parser(cls, f_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f_in=None):\n              if self.data is None:\n                  self.data = self.parser(f_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return "Case #%d: %s" % (self.number, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, resultData):\n              self.data = resultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f_in, f_out):\n          sys.stdout = f_out\n          self.f_in = f_in if f_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f_in.readline().strip())\n          for num in xrange(nCases):\n              case = type(self).Case(num+1)\n              case.execute( f_in=self.f_in)\n              print case\n  \n  \n      @classmethod\n      def __main__(cls):\n          f_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == "-t":\n                  unittest.main()\n                  sys.exit()\n              f_in = open(sys.argv[1])\n          framework = cls(f_in, sys.stdout)\n          framework.run()\n      \n  class Test(unittest.TestCase):\n      cases = []\n      case = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          counter = 1\n          self.cases = []\n          for c in self.c:\n              case = self.case(counter)\n              case.data = case.parser(StringIO.StringIO(c[0]))\n              self.cases.append( [case, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for case in self.cases:\n              print case[0].data, case[1]\n              case[0].execute()\n              self.assertEqual(case[0].result, case[1])\n  '''\n  Created on Apr 8, 2012\n  \n  @author: Joe\n  '''\n  \n  \n  class B(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              args = map(int, fh.readline().strip().split(" "))\n              N,S,p = args[:3]\n              scores = args[3:] \n              return {"N":N,"S":S,"p":p,"scores":scores}\n          \n          def run(self, N=None,S=None,p=None,scores=None):\n              ret = 0\n              surps = 0\n              for score in scores:\n                  if p > 0 and score == 0: continue\n                  if 3*p-2 <= score:\n                      ret += 1\n                  else:\n                      if 3*p - 4 <= score:\n                          surps += 1\n              return str(ret + min(surps,S))\n              \n  class Test(Test):\n      def defineCases(self):\n          self.case = B.Case\n          self.c = [\n                    ["3 1 5 15 13 11","3"],\n                    ["3 0 8 23 22 21","2"],\n                    ["2 1 1 8 0","1"],\n                    ["6 2 8 29 20 8 18 18 21","3"],\n                    ["1 1 1 1", "1"]\n                    ]\n  \n  if __name__ == "__main__":\n      B.__main__()\n      \n <CODESPLIT> 51
 \n  lines = sys.stdin.readlines()\n  def parseCase(lines):\n      dims = map(int,lines[0].split(" "))\n      return dims[0]+1, [map(int,l.split(" ")) for l in lines[1:dims[0]+1]]\n  \n  \n  def getCases(lines):\n      i =0\n      while i < len(lines):\n          lines_used, case = parseCase(lines[i:])\n          i += lines_used\n          yield case\n  \n          \n  cNum =0\n  for c in getCases(lines[1:]):\n      cNum += 1\n      answer = None\n      for i in range(len(c)):\n          if answer: break\n          for j in range(len(c[i])):\n              if answer: break\n              answer = max(c[i]) > c[i][j] and max([c[k][j] for k in range(len(c))]) > c[i][j]\n      print "Case #%d: %s" % ( cNum, "NO" if answer else "YES")\n  \n  \n      \n  \n  \n <CODESPLIT> 51
       \n  """\n  GCJ framework (gcj.fw.framework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing case input\n   - executing problem code against cases\n   - testing framework\n  """\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, caseNumber, caseData=None):\n              self.number = caseNumber\n              self.data = caseData\n              self.result = None\n      \n          @classmethod\n          def parser(cls, f_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f_in=None):\n              if self.data is None:\n                  self.data = self.parser(f_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return "Case #%d: %s" % (self.number, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, resultData):\n              self.data = resultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f_in, f_out):\n          sys.stdout = f_out\n          self.f_in = f_in if f_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f_in.readline().strip())\n          for num in xrange(nCases):\n              case = type(self).Case(num+1)\n              case.execute( f_in=self.f_in)\n              print case\n  \n  \n      @classmethod\n      def __main__(cls):\n          f_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == "-t":\n                  unittest.main()\n                  sys.exit()\n              f_in = open(sys.argv[1])\n          framework = cls(f_in, sys.stdout)\n          framework.run()\n      \n  class Test(unittest.TestCase):\n      cases = []\n      case = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          counter = 1\n          self.cases = []\n          for c in self.c:\n              case = self.case(counter)\n              case.data = case.parser(StringIO.StringIO(c[0]))\n              self.cases.append( [case, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for case in self.cases:\n              print case[0].data, case[1]\n              case[0].execute()\n              self.assertEqual(case[0].result, case[1])\n  '''\n  Created on Apr 8, 2012\n  \n  @author: Joe\n  '''\n  \n  class C(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              args = map(int, fh.readline().strip().split(" "))\n              A,B = args[:2]\n              return {"A":A,"B":B}\n          \n          def run(self,A=None,B=None):\n              ret = 0\n              found = set()\n              for i in range(A,B+1):\n                  if i in found: continue\n                  n = int(log(i,10))\n                  nums = set([i])\n                  tmp = i\n                  for j in range(n):\n                      tmp = tmp / 10 + (tmp%10)*10**(n)\n                      if tmp <= B and tmp>= A:\n                          nums.add(tmp)\n                          found.add(tmp)\n                  ret += len(nums)*(len(nums)-1)/2\n              return str(ret)\n              \n  class Test(Test):\n      def defineCases(self):\n          self.case = C.Case\n          self.c = [\n                    ["1 9", "0"],\n                    ["10 40", "3",                   ],\n                    ["10 99", "36"],\n                    ["100 500", "156"],\n                    ["1111 2222", "287"],\n                    ["1000000 2000000", "2000000"]\n                    ]\n  \n  if __name__ == "__main__":\n      C.__main__()\n      \n <CODESPLIT> 51
 \n  lines = sys.stdin.readlines()\n  def parseCase(lines):\n      return 5,lines[0:4]\n  \n  def getCases(lines):\n      i =0\n      while i < len(lines):\n          lines_used, case = parseCase(lines[i:])\n          i += lines_used\n          yield case\n  \n  def test(r):\n      if 'O' in r and '.' not in r and 'X' not in r: \n          return "O won"\n      elif 'X' in r and '.' not in r and 'O' not in r: \n          return "X won"\n      return None\n          \n  cNum =0\n  for c in getCases(lines[1:]):\n      cNum += 1\n      answer = None\n      for i in range(0,4):\n          if answer: break\n          r = c[i]\n          answer = test(r) \\n              or test("".join(c[j][i] for j in range(4)))\n  \n      if not answer:\n          answer = test("".join([c[j][3-j] for j in range(4)])) \\n              or test("".join(c[j][j] for j in range(4)))\n              \n      if not answer:\n          answer = any(["." in c[i] for i in range(4)]) and "Game has not completed"\n      if not answer:\n          answer = "Draw"\n      print "Case #%d: %s" % ( cNum, answer)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n      \n  \n  \n <CODESPLIT> 51
       \n  """\n  GCJ framework (gcj.fw.framework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing case input\n   - executing problem code against cases\n   - testing framework\n  """\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, caseNumber, caseData=None):\n              self.number = caseNumber\n              self.data = caseData\n              self.result = None\n      \n          @classmethod\n          def parser(cls, f_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f_in=None):\n              if self.data is None:\n                  self.data = self.parser(f_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return "Case #%d: %s" % (self.number, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, resultData):\n              self.data = resultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f_in, f_out):\n          sys.stdout = f_out\n          self.f_in = f_in if f_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f_in.readline().strip())\n          for num in xrange(nCases):\n              case = type(self).Case(num+1)\n              case.execute( f_in=self.f_in)\n              print case\n  \n  \n      @classmethod\n      def __main__(cls):\n          f_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == "-t":\n                  unittest.main()\n                  sys.exit()\n              f_in = open(sys.argv[1])\n          framework = cls(f_in, sys.stdout)\n          framework.run()\n      \n  class Test(unittest.TestCase):\n      cases = []\n      case = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          counter = 1\n          self.cases = []\n          for c in self.c:\n              case = self.case(counter)\n              case.data = case.parser(StringIO.StringIO(c[0]))\n              self.cases.append( [case, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for case in self.cases:\n              print case[0].data, case[1]\n              case[0].execute()\n              self.assertEqual(case[0].result, case[1])\n  \n  D={'a':'y','o':'e','z':'q','q':'z'}\n  \n  a=["ejp mysljylc kd kxveddknmc re jsicpdrysi",\n     "our language is impossible to understand",\n     "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n     "there are twenty six factorial possibilities",\n     "de kr kd eoya kw aej tysr re ujdr lkgc jv",\n     "so it is okay if you want to just give up"]\n  \n  for i in range(0,len(a),2):\n      for j in range(0,len(a[i])):\n          D[a[i][j]] = a[i+1][j]\n  \n  class A(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              statement = fh.readline().strip() \n              return {'secret': statement}\n          \n          def run(self, secret=None):\n              word = ""\n              for i in range(0,len(secret)):\n                  word += D[secret[i]]\n              return word\n          \n  class Test(Test):\n      def defineCases(self):\n          self.case = A.Case\n          self.c = [["ejp mysljylc kd kxveddknmc re jsicpdrysi",\n     "our language is impossible to understand"],\n                    [   "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n     "there are twenty six factorial possibilities",],\n                    [ "de kr kd eoya kw aej tysr re ujdr lkgc jv",\n     "so it is okay if you want to just give up"],\n                    ]\n  \n  if __name__ == "__main__":\n      A.__main__()\n      \n <CODESPLIT> 51
__author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(" "))\n  LA = lambda: map(long, RL().split(" "))\n  FA = lambda: map(float, RL().split(" "))\n  \n  T = int(sys.stdin.readline())\n  \n  def war(N,K):\n      """\n      strategy: N plays lowest number first, K chooses next best number\n      """\n      if len(N) == 0: return 0\n      n = N[0]\n      if K[-1] > n:\n          k = len(K)-1\n          for k in range(len(K)-1):\n              if K[k] > n and K[k+1] > n:\n                  break\n          if K[k] < n: k += 1\n          K = K[:k] + K[k+1:]\n          return war(N[1:],K)\n      else:\n          return 1 + war(N[1:], K[1:])\n  \n  def beawoman(N,K):\n      if len(N) == 0: return 0\n      n = N[0]\n      bad = False\n      for i in range(len(N)):\n          if N[i] < K[i]:\n              bad = True\n      if bad:\n          return beawoman(N[1:], K[:-1])\n      else:\n          return 1 + beawoman(N[:-1], K[:-1])\n  \n  for CASE in range(T):\n      RL()\n      N = FA()\n      K = FA()\n      N.sort()\n      K.sort()\n      answer = "%d %d" % (beawoman(N,K), war(N,K))\n      print "Case #%d: %s" % (CASE+1, answer)\n  \n <CODESPLIT> 51
def solve_case(t):\n      c, f, x = [float(num) for num in raw_input().strip().split()]\n      current_time_usage = x / 2.0\n  \n      n = 1\n      build_farm_time = c / (2.0 + float((n - 1) * f))\n      attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time\n  \n      while attemp_time_usage < current_time_usage:\n          current_time_usage = attemp_time_usage\n  \n          n += 1\n          build_farm_time += c / (2.0 + float((n - 1) * f))\n          attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time\n  \n      print 'Case #%d: %.7f' % (t, current_time_usage,)\n  \n  def main():\n      t = int(raw_input().strip())\n      for i in range(1, t + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 52
 \n  def get_number_of_test_case():\n      return int(raw_input().strip())\n  \n  def solve_case(t):\n      A, B = [int(x) for x in raw_input().strip().split()]\n  \n      print 'Case #%d: %d' % (t, get_number_of_palindrome(B) - get_number_of_palindrome(A - 1),)\n  \n  def get_number_of_palindrome(n):\n      ret = 0\n  \n      nt = int(math.floor(math.sqrt(n)))\n      total_column = int(math.ceil(math.ceil(math.log10(nt + 1)) / 2.0))\n      upper_limit = 10 ** total_column\n  \n      counter = 0\n      while counter < upper_limit:\n          c_str = [c for c in str(counter)]\n          c_str.reverse()\n  \n          number = str(counter)\n          for c in c_str:\n              number += c\n          number = int(number)\n          number = number ** 2\n          if number <= n and is_palindrome(number):\n              ret += 1\n  \n          number = str(counter)\n          for c in c_str[1:]:\n              number += c\n          number = int(number)\n          number = number ** 2\n          if number <= n and is_palindrome(number):\n              ret += 1\n          \n          counter += 1\n  \n      return ret\n  \n  def is_palindrome(n):\n      if n == 0:\n          return False\n      num = str(n)\n      check_len = len(num) / 2\n      ret = True\n      for i in range(check_len):\n          ret &= num[i] == num[-i - 1]\n      return ret\n  \n  T = get_number_of_test_case()\n  t = 1\n  while t <= T:\n      solve_case(t)\n      t += 1\n  \n <CODESPLIT> 52
t = int(raw_input().strip())\n  t_count = 1\n  while t_count <= t:\n  	line = raw_input().strip().split()\n  	n = int(line[0])\n  	s = int(line[1])\n  	p = int(line[2])\n  	ti_list = line[3:]\n  	p_min = max(p * 3 - 2, p)\n  	p_min_surprise = max(p * 3 - 4, p)\n  	result = 0\n  	for ti in ti_list:\n  		ti = int(ti)\n  		if ti >= p_min:\n  			result += 1\n  		elif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:\n  			result += 1\n  			s -= 1\n  	print 'Case #%d: %d' % (t_count, result,)\n  	t_count += 1\n <CODESPLIT> 52
def get_number_of_test_case():\n      return int(raw_input().strip())\n  \n  def solve_case(t):\n      N, M = [int(x) for x in raw_input().strip().split()]\n      \n      matrix = [[int(x) for x in raw_input().strip().split()] for y in range(N)]\n  \n      s_list = list()\n      for i in range(N):\n          for j in range(M):\n              s_list.append([matrix[i][j], i, j,])\n      s_list.sort(cmp = lambda x, y: x[0] - y[0])\n  \n      outcome = 'YES'\n      for s in s_list:\n          if matrix[s[1]][s[2]] == 0:\n              continue\n  \n          row, col = s[1], s[2]\n  \n          can_do = True\n          for i in range(N):\n              can_do &= matrix[i][col] <= s[0]\n          if can_do:\n              for i in range(N):\n                  matrix[i][col] = 0\n              continue\n  \n          can_do = True\n          for j in range(M):\n              can_do &= matrix[row][j] <= s[0]\n          if can_do:\n              for j in range(M):\n                  matrix[row][j] = 0\n          else:\n              outcome = 'NO'\n              break\n      \n      print 'Case #%d: %s' % (t, outcome,)\n  \n  \n  T = get_number_of_test_case()\n  t = 1\n  while t <= T:\n      solve_case(t)\n      t += 1\n  \n <CODESPLIT> 52
def count_between(a, b):\n  	count = 0\n  	for item in range(a, b + 1):\n  		rotate = len(str(item)) - 1\n  		watch_list = [item,]\n  		rotate_count = 0\n  		item_len = len(str(item))\n  		while rotate_count < rotate:\n  			r_item = str(item)\n  			r_item = r_item[rotate_count + 1:] + r_item[:rotate_count + 1]\n  			r_item_len = len(r_item)\n  			r_item = int(r_item)\n  			if r_item not in watch_list and r_item > item and r_item <= b and r_item >= a and item_len == r_item_len:\n  				watch_list.append(r_item)\n  				count +=1\n  			rotate_count += 1\n  	return count\n  \n  pre_computed = [0, 36, 801, 12060, 161982, 2023578, 299997,]\n  \n  t = int(raw_input().strip())\n  t_count = 1\n  while t_count <= t:\n  	a, b = [int(x) for x in raw_input().strip().split()]\n  	print 'Case #%d: %d' % (t_count, count_between(a, b),)\n  	t_count += 1\n  \n <CODESPLIT> 52
def get_number_of_test_case():\n      return int(raw_input().strip())\n  \n  def solve_case(t):\n      lines = [list(raw_input().strip()) for i in range(4)]\n      raw_input()\n  \n      i = 0\n      j = 0\n  \n      p_list = list()\n      while i < 4:\n          j = 0\n          s = ''\n          while j < 4:\n              s += lines[i][j]\n              j += 1\n          p_list.append(s.replace('T', 'X'))\n          p_list.append(s.replace('T', 'O'))\n          i += 1\n  \n      j = 0\n      while j < 4:\n          i = 0\n          s = ''\n          while i < 4:\n              s += lines[i][j]\n              i += 1\n          p_list.append(s.replace('T', 'X'))\n          p_list.append(s.replace('T', 'O'))\n          j += 1\n      \n      s = lines[0][0] + lines[1][1] + lines[2][2] + lines[3][3]\n      p_list.append(s.replace('T', 'X'))\n      p_list.append(s.replace('T', 'O'))\n  \n      s = lines[0][3] + lines[1][2] + lines[2][1] + lines[3][0]\n      p_list.append(s.replace('T', 'X'))\n      p_list.append(s.replace('T', 'O'))\n  \n      has_empty = False\n      outcome = ''\n      for p in p_list:\n          has_empty |= '.' in p\n          if p == 'XXXX':\n              outcome = 'X won'\n              break\n          elif p == 'OOOO':\n              outcome = 'O won'\n              break\n      if not outcome:\n          if has_empty:\n              outcome = 'Game has not completed'\n          else:\n              outcome = 'Draw'\n      \n      print 'Case #%d: %s' % (t, outcome,)\n  \n  T = get_number_of_test_case()\n  t = 1\n  while t <= T:\n      solve_case(t)\n      t += 1\n  \n <CODESPLIT> 52
"""\n  num = int(raw_input('num: ').strip())\n  \n  c_map = [None for x in range(0, 26)]\n  \n  while num > 0:\n  	googleres = raw_input('googleres: ').strip()\n  	original = raw_input('original: ').strip()\n  \n  \n  	ord_a = ord('a')\n  	ord_z = ord('z')\n  \n  	i = 0\n  	for c in googleres:\n  		ord_c = ord(c)\n  		if ord_a <= ord_c and ord_c <= ord_z:\n  			c_map[ord_c - ord_a] = ord(original[i]) - ord_c\n  		i += 1\n  	\n  	num -= 1\n  \n  print c_map\n  """\n  \n  """\n  c_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]\n  i = 0\n  original_list = list()\n  while i < 25:\n  	original_list.append(c_map[i] + i)\n  	i += 1\n  original_list.sort()\n  print original_list\n  """\n  \n  c_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]\n  \n  t = int(raw_input().strip())\n  t_count = 1\n  while t_count <= t:\n  	ord_a = ord('a')\n  	ord_z = ord('z')\n  	googleres = raw_input().strip()\n  	original = ''\n  	for c in googleres:\n  		ord_c = ord(c)\n  		if ord_a <= ord_c and ord_c <= ord_z:\n  			original += chr(c_map[ord_c - ord_a] + ord_c)\n  		else:\n  			original += c\n  	print 'Case #%d: %s' % (t_count, original,)\n  	t_count += 1\n  \n <CODESPLIT> 52
def solve_case(t):\n      n = int(raw_input().strip())\n      naomi = sorted([float(num) for num in raw_input().strip().split()])\n      ken = sorted([float(num) for num in raw_input().strip().split()])\n  \n  \n      i, j = 0, 0\n      while j < n:\n          if ken[j] > naomi[i]:\n              i += 1\n          j += 1\n      optimal_result = n - i\n  \n      deceit_result = 0\n      while n > 0:\n          if naomi[0] < ken[0]:\n              ken.pop()\n          else:\n              deceit_result += 1\n              ken = ken[1:]\n          naomi = naomi[1:]\n          n -= 1\n      \n  \n  \n  \n      print 'Case #%d: %d %d' % (t, deceit_result, optimal_result,)\n  \n  def main():\n      t = int(raw_input().strip())\n      for i in range(1, t + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 52
 \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_floats(): return map(float, stdin.readline().split())\n  \n  \n  def solve_case():\n      C, F, X = read_floats()\n      rate = 2\n      current = 0\n      best = X / rate\n      \n      while True:\n          current += C / rate\n          rate += F\n          next = current + X / rate\n          if next < best:\n              best = next\n          else:\n              break\n      \n      return best\n  \n      \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          print('Case #{}: {:.7f}'.format(case, solve_case()))\n  \n          \n  main()\n <CODESPLIT> 53
 \n  def read_ints():\n      return map(int, stdin.readline().rstrip().split(' '))\n  \n  def is_palin(n):\n      s = str(n)\n      return s == s[::-1]\n      \n  def find(n, fas):\n      for i in xrange(len(fas)):\n          if fas[i] >= n:\n              return i\n      return len(fas)\n      \n  def gen_fas(max):\n      fas = []\n      fasappend = fas.append\n      square, base, d = 1, 1, 3\n      while square < max:\n          if is_palin(square) and is_palin(base):\n              fasappend(square)\n          square += d\n          d += 2\n          base += 1\n      return fas\n      \n  def main():\n      MAX = 1000\n      fas = gen_fas(MAX)\n      \n      T = int(stdin.readline())\n      for Ti in xrange(T):\n          A, B = read_ints()\n          answer = find(B + 1, fas) - find(A, fas)\n          print 'Case #{}: {}'.format(Ti + 1, answer)\n          \n  main()\n <CODESPLIT> 53
 \n  def program():\n  	T = int(stdin.readline())\n  	for Ti in xrange(T):\n  		numbers = a = map(int, stdin.readline().rstrip().split(' '))\n  		N, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]\n  		\n  		m = 0\n  		curr_S = S\n  		for i in xrange(N):\n  			t = totals[i]\n  			\n  			if t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):\n  				m += 1\n  			elif curr_S > 0 and t > 0:\n  				if (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):\n  					m += 1\n  					curr_S -= 1\n  		\n  		print 'Case #%d: %d' % (Ti + 1, m)	\n  	\n  if __name__ == '__main__':\n  	program()\n <CODESPLIT> 53
 \n  def read_ints():\n      return map(int, stdin.readline().rstrip().split(' '))\n  \n  def print_lawn(lawn):\n      for row in lawn:\n          print row\n          \n  def is_higher(a, i, j, N, M):\n      s = a[i][j]\n      v, h = False, False\n      for ii in xrange(N):\n          if a[ii][j] > s:\n              v = True\n              break\n      for jj in xrange(M):\n          if a[i][jj] > s:\n              h = True\n              break\n      return v and h\n      \n  def check(a, N, M):\n      if N == 1 or M == 1:\n          return True\n      else:\n          for i in xrange(N):\n              for j in xrange(M):\n                  h = is_higher(a, i, j, N, M)\n                  if h:\n                      return False\n          return True\n      \n  def main():\n      T = int(stdin.readline())\n      for Ti in xrange(T):\n          N, M = read_ints()\n          a = []\n          for i in xrange(N):\n              a.append(read_ints())\n          answer = 'YES' if check(a, N, M) else 'NO'\n          print 'Case #{}: {}'.format(Ti + 1, answer)\n          \n  main()\n <CODESPLIT> 53
 \n  def program():\n  	T = int(stdin.readline())\n  	for Ti in xrange(T):\n  		A, B =  map(int, stdin.readline().rstrip().split(' '))\n  		\n  		ss = set()\n  		for n in xrange(A, B + 1):\n  			sn = str(n)\n  			for i in xrange(1, len(sn)):\n  				sm = sn[i:] + sn[:i]\n  				if sm[0] != '0':\n  					m = int(sm)\n  					if m > n and m <= B:\n  						ss.add((n, m))\n  		\n  		print 'Case #%d: %d' % (Ti + 1, len(ss))	\n  	\n  if __name__ == '__main__':\n  	program()\n <CODESPLIT> 53
 \n  def won(x, o, t):\n      if x == 4 or (x == 3 and t == 1):\n          return 1\n      elif o == 4 or (o == 3 and t == 1):\n          return 2\n  \n  def check(board, BOARD_SIZE, RESULTS):\n      d = 0\n      for i in xrange(BOARD_SIZE):\n          x = board[i].count('X')\n          o = board[i].count('O')\n          t = board[i].count('T')\n          d += board[i].count('.')\n          w = won(x, o, t)\n          if w:\n              return w\n      for i in xrange(BOARD_SIZE):\n          vertical = [ board[j][i] for j in xrange(BOARD_SIZE) ]\n          x = vertical.count('X')\n          o = vertical.count('O')\n          t = vertical.count('T')\n          w = won(x, o, t)\n          if w:\n              return w\n      x, o, t = 0, 0, 0\n      for i in xrange(BOARD_SIZE):\n          if board[i][i] == 'X':\n              x += 1\n          elif board[i][i] == 'O':\n              o += 1\n          elif board[i][i] == 'T':\n              t += 1\n      w = won(x, o, t)\n      if w:\n          return w    \n      x, o, t = 0, 0, 0\n      for i in xrange(BOARD_SIZE):\n          if board[i][BOARD_SIZE - i - 1] == 'X':\n              x += 1\n          elif board[i][BOARD_SIZE - i - 1] == 'O':\n              o += 1\n          elif board[i][BOARD_SIZE - i - 1] == 'T':\n              t += 1\n      w = won(x, o, t)\n      if w:\n          return w\n      if d == 0:\n          return 3\n      else:\n          return 4\n      \n  def main():\n      BOARD_SIZE = 4\n      RESULTS = 'X won', 'O won', 'Draw', 'Game has not completed'\n  \n      T = int(stdin.readline())\n      for Ti in xrange(T):\n          board = []\n          for i in xrange(BOARD_SIZE):\n              board.append(list(stdin.readline().rstrip()))\n          print 'Case #{}: {}'.format(Ti + 1, RESULTS[check(board, BOARD_SIZE, RESULTS) - 1])    \n          stdin.readline()\n          \n  main()\n <CODESPLIT> 53
 \n  def get_mapping():\n  	d = ord('a')\n  	mapping = [ None ] * 26\n  	inputs = [ 'ejp mysljylc kd kxveddknmc re jsicpdrysi', \n  		'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', \n  		'de kr kd eoya kw aej tysr re ujdr lkgc jv' ]\n  	outputs = [ 'our language is impossible to understand', \n  		'there are twenty six factorial possibilities', \n  		'so it is okay if you want to just give up' ]\n  	\n  	for i in xrange(len(inputs)):\n  		input = inputs[i]\n  		output = outputs[i]\n  		for j in xrange(len(input)):\n  			if input[j] == ' ':\n  				continue\n  			k = ord(input[j]) - d\n  			if mapping[k] is None:\n  				mapping[k] = output[j]\n  	mapping[ord('q') - d] = 'z'\n  	mapping[ord('z') - d] = 'q'\n  				\n  	return mapping\n  			\n  \n  def program():\n  	T = int(stdin.readline())\n  	mapping = get_mapping()\n  	d = ord('a')\n  	for i in xrange(T):\n  		s = stdin.readline().rstrip()\n  		t = ''\n  		\n  		for ss in s:\n  			if ss == ' ':\n  				t += ' '\n  			else:\n  				t += mapping[ord(ss) - d]\n  		print 'Case #%d: %s' % (i + 1, t)\n  	\n  if __name__ == '__main__':\n  	program()\n <CODESPLIT> 53
 \n  \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_floats(): return map(float, stdin.readline().split())\n  \n      \n  def war(N, K):\n      points = 0\n      j = 0\n      for i in range(len(N)):\n          while j < len(K) and K[j] < N[i]:\n              j += 1\n          if j == len(K):\n              points += 1\n          else:\n              j += 1\n      return points\n  \n  \n  def deceitful_war(N, K):\n      return len(N) - war(K, N)\n      \n  \n  def solve_case():\n      read_int()\n      N = sorted(read_floats())\n      K = sorted(read_floats())\n      \n      return '{} {}'.format(deceitful_war(N, K), war(N, K))\n  \n      \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          print('Case #{}: {}'.format(case, solve_case()))\n  \n          \n  main()\n <CODESPLIT> 53
 \n  T = int(input())\n  for case in range(1,T+1):\n      C,F,X = (Decimal(x) for x in input().split())\n      \n      ans = X/2\n      time,rate = 0,2\n      while True:\n          if time >= ans:\n              break\n          ans = min(ans,(X/rate)+time)\n          time,rate = time+(C/rate),rate+F\n      print("Case #",case,": ",ans,sep = '')\n <CODESPLIT> 54
def checkpalin(s):\n      k = len(s)//2\n      for i in range(k):\n          if s[i]!= s[-1-i]:\n              return False\n      return True\n  \n  goods = [1,2,3]\n  \n  for i in range(1000):\n      for j in ['']+list(range(10)):\n          test = str(i)+str(j)+(str(i)[::-1])\n          if checkpalin(str(int(test)**2)):\n              goods.append(int(test))\n  goods = list(set(goods))\n  goods.sort()\n  \n  T = int(input())\n  \n  for case in range(1,T+1):\n      A,B = [int(x) for x in input().split()]\n      ans = 0\n      for n in goods:\n          if A <= n*n <= B:\n              ans += 1\n      print("Case #",case,": ",ans,sep='')\n <CODESPLIT> 54
T=int(input())\n  for t in range(T):\n    l = [int(x) for x in input().split()]\n    n,huh,p = l[:3]\n    ss = l[3:]\n    nice, maybe = 0,0\n    for s in ss:\n      if s>= p+2*max(p-1,0):\n        nice += 1\n      elif s>= p+2*max(p-2,0):\n        maybe += 1\n    y = nice + min(maybe,huh)\n    print('Case #',t+1,': ',y,sep = '')\n  \n  \n <CODESPLIT> 54
T = int(input().strip())\n  \n  for case in range(1,T+1):\n      N,M = [int(x) for x in input().strip().split()]\n      lawn = []\n      for r in range(N):\n          lawn.append([int(x) for x in input().strip().split()])\n      rmax = [max(row) for row in lawn]\n      cmax = [max(lawn[r][c] for r in range(N)) for c in range(M)]\n      ans = all(lawn[r][c] == min(rmax[r],cmax[c]) for r in range(N) for c in range(M))\n      ans = "YES" if ans else "NO"\n      print("Case #",case,": ",ans,sep = '')\n <CODESPLIT> 54
T=int(input())\n  for t in range(T):\n      a,b = [int(x) for x in input().split()]\n      count = 0\n      l = [0 for i in range(a,b+1)]\n      for n in range(a,b):\n          if l[n-a]:\n              continue\n          l[n-a]=1\n          ms = set()\n          s = str(n)\n          for i in range(len(s)):\n              m = int(s[i:]+s[:i])\n              if n<m<=b:\n                  l[m-a]=1\n                  ms.add(m)\n          case = len(ms)\n          count+= (case*(case+1))//2\n      print('Case #',t+1,': ',count,sep = '')\n <CODESPLIT> 54
T = int(input().strip())\n  \n  def check(s,ans):\n      if '.' in s:\n          return ans if ans < 2 else 3\n      if 'O' not in s:\n          return 0\n      if 'X' not in s:\n          return 1\n      return ans\n  \n  for case in range(1,T+1):\n      ans = 2\n      answers = ["X won", "O won", "Draw", "Game has not completed"]\n      board = [0]*4\n      for r in range(4):\n          board[r] = input().strip()\n      input()\n      for row in board:\n          ans = check(row,ans)\n      for c in range(4):\n          col = ''.join(board[r][c] for r in range(4))\n          ans = check(col,ans)\n      diag = ''.join(board[r][r] for r in range(4))\n      ans = check(diag,ans)\n      diag = ''.join(board[r][3-r] for r in range(4))\n      ans = check(diag,ans)\n      print("Case #",case,": ",answers[ans],sep = '')\n <CODESPLIT> 54
sub = {}\n  sub['y']='a'\n  sub['e']='o'\n  sub['q']='z'\n  sub[' ']=' '\n  sub['z'] = 'q'\n  \n  pairs = [('ejp mysljylc kd kxveddknmc re jsicpdrysi','our language is impossible to understand'), ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd','there are twenty six factorial possibilities'), ('de kr kd eoya kw aej tysr re ujdr lkgc jv','so it is okay if you want to just give up')]\n  \n  for (j,(a,b)) in enumerate(pairs):\n    for i in range(len(a)):\n      sub[a[i]] = b[i]\n  \n  \n  T=int(input())\n  for i in range(T):\n    s = input().strip()\n    new = ''.join([sub[c] for c in s])\n    print('Case #',i+1,': ',new,sep = '')\n  \n  \n <CODESPLIT> 54
def findmin(l,y):\n      for (i,x) in enumerate(l):\n          if x>y:\n              return i\n      return None\n  \n  T = int(input())\n  for case in range(1,T+1):\n      N = int(input())\n      Ns = [float(x) for x in input().split()]\n      Ks = [float(x) for x in input().split()]\n  \n      Ns.sort()\n      Ks.sort()\n      bad = 0\n  \n      Ns1 = Ns[:]\n      Ks1 = Ks[:]\n      while Ns1:\n          y = Ks1.pop()\n          if Ns1[-1]>y:\n              i = findmin(Ns1,y)\n              Ns1[i:i+1]=[]\n              bad += 1\n          else:\n              Ns1[:1] = []\n  \n      good = 0\n      Ns2 = Ns[:]\n      Ks2 = Ks[:]\n      for x in Ns2:\n          if Ks2[-1]>x:\n              i = findmin(Ks2,x)\n              Ks2[i:i+1]=[]\n          else:\n              Ks2[:1]=[]\n              good += 1\n  \n      print("Case #",case,": ",bad,' ',good,sep = '')\n <CODESPLIT> 54
filename = raw_input("Name of file: ")\n  infile = open(filename, "r")\n  outfile = open(filename + ".out", "w")\n  \n  \n  T = int(infile.readline()[:-1])\n  \n  \n  def getMinTime(c, f, x):\n      p0 = 2.0\n      s_prev = x / p0\n      s_curr = c / p0\n      prev_item = 0\n      next_item = x / (p0 + f)\n      n = 1\n      while s_prev + prev_item > s_curr + next_item:\n          s_prev = s_curr\n          prev_item = next_item\n          s_curr += c / (p0 + (n * f))\n          next_item = x / (p0 + ((n + 1) * f))\n          n += 1\n      return s_prev + prev_item\n  \n  for t in range(1, T + 1):\n      items = infile.readline()[:-1].split(" ")\n      c = float(items[0])\n      f = float(items[1])\n      x = float(items[2])\n      time = getMinTime(c, f, x)\n      outfile.write("Case #%d: %.7f\n" %(t, time))\n      \n          \n      \n  \n  outfile.close()\n  infile.close()\n <CODESPLIT> 55
lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,\n      100020001,102030201,104060401,121242121,123454321,125686521,400080004,\n      404090404,10000200001,10221412201,12102420121,12345654321,40000800004,\n      1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,\n      1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,\n      1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,\n      102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,\n      123456787654321,400000080000004]\n  \n  \n  def solve(lo,hi):\n      global lst\n      count = 0\n      for i in range(len(lst)):\n          if (lst[i] >= lo and lst[i] <= hi ):\n              count += 1\n      return count\n  \n  fname = raw_input("name of file: ")\n  oname = raw_input("output file name:")\n  f = open(fname,"r")\n  out = open(oname,"w")\n  n = int(f.readline()[:-1])\n  case_num = 1\n  for line in f:\n      args = line[:-1].split()\n      lo = int(args[0])\n      hi = int(args[1])\n      out.write("Case #%d: %d\n" %(case_num,solve(lo,hi)))\n      case_num += 1\n      \n  out.close()\n  f.close()\n      \n <CODESPLIT> 55
fileName = raw_input("File name: ")\n  \n  f = open(fileName,"r")\n  \n  t = int(f.readline()[:-1])\n  \n  tests = []\n  \n  for i in range (t):\n      tests += [f.readline()[:-1]]\n  \n  f.close()\n  \n  \n  def compute(raw):\n      dataN = [] # keeps the max mark for not surprising\n      dataS = [] # keeps the max marks for surprisings\n      \n      items = raw.split() \n      \n      for i in range (int(items[0])):\n          ti = int(items[3+i])\n          if ti < 1:\n              dataS += [0]\n              dataN += [0]\n          elif ti > 28:\n              dataS += [10]\n              dataN += [10]\n          else:\n              dataN += [int((ti+2)/3)] # put the values for all participants\n              dataS += [int((ti+4)/3)]\n          \n          \n  \n      \n      p = int(items[2])\n      s = int(items[1])\n      \n      n_vals = dataN\n      n_vals.sort()\n      \n  \n      i=0\n      minimum = 0 # how many numbers greater than p are there in "not surprising"\n      if n_vals[0] < p:\n          while n_vals[-1-i] >= p:\n              minimum += 1\n              i += 1\n      else:\n          minimum = len(n_vals)\n          \n  \n      s_vals = dataS\n      s_vals.sort()\n      i=0\n      maximum = 0 # how many numbers greater than p are there in "surprising"\n      if s_vals[0] < p:\n          while s_vals[-1-i] >= p:\n              maximum += 1\n              i += 1\n      else:\n          maximum = len(n_vals)\n      \n      return min(maximum, minimum+s) \n      \n  \n  for i in range (t):\n      print "Case #%d: %d" %(i+1,compute(tests[i]))\n  \n  \n      \n <CODESPLIT> 55
fileName = raw_input("File name: ")\n  f = open(fileName,"r")\n  \n  \n  n = int(f.readline()[:-1])\n  \n  def check_row(board, index):\n      row = board[index]\n      M = row[0]\n      index = 0\n      for i in range(len(row)):\n          num = row[i]\n          if(num > M):\n              M = num\n              index = i\n      for i in range(len(row)):\n          num = row[i]\n          if(num < M):\n              if not check_col(board,i,num):\n                  return False\n      return True\n  \n  \n  def check_col(board,index,number):\n      for i in range(len(board)):\n          if board[i][index] > number:\n              return False\n      return True\n  \n  def check_all(board):\n      for i in range(len(board)):\n          if not check_row(board, i):\n              return False\n      return True    \n   \n  outputFileName = raw_input("output file name: ")\n  of = open(outputFileName,"w")\n  \n  for i in range(n):\n      board = []\n      mn = f.readline()[:-1].split()\n      m = int(mn[0])\n      n = int(mn[1])\n      for j in range(m): \n          row = f.readline()[:-1].split()\n          row_lst = []\n          for s in row:\n              row_lst += [int(s)]\n          board += [row]\n      if check_all(board):\n          of.write( "Case #%d: %s\n" %(i+1, "YES"))\n      else:\n          of.write( "Case #%d: %s\n" %(i+1, "NO"))\n  \n  of.close()\n  f.close()\n  \n  \n      \n      \n  \n  \n      \n <CODESPLIT> 55
 \n  def compute(A,B):\n      start = A\n  \n      count = 0\n  \n      while start < B:\n          temp = str(start)+str(start)[:len(str(start))-1]\n          for i in range (len(str(start))):\n              if int(temp[i:len(str(start))+i]) > start and int(temp[i:len(str(start))+i]) <= B:\n                  count += 1\n          \n          start += 1\n  \n      return count\n          \n  fileName = raw_input("File name: ")\n  f = open(fileName,"r")\n  n = int(f.readline()[:-1])\n  i=0\n  for line in f:\n  \n      items = (line[:-1]).split()\n  \n      A = int(items[0])\n      B = int(items[1])\n      print "Case #%d: %d" %(i+1,compute(A,B))\n      i+=1\n      \n  f.close()\n <CODESPLIT> 55
fileName = raw_input("File name: ")\n  f = open(fileName,"r")\n  \n  \n  n = int(f.readline()[:-1])\n  boards = []\n  \n  def check_tuple(row):\n      has_o = False\n      has_x = False\n      for char in row:\n          if(char == "."):\n              return (False, "Game has not completed")\n          if(char == "x" or char == "X"):\n              has_x = True\n          if(char == "o" or char == "O"):\n              has_o = True\n          \n      if has_o and has_x:\n          return (False, "Draw")\n      if has_o:\n          return (True, "O won")\n      return (True, "X won")\n  \n  def check_rows(board):\n      for row in board:\n          result = check_tuple(row)\n          if result[0]:\n              return result\n      return (False, "Unknown result")\n  \n  def check_columns(board):\n      for i in range(len(board)):\n          col = ""\n          col += board[0][i]\n          col += board[1][i]\n          col += board[2][i]\n          col += board[3][i]\n          result = check_tuple(col)\n          if result[0]:\n              return result\n      return (False, "Unknown result")\n  \n  def check_diagonals(board):\n      main_diag = ""\n      main_diag += board[0][0]\n      main_diag += board[1][1]\n      main_diag += board[2][2]\n      main_diag += board[3][3]\n      result = check_tuple(main_diag)\n      if result[0]:\n          return result\n      \n      sec_diag = ""\n      sec_diag += board[0][3]\n      sec_diag += board[1][2]\n      sec_diag += board[2][1]\n      sec_diag += board[3][0]\n  \n      result = check_tuple(sec_diag)\n      if result[0]:\n          return result\n  \n      return (False,"Unknown reason")\n  \n      \n              \n      \n  \n  def check_board(board,might_have_finished):\n      result = check_rows(board)\n      if result[0]:\n          return result[1]\n      \n      result = check_columns(board)\n      if result[0]:\n          return result[1]\n      \n      result = check_diagonals(board)\n      if result[0]:\n          return result[1]\n  \n      if(might_have_finished):\n          return "Game has not completed"\n      return "Draw"\n      \n      \n      \n      \n      \n  \n  \n  for i in range(n):\n      board = []\n      might_have_finished = False\n      for j in range(4): \n          row = f.readline()[:-1]\n          if "." in row:\n              might_have_finished = True\n          board += [row]\n      print "Case #%d: %s" %(i+1, check_board(board,might_have_finished))\n      f.readline()\n  \n  f.close()\n  \n      \n      \n  \n  \n      \n <CODESPLIT> 55
 dictionary = {\n      "a":"y",\n      "b":"h",\n      "c":"e",\n      "d":"s",\n      "e":"o",\n      "f":"c",\n      "g":"v",\n      "h":"x",\n      "i":"d",\n      "j":"u",\n      "k":"i",\n      "l":"g",\n      "m":"l",\n      "n":"b",\n      "o":"k",\n      "p":"r",\n      "q":"z",\n      "r":"t",\n      "s":"n",\n      "t":"w",\n      "u":"j",\n      "v":"p",\n      "w":"f",\n      "x":"m",\n      "y":"a",\n      "z":"q",\n      " ":" "    \n      }\n  \n  def translate(sen):\n      \n      new_sen = ""\n  \n      for char in sen: #translate each charecter\n          new_sen += dictionary[char]\n          \n      return new_sen\n  \n  fileName = raw_input("File name: ")\n  f = open(fileName,"r")\n  \n  n = int(f.readline()[:-1])\n  cases = [] #keeps the input msgs\n  \n  for i in range(n):\n      cases += [f.readline()[:-1]]\n  \n  f.close()\n  \n  \n  for i in range(n): # print out\n      print "Case #%d: %s" %(i+1, translate(cases[i]))\n      \n      \n  \n  \n      \n <CODESPLIT> 55
filename = raw_input("Name of file: ")\n  infile = open(filename, "r")\n  outfile = open(filename + ".out", "w")\n  \n  \n  T = int(infile.readline()[:-1])\n  \n  def playDecWars(her, his):\n      n = len(her)\n      count = 0\n      while n > 0:\n          if her[0] < his[0]:\n              del(her[0])\n              del(his[-1])\n          else:\n              del(her[0])\n              del(his[0])\n              count += 1\n          n -= 1\n      return count\n  \n  def playWars(her, his):\n      n = len(her)\n      count = 0\n      while n > 0:\n          if her[0] > his[-1]:\n              count += 1\n              del(her[0])\n              del(his[0])\n          else:\n              his_index = 0\n              for num in his:\n                  if num > her[0]:\n                      break\n                  his_index += 1\n              del(her[0])\n              del(his[his_index])\n          n -= 1\n      return count\n  \n  for t in range(1, T + 1):\n      n = int(infile.readline()[:-1])\n      her = infile.readline()[:-1].split(" ")\n      his = infile.readline()[:-1].split(" ")\n      her = [float(x) for x in her]\n      his = [float(x) for x in his]\n  \n      her.sort()\n      his.sort()\n  \n      d_wars = playDecWars(her[:], his[:])\n      wars = playWars(her[:], his[:])\n      \n      outfile.write("Case #%d: %d %d\n" % (t, d_wars, wars))\n      \n          \n      \n  \n  outfile.close()\n  infile.close()\n <CODESPLIT> 55
 \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n    C, F, X = raw_input().split()\n    C = float(C)\n    F = float(F)\n    X = float(X)\n    time = 0.0\n    rate = 2.0\n    \n    while ( True ):\n      timeToFinish = X / rate\n      timeToFarm   = C / rate\n      farmPayoffTime = C / F\n  \n      if timeToFinish < ( timeToFarm + farmPayoffTime ):\n        time += timeToFinish\n        break\n      else:\n        time += timeToFarm\n        rate += F\n  \n  \n    output = '{0:0.15f}'.format( time )\n  \n    print 'Case #' + str( case ) + ': ' + str( output )\n <CODESPLIT> 56
 \n  def is_sym( number ):\n  	num_str = str( number )\n  	num_len = len( num_str )\n  	half_len = int( num_len / 2 )\n  	end = num_str[-half_len:]\n  	rev_end = end[::-1]\n  	start = num_str[:half_len]\n  	equal = rev_end == start \n  	return equal\n  \n  f = open( 'palindromes.out' )\n  \n  numbers = [ int(x) for x in f.read().split() ]\n  \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n  	min, max = [ int(x) for x in raw_input().split() ]\n  	count = 0\n  	for number in numbers:\n  		if min <= number and max >= number:\n  			count += 1\n  \n  	print 'Case #' + str( case ) + ': ' + str( count )\n <CODESPLIT> 56
def build_table():\n  	table = []\n  	for i in range( 0, 31 ):\n  		table.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )\n  \n  	return table\n  \n  \n  def get_max_score( i ):\n  	return max( 0, min( 10, ( i + 2 ) / 3 ) )\n  \n  def get_max_surprise_score( i ):\n  	return min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )\n  \n  def get_max( x, scores, score_needed, num_surprises ):\n  	scores = sorted( scores, reverse=True )\n  	numPass = 0\n  	i = 0;\n  	while ( i < len(scores) ):\n  		if ( x[scores[i]][0] >= score_needed ):\n  			numPass += 1\n  		else:\n  			break\n  		i += 1\n  \n  	while ( i < len(scores) and num_surprises > 0 ):\n  		if ( x[scores[i]][1] >= score_needed ):\n  			numPass += 1\n  			num_surprises -= 1\n  			\n  		i += 1\n  \n  	return numPass\n  \n  x = build_table()\n  \n  num_cases = input()\n  \n  for i in range( 1, num_cases + 1 ):\n  	line = raw_input().split()\n  	num_surprises = int(line[1])\n  	score_needed = int(line[2])\n  	scores_raw = line[3:]\n  \n  	scores = [ int(y) for y in scores_raw ]\n  \n  	print 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )\n <CODESPLIT> 56
 \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n  	sizeX, sizeY = raw_input().split()\n  	sizeX = int(sizeX)\n  	sizeY = int(sizeY)\n  	board = {}\n  	rowMax = {}\n  	colMax = {}\n  	\n  	for row in range( 0, sizeX ):\n  		row_raw = raw_input()\n  		board[ row ] = {}\n  		col = 0\n  		for value in row_raw.split():\n  			board[ row ][ col ] = int(value)\n  			colMax[ col ] = max( colMax.get(col, 0 ), board[row][col] )\n  			col += 1\n  \n  		rowMax[row] = max( board[row].values() )\n  	\n  	possible = True\n  	result = 'YES'\n  	for row in range( 0, sizeX ):\n  		for col in range( 0, sizeY ):\n  			if board[ row ][ col ] != colMax[ col ] and board[ row ][ col ] != rowMax[ row ]:\n  				possible = False\n  				break\n  		if not possible:\n  			result = 'NO'\n  			break\n  \n  	print 'Case #' + str( case ) + ': ' + result \n <CODESPLIT> 56
 \n  def get_num_recycled( number_s, limit ):\n    num_digits = len(number_s)\n    num_s = number_s + number_s\n    num = int(number_s)\n    r_nums = []\n    for i in range( 1, num_digits ):\n      r_num_s = num_s[i:num_digits+i]\n      r_num = int(r_num_s)\n      if ( r_num > num and r_num <= limit ):\n        r_nums.append( r_num )\n  \n    return len(set(r_nums))\n  \n  \n  num_cases = input()\n  for i in range( 1, num_cases + 1 ):\n    start, limit = raw_input().split()\n    num_recycled = 0\n    for num in range( int(start), int(limit) + 1 ):\n       num_recycled += get_num_recycled( str(num), int(limit) )\n    print 'Case #' + str(i) + ': ' + str( num_recycled )\n <CODESPLIT> 56
 \n  def get_winner( row ):\n  	if row.count( 'X' ) + row.count( 'T' )  == size:\n  		return 'X won'\n  	if row.count( 'O' ) + row.count( 'T' )  == size:\n  		return 'O won'\n  	return 'Draw'\n  	\n  \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n  	size = 4\n  	board = {}\n  	full = True\n  	winner = 'Draw'\n  	\n  	for row in range( 0, size ):\n  		row_raw = raw_input()\n  		board[row] = row_raw\n  		if '.' in row_raw:\n  			full = False\n  \n  		if winner == 'Draw':\n  			winner = get_winner( row_raw )\n  	\n  	raw_input()\n  \n  	if winner == 'Draw':\n  		for col in range( 0, size ):\n  			row_new = ''\n  			for row in range( 0, size ):\n  				row_new += board[row][col]\n  			winner = get_winner( row_new )\n  			if winner != 'Draw':\n  				break\n  \n  	if winner == 'Draw':\n  		row_new = ''\n  		for z in range( 0, size ):\n  			row_new += board[z][z]\n  		winner = get_winner( row_new )\n  		if winner == 'Draw':\n  			row_new = ''\n  			for z in range( 0, size ):\n  				row_new += board[z][size - z - 1]\n  			winner = get_winner( row_new )\n  		\n  \n  	if winner == 'Draw' and not full:\n  		winner = 'Game has not completed'\n  \n  	print 'Case #' + str( case ) + ': ' + winner\n <CODESPLIT> 56
 \n  translation = { 'a' : 'y', 'b' : 'h', 'c' : 'e', 'd' : 's', 'e' : 'o', 'f' : 'c', 'g' : 'v', 'h' : 'x',\n  'i' : 'd', 'j' : 'u', 'k' : 'i', 'l' : 'g', 'm' : 'l', 'n' : 'b', 'o' : 'k', 'p' : 'r', 'q' : 'z', 'r' : 't',\n   's' : 'n', 't' : 'w', 'u' : 'j', 'v' : 'p', 'w' : 'f', 'x' : 'm', 'y' : 'a', 'z' : 'q', ' ' : ' ' }\n  \n  \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n  	words = raw_input()\n  	output = ''\n  	\n  	for letter in words:\n  		output = output + translation[letter]\n  \n  	print 'Case #' + str( case ) + ': ' + output\n <CODESPLIT> 56
 \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n    N = input()\n    Naomis = list( [float(x) for x in raw_input().split() ] )\n    Kens = list( [float(x) for x in raw_input().split() ] )\n    Naomis = sorted( Naomis )\n    Kens = sorted( Kens )\n  \n    NaomisOptimal = Naomis[:]\n    KensOptimal = Kens[:]\n  \n    KenScore = 0\n    for i in xrange( 0, N ):\n      Naomi = NaomisOptimal.pop()\n      x = bisect_left( KensOptimal, Naomi )\n      if x < len( KensOptimal ):\n        KenScore += 1\n        del KensOptimal[ x ]\n      else:\n        del KensOptimal[ 0 ]\n  \n    NScore = 0\n    for i in xrange( 0, N ):\n      Naomi = Naomis[0]\n      del Naomis[0]\n      x = bisect_left( Kens, Naomi )\n      if x == 0:\n        Kens.pop()\n      else:\n        NScore += 1\n        del Kens[ 0 ]\n  \n      output = str( NScore ) + ' ' + str( N - KenScore )\n    \n    print 'Case #' + str( case ) + ': ' + str( output )\n <CODESPLIT> 56
 \n  BASE_RATE = 2.0\n  \n  def process_case(C, F, X):\n      rate = BASE_RATE\n      total_time = 0.0\n      while True:        \n          xtime = X / rate\n          ctime = C / rate\n          ext_rate = rate + F\n          ext_time = ctime + (X / ext_rate)\n          if xtime <= ext_time:\n              total_time += xtime\n              break\n          total_time += ctime\n          rate = ext_rate\n      return total_time\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          C, F, X = line_of_floats(next(lines))\n          result = process_case(C, F, X)\n          yield 'Case #{0}: {1:.7f}\n'.format(ci, result)\n  \n  def line_of_floats(s):\n      return [float(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('B-small-attempt0')\n <CODESPLIT> 57
 \n  \n  def is_palindrome(num):\n      s = str(num)\n      end_idx = len(s)-1\n      for i in range(len(s)//2):\n          if s[i] != s[end_idx-i]:\n              return False\n      return True\n  \n  def is_valid_base(base):\n      return is_palindrome(base) and is_palindrome(base*base)\n  \n  def process_case(lo, hi):\n      cnt = 0\n      base_lo = math.ceil(math.sqrt(lo))\n      base_hi = math.floor(math.sqrt(hi))\n      for base in range(base_lo, base_hi+1):\n          if is_valid_base(base):\n              cnt += 1\n      return cnt\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          lo,hi = line_of_numbers(next(lines))\n          result = process_case(lo, hi)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('C-small-attempt0')\n <CODESPLIT> 57
 \n  def threshold(p, maxdiff):\n      minval = max(p - maxdiff, 0)\n      return p + minval + minval\n  \n  def process_case(numdata):\n      N,S,p = numdata[0:3]\n      scores = numdata[3:]\n      thre_normal = threshold(p, 1)\n      thre_surprise = threshold(p, 2)\n      result = 0\n      for tot in scores:\n          if tot >= thre_normal:\n              result += 1\n          elif S > 0 and tot >= thre_surprise:\n              result += 1\n              S -= 1\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          result = process_case(line_of_numbers(next(lines)))\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('B-small-attempt0')\n <CODESPLIT> 57
 \n  def is_valid(height, max1, max2):\n      if height < max1 and height < max2:\n          return False\n      return True\n  \n  def process_case(heights):\n      nrows = len(heights)\n      ncols = len(heights[0])\n      col_max_vals = [max((heights[r][c] for r in range(nrows)))\n                      for c in range(ncols)]\n      row_max_vals = [max((heights[r][c] for c in range(ncols)))\n                      for r in range(nrows)]\n      for r in range(nrows):\n          for c in range(ncols):\n              if not is_valid(heights[r][c], row_max_vals[r], col_max_vals[c]):\n                  return 'NO'\n      return 'YES'\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          nrows, ncols = line_of_numbers(next(lines))\n          heights = [line_of_numbers(next(lines)) for r in range(nrows)]\n          result = process_case(heights)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('B-small-attempt0')\n <CODESPLIT> 57
 \n  def gen_rotations(num):\n      digits = [ch for ch in str(num)]\n      for i in range(1, len(digits)):\n          if digits[i] != '0':\n              result = 0\n              for d in digits[i:]:\n                  result = 10*result + ord(d) - ord('0')\n              for d in digits[:i]:\n                  result = 10*result + ord(d) - ord('0')\n              if result == num:\n                  return\n              yield result\n      \n  def process_case(a,b):\n      result = 0\n      for n in range(a,b+1):\n          for m in gen_rotations(n):\n              if (n < m <= b):\n                  result += 1\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          a,b = line_of_numbers(next(lines))\n          result = process_case(a,b)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('C-small-attempt0')\n <CODESPLIT> 57
 \n  P1 = 'X'\n  P2 = 'O'\n  PA = 'T'\n  EMPTY = '.'\n  \n  def no_empty_fields(board):\n      for row in board:\n          for field in row:\n              if field==EMPTY:\n                  return False\n      return True\n  \n  def is_winning_series(board, r0, c0, dr, dc, player):\n      r,c = r0,c0\n      for i in range(4):\n          if board[r][c] != player and board[r][c] != PA:\n              return False\n          r,c = r+dr,c+dc\n      return True\n  \n  def win_condition(board, player):\n      if is_winning_series(board, 0,0, 1,1, player):\n          return True\n      if is_winning_series(board, 0,3, 1,-1, player):\n          return True\n      for i in range(4):\n          if is_winning_series(board, 0,i, 1,0, player):\n              return True\n          if is_winning_series(board, i,0, 0,1, player):\n              return True\n      return False\n  \n  def process_case(board):\n      for player in {P1, P2}:\n          if win_condition(board, player):\n              return '{0} won'.format(player)\n      if no_empty_fields(board):\n          return 'Draw'\n      return 'Game has not completed'\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          board = [[ch for ch in next(lines)] for i in range(4)]\n          next(lines)\n          result = process_case(board)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('A-small-attempt0')\n <CODESPLIT> 57
 \n  samples = [('a zoo',\n              'y qee'),\n             ('our language is impossible to understand',\n              'ejp mysljylc kd kxveddknmc re jsicpdrysi'),\n             ('there are twenty six factorial possibilities',\n              'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd'),\n             ('so it is okay if you want to just give up',\n              'de kr kd eoya kw aej tysr re ujdr lkgc jv')]\n             \n  def process_case(line, trans):\n      return ''.join(trans[ch] for ch in line)\n  \n  def prepare_translation():\n      trans = {}\n      for eg_seqs in samples:\n          for echar,gchar in zip(*eg_seqs):\n              trans[gchar] = echar\n      miss_g = set(string.ascii_lowercase) - set(trans.keys())\n      miss_e = set(string.ascii_lowercase) - set(trans.values())\n      if (len(miss_g) == 1 and len(miss_e) == 1):\n          trans[miss_g.pop()] = miss_e.pop();\n      return trans\n  \n  def result_gen(lines):\n      trans = prepare_translation()\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          result = process_case(next(lines), trans)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('A-small-attempt0')\n <CODESPLIT> 57
 \n  def war_points(N, naomi_sorted, ken_sorted):\n      j=0\n      naomi_points = 0\n      for i in range(N):\n          while j < N and naomi_sorted[i] > ken_sorted[j]:\n              j += 1\n          if j < N:\n              j += 1\n          else:\n              naomi_points += 1\n      return naomi_points\n      \n  def deceitful_war_points(N, naomi_sorted, ken_sorted):\n      j=0\n      naomi_points = 0\n      for i in range(N):\n          while j < N and ken_sorted[i] > naomi_sorted[j]:\n              j += 1\n          if j < N:\n              naomi_points += 1\n              j += 1\n      return naomi_points\n  \n  def process_case(N, naomi_sorted, ken_sorted):\n      x1 = deceitful_war_points(N, naomi_sorted, ken_sorted)\n      x2 = war_points(N, naomi_sorted, ken_sorted)\n      return (x1, x2)\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          N = int(next(lines))\n          naomi_sorted = line_of_floats_sorted(next(lines))\n          ken_sorted = line_of_floats_sorted(next(lines))\n          x1, x2 = process_case(N, naomi_sorted, ken_sorted)\n          yield 'Case #{0}: {1} {2}\n'.format(ci, x1, x2)\n      \n  def line_of_floats_sorted(s):\n      fv = [float(sub) for sub in s.split()]\n      fv.sort()\n      return fv\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('D-small-attempt0')\n <CODESPLIT> 57
 \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     """Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     """\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      """Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      """\n      pass\n  \n  def read_input(infile):\n      """This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      """\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      C, F, X = read_floats()\n      \n      case = (C, F, X)\n      \n      return case\n  \n  def solve_case(case):\n      """Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      """\n      C, F, X = case\n      \n      rate = 2.0\n      cookies = 0.0\n      time = 0.0\n      \n      if C >= X:\n          return X / rate\n      \n      while cookies < X:\n          if cookies < C:\n              wait_time = (C - cookies) / rate\n              time += wait_time\n              cookies = C\n          time_if_wait = (X - C) / rate\n          time_if_buy = X / (rate + F)\n          if time_if_wait < time_if_buy:\n              return time + time_if_wait\n          else:\n              rate += F\n              cookies = 0.0\n  \n  \n  if __name__ == "__main__":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == ".in" #input must end with .in\n      infile = open("%s" % sys.argv[1], 'r')\n      outfile = open("%s.out" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n <CODESPLIT> 58
 \n  \n  \n  \n  problem = "C"\n  tag = "small" #commonly sample, small, or large\n  suffix = "-attempt0" #used sometimes for indexing later input files\n  table_of_fairs = np.array([0, 1, 4, 9, 121, 484, 676, 10201, 12321, 14641, \n  40804, 44944, 69696, 94249, 698896, 1002001, 1234321, 4008004, 5221225, 6948496, \n  100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, \n  404090404, 522808225, 617323716, 942060249, 10000200001, 10221412201, 12102420121, \n  12345654321, 40000800004, 637832238736, 1000002000001, 1002003002001, 1004006004001, \n  1020304030201, 1022325232201, 1024348434201, 1086078706801, 1210024200121, \n  1212225222121, 1214428244121, 1230127210321, 1232346432321, 1234567654321, \n  1615108015161, 4000008000004, 4004009004004, 4051154511504, 5265533355625, \n  9420645460249, 100000020000001, 100220141022001, 102012040210201, 102234363432201, \n  121000242000121, 121242363242121, 123212464212321, 123456787654321, \n  123862676268321, 144678292876441, 165551171155561, 400000080000004, \n  900075181570009, 4099923883299904, 10000000200000001, 10002000300020001, \n  10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, \n  10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, \n  10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, \n  12120030703002121, 12122232623222121, 12124434743442121, 12321024642012321, \n  12323244744232321, 12341234943214321, 12343456865434321, 12345678987654321, \n  40000000800000004, 40004000900040004, 94206450305460249, 1000000002000000001, \n  1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, \n  1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, \n  1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, \n  1232344458544432321, 1234323468643234321, 4000000008000000004, 4253436912196343524, \n  6158453974793548516, 100000000020000000001, 100002000030000200001, 100004000060000400001, \n  100020201040102020001, 100022201252102220001, 100024201484102420001, \n  100200120040021002001, 100202122050221202001, 100204124080421402001, \n  100220341262143022001, 100222343474343222001, 102010002040200010201, \n  102012022050220210201, 102014042080240410201, 102030405060504030201, \n  102032425272524230201, 102132537636735231201, 102210100272001012201, 102212122262221212201, \n  102214144272441412201, 102230523292325032201, 102232545484545232201, 102234567696765432201, \n  104190107303701091401, 121000000242000000121, 121002200252002200121, 121004400282004400121, \n  121020021070120020121, 121022221262122220121, 121024421474124420121, 121220122262221022121, \n  121222324272423222121, 121240161292161042121, 121242363484363242121, 121244565696565442121, \n  123210002464200012321, 123212222474222212321, 123230205292502032321, 123232425484524232321, \n  123234645696546432321, 123432124686421234321, 123434346696643434321, 184398883818388893481, \n  400000000080000000004, 400004000090000400004, 522815090696090518225, 906086675171576680609, \n  942064503484305460249, 6916103777337773016196, 10000000000200000000001, 10000220001410002200001, \n  10002002100400120020001, 10002222123632122220001, 10020010200400201002001, 10020230421612403202001, \n  10022014302620341022001, 10022234545854543222001, 10201000020402000010201, 10201222221612222210201, \n  10203022140604122030201, 10203244363836344230201, 10221210222622201212201, 10221432643834623412201, \n  10223234344844343232201, 10224609234443290642201, 12100000002420000000121, 12100242003630024200121,\n  12102202302620320220121, 12102444325852344420121, 12122010222622201022121, 12122252443834425222121, \n  12124214524842541242121, 12321000024642000012321, 12321244225852244212321, 12323222344844322232321, \n  12343210246864201234321, 12384043938083934048321, 12599536942224963599521, 16593841302620314839561, \n  40000000000800000000004, 1000000000002000000000001, 1000002000003000002000001, \n  1000004000006000004000001, 1000020200104010020200001, 1000022200125210022200001, 1000024200148410024200001, 1000200030004000300020001, 1000202030205020302020001, 1000204030408040304020001, 1000220232126212320220001, 1000222232347432322220001, 1002001002004002001002001, 1002003004005004003002001, 1002005006008006005002001, 1002021222306032221202001, 1002023224327234223202001, 1002201232026202321022001, 1002203234227224323022001, 1002221454348434541222001, 1002223456569656543222001, 1020100000204020000010201, 1020102020205020202010201, 1020104040208020404010201, 1020120402306032040210201, 1020122422327232242210201, 1020300010207020100030201, 1020302030406040302030201, 1020304050607060504030201, 1020320414309034140230201, 1020322434528254342230201, 1020324454749474544230201, 1022121002226222001212201, 1022123024227224203212201, 1022141424528254241412201, 1022143446549456443412201, 1022321210249420121232201, 1022323232448442323232201, 1022325254649464525232201, 1210000000024200000000121, 1210002200025200022000121, 1210004400028200044000121, 1210020020107010200200121, 1210022220126210222200121, 1210024420147410244200121, 1210220032026202300220121, 1210222232227222322220121, 1210242254148414522420121, 1210244454369634544420121, 1212201002226222001022121, 1212203204227224023022121, 1212221040509050401222121, 1212223242528252423222121, 1212225444549454445222121, 1212421234248424321242121, 1212423436449446343242121, 1232100000246420000012321, 1232102220247420222012321, 1232120202329232020212321, 1232122422348432242212321, 1232124642369632464212321, 1232322032448442302232321, 1232324252649462524232321, 1234321002468642001234321, 1234323224469644223234321, 1821056104269624016501281, 4000000000008000000000004, 4000004000009000004000004, 4618627222542452227268164, 6942236477330337746322496, 9420645034800084305460249, 40460195511188111559106404, 100000000000020000000000001, 100000220000141000022000001, 100002002010040010200200001, 100002222012363210222200001, 100020001200040002100020001, 100020221222161222122020001, 100022003410262014300220001, 100022223434585434322220001, 100200100020040020001002001, 100200320240161042023002001, 100202104032060230401202001, 100202324254383452423202001, 100220121220262022121022001, 100220341462383264143022001, 100222125432484234521222001, 102010000002040200000010201, 102010222202161202222010201, 102012022032060230220210201, 102012244234383432442210201, 102030201204060402102030201, 102030423426181624324030201, 102032223434282434322230201, 102212100022262220001212201, 102212322442383244223212201, 102214124054282450421412201, 102232321224484422123232201, 121000000000242000000000121, 121000242000363000242000121, 121002202210262012202200121, 121002444212585212444200121, 121022001220262022100220121, 121022243242383242342220121, 121024203630484036302420121, 121220100022262220001022121, 121220342242383242243022121, 121222304234282432403222121, 121242121242484242121242121, 123210000002464200000012321, 123210244202585202442012321, 123212222232484232222212321, 123232201224484422102232321, 123432100024686420001234321, 400000000000080000000000004, 923860899791363197998068329, 4872133543202112023453312784, 9658137819052882509187318569, 10000000000000200000000000001, 10000002000000300000020000001, 10000004000000600000040000001, 10000020200010401000202000001, 10000022200012521000222000001, 10000024200014841000242000001, 10000200021000400012000200001, 10000202021020502012020200001, 10000204021040804012040200001, 10000220221212621212202200001, 10000222221234743212222200001, 10002000102000400020100020001, 10002002102200500220120020001, 10002004102400800420140020001, 10002020304030603040302020001, 10002022304232723240322020001, 10002200143002620034100220001, 10002202143222722234120220001, 10002220345234843254302220001, 10002222345456965454322220001, 10020010000200400200001002001, 10020012002200500220021002001, 10020014004200800240041002001, 10020030220410601402203002001, 10020032222412721422223002001, 10020210221220602212201202001, 10020212223240704232221202001, 10020230441632823614403202001, 10020232443654945634423202001, 10022010100002720000101022001, 10022012102202620220121022001, 10022014104402720440141022001, 10022030322230903222303022001, 10022032324432823442323022001, 10022034326634943662343022001, 10022210341004940014301222001, 10022212343224842234321222001, 10022214345444944454341222001, 10201000000020402000000010201, 10201002020020502002020010201, 10201004040020802004040010201, 10201020402030603020402010201, 10201022422032723022422010201, 10201200001200700210000210201, 10201202021220602212020210201, 10201204041240704214040210201, 10201220403410901430402210201, 10201222423432823432422210201, 10201224443454945434442210201, 10203020102040604020102030201, 10203022122240704222122030201, 10203040506070807060504030201, 10203042526272927262524030201, 10203220123022922032102230201, 10203222143242824234122230201, 10203224163462926436142230201, 10221210000222622200001212201, 10221212022222722222021212201, 10221230422432823422403212201, 10221232444434943444423212201, 10221412221442824412221412201, 10221414243462926434241412201, 10223232102244844220123232201, 10223234124444944442143232201, 12100000000002420000000000121, 12100002200002520000220000121, 12100004400002820000440000121, 12100020020010701002002000121, 12100022220012621002222000121, 12100024420014741002442000121, 12100220023002620032002200121, 12100222223022722032222200121, 12100242243214841234224200121, 12100244443236963234444200121, 12102200102202620220100220121, 12102202302402720420320220121, 12102220124030903042102220121, 12102222324232823242322220121, 12102224524434943442542220121, 12102420145204840254102420121, 12102422345424942454322420121, 12122010000222622200001022121, 12122012202222722220221022121, 12122032240432823404223022121, 12122034442434943424443022121, 12122230223242824232203222121, 12122232425262926252423222121, 12124212102424842420121242121, 12124214304624942640341242121, 12321000000024642000000012321, 12321002220024742002220012321, 12321020202032923020202012321, 12321022422034843022422012321, 12321024642036963024642012321, 12321222023224842232022212321, 12321224243244944234242212321, 12323220102244844220102232321, 12323222322444944422322232321, 12343210000246864200001234321, 12343212222246964222221234321, 16799008923862526832980099761, 40000000000000800000000000004, 40000004000000900000040000004, 44431002775280908257720013444, 98693567900935453900976539689, 1000000000000002000000000000001, 1000000220000014100000220000001, 1000002002001004001002002000001, 1000002222001236321002222000001, 1000020000300004000030000200001, 1000020220302216122030220200001, 1000022002321026201232002200001, 1000022222323458543232222200001, 1000200010020004000200100020001, 1000200230042016102400320020001, 1000202012221206021222102020001, 1000202232243438343422322020001, 1000220012320026200232100220001, 1000220232344238324432320220001, 1000222014541248421454102220001, 1002001000002004002000001002001, 1002001220222016102220221002001, 1002003004005006005004003002001, 1002003224225238325224223002001, 1002021020302206022030201202001, 1002021240524418144250421202001, 1002023024325228225234203202001, 1002201210022026202200121022001, 1002201430264038304620341022001, 1002203214225228225224123022001, 1002221232322248422232321222001, 1020100000000204020000000010201, 1020100222200216120022220010201, 1020102022021206021202202010201, 1020102244221438341224422010201, 1020120200302206022030020210201, 1020120422504418144052240210201, 1020122222343228223432222210201, 1020302010020406040200102030201, 1020302232242418142422322030201, 1020304032241608061422304030201, 1020322212322428242232122230201, 1022121000002226222000001212201, 1022121222422238322242221212201, 1022123024025228225204203212201, 1022141220304428244030221412201, 1022323210022448442200123232201, 1210000000000024200000000000121, 1210000242000036300002420000121, 1210002202201026201022022000121, 1210002444201258521024442000121, 1210022000320026200230002200121, 1210022242322238322232422200121, 1210024202541048401452024200121, 1210220010022026202200100220121, 1210220252044038304402520220121, 1210222212423228223242122220121, 1210242012342048402432102420121, 1212201000002226222000001022121, 1212201242222238322222421022121, 1212203204205228225024023022121, 1212223020322428242230203222121, 1212421210024248424200121242121, 1232100000000246420000000012321, 1232100244200258520024420012321, 1232102222221248421222222012321, 1232122200322248422230022212321, 1232322010022448442200102232321, 1234321000002468642000001234321, 4000000000000008000000000000004, 4844486878939076709398786844484, 6574372239019762679109322734756, 9403095533541415141453355903049, 9659504223792743472973224059569, 9848294822582726272852284928489\n  ])\n  \n  filtered_table = np.array([0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001,\n         1234321, 4008004, 100020001, 102030201, 104060401, 121242121,\n         123454321, 125686521, 400080004, 404090404, 10000200001,\n         10221412201, 12102420121, 12345654321, 40000800004, 1000002000001,\n         1002003002001, 1004006004001, 1020304030201, 1022325232201,\n         1024348434201, 1210024200121, 1212225222121, 1214428244121,\n         1232346432321, 1234567654321, 4000008000004, 4004009004004,\n         100000020000001, 100220141022001, 102012040210201, 102234363432201,\n         121000242000121, 121242363242121, 123212464212321, 123456787654321,\n         400000080000004, 10000000200000001, 10002000300020001,\n         10004000600040001, 10020210401202001, 10022212521222001,\n         10024214841242001, 10201020402010201, 10203040504030201,\n         10205060806050201, 10221432623412201, 10223454745432201,\n         12100002420000121, 12102202520220121, 12104402820440121,\n         12122232623222121, 12124434743442121, 12321024642012321,\n         12323244744232321, 12343456865434321, 12345678987654321,\n         40000000800000004, 40004000900040004, 1000000002000000001,\n         1000220014100220001, 1002003004003002001, 1002223236323222001,\n         1020100204020010201, 1020322416142230201, 1022123226223212201,\n         1022345658565432201, 1210000024200000121, 1210242036302420121,\n         1212203226223022121, 1212445458545442121, 1232100246420012321,\n         1232344458544432321, 1234323468643234321, 4000000008000000004,\n         100000000020000000001, 100002000030000200001, 100004000060000400001,\n         100020201040102020001, 100022201252102220001, 100024201484102420001,\n         100200120040021002001, 100202122050221202001, 100204124080421402001,\n         100220341262143022001, 100222343474343222001, 102010002040200010201,\n         102012022050220210201, 102014042080240410201, 102030405060504030201,\n         102032425272524230201, 102212122262221212201, 102214144272441412201,\n         102232545484545232201, 102234567696765432201, 121000000242000000121,\n         121002200252002200121, 121004400282004400121, 121022221262122220121,\n         121024421474124420121, 121220122262221022121, 121222324272423222121,\n         121242363484363242121, 121244565696565442121, 123210002464200012321,\n         123212222474222212321, 123232425484524232321, 123234645696546432321,\n         123432124686421234321, 123434346696643434321, 400000000080000000004,\n         400004000090000400004, 10000000000200000000001,\n         10000220001410002200001, 10002002100400120020001,\n         10002222123632122220001, 10020010200400201002001,\n         10020230421612403202001, 10022014302620341022001,\n         10022234545854543222001, 10201000020402000010201,\n         10201222221612222210201, 10203022140604122030201,\n         10203244363836344230201, 10221210222622201212201,\n         10221432643834623412201, 10223234344844343232201,\n         12100000002420000000121, 12100242003630024200121,\n         12102202302620320220121, 12102444325852344420121,\n         12122010222622201022121, 12122252443834425222121,\n         12124214524842541242121, 12321000024642000012321,\n         12321244225852244212321, 12323222344844322232321,\n         12343210246864201234321, 40000000000800000000004,\n         1000000000002000000000001, 1000002000003000002000001,\n         1000004000006000004000001, 1000020200104010020200001,\n         1000022200125210022200001, 1000024200148410024200001,\n         1000200030004000300020001, 1000202030205020302020001,\n         1000204030408040304020001, 1000220232126212320220001,\n         1000222232347432322220001, 1002001002004002001002001,\n         1002003004005004003002001, 1002005006008006005002001,\n         1002021222306032221202001, 1002023224327234223202001,\n         1002201232026202321022001, 1002203234227224323022001,\n         1002221454348434541222001, 1002223456569656543222001,\n         1020100000204020000010201, 1020102020205020202010201,\n         1020104040208020404010201, 1020120402306032040210201,\n         1020122422327232242210201, 1020302030406040302030201,\n         1020304050607060504030201, 1020322434528254342230201,\n         1020324454749474544230201, 1022121002226222001212201,\n         1022123024227224203212201, 1022141424528254241412201,\n         1022143446549456443412201, 1022323232448442323232201,\n         1022325254649464525232201, 1210000000024200000000121,\n         1210002200025200022000121, 1210004400028200044000121,\n         1210022220126210222200121, 1210024420147410244200121,\n         1210220032026202300220121, 1210222232227222322220121,\n         1210242254148414522420121, 1210244454369634544420121,\n         1212201002226222001022121, 1212203204227224023022121,\n         1212223242528252423222121, 1212225444549454445222121,\n         1212421234248424321242121, 1212423436449446343242121,\n         1232100000246420000012321, 1232102220247420222012321,\n         1232122422348432242212321, 1232124642369632464212321,\n         1232322032448442302232321, 1232324252649462524232321,\n         1234321002468642001234321, 1234323224469644223234321,\n         4000000000008000000000004, 4000004000009000004000004,\n         100000000000020000000000001, 100000220000141000022000001,\n         100002002010040010200200001, 100002222012363210222200001,\n         100020001200040002100020001, 100020221222161222122020001,\n         100022003410262014300220001, 100022223434585434322220001,\n         100200100020040020001002001, 100200320240161042023002001,\n         100202104032060230401202001, 100202324254383452423202001,\n         100220121220262022121022001, 100220341462383264143022001,\n         100222125432484234521222001, 102010000002040200000010201,\n         102010222202161202222010201, 102012022032060230220210201,\n         102012244234383432442210201, 102030201204060402102030201,\n         102030423426181624324030201, 102032223434282434322230201,\n         102212100022262220001212201, 102212322442383244223212201,\n         102214124054282450421412201, 102232321224484422123232201,\n         121000000000242000000000121, 121000242000363000242000121,\n         121002202210262012202200121, 121002444212585212444200121,\n         121022001220262022100220121, 121022243242383242342220121,\n         121024203630484036302420121, 121220100022262220001022121,\n         121220342242383242243022121, 121222304234282432403222121,\n         121242121242484242121242121, 123210000002464200000012321,\n         123210244202585202442012321, 123212222232484232222212321,\n         123232201224484422102232321, 123432100024686420001234321,\n         400000000000080000000000004, 10000000000000200000000000001,\n         10000002000000300000020000001, 10000004000000600000040000001,\n         10000020200010401000202000001, 10000022200012521000222000001,\n         10000024200014841000242000001, 10000200021000400012000200001,\n         10000202021020502012020200001, 10000204021040804012040200001,\n         10000220221212621212202200001, 10000222221234743212222200001,\n         10002000102000400020100020001, 10002002102200500220120020001,\n         10002004102400800420140020001, 10002020304030603040302020001,\n         10002022304232723240322020001, 10002200143002620034100220001,\n         10002202143222722234120220001, 10002220345234843254302220001,\n         10002222345456965454322220001, 10020010000200400200001002001,\n         10020012002200500220021002001, 10020014004200800240041002001,\n         10020030220410601402203002001, 10020032222412721422223002001,\n         10020210221220602212201202001, 10020212223240704232221202001,\n         10020230441632823614403202001, 10020232443654945634423202001,\n         10022012102202620220121022001, 10022014104402720440141022001,\n         10022032324432823442323022001, 10022034326634943662343022001,\n         10022212343224842234321222001, 10022214345444944454341222001,\n         10201000000020402000000010201, 10201002020020502002020010201,\n         10201004040020802004040010201, 10201020402030603020402010201,\n         10201022422032723022422010201, 10201202021220602212020210201,\n         10201204041240704214040210201, 10201222423432823432422210201,\n         10201224443454945434442210201, 10203020102040604020102030201,\n         10203022122240704222122030201, 10203040506070807060504030201,\n         10203042526272927262524030201, 10203222143242824234122230201,\n         10203224163462926436142230201, 10221210000222622200001212201,\n         10221212022222722222021212201, 10221230422432823422403212201,\n         10221232444434943444423212201, 10221412221442824412221412201,\n         10221414243462926434241412201, 10223232102244844220123232201,\n         10223234124444944442143232201, 12100000000002420000000000121,\n         12100002200002520000220000121, 12100004400002820000440000121,\n         12100022220012621002222000121, 12100024420014741002442000121,\n         12100220023002620032002200121, 12100222223022722032222200121,\n         12100242243214841234224200121, 12100244443236963234444200121,\n         12102200102202620220100220121, 12102202302402720420320220121,\n         12102222324232823242322220121, 12102224524434943442542220121,\n         12102420145204840254102420121, 12102422345424942454322420121,\n         12122010000222622200001022121, 12122012202222722220221022121,\n         12122032240432823404223022121, 12122034442434943424443022121,\n         12122230223242824232203222121, 12122232425262926252423222121,\n         12124212102424842420121242121, 12124214304624942640341242121,\n         12321000000024642000000012321, 12321002220024742002220012321,\n         12321022422034843022422012321, 12321024642036963024642012321,\n         12321222023224842232022212321, 12321224243244944234242212321,\n         12323220102244844220102232321, 12323222322444944422322232321,\n         12343210000246864200001234321, 12343212222246964222221234321,\n         40000000000000800000000000004, 40000004000000900000040000004,\n         1000000000000002000000000000001, 1000000220000014100000220000001,\n         1000002002001004001002002000001, 1000002222001236321002222000001,\n         1000020000300004000030000200001, 1000020220302216122030220200001,\n         1000022002321026201232002200001, 1000022222323458543232222200001,\n         1000200010020004000200100020001, 1000200230042016102400320020001,\n         1000202012221206021222102020001, 1000202232243438343422322020001,\n         1000220012320026200232100220001, 1000220232344238324432320220001,\n         1000222014541248421454102220001, 1002001000002004002000001002001,\n         1002001220222016102220221002001, 1002003004005006005004003002001,\n         1002003224225238325224223002001, 1002021020302206022030201202001,\n         1002021240524418144250421202001, 1002023024325228225234203202001,\n         1002201210022026202200121022001, 1002201430264038304620341022001,\n         1002203214225228225224123022001, 1002221232322248422232321222001,\n         1020100000000204020000000010201, 1020100222200216120022220010201,\n         1020102022021206021202202010201, 1020102244221438341224422010201,\n         1020120200302206022030020210201, 1020120422504418144052240210201,\n         1020122222343228223432222210201, 1020302010020406040200102030201,\n         1020302232242418142422322030201, 1020304032241608061422304030201,\n         1020322212322428242232122230201, 1022121000002226222000001212201,\n         1022121222422238322242221212201, 1022123024025228225204203212201,\n         1022141220304428244030221412201, 1022323210022448442200123232201,\n         1210000000000024200000000000121, 1210000242000036300002420000121,\n         1210002202201026201022022000121, 1210002444201258521024442000121,\n         1210022000320026200230002200121, 1210022242322238322232422200121,\n         1210024202541048401452024200121, 1210220010022026202200100220121,\n         1210220252044038304402520220121, 1210222212423228223242122220121,\n         1210242012342048402432102420121, 1212201000002226222000001022121,\n         1212201242222238322222421022121, 1212203204205228225024023022121,\n         1212223020322428242230203222121, 1212421210024248424200121242121,\n         1232100000000246420000000012321, 1232100244200258520024420012321,\n         1232102222221248421222222012321, 1232122200322248422230022212321,\n         1232322010022448442200102232321, 1234321000002468642000001234321,\n         4000000000000008000000000000004], dtype=object)\n  \n  \n  def read_input(infile):\n      """This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      """\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints():\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #change the dtype?\n      \n      A, B = read_bigints()\n      \n      return (A, B)\n  \n  def is_palindrome(num):\n      digits = []\n      num = int(num)\n      while num > 0:\n          digits.append(num % 10)\n          num = num / 10 #n.b. int division (discard remainder)\n  \n      return digits == digits[::-1]\n  \n      for i in range(len(digits) / 2): #n.b. int division (skips center)\n          if digits[i] != digits[-i+1]:\n              return False\n      return True\n  \n  def solve_case_simple(case):\n      A, B = case\n      \n      if B > table_of_fairs[-1]:\n          raise ValueError, "Ranges too big for lookup table!"\n      \n      valid = (A <= filtered_table) * (filtered_table <= B)\n      return valid.sum()\n  \n  def solve_case(case):\n      """Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      """\n      \n      output = solve_case_simple(case)\n      return output\n  \n  \n  if __name__ == "__main__":\n      infile = open("%s-%s%s.in" % (problem, tag, suffix), 'r')\n      outfile = open("%s-%s%s.out" % (problem, tag, suffix), 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n <CODESPLIT> 58
 \n  \n  case = 1\n  problem = "B"\n  practice = False\n  \n  if practice:\n      practice = "-practice"\n  else:\n      practice = "-attempt0"\n  if case == 0:\n      infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')        \n  elif case == 1:\n      infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')    \n  elif case == 2:\n      infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')   \n  else:\n      raise ValueError, 'Invalid case'\n      \n  lookup = {}\n  \n  def check_total(total, p):\n      assert type(total) == int\n      resid = total % 3\n  \n      min_nosurprise = (total / 3)    \n      max_nosurprise = (total / 3) + min(1, resid)\n      \n      \n      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):\n          if max_nosurprise >= p:\n              return 1\n          else:\n              return -1\n  \n      if max_nosurprise >= p:\n          return 1\n      elif max_nosurprise == p-1:\n          return 0\n      else:\n          return -1\n      \n  cases = int(infile.readline().strip('\n'))\n  for i in range(cases):\n      print 'case %i of %i' % (i+1, cases)\n      line = infile.readline().split()\n      N = int(line[0])\n      S = int(line[1])\n      p = int(line[2])\n      points = []\n      for item in line[3:]:\n          points.append(int(item))\n      assert N == len(points)\n      assert p <= 10\n      assert p >= 0\n      assert S >= 0\n      assert S <= N\n      \n      always = 0\n      possible = 0\n      \n      for total in points:\n          if (total, p) in lookup:\n              depends = lookup[total, p]\n          else:\n              depends = check_total(total, p)\n          \n          if depends == 1:\n              always += 1\n          elif depends == 0:\n              possible += 1\n      \n      output = '%i' % (always + min(possible, S))\n      \n      outfile.write('Case #%i: %s\n' % (i+1, output))\n      \n  infile.close()\n  outfile.close()\n <CODESPLIT> 58
 \n  \n  \n  \n  problem = "B"\n  tag = "small" #commonly sample, small, or large\n  suffix = "-attempt0" #used sometimes for indexing later input files\n  \n  \n  \n  def read_input(infile):\n      """This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      """\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #change the dtype?\n      \n      N, M = read_ints()\n      \n      lawn = np.empty((N, M), dtype=int)\n      for i in range(N):\n          row = read_ints()\n          assert len(row) == M\n          lawn[i,:] = row\n      \n      return lawn\n  \n  def solve_case(case):\n      """Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      """\n      \n      lawn = case\n      undefined = np.zeros(lawn.shape, dtype=bool)\n      \n      colvals, rowvals = np.meshgrid(range(lawn.shape[1]), range(lawn.shape[0]))\n      \n      while not undefined.all():\n          valid = undefined == False\n          minval = lawn[valid].min()\n      \n          minindex = np.where(lawn[valid] == minval)[0][0]\n          minrow = rowvals[valid][minindex]\n          mincol = colvals[valid][minindex]\n          if (lawn[minrow,:][valid[minrow,:]] == minval).all():\n              undefined[minrow,:] = True\n              continue\n          \n          if (lawn[:,mincol][valid[:,mincol]] == minval).all():\n              undefined[:,mincol] = True\n              continue\n          \n          return "NO"\n      \n      return "YES"\n  \n  \n  if __name__ == "__main__":\n      infile = open("%s-%s%s.in" % (problem, tag, suffix), 'r')\n      outfile = open("%s-%s%s.out" % (problem, tag, suffix), 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n <CODESPLIT> 58
 \n  \n  case = 1\n  problem = "C"\n  practice = False\n  \n  if practice:\n      practice = "-practice"\n  else:\n      practice = "-attempt0"\n  if case == 0:\n      infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')        \n  elif case == 1:\n      infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')    \n  elif case == 2:\n      infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')   \n  else:\n      raise ValueError, 'Invalid case'\n      \n  def permute(num, maxval):\n      assert type(num) == int\n      output = []\n      digits = int(N.ceil(N.log10(num)))\n      current = num\n      for i in range(digits-1):\n          current = current / 10 + 10**(digits-1) * (current % 10)\n          if current <= num: #We only want permutations greater than num (for uniqueness)\n              continue\n          if current > maxval: #only permutations less than the maximum value\n              continue\n          if current not in output:\n              output.append(current)\n      return len(output)\n      \n  def count_recycled(A, B):\n      count = 0\n      for num in xrange(A, B+1):\n          count += permute(num, B)\n      return count\n      \n  cases = int(infile.readline().strip('\n'))\n  for i in range(cases):\n      A, B = infile.readline().split()\n      A = int(A)\n      B = int(B)\n      \n      output = '%i' % count_recycled(A, B)\n      \n      outfile.write('Case #%i: %s\n' % (i+1, output))\n      \n  infile.close()\n  outfile.close()\n <CODESPLIT> 58
 \n  \n  \n  \n  problem = "A"\n  tag = "small" #commonly sample, small, or large\n  suffix = "-attempt1" #used sometimes for indexing later input files\n  \n  \n  def read_input(infile):\n      """This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      """\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #change the dtype?\n      \n      board = np.empty((4,4), dtype=int)\n      \n      dic = {'X': 1, 'T': 2, 'O': 3, '.': 4}\n      \n      for i in range(4):\n          line = read_string()\n          for j in range(4):\n              board[i,j] = dic[line[j]]\n      infile.readline()\n      \n      return board\n  \n  def iswin(row):\n      if 4 in row:\n          return None #gap\n      if (row <= 2).all():\n          return "X won"\n      if (row >= 2).all():\n          return "O won"\n      return None\n  \n  def solve_case(case):\n      """Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      """\n      \n      board = case\n  \n      for i in range(4):\n          row = board[i,:]\n          if iswin(row) is not None:\n              return iswin(row)\n          \n      for i in range(4):\n          col = board[:,i]\n          if iswin(col) is not None:\n              return iswin(col)\n          \n      vals = np.arange(4)\n      diag = board[vals,vals]\n      if iswin(diag) is not None:\n          return iswin(diag)\n      \n      diag = board[vals, vals[::-1]]\n      if iswin(diag) is not None:\n          return iswin(diag)\n  \n      if 4 in board:\n          return "Game has not completed"\n      \n      return "Draw"\n  \n  \n  if __name__ == "__main__":\n      infile = open("%s-%s%s.in" % (problem, tag, suffix), 'r')\n      outfile = open("%s-%s%s.out" % (problem, tag, suffix), 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n <CODESPLIT> 58
 \n  \n  case = 1\n  problem = "A"\n  practice = False\n  \n  if practice:\n      practice = "-practice"\n  else:\n      practice = "-attempt0"\n  if case == 0:\n      infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')        \n  elif case == 1:\n      infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')    \n  elif case == 2:\n      infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')   \n  else:\n      raise ValueError, 'Invalid case'\n      \n  alpha = 'abcdefghijklmnopqrstuvwxyz '\n  trans = 'ynficwlbkuomxsevzpdrjgthaq '\n  table = maketrans(trans, alpha)\n      \n  cases = int(infile.readline().strip('\n'))\n  for i in range(cases):\n      instr = infile.readline().strip('\n')\n      \n      \n      output = translate(instr, table)\n      \n      \n      outfile.write('Case #%i: %s\n' % (i+1, output))\n      \n  infile.close()\n  outfile.close()\n <CODESPLIT> 58
 \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     """Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     """\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      """Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      """\n      pass\n  \n  def read_input(infile):\n      """This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      """\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      N = read_int()\n      naomi = read_floats()\n      ken = read_floats()\n      naomi.sort()\n      ken.sort()\n      assert len(naomi) == N\n      assert len(ken) == N\n      \n      return naomi, ken\n  \n  def ken_choice(told_naomi, ken, ken_free):\n      N = len(ken)\n      lowest = None\n      for j in range(N):\n          if not ken_free[j]:\n              continue\n          if lowest is None:\n              lowest, idx = ken[j], j\n          if ken[j] > told_naomi:\n              return ken[j], j\n      return lowest, idx\n  \n  def normal_war(naomi, ken):\n      \n      N = len(naomi)\n      ken_free = np.ones(N, dtype=bool)\n      score = 0\n      for i in range(N)[::-1]:\n          chosen_naomi = naomi[i]\n          chosen_ken, j = ken_choice(chosen_naomi, ken, ken_free)\n          ken_free[j] = False\n          \n          if chosen_naomi > chosen_ken:\n              score += 1\n      return score\n  \n  \n  def new_deceitful_war(naomi, ken):\n      score = 0\n      \n      N = len(naomi)\n      \n      for i in range(N):\n          if naomi[-1] > ken[-1]:\n              score += 1\n              naomi = naomi[:-1]\n              ken = ken[:-1]\n          else:\n              naomi = naomi[1:]\n              ken = ken[:-1]\n      return score\n  \n  \n  def deceitful_war(naomi, ken):\n      \n      \n      \n      \n      N = len(naomi)\n      no_hopers = 0\n      for i in range(N):\n          if naomi[i] < ken[0]:\n              no_hopers += 1\n      def_losses = 0\n      for i in range(N)[::-1]:\n          if ken[i] > naomi[-1]:\n              def_losses += 1\n      \n      edge = max(no_hopers, def_losses)\n      naomi = naomi[edge:]\n      ken = ken[:N-edge]\n  \n      '''\n      print "After removing sure losers:"\n      print N, N-edge, edge\n      if N - edge > 0:\n          if min(naomi) < max(ken):\n              print naomi\n              print ken\n      '''\n  \n  \n      score = 0\n      for i in range(N - edge):\n          if naomi[i] > ken[i]:\n              score += 1\n              \n      return score\n  \n  def solve_case(case):\n      """Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      """\n      \n      naomi, ken = case\n      print naomi\n      print ken\n      \n      new = new_deceitful_war(naomi, ken)\n      \n      good, bad = deceitful_war(naomi, ken), normal_war(naomi, ken)\n      \n      if not new == good:\n          print 'Hey!', new, good\n      \n      output = "%i %i" % (new, bad)\n      return output\n  \n  \n  if __name__ == "__main__":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == ".in" #input must end with .in\n      infile = open("%s" % sys.argv[1], 'r')\n      outfile = open("%s.out" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n <CODESPLIT> 58
 \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      C, F, X = map(float, raw_input().split())\n      answer = X / 2\n      i = 0\n      last_tc = 0\n      while True:\n          tc = last_tc + C / (2 + (i * F))\n          if answer < tc:\n              break\n          answer = min(tc + X / (2 + (i + 1) * F), answer)\n  \n          i += 1\n          last_tc = tc\n      print 'Case #{}: {:.7f}'.format(test_case, answer)\n <CODESPLIT> 59
 \n  N_MAX = 10 ** 7  # for First large dataset\n  \n  \n  def is_palindrome(n):\n      s = str(n)\n      for i in xrange(len(s) / 2):\n          if s[i] != s[-1 - i]:\n              return False\n      return True\n  \n  palindromes = [x for x in xrange(N_MAX) if is_palindrome(x)]\n  palindrome_squares = [x ** 2 for x in palindromes]\n  fair_and_square_palindromes = filter(is_palindrome, palindrome_squares)\n  \n  \n  T = int(raw_input())\n  for test_case_id in xrange(1, T + 1):\n      A, B = map(int, raw_input().split())\n      answer = len([x for x in fair_and_square_palindromes if A <= x <= B])\n      print 'Case #{}: {}'.format(test_case_id, answer)\n <CODESPLIT> 59
 \n  \n  poss = dict([(i, {}) for i in xrange(0, 30 + 1)])\n  for a, b, c in itertools.product(range(10 + 1), repeat=3):\n      if a <= b <= c and c - a <= 2:\n          n = a + b + c\n          if c - a == 2:\n              poss[n]['s'] = tuple(sorted((a, b, c)))\n          else:\n              poss[n]['n'] = tuple(sorted((a, b, c)))\n  \n  \n  T = int(raw_input())\n  for case in xrange(1, T + 1):\n      div = map(int, raw_input().split())\n      N, S, p = div[:3]\n      t = div[3:]\n  \n      ans = 0\n      t.sort(reverse=True)\n      for i in xrange(len(t)):\n          na, nb, nc = poss[t[i]]['n']\n          sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))\n          if p <= nc:\n              ans += 1\n          elif 0 < S and p <= sc:\n              ans += 1\n              S -= 1\n  \n      print 'Case #%d: %d' % (case, ans)\n  \n <CODESPLIT> 59
 \n  T = int(raw_input())\n  for test_case_id in xrange(1, T + 1):\n      N, M = map(int, raw_input().split())\n      A = []\n      for i in xrange(N):\n          A.append(map(int, raw_input().split()))\n  \n      heights = reduce(lambda a, b: a | b, (set(row) for row in A))\n      for y in xrange(N):\n          for x in xrange(M):\n              if (\n                  any(A[y][j] > A[y][x] for j in xrange(M)) and\n                  any(A[i][x] > A[y][x] for i in xrange(N))\n              ):\n                  print 'Case #{}: NO'.format(test_case_id)\n                  break\n          else:\n              continue\n          break\n      else:\n          print 'Case #{}: YES'.format(test_case_id)\n <CODESPLIT> 59
 \n  \n  def rotate(x, w):\n      x = str(x)\n      return int(x[-w:] + x[:-w])\n  \n  \n  T = int(raw_input())\n  for case in xrange(1, T + 1):\n      A, B = map(int, raw_input().split())\n  \n      l = len(str(A))\n      assert l == len(str(B))\n  \n      s = []\n      for n in xrange(A, B + 1):\n          for w in xrange(1, len(str(n))):\n              m = int(rotate(n, w))\n              if n < m <= B:\n                  s.append((n, m))\n  \n      print 'Case #%d: %d' % (case, len(set(s)))\n  \n <CODESPLIT> 59
 \n  T = int(raw_input())\n  for test_case_id in xrange(1, T + 1):\n      cells = []\n      for i in xrange(4):\n          cells.append(raw_input())\n      raw_input()\n  \n      R = range(4)\n      for c in 'XO':\n          if (\n              any(all(cells[i][j] in (c, 'T') for j in R) for i in R) or\n              any(all(cells[i][j] in (c, 'T') for i in R) for j in R) or\n              all(cells[i][i] in (c, 'T') for i in R) or\n              all(cells[i][3 - i] in (c, 'T') for i in R)\n          ):\n              print 'Case #{}: {} won'.format(test_case_id, c)\n              break\n      else:\n          if '.' in ''.join(cells):\n              print 'Case #{}: Game has not completed'.format(test_case_id)\n          else:\n              print 'Case #{}: Draw'.format(test_case_id)\n <CODESPLIT> 59
 \n  \n  \n  str_to = '''\n  ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv\n  '''.replace(' ', '').replace('\n', '')\n  \n  str_from = '''\n  our language is impossible to understand\n  there are twenty six factorial possibilities\n  so it is okay if you want to just give up\n  '''.replace(' ', '').replace('\n', '')\n  \n  conv = {}\n  for i, c in enumerate(str_from):\n      assert c not in conv or conv[c] == str_to[i]\n      conv[c] = str_to[i]\n  conv['z'] = 'q'\n  conv['q'] = 'z'\n  \n  assert len(set(conv.keys())) == 26\n  assert len(set(conv.values())) == 26\n  mat = ['', '']\n  for k, v in conv.items():\n      mat[0] += v\n      mat[1] += k\n  \n  T = int(raw_input())\n  for case in xrange(1, T + 1):\n      line = raw_input()\n      ans = string.translate(line, string.maketrans(*mat))\n      print 'Case #%d: %s' % (case, ans)\n  \n <CODESPLIT> 59
 \n  \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      N = int(raw_input())\n      W1 = sorted(map(float, raw_input().split()))\n      W2 = sorted(map(float, raw_input().split()))\n  \n      y = 0\n      c1 = c2 = 0\n      while c1 < N and c2 < N:\n          if W2[c2] < W1[c1]:\n              y += 1\n              c1 += 1\n              c2 += 1\n          while c1 < N and c2 < N and W1[c1] < W2[c2]:\n              c1 += 1\n  \n      z = N\n      c1 = c2 = 0\n      while c1 < N and c2 < N:\n          if W1[c1] < W2[c2]:\n              z -= 1\n              c1 += 1\n              c2 += 1\n          while c1 < N and c2 < N and W2[c2] < W1[c1]:\n              c2 += 1\n  \n      print 'Case #{}: {} {}'.format(test_case, y, z)\n <CODESPLIT> 59
 \n  \n  def process(C, F, X):\n  	speed = 2.0\n  	time = 0.0\n  	while True:\n  		if C / speed + X / (speed + F) > X / speed:\n  			time += X / speed\n  			break\n  		time += C / speed\n  		speed += F\n  	return round(time, 7)\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  	(C, F, X) = map(float, input_file.readline().split())\n  	print 'Case #%d:' % (i + 1), process(C, F, X)\n <CODESPLIT> 60
'''\n  Created on 13 Apr 2013\n  \n  @author: mengda\n  '''\n  \n  ls = []\n  \n  def isP(num):\n      num = str(int(num))\n      for i in range(len(num) / 2):\n          if num[i] <> num[-1 - i]:\n              return False\n      return True\n  \n  def createP(root, half_digits):\n      root = str(root)\n      for i in range(half_digits):\n          ls[i] = root[i]\n          ls[-1 - i] = root[i]\n      return int(''.join(ls))\n  \n  def process(A, B):\n      rlt = 0\n      a = int(math.ceil(math.sqrt(A)))\n      b = int(math.floor(math.sqrt(B)))\n      str_a = str(a)\n      half_digits = int(math.ceil(len(str_a) / 2.0))\n      root = int(str_a[:half_digits])\n      next_root = 10 ** half_digits\n      digits = len(str_a)\n      for _ in range(digits - len(ls)):\n          ls.append('')\n      while True:\n          if root == next_root:\n              if digits % 2 == 0:\n                  next_root *= 10\n                  half_digits += 1\n              else:\n                  root /= 10\n              digits += 1\n              ls.append('')\n          p = createP(root, half_digits)\n          print p,\n          if p > b:\n              print 'too large'\n              break\n          if isP(math.pow(p, 2)):\n              print 'right one!'\n              rlt += 1\n          else:\n              print \n          root += 1\n      return rlt\n  \n  def process1(A, B):\n      rlt = 0\n      a = int(math.ceil(math.sqrt(A)))\n      b = int(math.floor(math.sqrt(B)))\n      for i in range(a, b + 1):\n          if not isP(i):\n              continue\n          power = math.pow(i, 2)\n          if isP(power):\n              rlt += 1\n      return rlt\n  \n  f = open('C-small-attempt1.in', 'r')\n  T = int(f.readline())\n  outLine = []\n  \n  for i in range(1, T + 1):\n      (A, B) = map(int, f.readline().split())\n      outLine.append('Case #%d: %s\n' % (i, process1(A, B)))\n      print outLine[-1],\n  \n  f.close()\n  outFile = open('C-S.out', 'w')\n  outFile.writelines(outLine)\n  outFile.close()\n <CODESPLIT> 60
'''\n  Created on 2012-4-14\n  \n  @author: hemnd\n  '''\n  def cal(args):\n      rslt = 0\n      N = int(args[0])\n      S = int(args[1])\n      p = int(args[2])\n      for i in range(N):\n          s = int(args[i + 3])\n          e = s / 3\n          r = s % 3\n          if e >= p:\n              rslt += 1\n          elif r == 1:\n              if e + 1 >= p:\n                  rslt += 1\n          elif r == 0:\n              if e == 0:\n                  continue\n              if S > 0 and e + 1 >= p:\n                  rslt += 1\n                  S -= 1\n          elif r == 2:\n              if e + 1 >= p:\n                  rslt += 1\n              elif S > 0 and e + 2 >= p:\n                  rslt += 1\n                  S -= 1\n      return rslt\n  \n  inputFile = open('B-small-attempt0.in', 'r')\n  inputLines = inputFile.readlines()\n  inputFile.close()\n  \n  T = int(inputLines[0])\n  outputLines = []\n  \n  for i in range(1, T + 1):\n      args = inputLines[i].strip().split(' ')\n      outputLines.append('Case #%d: %d\n' % (i, cal(args)))\n      print outputLines[i - 1],\n  \n  outputFile = open('B-small.out', 'w')\n  outputFile.writelines(outputLines)\n  outputFile.close()\n <CODESPLIT> 60
'''\n  Created on 13 Apr 2013\n  \n  @author: mengda\n  '''\n  expected = []\n  \n  def process(N, M):\n      lawn = []\n      for n in range(N):\n          lawn.append([100] * M)\n      for n in range(N):\n          highest = 0\n          for m in range(M):\n              if expected[n][m] > highest:\n                  highest = expected[n][m]\n          for m in range(M):\n              if lawn[n][m] > highest:\n                  lawn[n][m] = highest\n      for m in range(M):\n          highest = 0\n          for n in range(N):\n              if expected[n][m] > highest:\n                  highest = expected[n][m]\n          for n in range(N):\n              if lawn[n][m] > highest:\n                  lawn[n][m] = highest\n      for n in range(N):\n          for m in range(M):\n              if lawn[n][m] <> expected[n][m]:\n                  return 'NO'\n      return 'YES'\n  \n  f = open('B-small-attempt0.in', 'r')\n  T = int(f.readline())\n  outLine = []\n  \n  for i in range(1, T + 1):\n      expected = []\n      (N, M) = map(int, f.readline().split())\n      for _ in range(N):\n          expected.append(map(int, f.readline().split()))\n      outLine.append('Case #%d: %s\n' % (i, process(N, M)))\n      print outLine[-1],\n  \n  f.close()\n  outFile = open('b.s.out', 'w')\n  outFile.writelines(outLine)\n  outFile.close()\n <CODESPLIT> 60
'''\n  Created on 2012-4-14\n  \n  @author: hemnd\n  '''\n  def cal(A, B):\n      rslt = 0\n      tmp = []\n      for i in range(1, len(A)):\n          min = max = 0\n          for j in range(int(A[0:i]), int(B[0:i]) + 1):\n              sJ = str(j)\n              sMin = (sJ * (len(A) - i))[0:len(A) - i]\n              min = int(sMin)\n              if int(sMin + sJ) <= int(sJ + sMin):\n                  min += 1\n              if int(B[-i:]) >= j:\n                  max = int(B[:(len(A) - i)])\n              else:\n                  max = int(B[:(len(A) - i)]) - 1\n              if max < min:\n                  continue\n              for k in range(min, max + 1):\n                  if (sJ + str(k), str(k) + sJ) in tmp:\n                      print (sJ + str(k), str(k) + sJ), 'already there'\n                      continue\n                  else:\n                      tmp.append((sJ + str(k), str(k) + sJ))\n                      rslt += 1\n  \n      return rslt\n  \n  inputFile = open('C-small-attempt2.in', 'r')\n  inputLines = inputFile.readlines()\n  inputFile.close()\n  \n  T = int(inputLines[0])\n  outputLines = []\n  \n  for i in range(1, T + 1):\n      args = inputLines[i].strip().split(' ')\n      outputLines.append('Case #%d: %d\n' % (i, cal(args[0], args[1])))\n      print outputLines[i - 1],\n  \n  outputFile = open('C-small.out', 'w')\n  outputFile.writelines(outputLines)\n  outputFile.close()\n <CODESPLIT> 60
'''\n  Created on 13 Apr 2013\n  \n  @author: mengda\n  '''\n  board = []\n  \n  def whoIsWinner(num):\n      if num == 4000 or num == 3010:\n          return 'X'\n      if num == 400 or num == 310:\n          return 'O'\n      return False\n  \n  def process(board):\n      full = True\n      newboard = []\n      for i in range(4):\n          line = []\n          for j in range(4):\n              c = board[i][j]\n              if   c == 'X':\n                  line.append(1000)\n              elif c == 'O':\n                  line.append(100)\n              elif c == 'T':\n                  line.append(10)\n              elif c == '.':\n                  line.append(1)\n                  full = False\n          newboard.append(line)\n      board = newboard\n      for i in range(4):\n          sumH = 0\n          sumV = 0\n          for j in range(4):\n              sumH += board[i][j]\n              sumV += board[j][i]\n          winner = whoIsWinner(sumH)\n          if winner:\n              return winner + ' won'\n          winner = whoIsWinner(sumV)\n          if winner:\n              return winner + ' won'\n      sumD0 = board[0][0] + board[1][1] + board[2][2] + board[3][3]\n      winner = whoIsWinner(sumD0)\n      if winner:\n          return winner + ' won'\n      sumD1 = board[3][0] + board[2][1] + board[1][2] + board[0][3]\n      winner = whoIsWinner(sumD1)\n      if winner:\n          return winner + ' won'\n      if full:\n          return 'Draw'\n      return 'Game has not completed'\n  \n  f = open('A-small-attempt0.in', 'r')\n  N = int(f.readline())\n  outLine = []\n  \n  for i in range(1, N + 1):\n      board = []\n      for j in range(4):\n          board.append(f.readline())\n      outLine.append('Case #%d: %s\n' % (i, process(board)))\n      f.readline()\n      print outLine[-1],\n  \n  f.close()\n  outFile = open('1.out', 'w')\n  outFile.writelines(outLine)\n  outFile.close()\n <CODESPLIT> 60
'''\n  Created on 2012-4-14\n  \n  @author: hemnd\n  '''\n  dict = {}\n  strs1 = ['our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up']\n  strs0 = ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv']\n  \n  for i in range(3):\n      for j in range(len(strs1[i])):\n          c = strs0[i][j]\n          if c == ' ':\n              continue\n          e = strs1[i][j]\n          try:\n              dict[c]\n              print c, '=', dict[c], e\n          except:\n              dict[c] = e\n              print c, '=', e\n  \n  for k in dict.keys():\n      print k, dict[k]\n      \n  dict['q'] = 'z'\n  dict['z'] = 'q'\n  dict[' '] = ' '\n  \n  def trans(s):\n      rslt = ''\n      for i in range(len(s) - 1):\n          rslt += dict[s[i]]\n      return rslt\n  \n  inputFile = open('A-small-attempt0.in', 'r')\n  inputLines = inputFile.readlines()\n  inputFile.close()\n  \n  N = int(inputLines[0])\n  outputLines = []\n  \n  for i in range(1, N + 1):\n      outputLines.append('Case #%d: %s\n' % (i, trans(inputLines[i])))\n      print outputLines[i - 1],\n  \n  outputFile = open('A-small-practice.out', 'w')\n  outputFile.writelines(outputLines)\n  outputFile.close()\n <CODESPLIT> 60
 \n  \n  def process(N, naomi, ken):\n  	pointer_n = pointer_k = 0\n  	score0 = 0\n  	score1 = N\n  	for i in range(N):\n  		if naomi[i] > ken[pointer_k]:\n  			score0 += 1\n  			pointer_k += 1\n  		if ken[i] > naomi[pointer_n]:\n  			score1 -= 1\n  			pointer_n +=1\n  	return str(score0) + ' ' + str(score1)\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  	N = int(input_file.readline())\n  	naomi = sorted(map(float, input_file.readline().split()))\n  	ken = sorted(map(float, input_file.readline().split()))\n  	print 'Case #%d:' % (i + 1), process(N, naomi, ken)\n <CODESPLIT> 60
inputFile = open('B-small-attempt0.in', 'r')\n  lines = inputFile.readlines()\n  inputFile.close()\n  \n  outputFile = open('B-small-attempt0.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  \n  def solveCookies(c, f, x):\n      accumTime = 0\n      farmRate = 0\n      while True:\n          timeToWait = x/(2.0+farmRate)\n          timeIfBuyFarm = (c/(2.0+farmRate) +   # Time to get a farm\n                           x/(2.0+farmRate+f))\n          if timeToWait <= timeIfBuyFarm:\n              return accumTime+timeToWait\n          else:\n              accumTime += c/(2.0+farmRate)\n              farmRate += f\n  \n  for i in range(1, numTests+1):\n      [c, f, x] = map(lambda x: float(x), lines[i].split())\n  \n      outputFile.write('Case #'+str(i)+': ' + str(solveCookies(c, f, x))+'\n')\n  outputFile.close()\n      \n <CODESPLIT> 61
def isPalindrome(number):\n      strNum = str(number)\n      for i in range(len(strNum)/2 + 1):\n          if strNum[i] != strNum[-1*(i+1)]:\n              return False\n      return True\n  \n  '''for i in range(40):\n      if isPalindrome(i) and isPalindrome(i*i):\n          print i*i\n  '''\n  \n  \n  filename = "C-small-attempt0.in"\n  outputname = filename + "out.txt"\n  \n  inFile = open(filename, 'r')\n  outFile = open(outputname, 'w')\n  \n  \n  fairAndSquareNums = [1,4,9,121,484]\n  \n  numTests = int(inFile.readline())\n  \n  for i in range(numTests):\n      line = inFile.readline().split()\n      count = 0\n      for j in range(int(line[0]), int(line[1])+1):\n          if j in fairAndSquareNums:\n              count += 1\n      outFile.write("Case #" + str(i+1) + ": " + str(count) + '\n')\n      print "Case #" + str(i+1) + ": " + str(count)\n  \n  inFile.close()\n  outFile.close()\n <CODESPLIT> 61
inputFile = open("B-small-attempt0 (3).in", 'r')\n  outputFile = open("dancingOutSmall.txt", 'w')\n  numTests = int(inputFile.readline())\n  \n  def countDancers(n,s,p,totals):\n      guaranteed = 0\n      needSurprise = 0\n      if p == 1:\n          for total in totals:\n              if total != 0:\n                  guaranteed += 1\n          return guaranteed\n      for total in totals:\n          if total >= p*3 - 2:\n              guaranteed += 1\n          elif total >= p*3 - 4:\n              needSurprise += 1\n      if needSurprise > s:\n          return guaranteed + s\n      else:\n          return guaranteed + needSurprise\n  \n  for i in range(numTests):\n      line = inputFile.readline().split()\n      n = int(line[0])\n      s = int(line[1])\n      p = int(line[2])\n      totals = []\n      for j in range(n):\n          totals += [int(line[3+j])]\n      outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\n')\n  \n  outputFile.close()\n <CODESPLIT> 61
def isMowable(lawn):\n      for i in range(len(lawn)):\n          for j in range(len(lawn[i])):\n              cellHeight = lawn[i][j]\n              vertPossible = True\n              horizPossible = True\n              for k in range(len(lawn)):\n                  if lawn[k][j] > cellHeight:\n                      vertPossible = False\n                      break\n              for k in range(len(lawn[i])):\n                  if lawn[i][k] > cellHeight:\n                      horizPossible = False\n                      break\n              if not vertPossible and not horizPossible:\n                  return "NO"\n      return "YES"\n  \n  \n  filename = "B-small-attempt0.in"\n  outputname = filename + "out.txt"\n  \n  inFile = open(filename, 'r')\n  outFile = open(outputname, 'w')\n  \n  \n  numTests = int(inFile.readline())\n  \n      \n  \n  for i in range(numTests):\n      dimensions = inFile.readline().split()\n      n = int(dimensions[0])\n      m = int(dimensions[1])\n      lawn = []\n      for j in range(n):\n          line = inFile.readline().split()\n          for k in range(m):\n              line[k] = int(line[k])\n          lawn += [line]\n  \n      answer = isMowable(lawn)\n      \n      \n      outFile.write("Case #" + str(i+1) + ": " + answer + '\n')\n      print "Case #" + str(i+1) + ": " + answer\n  \n  inFile.close()\n  outFile.close()\n <CODESPLIT> 61
inputFile = open("C-small-attempt0.in", 'r')\n  outputFile = open("recycleOut.txt", 'w')\n  numTests = int(inputFile.readline())\n  \n  def countRecycle(a,b):\n      count = 0\n      for n in range(a,b):\n          for m in range(n+1,b+1):\n              nStr = str(n)\n              canRecycle = False\n              for k in range(len(nStr)):\n                  if nStr[k:] + nStr[0:k] == str(m):\n                      canRecycle = True\n                      break\n              if canRecycle:\n                  count += 1\n      return count\n  \n  for i in range(numTests):\n      line = inputFile.readline().split()\n      a = int(line[0])\n      b = int(line[1])\n      outputFile.write('Case #' + str(i+1) + ': ' + str(countRecycle(a,b)) + '\n')\n  \n  inputFile.close()\n  outputFile.close()\n <CODESPLIT> 61
filename = "A-small-attempt0 (3).in"\n  outputname = filename + "out.txt"\n  \n  inFile = open(filename, 'r')\n  outFile = open(outputname, 'w')\n  \n  \n  \n  \n  \n  def evalGame(lines):\n      board = []\n      gameOver = True\n      \n      for line in lines:\n          bline = []\n          for i in range(len(line)):\n              if line[i] == 'X':\n                  bline += [1]\n              elif line[i] == 'O':\n                  bline += [2]\n              elif line[i] == 'T':\n                  bline += [3]\n              elif line[i] == '.':\n                  gameOver = False\n                  bline += [0]\n          board += [bline]\n  \n      for i in range(1):\n          for j in range(4):\n              startTile = board[i][j]\n              if startTile == 3 or startTile == 0:\n                  continue\n              winner = True\n              for k in range(1,4):\n                  if board[i+k][j] not in [startTile, 3]:\n                      winner = False\n                      break\n              if winner:\n                  return startTile\n  \n      for i in range(4):\n          for j in range(1):\n              startTile = board[i][j]\n              if startTile == 3 or startTile == 0:\n                  continue\n              winner = True\n              for k in range(1,4):\n                  if board[i][j+k] not in [startTile, 3]:\n                      winner = False\n                      break\n              if winner:\n                  return startTile\n  \n      for i in range(3,4):\n          for j in range(4):\n              startTile = board[i][j]\n              if startTile == 3 or startTile == 0:\n                  continue\n              winner = True\n              for k in range(1,4):\n                  if board[i-k][j] not in [startTile, 3]:\n                      winner = False\n                      break\n              if winner:\n                  return startTile\n  \n      for i in range(4):\n          for j in range(3,4):\n              startTile = board[i][j]\n              if startTile == 3 or startTile == 0:\n                  continue\n              winner = True\n              for k in range(1,4):\n                  if board[i][j-k] not in [startTile, 3]:\n                      winner = False\n                      break\n              if winner:\n                  return startTile\n      \n      startTile = board[0][0]\n      if startTile != 3 and startTile != 0:\n          winner = True\n          for k in range(1,4):\n              if board[k][k] not in [startTile, 3]:\n                  winner = False\n                  break\n          if winner:\n              return startTile\n  \n      startTile = board[3][0]\n      if startTile != 3 and startTile != 0:\n          winner = True\n          for k in range(1,4):\n              if board[3-k][k] not in [startTile, 3]:\n                  winner = False\n                  break\n          if winner:\n              return startTile\n  \n      startTile = board[3][3]\n      if startTile != 3 and startTile != 0:\n          winner = True\n          for k in range(1,4):\n              if board[3-k][3-k] not in [startTile, 3]:\n                  winner = False\n                  break\n          if winner:\n              return startTile\n  \n      startTile = board[0][3]\n      if startTile != 3 and startTile != 0:\n          winner = True\n          for k in range(1,4):\n              if board[k][3-k] not in [startTile, 3]:\n                  winner = False\n                  break\n          if winner:\n              return startTile\n  \n  \n      if gameOver:\n          return 0\n  \n      else:\n          return -1\n      \n                        \n  \n  \n  \n  \n  \n  def resultToString(result):\n      if result == 0:\n          return "Draw"\n      elif result == 1:\n          return "X won"\n      elif result == 2:\n          return "O won"\n      else:\n          return "Game has not completed"\n  \n  \n  numCases = int(inFile.readline())\n  \n  for i in range(numCases):\n      lines = []\n      for j in range(4):\n          lines += [inFile.readline().strip()]\n  \n      result = evalGame(lines)\n  \n      print "Case #" + str(i+1) + ": " + resultToString(result)\n      outFile.write("Case #" + str(i+1) + ": " + resultToString(result) + '\n')\n      \n      if i < numCases -1:\n          inFile.readline()\n  \n  inFile.close()\n  outFile.close()\n <CODESPLIT> 61
translator = {}\n  translator['a'] = 'y'\n  translator['b'] = 'h'\n  translator['c'] = 'e'\n  translator['d'] = 's'\n  translator['e'] = 'o'\n  translator['f'] = 'c'\n  translator['g'] = 'v'\n  translator['h'] = 'x'\n  translator['i'] = 'd'\n  translator['j'] = 'u'\n  translator['k'] = 'i'\n  translator['l'] = 'g'\n  translator['m'] = 'l'\n  translator['n'] = 'b'\n  translator['o'] = 'k'\n  translator['p'] = 'r'\n  translator['q'] = 'z'\n  translator['r'] = 't'\n  translator['s'] = 'n'\n  translator['t'] = 'w'\n  translator['u'] = 'j'\n  translator['v'] = 'p'\n  translator['w'] = 'f'\n  translator['x'] = 'm'\n  translator['y'] = 'a'\n  translator['z'] = 'q'\n  \n  def translate(string, translator):\n      accum = ""\n      for i in range(len(string)):\n          if string[i] == ' ':\n              accum += ' '\n          elif string[i] == '\n':\n              break\n          else:\n              accum += translator[string[i]]\n      return accum\n  \n  inputFile = open("A-small-attempt0.in", 'r')\n  outputFile = open("tonguesOut.txt", 'w')\n  numTests = int(inputFile.readline())\n  \n  for i in range(numTests):\n      outputFile.write('Case #' + str(i+1) + ': ' + translate(inputFile.readline(), translator) + '\n')\n  \n  inputFile.close()\n  outputFile.close()\n  \n <CODESPLIT> 61
inputFile = open('D-small-attempt0.in', 'r')\n  lines = inputFile.readlines()\n  inputFile.close()\n  \n  outputFile = open('D-small-attempt0.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  def scoreWar(naomiNums, kenNums):\n      naomiInd = 0\n      kenInd = 0\n      while naomiInd < len(naomiNums):\n          naomiPlay = naomiNums[naomiInd]\n          while kenInd < len(kenNums) and kenNums[kenInd] < naomiPlay:\n              kenInd += 1\n          if kenInd == len(kenNums):\n              break\n          naomiInd += 1\n          kenInd += 1\n      return len(naomiNums) - naomiInd\n  \n  def scoreDeceit(naomiNums, kenNums):\n      naomiInd = 0\n      kenInd = 0\n      while kenInd < len(kenNums):\n          kenPlay = kenNums[kenInd]\n          while naomiInd < len(naomiNums) and naomiNums[naomiInd] < kenPlay:\n              naomiInd += 1\n          if naomiInd == len(naomiNums):\n              break\n          naomiInd += 1\n          kenInd += 1\n      return kenInd\n  \n  for i in range(1, numTests+1):\n      naomiNums = map(lambda x: float(x), lines[3*i-1].split())\n      kenNums = map(lambda x: float(x), lines[3*i].split())\n      naomiNums.sort()\n      kenNums.sort()\n      deceitScore = scoreDeceit(naomiNums, kenNums)\n      warScore = scoreWar(naomiNums, kenNums)\n      outputFile.write('Case #'+str(i)+': ' + str(deceitScore) + ' ' + str(warScore) + '\n')\n  \n  outputFile.close()\n <CODESPLIT> 61
 \n  INPUT = 'B-small-attempt1.in'\n  OUTPUT = 'B-small-attempt1.out'\n  \n  \n  def solve(C, F, X):\n  \n      cps = 2.0\n      farm_time = 0.0\n      time = X / cps\n      \n      while True:\n          farm_time += C / cps\n          cps += F\n          ntime = farm_time + X / cps\n          if ntime < time:\n              time = ntime\n          else:\n              break\n      return time\n  \n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      for case in range(T):\n          sol = solve(*map(float, inp.readline().split()))\n          out.write('Case #%i: %.7f\n' % (case + 1, sol))\n <CODESPLIT> 62
 \n  fin = open('C-small-attempt0.in', 'r')\n  fout = open('ass3.out', 'w')\n  \n  T = int(fin.readline())\n  \n  def perfsq(n):\n      sq = int(math.sqrt(n))\n      if n == sq * sq:\n          return sq\n      return 0\n  \n  def palindrome(n):\n      s = str(n)\n      return (s == s[::-1])\n  \n  def getpal(n):\n      if n == 1:\n          for i in range(10):\n              yield i\n      else:\n          n2 = n / 2\n          for x in xrange(10 ** (n2 - 1), 10 ** n2):\n              s = str(x)\n              if n % 2:\n                  for i in range(10):\n                      ns = s + str(i) + s[::-1]\n                      yield int(ns)\n              else:\n                  ns = s + s[::-1]\n                  yield int(ns)\n  \n  for i in range(T):\n      A, B = map(int, fin.readline().split())\n  \n      ret = 0\n      for j in range(len(str(A)), len(str(B)) + 1):\n          for x in getpal(j):\n              if x < A:\n                  continue\n              if x > B:\n                  break\n              sq = perfsq(x)\n              if sq and palindrome(sq):\n                  ret += 1\n      fout.write('Case #%i: %i\n' % (i + 1, ret))\n <CODESPLIT> 62
input_file = 'B-small-attempt1.in'\n  output_file = 'b.out'\n  \n  \n  def solvecase(inp):\n  	data = [int(n) for n in inp.split()]\n  	N, S, p = data[0:3]\n  	if p == 0:\n  		return N\n  	t = data[3:]\n  	ret = 0\n  	for br in t:\n  		d, r = br / 3, br % 3\n  		if br == 0 or p - d > 2:\n  			continue\n  		if (d >= p) or (r and (d + 1) >= p):\n  			ret += 1\n  		elif S and (d + max(r, 1)) >= p:\n  			ret += 1\n  			S -= 1\n  	return ret\n  \n  lines = open(input_file, 'r').readlines()\n  out = open(output_file, 'w')\n  \n  for i, l in enumerate(lines[1:]):\n  	sout = 'Case #%i: %i' % (i + 1, solvecase(l))\n  	print sout\n  	out.write(sout + '\n')\n  \n  out.close()\n <CODESPLIT> 62
fin = open('B-small-attempt0.in', 'r')\n  fout = open('ass2.out', 'w')\n  \n  \n  T = int(fin.readline())\n  \n  def check(lawn, r, c):\n      h, v = True, True\n      for i in range(len(lawn[0])):\n          if i == c:\n              continue\n          if lawn[r][i] > lawn[r][c]:\n              h = False\n              break\n      for i in range(len(lawn)):\n          if i == r:\n              continue\n          if lawn[i][c] > lawn[r][c]:\n              v = False\n      return (h or v)\n  \n  for i in range(T):\n      N, M = map(int, fin.readline().split())\n      lawn = []\n      for j in range(N):\n          lawn.append( map(int, fin.readline().split()) )\n  \n      n = i + 1\n      ret = True\n      for j in range(len(lawn)):\n          if not ret: break\n          for k in range(len(lawn[0])):\n              if not check(lawn, j, k):\n                  ret = False\n                  fout.write('Case #%i: NO\n' % n)\n                  break\n      if ret:\n          fout.write('Case #%i: YES\n' % n)\n <CODESPLIT> 62
input_file = 'C-small-attempt4.in'\n  output_file = 'c.out'\n  \n  \n  def solvecase(inp):\n  	A, B = [int(n) for n in inp.split()]\n  	\n  	def shift(s):\n  		return s[-1] + s[:-1]\n  	\n  	ret = 0\n  	for n in range(A, B + 1):\n  		sn = str(n)\n  		sm = sn\n  		rep = []\n  		for i in range(len(sn) - 1):\n  			sm = shift(sm)\n  			if not (sm in rep) and (B >= int(sm) > n):\n  				ret += 1\n  				rep.append(sm)\n  	return ret\n  \n  \n  lines = open(input_file, 'r').readlines()\n  out = open(output_file, 'w')\n  \n  for i, l in enumerate(lines[1:]):\n  	sout = 'Case #%i: %i' % (i + 1, solvecase(l))\n  	print sout\n  	out.write(sout + '\n')\n  \n  out.close()\n <CODESPLIT> 62
 fin = open('A-small-attempt0.in', 'r')\n  fout = open('ass1.out', 'w')\n  \n  N = int(fin.readline())\n  \n  for i in range(N):\n      field = []\n      for j in range(4):\n          field.append(fin.readline())\n      fin.readline()\n  \n      for j in range(4):\n          field.append([field[ln][j] for ln in range(4)])\n      field.append([field[x][x] for x in range(4)])\n      field.append([field[x][3 - x] for x in range(4)])\n  \n      \n      hasdot = False\n      winner = None\n      for ln in field:\n          if '.' in ln:\n              hasdot = True\n              continue\n          if 'X' in ln and not ('O' in ln):\n              winner = 'X'\n              break\n          if 'O' in ln and not ('X' in ln):\n              winner = 'O'\n              break\n      n = i + 1\n      if not (winner or hasdot):\n          fout.write('Case #%i: Draw\n' % n)\n      elif not winner and hasdot:\n          fout.write('Case #%i: Game has not completed\n' % n)\n      else:\n          fout.write('Case #%i: %s won\n' % (n, winner))\n <CODESPLIT> 62
 input_file = 'A-small-attempt0.in'\n  output_file = 'a_out'\n  \n  googlerese = ''.join([\n  	'ejp mysljylc kd kxveddknmc re jsicpdrysi',\n  	'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',\n  	'de kr kd eoya kw aej tysr re ujdr lkgc jv',\n  	'y qee', 'z'\n  ])\n  \n  english = ''.join([\n  	'our language is impossible to understand',\n  	'there are twenty six factorial possibilities',\n  	'so it is okay if you want to just give up',\n  	'a zoo', 'q'\n  ])\n  \n  alphabet = {}\n  \n  for g, e in zip(googlerese, english):\n  	alphabet[g] = e\n  \n  lines = open(input_file, 'r').readlines()\n  out = open(output_file, 'w')\n  \n  for i, l in enumerate(lines[1:]):\n  	trans = 'Case #%i: %s' % (\n  		i + 1, \n  		''.join([alphabet[c] for c in l if c in alphabet]))\n  	print trans\n  	out.write(trans + '\n')\n  \n  out.close()\n  \n  	\n  	\n  \n <CODESPLIT> 62
 \n  INPUT = 'D-small-attempt3.in'\n  OUTPUT = 'D-small-attempt3.out'\n  \n  \n  def solve(N, naomis, kens):\n      naomis.sort()\n      kens.sort()\n  \n      def play_war(naomis, kens):\n          score = 0\n          for game_round in range(N):\n              nweight = naomis.pop(0)\n              if nweight > kens[-1]:\n                  kweight = kens.pop(0)\n              else:\n                  for i, weight in enumerate(kens):\n                      if weight > nweight:\n                          kweight = kens.pop(i)\n                          break\n              if nweight > kweight:\n                  score += 1\n          return score\n  \n      def play_deceitful_war(naomis, kens):\n          score = 0\n          crap = 0\n          for i, weight in enumerate(naomis):\n              if weight < kens[i]:\n                  crap += 1\n  \n          for game_round in range(N):\n              if crap:\n                  ntold = kens[-1] - 0.0000001\n                  crap -= 1\n              else:\n                  ntold = naomis[-1]\n              nweight = naomis.pop(0)\n  \n              if ntold > kens[-1]:\n                  kweight = kens.pop(0)\n              else:\n                  for i, weight in enumerate(kens):\n                      if weight > ntold:\n                          kweight = kens.pop(i)\n                          break\n              if nweight > kweight:\n                  score += 1\n          return score \n  \n      return play_deceitful_war(naomis[:], kens[:]), play_war(naomis[:], kens[:])\n  \n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      for case in range(T):\n          N = int(inp.readline())\n          naomis = map(float, inp.readline().split())\n          kens = map(float, inp.readline().split())\n          sol = solve(N, naomis, kens)\n          out.write('Case #%i: %i %i\n' % (case + 1, sol[0], sol[1]))\n <CODESPLIT> 62
 \n  \n  \n  def solve(C, F, X):\n      def needtime(cookies, farm):\n          speed = 2.0 + F * farm\n          return cookies / speed\n  \n      farm = 0\n      pasttime = 0\n      while True:\n          complete = needtime(X, farm)\n          nextfarm = needtime(C, farm)\n          nextchallenge = needtime(X, farm + 1)\n          if complete <= nextfarm + nextchallenge:\n              return pasttime + complete\n          pasttime += nextfarm\n          farm += 1\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          C, F, X = map(float, IN.readline().split())\n          OUT.write('Case #%d: %.7f\n' % (index + 1, solve(C, F, X)))\n  \n  \n  def makesample(maxC=500, maxF=4, maxX=2000, T=100):\n      print T\n      for index in range(T):\n          print ' '.join('{0}'.format(random.randint(10000, maxvalue * 10000) / 10000.0)\n                         for maxvalue in (maxC, maxF, maxX))\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 63
 \n  \n  \n  def ispalindrome(n):\n      return str(n) == str(n)[::-1]\n  \n  \n  def solve(A, B):\n      solution = []\n      for n in range(int(math.sqrt(A)), int(math.sqrt(B))+1):\n          if ispalindrome(n):\n              m = n ** 2\n              if ispalindrome(m) and A <= m <= B:\n                  solution.append(n)\n      return len(solution)\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          A, B = map(int, IN.readline().split())\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(A, B)))\n  \n  \n  def makesample(T=100, ABmax=1000):\n      print T\n      for index in range(T):\n          A = random.randint(1, ABmax)\n          B = random.randint(A, ABmax)\n          print A, B\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 63
 \n  \n  \n  \n  \n  def solve(S, p, tlist):\n  	above = 0\n  	consider = 0\n  \n  	for t in tlist:\n  		avg = t / 3\n  		mod = t % 3\n  \n  		if mod == 0:\n  			if avg >= p:\n  				above += 1\n  			elif avg + 1 >= p and t > 0:\n  				consider += 1\n  \n  		elif mod == 1:\n  			if avg + 1 >= p:\n  				above += 1\n  \n  		elif mod == 2:\n  			if avg + 1 >= p:\n  				above += 1\n  			elif avg + 2 >= p:\n  				consider += 1\n  \n  	return above + min(S, consider)\n  \n  \n  def main(IN, OUT):\n  	N = int(IN.readline())\n  	for index in range(N):\n  		data = map(int, IN.readline().strip().split())\n  		(N, S, p), tlist = data[:3], data[3:]\n  		OUT.write('Case #%d: %d\n' % (index + 1, solve(S, p, tlist)))\n  \n  \n  if __name__ == '__main__':\n  	main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 63
 \n  \n  \n  def solve(board):\n      vboard = []\n      for m in range(len(board[0])):\n          vboard.append([board[n][m] for n in range(len(board))])\n  \n      for n in range(len(board)):\n          for m in range(len(board[n])):\n              h = board[n][m]\n              if h < max(board[n]) and h < max(vboard[m]):\n                  return 'NO'\n      return 'YES'\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          N, M = map(int, IN.readline().split())\n          field = [map(int, IN.readline().split()) for n in range(N)]\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(field)))\n  \n  \n  def makesample(NMmax=100, amax=100, T=100):\n      print T\n      for index in range(T):\n          N = random.randint(1, NMmax)\n          M = random.randint(1, NMmax)\n          print N, M\n          for n in range(N):\n              print ' '.join(str(random.randint(1, amax)) for m in range(M))\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 63
 \n  \n  \n  def solve(A, B):\n  	top = str(B)[0]\n  \n  	count = 0\n  	for n in xrange(A, B):		# n=B (n < m <= B )\n  		digit = str(n)\n  		found = set()\n  		for index in range(1, len(digit)):\n  			if digit[index] < digit[0]:\n  				continue\n  			if digit[index] > top:\n  				continue\n  \n  			m = int(digit[index:] + digit[:index])\n  			if n < m and m <= B and m not in found:\n  				found.add(m)		# distinct ()\n  				count += 1\n  	return count\n  \n  \n  def main(IN, OUT):\n  	N = int(IN.readline())\n  	for index in range(N):\n  		A, B = map(int, IN.readline().strip().split())\n  		OUT.write('Case #%d: %d\n' % (index + 1, solve(A, B)))\n  \n  \n  def makesample(ABmax=2000000, T=50):\n  	print T\n  	for index in range(T):\n  		A = random.randint(1, ABmax)\n  		B = random.randint(A, ABmax)\n  		print A, B\n  \n  \n  if __name__ == '__main__':\n  	if '-makesample' in sys.argv[1:]:\n  		makesample()\n  	else:\n  		main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 63
 \n  \n  \n  def solve(board):\n      rows = [board[n:][:4] for n in range(0, len(board), 4)]\n      cols = [''.join(board[step+n*4] for n in range(4)) for step in range(4)]\n      corners = [''.join(board[n] for n in range(0, len(board), 5)),\n                 ''.join(board[n] for n in range(3, len(board)-1, 3))]\n      lines = rows + cols + corners\n  \n      for line in lines:\n          if line.replace('T', 'X') == 'XXXX':\n              return 'X won'\n          if line.replace('T', 'O') == 'OOOO':\n              return 'O won'\n      return 'Game has not completed' if '.' in board else 'Draw'\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          board = ''.join([IN.readline().strip() for row in range(4)])\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(board)))\n          IN.readline()\n  \n  \n  def makesample(T=1000):\n      print T\n      for index in range(T):\n          board = []\n          for row in range(4):\n              board.append(''.join(random.choice('XO.') for col in range(4)))\n          tcol = random.randint(0, 3)\n          trow = random.randint(0, 3)\n          board[trow] = board[trow][:tcol] + 'T' + board[trow][tcol+1:]\n          print '\n'.join(board)\n          print\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 63
 \n  \n  INPUT = '''ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv'''\n  OUTPUT = '''our language is impossible to understand\n  there are twenty six factorial possibilities\n  so it is okay if you want to just give up'''\n  \n  \n  class Table(dict):\n  	TARGET = string.ascii_lowercase\n  \n  	def translate(self, msg):\n  		return ''.join((self[c] if c in self.TARGET else c) for c in msg)\n  \n  	@classmethod\n  	def maketable(cls, src, dst):\n  		table = cls()\n  		left = set(cls.TARGET)\n  		for s, d in zip(src, dst):\n  			if s in table:\n  				if table[s] != d:\n  					raise Exception('BAD MAPPING "%s" => "%s"/"%s"' % (s, table[s], d))\n  			elif s in cls.TARGET:\n  				table[s] = d\n  				left.remove(s)\n  		if left:\n  			if len(left) != 2:\n  				raise Exception('left letter incorrect')\n  			l1, l2 = left\n  			table[l1] = l2\n  			table[l2] = l1\n  		return table\n  \n  \n  def main():\n  	table = Table.maketable(INPUT, OUTPUT)\n  	N = int(sys.stdin.readline())\n  	for index in range(N):\n  		line = sys.stdin.readline().strip()\n  		print 'Case #%d:' % (index + 1), table.translate(line)\n  \n  \n  if __name__ == '__main__':\n  	main()\n  \n <CODESPLIT> 63
 \n  \n  \n  def solve1(naomi, ken):\n      win = 0\n      while naomi:\n          chosenK = max(ken)\n          chosenN = min(filter(lambda mass: mass > chosenK, naomi) or naomi)\n          if chosenN > chosenK:\n              win += 1\n          naomi.remove(chosenN)\n          ken.remove(chosenK)\n      return win\n  \n  \n  def solve2(naomi, ken):\n      win = 0\n      while naomi:\n          chosenN = min(naomi)\n          chosenK = min(filter(lambda mass: mass > chosenN, ken) or ken)\n          if chosenN > chosenK:\n              win += 1\n          naomi.remove(chosenN)\n          ken.remove(chosenK)\n      return win\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          N = int(IN.readline())\n          naomi = map(float, IN.readline().split())\n          ken = map(float, IN.readline().split())\n          OUT.write('Case #%d: %d %d\n' % (index + 1, solve1(naomi[:], ken[:]), solve2(naomi[:], ken[:])))\n  \n  \n  def makesample(maxN=1000, T=50):\n      print T\n      for index in range(T):\n          N = random.randint(1, maxN)\n          print N\n          print ' '.join(map(str, (random.random() for n in range(N))))\n          print ' '.join(map(str, (random.random() for n in range(N))))\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 63
 \n  \n  def solve(C, F, X):\n      rate = 2.0\n      time_to_win = X / rate\n  \n      time_used = C / rate\n      rate += F\n      time_to_win_new = time_used + X / rate\n  \n      while time_to_win_new < time_to_win:\n          time_to_win = time_to_win_new\n          \n          time_used += C / rate\n          rate += F\n          time_to_win_new = time_used + X / rate\n  \n      return time_to_win\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          [C, F, X] = [float(x) for x in sys.stdin.readline().rstrip().split()]\n  \n          result = solve(C, F, X)\n          print ("Case #%s: %.7f" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 64
 \n  \n  def isPal(n):\n      l = str(n)\n      return l == l[::-1]\n  \n  def solve(a, b):\n      l = int(math.ceil(math.sqrt(a)))\n      u = int(math.floor(math.sqrt(b)))\n  \n      count = 0\n      for x in range(l, u + 1):\n          if isPal(x):\n              if isPal(x*x):\n                  count += 1\n      return str(count)\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n          result = solve(a, b)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 64
 \n  \n  \n  def solve(num_surprises, p, ts):\n      s = 0\n      u = 0\n      for t in ts:\n          a = int(t/3)\n          r = t % 3\n          if a+1 >= p and not r == 0:\n              u += 1\n          elif a >= p and r == 0:\n              u += 1\n          elif a > 0 and a+1 >= p and r == 0:\n              s += 1\n          elif a+2 >= p and r == 2:\n              s += 1\n  \n      return min(num_surprises, s) + u\n          \n          \n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          line = [int(x) for x in sys.stdin.readline().split()]\n          num_surprises = line[1]\n          p = line[2]\n          ts = line[3:]\n          result = solve(num_surprises, p, ts)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 64
 \n  \n  def solve(M, a, b):\n      rowmax = [max(r) for r in M]\n      colmax = [max([M[j][i] for j in range(a)]) for i in range(b)]\n      rowmin = [min(r) for r in M]\n      colmin = [min([M[j][i] for j in range(a)]) for i in range(b)]\n  \n      for i in range(a):\n          for j in range(b):\n              if M[i][j] != min(rowmax[i], colmax[j]):\n                  return 'NO'\n      return 'YES'\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n          M = []\n          for j in range(a):\n              M += [[int(x) for x in sys.stdin.readline().split()]]\n          result = solve(M, a, b)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 64
 \n  \n  \n  def solve(a,b):\n      num_recycled = 0\n      for n in range(a, b+1):\n          s = str(n)\n          pairs = []\n          for i in range(1,len(s)):\n              m = int(s[i:] + s[:i])\n              if n < m and m <= b and m not in pairs:\n                  num_recycled += 1\n                  pairs.append(m)\n      return num_recycled\n          \n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          [a, b] = [int(x) for x in sys.stdin.readline().split()]\n          result = solve(a,b)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 64
 \n  \n  def result(l):\n      xcount = 0\n      ocount = 0\n      empty = False\n      for field in l:\n          if field == 'X' or field == 'T':\n              xcount += 1\n          if field == 'O' or field == 'T':\n              ocount += 1\n          if field == '.':\n              empty = True\n  \n      if xcount == 4:\n          return 'X'\n      if ocount == 4:\n          return 'O'\n      if empty:\n          return '.'\n      else:\n          return ''\n  \n  def solve(M):\n      empty = False\n      for i in range(4):\n          r = result(M[i])\n          if (r == 'X' or r == 'O'):\n              return r + ' won'\n          if r == '.':\n              empty = True\n  \n      for i in range(4):\n          r = result([M[j][i] for j in range(4)])\n          if (r == 'X' or r == 'O'):\n              return r + ' won'\n  \n      r = result([M[i][i] for i in range(4)])\n      if (r == 'X' or r == 'O'):\n          return r + ' won'\n      r = result([M[i][3-i] for i in range(4)])\n      if (r == 'X' or r == 'O'):\n          return r + ' won'\n  \n      if empty:\n          return 'Game has not completed'\n      else:\n          return 'Draw'\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          M = []\n          for j in range(4):\n              M += [list(sys.stdin.readline().rstrip())]\n          sys.stdin.readline()\n          result = solve(M)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 64
 \n  \n  \n  table = {'a': 'y',\n           'b': 'h',\n           'c': 'e',\n           'd': 's',\n           'e': 'o',\n           'f': 'c',\n           'g': 'v',\n           'h': 'x',\n           'i': 'd',\n           'j': 'u',\n           'k': 'i',\n           'l': 'g',\n           'm': 'l',\n           'n': 'b',\n           'o': 'k',\n           'p': 'r',\n           'q': 'z',\n           'r': 't',\n           's': 'n',\n           't': 'w',\n           'u': 'j',\n           'v': 'p',\n           'w': 'f',\n           'x': 'm',\n           'y': 'a',\n           'z': 'q',\n           ' ': ' ',\n           '\n': ''}\n  \n  def solve(s):\n      return ''.join([table[c] for c in s])\n          \n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          result = solve(sys.stdin.readline())\n          print ("Case #%s: %s" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 64
 \n  \n  def solveWar(n_weights, k_weights):\n      nweights = sorted(n_weights)\n      kweights = sorted(k_weights)\n      score = 0\n      \n  \n      for w in nweights:\n          while kweights and kweights[0] < w:\n              kweights.pop(0)\n              score += 1\n  \n          if not kweights:\n              break\n          else:\n              kweights.pop(0)\n              \n      return score\n  \n  def solveDWar(n_weights, k_weights):\n      nweights = sorted(n_weights)\n      kweights = sorted(k_weights)\n      score = 0\n  \n      for w in nweights:\n          if w > kweights[0]:\n              score += 1\n              kweights.pop(0)\n          else:\n              kweights.pop(-1)\n      \n      return score\n  \n  def solve(nweights, kweights):\n      return ("%s %s" % (solveDWar(nweights, kweights), solveWar(nweights, kweights)))\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          sys.stdin.readline()\n          nweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n          kweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n  \n          result = solve(nweights, kweights)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 64
 \n  sys.setrecursionlimit(9299999)\n  \n  def min_time(C, F, X, speed, nb_cookies):\n  	if (X - nb_cookies) / speed < (X - (nb_cookies - C)) / (speed + F):\n  		return (X - nb_cookies) / speed\n  	elif nb_cookies >= C:\n  		return min_time(C, F, X, speed + F, nb_cookies - C)\n  	else:\n  		return (C - nb_cookies) / speed + min_time(C, F, X, speed, C)\n  \n  T = int(raw_input())\n  for i in range(T):\n  	C, F, X = map(float, raw_input().split())\n  	print 'Case #%d: %f' % (i + 1, min_time(C, F, X, 2, 0))\n <CODESPLIT> 65
 \n  \n  def is_palindromic(i):\n      n = i\n      rev = 0\n      while i > 0:\n          dig = i % 10\n          rev = rev * 10 + dig\n          i = i // 10\n      return n == rev\n  \n  def is_square(i):\n      if i == 1:\n          return True\n      x = i // 2\n      seen = set([x])\n      while x * x != i:\n          x = (x + (i // x)) // 2\n          if x in seen:\n              return False\n          seen.add(x)\n      return True\n  \n  def f(a, b):\n      tot = 0\n  \n      sra = a\n      while not is_square(sra):\n          sra += 1\n      srb = b\n      while not is_square(srb):\n          srb -= 1\n  \n      sra = int(sqrt(sra))\n      srb = int(sqrt(srb))\n  \n      for i in range(sra, srb+1):\n          if is_palindromic(i) and is_palindromic(i ** 2):\n              tot += 1\n  \n      return tot\n  \n  if __name__ == '__main__':\n      T = int(input())\n      for i in range(T):\n          a, b = map(int, input().split())\n          r = f(a, b)\n          print('Case #{}: {}'.format(i+1, r))\n <CODESPLIT> 65
 \n  T = int(raw_input())\n  for i in xrange(T):\n      values = map(int, raw_input().split())\n      [N,s,p] = values[0:3]\n      t = values[3:]\n      answer = 0\n      for note in t:\n          if note < 2:\n              if note >= p:\n                  answer += 1\n          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n              answer += 1\n          elif note % 3 == 0:\n              n = note / 3\n              if n >= p:\n                  answer += 1\n              elif s > 0 and n + 1 >= p:\n                  answer += 1\n                  s -= 1\n          elif note % 3 == 2:\n              n = (note - 2) / 3\n              if n + 1 >= p:\n                  answer += 1\n              elif s > 0 and n + 2 >= p:\n                  answer += 1\n                  s -= 1\n      print 'Case #{0}: {1}'.format(i+1, answer)\n <CODESPLIT> 65
 \n  \n  def f(m):\n      max_cols = []\n      for e in zip(*m):\n          max_cols.append(max(e))\n  \n      for r in m:\n          max_row = max(r)\n          for y, c in enumerate(r):\n              if c != max_row and c != max_cols[y]:\n                  return 'NO'\n      return 'YES'\n  \n  if __name__ == '__main__':\n      T = int(input())\n      for i in range(T):\n          n, m = map(int, input().split())\n          r = f([input().split() for i in range(n)])\n          print('Case #{}: {}'.format(i+1, r))\n <CODESPLIT> 65
 \n  T = int(raw_input())\n  for i in xrange(T):\n      values = map(int, raw_input().split())\n      [N,s,p] = values[0:3]\n      t = values[3:]\n      answer = 0\n      for note in t:\n          if note < 2:\n              if note >= p:\n                  answer += 1\n          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n              answer += 1\n          elif note % 3 == 0:\n              n = note / 3\n              if n >= p:\n                  answer += 1\n              elif s > 0 and n + 1 >= p:\n                  answer += 1\n                  s -= 1\n          elif note % 3 == 2:\n              n = (note - 2) / 3\n              if n + 1 >= p:\n                  answer += 1\n              elif s > 0 and n + 2 >= p:\n                  answer += 1\n                  s -= 1\n      print 'Case #{0}: {1}'.format(i+1, answer)\n <CODESPLIT> 65
 \n  \n  def who_won(l):\n      current = None\n      for i in l:\n          if i == '.':\n              return None\n          if not current and i in 'OX':\n              current = i\n          if current and current != i and i != 'T':\n              return None\n      return current\n  \n  \n  def f(m):\n      still = False\n      for i in m:\n          for j in i:\n              if j == '.':\n                  still = True\n  \n      rows = m # [[m[i][j] for i in range(4)] for j in range(4)]\n      cols = [[m[i][j] for i in range(4)] for j in range(4)]\n      diag = [[m[i][i] for i in range(4)], [m[3-i][i] for i in range(4)]]\n  \n      winner = None\n  \n      for l in rows + cols + diag:\n          c = who_won(l)\n          if c:\n              winner = c + ' won'\n  \n      if not winner:\n          if still:\n              winner = 'Game has not completed'\n          else:\n              winner = 'Draw'\n      return winner\n  \n  if __name__ == '__main__':\n      T = int(input())\n      for i in range(T):\n          m = [list(input()) for k in range(4)]\n          if i != T- 1:\n              input()\n          r = f(m)\n          print('Case #{}: {}'.format(i+1, r))\n <CODESPLIT> 65
 \n  translate = {'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'q': 'z', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm', 'z': 'q'}\n  \n  nb = int(raw_input())\n  for i in xrange(nb):\n      s = ''.join([translate[char] if char in translate.keys() else char for char in str(raw_input())])\n      print 'Case #{0}:'.format(i+1), s\n <CODESPLIT> 65
 \n  T = int(input())\n  \n  for t in range(T):\n      N = int(input())\n      naomi = sorted(list(map(float, input().split())))\n      ken = sorted(list(map(float, input().split())))\n      naomi_dw = naomi[:]\n      ken_dw = ken[:]\n      war = 0\n      dwar = 0\n      for pn in naomi:\n          pk = bisect.bisect_left(ken, pn)\n          if pk == len(ken):\n              war += 1\n              ken.pop(0)\n          else:\n              ken.pop(pk)\n      for pn in naomi_dw:\n          if pn > ken_dw[0]:\n              dwar += 1\n              ken_dw.pop(0)\n          else:\n              ken_dw.pop()\n      print('Case #{}: {} {}'.format(t + 1, dwar, war))\n <CODESPLIT> 65
